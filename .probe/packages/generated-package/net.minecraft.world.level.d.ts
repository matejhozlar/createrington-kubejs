declare module "net.minecraft.world.level.levelgen.feature.stateproviders.NoiseProvider" {
import {$RecordCodecBuilder$Instance$$Type} from "com.mojang.serialization.codecs.RecordCodecBuilder$Instance"
import {$List, $List$$Type} from "java.util.List"
import {$BlockStateProviderType} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProviderType"
import {$NormalNoise} from "net.minecraft.world.level.levelgen.synth.NormalNoise"
import {$NoiseBasedStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.NoiseBasedStateProvider"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Products$P4} from "com.mojang.datafixers.Products$P4"
import {$RecordCodecBuilder$Mu} from "com.mojang.serialization.codecs.RecordCodecBuilder$Mu"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$NormalNoise$NoiseParameters, $NormalNoise$NoiseParameters$$Type} from "net.minecraft.world.level.levelgen.synth.NormalNoise$NoiseParameters"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $NoiseProvider extends $NoiseBasedStateProvider {
static readonly "CODEC": $MapCodec<($NoiseProvider)>
readonly "seed": long
readonly "noise": $NormalNoise
readonly "scale": float
readonly "parameters": $NormalNoise$NoiseParameters
readonly "states": $List<($BlockState)>

constructor(arg0: long, arg1: $NormalNoise$NoiseParameters$$Type, arg2: float, arg3: $List$$Type<($BlockState$$Type)>)

public "type"(): $BlockStateProviderType<(never)>
public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
public static "noiseProviderCodec"<P extends $NoiseProvider>(arg0: $RecordCodecBuilder$Instance$$Type<(P)>): $Products$P4<($RecordCodecBuilder$Mu<(P)>), (long), ($NormalNoise$NoiseParameters), (float), ($List<($BlockState)>)>
public "getRandomState"(arg0: $List$$Type<($BlockState$$Type)>, arg1: double): $BlockState
public "getRandomState"(arg0: $List$$Type<($BlockState$$Type)>, arg1: $BlockPos$$Type, arg2: double): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseProvider$$Type = ($NoiseProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseProvider$$Original = $NoiseProvider;}
declare module "net.minecraft.world.level.levelgen.RandomState" {
import {$Climate$Sampler} from "net.minecraft.world.level.biome.Climate$Sampler"
import {$NoiseGeneratorSettings$$Type} from "net.minecraft.world.level.levelgen.NoiseGeneratorSettings"
import {$HolderGetter$Provider$$Type} from "net.minecraft.core.HolderGetter$Provider"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$NormalNoise} from "net.minecraft.world.level.levelgen.synth.NormalNoise"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PositionalRandomFactory} from "net.minecraft.world.level.levelgen.PositionalRandomFactory"
import {$SurfaceSystem} from "net.minecraft.world.level.levelgen.SurfaceSystem"
import {$NormalNoise$NoiseParameters$$Type} from "net.minecraft.world.level.levelgen.synth.NormalNoise$NoiseParameters"
import {$NoiseRouter} from "net.minecraft.world.level.levelgen.NoiseRouter"
import {$HolderGetter$$Type} from "net.minecraft.core.HolderGetter"

export class $RandomState {
readonly "random": $PositionalRandomFactory

public static "create"(arg0: $HolderGetter$Provider$$Type, arg1: $ResourceKey$$Type<($NoiseGeneratorSettings)>, arg2: long): $RandomState
public static "create"(arg0: $NoiseGeneratorSettings$$Type, arg1: $HolderGetter$$Type<($NormalNoise$NoiseParameters$$Type)>, arg2: long): $RandomState
public "surfaceSystem"(): $SurfaceSystem
public "sampler"(): $Climate$Sampler
public "getOrCreateRandomFactory"(arg0: $ResourceLocation$$Type): $PositionalRandomFactory
public "router"(): $NoiseRouter
public "getOrCreateNoise"(arg0: $ResourceKey$$Type<($NormalNoise$NoiseParameters)>): $NormalNoise
public "aquiferRandom"(): $PositionalRandomFactory
public "oreRandom"(): $PositionalRandomFactory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomState$$Type = ($RandomState);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomState$$Original = $RandomState;}
declare module "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder" {
import {$AnyOfCondition$Builder} from "net.minecraft.world.level.storage.loot.predicates.AnyOfCondition$Builder"
import {$AllOfCondition$Builder} from "net.minecraft.world.level.storage.loot.predicates.AllOfCondition$Builder"
import {$LootItemCondition, $LootItemCondition$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"

export interface $LootItemCondition$Builder$$Interface {

(): $LootItemCondition$$Type
}

export class $LootItemCondition$Builder implements $LootItemCondition$Builder$$Interface {
 "build"(): $LootItemCondition
 "or"(arg0: $LootItemCondition$Builder$$Type): $AnyOfCondition$Builder
 "and"(arg0: $LootItemCondition$Builder$$Type): $AllOfCondition$Builder
 "invert"(): $LootItemCondition$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootItemCondition$Builder$$Type = (() => $LootItemCondition$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootItemCondition$Builder$$Original = $LootItemCondition$Builder;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager" {
import {$LevelStorageSource$LevelStorageAccess$$Type} from "net.minecraft.world.level.storage.LevelStorageSource$LevelStorageAccess"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Optional} from "java.util.Optional"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Path} from "java.nio.file.Path"
import {$Stream} from "java.util.stream.Stream"
import {$StructureTemplate} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate"
import {$DataFixer$$Type} from "com.mojang.datafixers.DataFixer"
import {$HolderGetter$$Type} from "net.minecraft.core.HolderGetter"
import {$ResourceManager$$Type} from "net.minecraft.server.packs.resources.ResourceManager"

export class $StructureTemplateManager {
static readonly "STRUCTURE_RESOURCE_DIRECTORY_NAME": StringJS

constructor(arg0: $ResourceManager$$Type, arg1: $LevelStorageSource$LevelStorageAccess$$Type, arg2: $DataFixer$$Type, arg3: $HolderGetter$$Type<($Block$$Type)>)

public "getOrCreate"(arg0: $ResourceLocation$$Type): $StructureTemplate
public "remove"(arg0: $ResourceLocation$$Type): void
public "get"(arg0: $ResourceLocation$$Type): $Optional<($StructureTemplate)>
public "save"(arg0: $ResourceLocation$$Type): boolean
public "onResourceManagerReload"(arg0: $ResourceManager$$Type): void
public "createAndValidatePathToGeneratedStructure"(arg0: $ResourceLocation$$Type, arg1: StringJS): $Path
public "readStructure"(arg0: $CompoundTag$$Type): $StructureTemplate
public "listTemplates"(): $Stream<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureTemplateManager$$Type = ($StructureTemplateManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureTemplateManager$$Original = $StructureTemplateManager;}
declare module "net.minecraft.world.level.levelgen.feature.WeightedPlacedFeature" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $WeightedPlacedFeature {
static readonly "CODEC": $Codec<($WeightedPlacedFeature)>
readonly "chance": float
readonly "feature": $Holder<($PlacedFeature)>

constructor(arg0: $Holder$$Type<($PlacedFeature)>, arg1: float)

public "place"(arg0: $WorldGenLevel$$Type, arg1: $ChunkGenerator$$Type, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeightedPlacedFeature$$Type = ($WeightedPlacedFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeightedPlacedFeature$$Original = $WeightedPlacedFeature;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.RotatedBlockProvider" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BlockStateProviderType} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProviderType"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $RotatedBlockProvider extends $BlockStateProvider {
static readonly "CODEC": $MapCodec<($RotatedBlockProvider)>

constructor(arg0: $Block$$Type)

public "type"(): $BlockStateProviderType<(never)>
public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotatedBlockProvider$$Type = ($RotatedBlockProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RotatedBlockProvider$$Original = $RotatedBlockProvider;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.BushFoliagePlacer" {
import {$FoliagePlacerType} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacerType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$FoliagePlacer$FoliageSetter$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageSetter"
import {$BlobFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.BlobFoliagePlacer"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$FoliagePlacer$FoliageAttachment$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $BushFoliagePlacer extends $BlobFoliagePlacer {
static readonly "CODEC": $MapCodec<($BushFoliagePlacer)>
readonly "offset": $IntProvider
readonly "radius": $IntProvider
readonly "height": integer

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: integer)

public "type"(): $FoliagePlacerType<(never)>
public "createFoliage"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: integer, arg5: $FoliagePlacer$FoliageAttachment$$Type, arg6: integer, arg7: integer, arg8: integer): void
public "shouldSkipLocation"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BushFoliagePlacer$$Type = ($BushFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BushFoliagePlacer$$Original = $BushFoliagePlacer;}
declare module "net.minecraft.world.level.levelgen.DensityFunctions$Marker$Type" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunctions$MarkerOrMarked} from "net.minecraft.world.level.levelgen.DensityFunctions$MarkerOrMarked"

export class $DensityFunctions$Marker$Type extends $Enum<($DensityFunctions$Marker$Type)> implements $StringRepresentable$$Interface {
static readonly "CacheAllInCell": $DensityFunctions$Marker$Type
readonly "codec": $KeyDispatchDataCodec<($DensityFunctions$MarkerOrMarked)>
static readonly "CacheOnce": $DensityFunctions$Marker$Type
static readonly "FlatCache": $DensityFunctions$Marker$Type
static readonly "Interpolated": $DensityFunctions$Marker$Type
static readonly "Cache2D": $DensityFunctions$Marker$Type

public static "values"(): ($DensityFunctions$Marker$Type)[]
public static "valueOf"(arg0: StringJS): $DensityFunctions$Marker$Type
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunctions$Marker$Type$$Type = (("interpolated") | ("flat_cache") | ("cache_2d") | ("cache_once") | ("cache_all_in_cell"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunctions$Marker$Type$$Original = $DensityFunctions$Marker$Type;}
declare module "net.minecraft.world.level.dimension.end.EndDragonFight" {
import {$EndDragonFight$Data, $EndDragonFight$Data$$Type} from "net.minecraft.world.level.dimension.end.EndDragonFight$Data"
import {$DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$DragonRespawnAnimation$$Type} from "net.minecraft.world.level.dimension.end.DragonRespawnAnimation"
import {$UUID} from "java.util.UUID"
import {$EndCrystal$$Type} from "net.minecraft.world.entity.boss.enderdragon.EndCrystal"
import {$EnderDragon$$Type} from "net.minecraft.world.entity.boss.enderdragon.EnderDragon"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $EndDragonFight {
static readonly "TIME_BETWEEN_PLAYER_SCANS": integer
static readonly "ARENA_TICKET_LEVEL": integer
static readonly "DRAGON_SPAWN_Y": integer

constructor(arg0: $ServerLevel$$Type, arg1: long, arg2: $EndDragonFight$Data$$Type)
constructor(arg0: $ServerLevel$$Type, arg1: long, arg2: $EndDragonFight$Data$$Type, arg3: $BlockPos$$Type)

public "tick"(): void
public "addPlayer"(arg0: $ServerPlayer$$Type): void
public "saveData"(): $EndDragonFight$Data
public "hasPreviouslyKilledDragon"(): boolean
public "onCrystalDestroyed"(arg0: $EndCrystal$$Type, arg1: $DamageSource$$Type): void
public "getCrystalsAlive"(): integer
public "getDragonUUID"(): $UUID
public "updateDragon"(arg0: $EnderDragon$$Type): void
public "setDragonKilled"(arg0: $EnderDragon$$Type): void
public "removePlayer"(arg0: $ServerPlayer$$Type): void
public "tryRespawn"(): void
public "resetSpikeCrystals"(): void
public "setRespawnStage"(arg0: $DragonRespawnAnimation$$Type): void
/**
 * 
 * @deprecated
 */
public "removeAllGateways"(): void
/**
 * 
 * @deprecated
 */
public "skipArenaLoadedCheck"(): void
get "crystalsAlive"(): integer
get "dragonUUID"(): $UUID
set "dragonKilled"(value: $EnderDragon$$Type)
set "respawnStage"(value: $DragonRespawnAnimation$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndDragonFight$$Type = ($EndDragonFight);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EndDragonFight$$Original = $EndDragonFight;}
declare module "net.minecraft.world.level.levelgen.blending.BlendingData$BiomeConsumer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $BlendingData$BiomeConsumer$$Interface {
}

export class $BlendingData$BiomeConsumer implements $BlendingData$BiomeConsumer$$Interface {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlendingData$BiomeConsumer$$Type = ($BlendingData$BiomeConsumer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlendingData$BiomeConsumer$$Original = $BlendingData$BiomeConsumer;}
declare module "net.minecraft.world.level.levelgen.placement.PlacementModifierType" {
import {$CountOnEveryLayerPlacement} from "net.minecraft.world.level.levelgen.placement.CountOnEveryLayerPlacement"
import {$RarityFilter} from "net.minecraft.world.level.levelgen.placement.RarityFilter"
import {$BlockPredicateFilter} from "net.minecraft.world.level.levelgen.placement.BlockPredicateFilter"
import {$InSquarePlacement} from "net.minecraft.world.level.levelgen.placement.InSquarePlacement"
import {$HeightRangePlacement} from "net.minecraft.world.level.levelgen.placement.HeightRangePlacement"
import {$CountPlacement} from "net.minecraft.world.level.levelgen.placement.CountPlacement"
import {$NoiseBasedCountPlacement} from "net.minecraft.world.level.levelgen.placement.NoiseBasedCountPlacement"
import {$NoiseThresholdCountPlacement} from "net.minecraft.world.level.levelgen.placement.NoiseThresholdCountPlacement"
import {$RandomOffsetPlacement} from "net.minecraft.world.level.levelgen.placement.RandomOffsetPlacement"
import {$SurfaceWaterDepthFilter} from "net.minecraft.world.level.levelgen.placement.SurfaceWaterDepthFilter"
import {$HeightmapPlacement} from "net.minecraft.world.level.levelgen.placement.HeightmapPlacement"
import {$BiomeFilter} from "net.minecraft.world.level.levelgen.placement.BiomeFilter"
import {$FixedPlacement} from "net.minecraft.world.level.levelgen.placement.FixedPlacement"
import {$EnvironmentScanPlacement} from "net.minecraft.world.level.levelgen.placement.EnvironmentScanPlacement"
import {$CarvingMaskPlacement} from "net.minecraft.world.level.levelgen.placement.CarvingMaskPlacement"
import {$PlacementModifier} from "net.minecraft.world.level.levelgen.placement.PlacementModifier"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$SurfaceRelativeThresholdFilter} from "net.minecraft.world.level.levelgen.placement.SurfaceRelativeThresholdFilter"

export interface $PlacementModifierType$$Interface<P extends $PlacementModifier> {

(): $MapCodec$$Type<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenPlacementModifierType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenPlacementModifierTypeTag
}

export class $PlacementModifierType<P extends $PlacementModifier> implements $PlacementModifierType$$Interface {
static readonly "ENVIRONMENT_SCAN": $PlacementModifierType<($EnvironmentScanPlacement)>
static readonly "HEIGHT_RANGE": $PlacementModifierType<($HeightRangePlacement)>
static readonly "CARVING_MASK_PLACEMENT": $PlacementModifierType<($CarvingMaskPlacement)>
static readonly "RARITY_FILTER": $PlacementModifierType<($RarityFilter)>
static readonly "FIXED_PLACEMENT": $PlacementModifierType<($FixedPlacement)>
static readonly "SURFACE_RELATIVE_THRESHOLD_FILTER": $PlacementModifierType<($SurfaceRelativeThresholdFilter)>
static readonly "NOISE_THRESHOLD_COUNT": $PlacementModifierType<($NoiseThresholdCountPlacement)>
static readonly "BIOME_FILTER": $PlacementModifierType<($BiomeFilter)>
static readonly "HEIGHTMAP": $PlacementModifierType<($HeightmapPlacement)>
static readonly "BLOCK_PREDICATE_FILTER": $PlacementModifierType<($BlockPredicateFilter)>
static readonly "NOISE_BASED_COUNT": $PlacementModifierType<($NoiseBasedCountPlacement)>
static readonly "SURFACE_WATER_DEPTH_FILTER": $PlacementModifierType<($SurfaceWaterDepthFilter)>
static readonly "COUNT_ON_EVERY_LAYER": $PlacementModifierType<($CountOnEveryLayerPlacement)>
static readonly "IN_SQUARE": $PlacementModifierType<($InSquarePlacement)>
static readonly "RANDOM_OFFSET": $PlacementModifierType<($RandomOffsetPlacement)>
static readonly "COUNT": $PlacementModifierType<($CountPlacement)>

 "codec"(): $MapCodec<(P)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlacementModifierType$$Type<P> = (Special.WorldgenPlacementModifierType) | (() => $MapCodec$$Type<(P)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlacementModifierType$$Original<P> = $PlacementModifierType<(P)>;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration" {
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $RootSystemConfiguration implements $FeatureConfiguration$$Interface {
readonly "hangingRootsVerticalSpan": integer
static readonly "CODEC": $Codec<($RootSystemConfiguration)>
readonly "allowedVerticalWaterForTree": integer
readonly "hangingRootPlacementAttempts": integer
readonly "rootReplaceable": $TagKey<($Block)>
readonly "rootStateProvider": $BlockStateProvider
readonly "requiredVerticalSpaceForTree": integer
readonly "rootPlacementAttempts": integer
readonly "allowedTreePosition": $BlockPredicate
readonly "hangingRootRadius": integer
readonly "hangingRootStateProvider": $BlockStateProvider
readonly "rootRadius": integer
readonly "rootColumnMaxHeight": integer
readonly "treeFeature": $Holder<($PlacedFeature)>

constructor(arg0: $Holder$$Type<($PlacedFeature)>, arg1: integer, arg2: integer, arg3: $TagKey$$Type<($Block)>, arg4: $BlockStateProvider$$Type, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: $BlockStateProvider$$Type, arg10: integer, arg11: integer, arg12: $BlockPredicate$$Type)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RootSystemConfiguration$$Type = ($RootSystemConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RootSystemConfiguration$$Original = $RootSystemConfiguration;}
declare module "net.minecraft.world.level.block.entity.JigsawBlockEntity$JointType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Optional} from "java.util.Optional"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Component} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $JigsawBlockEntity$JointType extends $Enum<($JigsawBlockEntity$JointType)> implements $StringRepresentable$$Interface {
static readonly "ROLLABLE": $JigsawBlockEntity$JointType
static readonly "ALIGNED": $JigsawBlockEntity$JointType

public static "values"(): ($JigsawBlockEntity$JointType)[]
public static "valueOf"(arg0: StringJS): $JigsawBlockEntity$JointType
public "getSerializedName"(): StringJS
public static "byName"(arg0: StringJS): $Optional<($JigsawBlockEntity$JointType)>
public "getTranslatedName"(): $Component
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "translatedName"(): $Component
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JigsawBlockEntity$JointType$$Type = (("rollable") | ("aligned"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JigsawBlockEntity$JointType$$Original = $JigsawBlockEntity$JointType;}
declare module "net.minecraft.world.level.levelgen.structure.structures.WoodlandMansionStructure" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$Optional} from "java.util.Optional"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$PiecesContainer$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $WoodlandMansionStructure extends $Structure {
static readonly "CODEC": $MapCodec<($WoodlandMansionStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "type"(): $StructureType<(never)>
public "afterPlace"(arg0: $WorldGenLevel$$Type, arg1: $StructureManager$$Type, arg2: $ChunkGenerator$$Type, arg3: $RandomSource$$Type, arg4: $BoundingBox$$Type, arg5: $ChunkPos$$Type, arg6: $PiecesContainer$$Type): void
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WoodlandMansionStructure$$Type = ($WoodlandMansionStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WoodlandMansionStructure$$Original = $WoodlandMansionStructure;}
declare module "net.minecraft.world.level.block.entity.LecternBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$MenuProvider$$Interface} from "net.minecraft.world.MenuProvider"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LecternBlockEntity extends $BlockEntity implements $Clearable$$Interface, $MenuProvider$$Interface {
 "worldPosition": $BlockPos
static readonly "NUM_SLOTS": integer
static readonly "DATA_PAGE": integer
 "level": $Level
 "book": $ItemStack
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "page": integer
 "hasComparators": byte
static readonly "SLOT_BOOK": integer
static readonly "NUM_DATA": integer
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getDisplayName"(): $Component
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getRedstoneSignal"(): integer
public "getPage"(): integer
public "onBookItemRemove"(): void
public "onlyOpCanSetNbt"(): boolean
public "getBook"(): $ItemStack
public "setBook"(arg0: $ItemStack$$Type): void
public "setBook"(arg0: $ItemStack$$Type, arg1: $Player$$Type): void
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "hasBook"(): boolean
public "setPage"(arg0: integer): void
public "clearContent"(): void
public "handler$gdk000$camera$resolveBook"(arg0: $ItemStack$$Type, arg1: $Player$$Type, arg2: $CallbackInfoReturnable$$Type): void
public "handler$gdk000$camera$setBook"(arg0: $ItemStack$$Type, arg1: $Player$$Type, arg2: $CallbackInfo$$Type): void
public "handler$gdk000$camera$createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type, arg3: $CallbackInfoReturnable$$Type): void
public "handler$gdk000$camera$hasBook"(arg0: $CallbackInfoReturnable$$Type): void
public "handler$gdk000$camera$read"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: $CallbackInfo$$Type): void
public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public static "tryClear"(arg0: any): void
public "shouldTriggerClientSideContainerClosingOnOpen"(): boolean
public "writeClientSideData"(arg0: $AbstractContainerMenu$$Type, arg1: $RegistryFriendlyByteBuf$$Type): void
public "shouldCloseCurrentScreen"(): boolean
get "displayName"(): $Component
get "redstoneSignal"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LecternBlockEntity$$Type = ($LecternBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LecternBlockEntity$$Original = $LecternBlockEntity;}
declare module "net.minecraft.world.level.block.entity.BeehiveBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$BeehiveBlockEntity$Occupant$$Type} from "net.minecraft.world.level.block.entity.BeehiveBlockEntity$Occupant"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$BeehiveBlockEntity$BeeReleaseStatus$$Type} from "net.minecraft.world.level.block.entity.BeehiveBlockEntity$BeeReleaseStatus"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BeehiveBlockEntity extends $BlockEntity {
static readonly "IGNORED_BEE_TAGS": $List<(StringJS)>
 "worldPosition": $BlockPos
 "level": $Level
static readonly "MIN_OCCUPATION_TICKS_NECTARLESS": integer
static readonly "MAX_OCCUPANTS": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "isEmpty"(): boolean
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getOccupantCount"(): integer
public static "getHoneyLevel"(arg0: $BlockState$$Type): integer
public "addOccupant"(arg0: $Entity$$Type): void
public "isFireNearby"(): boolean
public "emptyAllLivingFromHive"(arg0: $Player$$Type, arg1: $BlockState$$Type, arg2: $BeehiveBlockEntity$BeeReleaseStatus$$Type): void
public "isFull"(): boolean
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "isSedated"(): boolean
public "storeBee"(arg0: $BeehiveBlockEntity$Occupant$$Type): void
public "setChanged"(): void
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BeehiveBlockEntity$$Type): void
public "collectImplicitComponents"(arg0: $DataComponentMap$Builder$$Type): void
public "applyImplicitComponents"(arg0: $BlockEntity$DataComponentInput$$Type): void
get "empty"(): boolean
get "occupantCount"(): integer
get "fireNearby"(): boolean
get "full"(): boolean
get "sedated"(): boolean
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeehiveBlockEntity$$Type = ($BeehiveBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeehiveBlockEntity$$Original = $BeehiveBlockEntity;}
declare module "net.minecraft.world.level.block.state.StateDefinition$Builder" {
import {$StateDefinition$Factory$$Type} from "net.minecraft.world.level.block.state.StateDefinition$Factory"
import {$Function$$Type} from "java.util.function.Function"
import {$StateHolder} from "net.minecraft.world.level.block.state.StateHolder"
import {$StateDefinition} from "net.minecraft.world.level.block.state.StateDefinition"
import {$Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $StateDefinition$Builder<O, S extends $StateHolder<(object), (object)>> {
constructor(arg0: O)

public "add"(...arg0: ($Property$$Type<(never)>)[]): $StateDefinition$Builder<(O), (S)>
public "create"(arg0: $Function$$Type<(O), (S)>, arg1: $StateDefinition$Factory$$Type<(O), (S)>): $StateDefinition<(O), (S)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StateDefinition$Builder$$Type<O, S> = ($StateDefinition$Builder<(O), (S)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StateDefinition$Builder$$Original<O, S> = $StateDefinition$Builder<(O), (S)>;}
declare module "net.minecraft.world.level.levelgen.NoiseRouter" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction, $DensityFunction$$Type} from "net.minecraft.world.level.levelgen.DensityFunction"
import {$Record} from "java.lang.Record"

export class $NoiseRouter extends $Record {
static readonly "CODEC": $Codec<($NoiseRouter)>

constructor(arg0: $DensityFunction$$Type, arg1: $DensityFunction$$Type, arg2: $DensityFunction$$Type, arg3: $DensityFunction$$Type, arg4: $DensityFunction$$Type, arg5: $DensityFunction$$Type, arg6: $DensityFunction$$Type, arg7: $DensityFunction$$Type, arg8: $DensityFunction$$Type, arg9: $DensityFunction$$Type, arg10: $DensityFunction$$Type, arg11: $DensityFunction$$Type, arg12: $DensityFunction$$Type, arg13: $DensityFunction$$Type, arg14: $DensityFunction$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "depth"(): $DensityFunction
public "temperature"(): $DensityFunction
public "continents"(): $DensityFunction
public "ridges"(): $DensityFunction
public "vegetation"(): $DensityFunction
public "veinRidged"(): $DensityFunction
public "veinToggle"(): $DensityFunction
public "veinGap"(): $DensityFunction
public "lavaNoise"(): $DensityFunction
public "fluidLevelSpreadNoise"(): $DensityFunction
public "fluidLevelFloodednessNoise"(): $DensityFunction
public "initialDensityWithoutJaggedness"(): $DensityFunction
public "erosion"(): $DensityFunction
public "finalDensity"(): $DensityFunction
public "barrierNoise"(): $DensityFunction
public "mapAll"(arg0: $DensityFunction$Visitor$$Type): $NoiseRouter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseRouter$$Type = ({"finalDensity"?: $DensityFunction$$Type, "veinRidged"?: $DensityFunction$$Type, "veinGap"?: $DensityFunction$$Type, "continents"?: $DensityFunction$$Type, "initialDensityWithoutJaggedness"?: $DensityFunction$$Type, "veinToggle"?: $DensityFunction$$Type, "lavaNoise"?: $DensityFunction$$Type, "fluidLevelFloodednessNoise"?: $DensityFunction$$Type, "fluidLevelSpreadNoise"?: $DensityFunction$$Type, "erosion"?: $DensityFunction$$Type, "ridges"?: $DensityFunction$$Type, "depth"?: $DensityFunction$$Type, "vegetation"?: $DensityFunction$$Type, "barrierNoise"?: $DensityFunction$$Type, "temperature"?: $DensityFunction$$Type}) | ([finalDensity?: $DensityFunction$$Type, veinRidged?: $DensityFunction$$Type, veinGap?: $DensityFunction$$Type, continents?: $DensityFunction$$Type, initialDensityWithoutJaggedness?: $DensityFunction$$Type, veinToggle?: $DensityFunction$$Type, lavaNoise?: $DensityFunction$$Type, fluidLevelFloodednessNoise?: $DensityFunction$$Type, fluidLevelSpreadNoise?: $DensityFunction$$Type, erosion?: $DensityFunction$$Type, ridges?: $DensityFunction$$Type, depth?: $DensityFunction$$Type, vegetation?: $DensityFunction$$Type, barrierNoise?: $DensityFunction$$Type, temperature?: $DensityFunction$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseRouter$$Original = $NoiseRouter;}
declare module "net.minecraft.world.level.block.state.StateDefinition" {
import {$Pattern} from "java.util.regex.Pattern"
import {$StateDefinition$Factory$$Type} from "net.minecraft.world.level.block.state.StateDefinition$Factory"
import {$Collection} from "java.util.Collection"
import {$Map$$Type} from "java.util.Map"
import {$Comparable} from "java.lang.Comparable"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StateHolder} from "net.minecraft.world.level.block.state.StateHolder"
import {$ImmutableList} from "com.google.common.collect.ImmutableList"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $StateDefinition<O, S extends $StateHolder<(object), (object)>> {
static readonly "NAME_PATTERN": $Pattern

constructor(arg0: $Function$$Type<(O), (S)>, arg1: O, arg2: $StateDefinition$Factory$$Type<(O), (S)>, arg3: $Map$$Type<(StringJS), ($Property$$Type<(never)>)>)

public "getProperty"(arg0: StringJS): $Property<(never)>
public "toString"(): StringJS
public "getProperties"(): $Collection<($Property<(never)>)>
public "getOwner"(): O
public "any"(): S
public static "appendPropertyCodec"<S extends $StateHolder<(object), (object)>, T extends $Comparable<(object)>>(arg0: $MapCodec$$Type<(S)>, arg1: $Supplier$$Type<(S)>, arg2: StringJS, arg3: $Property$$Type<(T)>): $MapCodec<(S)>
public "getPossibleStates"(): $ImmutableList<(S)>
get "properties"(): $Collection<($Property<(never)>)>
get "owner"(): O
get "possibleStates"(): $ImmutableList<(S)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StateDefinition$$Type<O, S> = ($StateDefinition<(O), (S)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StateDefinition$$Original<O, S> = $StateDefinition<(O), (S)>;}
declare module "net.minecraft.world.level.lighting.LayerLightEventListener" {
import {$LightEventListener$$Interface} from "net.minecraft.world.level.lighting.LightEventListener"
import {$SectionPos$$Type} from "net.minecraft.core.SectionPos"
import {$DataLayer} from "net.minecraft.world.level.chunk.DataLayer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"

export interface $LayerLightEventListener$$Interface extends $LightEventListener$$Interface {
}

export class $LayerLightEventListener implements $LayerLightEventListener$$Interface {
 "getLightValue"(arg0: $BlockPos$$Type): integer
 "getDataLayerData"(arg0: $SectionPos$$Type): $DataLayer
 "checkBlock"(arg0: $BlockPos$$Type): void
 "setLightEnabled"(arg0: $ChunkPos$$Type, arg1: boolean): void
 "runLightUpdates"(): integer
 "updateSectionStatus"(arg0: $SectionPos$$Type, arg1: boolean): void
 "updateSectionStatus"(arg0: $BlockPos$$Type, arg1: boolean): void
 "hasLightWork"(): boolean
 "propagateLightSources"(arg0: $ChunkPos$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LayerLightEventListener$$Type = ($LayerLightEventListener);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LayerLightEventListener$$Original = $LayerLightEventListener;}
declare module "net.minecraft.world.level.block.state.properties.WoodType" {
import {$Map} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$BlockSetType, $BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Stream} from "java.util.stream.Stream"
import {$Record} from "java.lang.Record"

export class $WoodType extends $Record {
static readonly "MANGROVE": $WoodType
static readonly "CODEC": $Codec<($WoodType)>
static readonly "BAMBOO": $WoodType
static readonly "ACACIA": $WoodType
static readonly "JUNGLE": $WoodType
static readonly "CRIMSON": $WoodType
static readonly "DARK_OAK": $WoodType
static readonly "TYPES": $Map<(StringJS), ($WoodType)>
static readonly "SPRUCE": $WoodType
static readonly "CHERRY": $WoodType
static readonly "BIRCH": $WoodType
static readonly "WARPED": $WoodType
static readonly "OAK": $WoodType

constructor(arg0: StringJS, arg1: $BlockSetType$$Type)
constructor(arg0: StringJS, arg1: $BlockSetType$$Type, arg2: $SoundType$$Type, arg3: $SoundType$$Type, arg4: $SoundEvent$$Type, arg5: $SoundEvent$$Type)

public "setType"(): $BlockSetType
public "name"(): StringJS
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public static "values"(): $Stream<($WoodType)>
public "hashCode"(): integer
public static "register"(arg0: $WoodType$$Type): $WoodType
public "hangingSignSoundType"(): $SoundType
public "fenceGateClose"(): $SoundEvent
public "soundType"(): $SoundType
public "fenceGateOpen"(): $SoundEvent
get "type"(): $BlockSetType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WoodType$$Type = ({"fenceGateClose"?: $SoundEvent$$Type, "name"?: StringJS, "hangingSignSoundType"?: $SoundType$$Type, "setType"?: $BlockSetType$$Type, "fenceGateOpen"?: $SoundEvent$$Type, "soundType"?: $SoundType$$Type}) | ([fenceGateClose?: $SoundEvent$$Type, name?: StringJS, hangingSignSoundType?: $SoundType$$Type, setType?: $BlockSetType$$Type, fenceGateOpen?: $SoundEvent$$Type, soundType?: $SoundType$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WoodType$$Original = $WoodType;}
declare module "net.minecraft.world.level.levelgen.structure.pools.SinglePoolElement" {
import {$StructurePoolElementType} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElementType"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$List, $List$$Type} from "java.util.List"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$StructurePlaceSettings} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"
import {$StructureProcessorList, $StructureProcessorList$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessorList"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Vec3i} from "net.minecraft.core.Vec3i"
import {$Either, $Either$$Type} from "com.mojang.datafixers.util.Either"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AccessorSinglePoolElement$$Interface} from "com.furiusmax.bjornlib.neo.mixin.structures.AccessorSinglePoolElement"
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$LiquidSettings, $LiquidSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings"
import {$StructurePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElement"
import {$StructureTemplate, $StructureTemplate$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$RecordCodecBuilder} from "com.mojang.serialization.codecs.RecordCodecBuilder"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$StructureTemplatePool$Projection$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool$Projection"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $SinglePoolElement extends $StructurePoolElement implements $AccessorSinglePoolElement$$Interface {
readonly "template": $Either<($ResourceLocation), ($StructureTemplate)>
static readonly "CODEC": $MapCodec<($SinglePoolElement)>
readonly "overrideLiquidSettings": $Optional<($LiquidSettings)>
readonly "processors": $Holder<($StructureProcessorList)>

constructor(arg0: $Either$$Type<($ResourceLocation$$Type), ($StructureTemplate$$Type)>, arg1: $Holder$$Type<($StructureProcessorList)>, arg2: $StructureTemplatePool$Projection$$Type, arg3: ($LiquidSettings$$Type)?)

public "toString"(): StringJS
public "getType"(): $StructurePoolElementType<(never)>
public "getSize"(arg0: $StructureTemplateManager$$Type, arg1: $Rotation$$Type): $Vec3i
public "getShuffledJigsawBlocks"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type, arg3: $RandomSource$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public static "sortBySelectionPriority"(arg0: $List$$Type<($StructureTemplate$StructureBlockInfo$$Type)>): void
public "getSettings"(arg0: $Rotation$$Type, arg1: $BoundingBox$$Type, arg2: $LiquidSettings$$Type, arg3: boolean): $StructurePlaceSettings
public static "overrideLiquidSettingsCodec"<E extends $SinglePoolElement>(): $RecordCodecBuilder<(E), ($Optional<($LiquidSettings)>)>
public "place"(arg0: $StructureTemplateManager$$Type, arg1: $WorldGenLevel$$Type, arg2: $StructureManager$$Type, arg3: $ChunkGenerator$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type, arg6: $Rotation$$Type, arg7: $BoundingBox$$Type, arg8: $RandomSource$$Type, arg9: $LiquidSettings$$Type, arg10: boolean): boolean
public "getTemplate"(): $Either
public "getDataMarkers"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type, arg3: boolean): $List<($StructureTemplate$StructureBlockInfo)>
public static "templateCodec"<E extends $SinglePoolElement>(): $RecordCodecBuilder<(E), ($Either<($ResourceLocation), ($StructureTemplate)>)>
public static "processorsCodec"<E extends $SinglePoolElement>(): $RecordCodecBuilder<(E), ($Holder<($StructureProcessorList)>)>
public "getBoundingBox"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type): $BoundingBox
get "type"(): $StructurePoolElementType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SinglePoolElement$$Type = ($SinglePoolElement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SinglePoolElement$$Original = $SinglePoolElement;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.BlockStateMatchTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$RuleTestType} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTestType"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStateMatchTest extends $RuleTest {
static readonly "CODEC": $MapCodec<($BlockStateMatchTest)>

constructor(arg0: $BlockState$$Type)

public "test"(arg0: $BlockState$$Type, arg1: $RandomSource$$Type): boolean
public "getType"(): $RuleTestType<(never)>
get "type"(): $RuleTestType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateMatchTest$$Type = ($BlockStateMatchTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateMatchTest$$Original = $BlockStateMatchTest;}
declare module "net.minecraft.world.level.chunk.status.ChunkStatusTask" {
import {$ChunkStep, $ChunkStep$$Type} from "net.minecraft.world.level.chunk.status.ChunkStep"
import {$CompletableFuture, $CompletableFuture$$Type} from "java.util.concurrent.CompletableFuture"
import {$ChunkAccess, $ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$WorldGenContext, $WorldGenContext$$Type} from "net.minecraft.world.level.chunk.status.WorldGenContext"
import {$StaticCache2D, $StaticCache2D$$Type} from "net.minecraft.util.StaticCache2D"
import {$GenerationChunkHolder, $GenerationChunkHolder$$Type} from "net.minecraft.server.level.GenerationChunkHolder"

export interface $ChunkStatusTask$$Interface {

(arg0: $WorldGenContext, arg1: $ChunkStep, arg2: $StaticCache2D<($GenerationChunkHolder)>, arg3: $ChunkAccess): $CompletableFuture$$Type<($ChunkAccess$$Type)>
}

export class $ChunkStatusTask implements $ChunkStatusTask$$Interface {
 "doWork"(arg0: $WorldGenContext$$Type, arg1: $ChunkStep$$Type, arg2: $StaticCache2D$$Type<($GenerationChunkHolder$$Type)>, arg3: $ChunkAccess$$Type): $CompletableFuture<($ChunkAccess)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkStatusTask$$Type = ((arg0: $WorldGenContext, arg1: $ChunkStep, arg2: $StaticCache2D<($GenerationChunkHolder)>, arg3: $ChunkAccess) => $CompletableFuture$$Type<($ChunkAccess$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkStatusTask$$Original = $ChunkStatusTask;}
declare module "net.minecraft.world.level.levelgen.BelowZeroRetrogen" {
import {$ProtoChunk$$Type} from "net.minecraft.world.level.chunk.ProtoChunk"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BiomeResolver, $BiomeResolver$$Type} from "net.minecraft.world.level.biome.BiomeResolver"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ChunkStatus} from "net.minecraft.world.level.chunk.status.ChunkStatus"

export class $BelowZeroRetrogen {
static readonly "CODEC": $Codec<($BelowZeroRetrogen)>
static readonly "UPGRADE_HEIGHT_ACCESSOR": $LevelHeightAccessor

public static "read"(arg0: $CompoundTag$$Type): $BelowZeroRetrogen
public "targetStatus"(): $ChunkStatus
public static "getBiomeResolver"(arg0: $BiomeResolver$$Type, arg1: $ChunkAccess$$Type): $BiomeResolver
public static "replaceOldBedrock"(arg0: $ProtoChunk$$Type): void
public "hasBedrockHoles"(): boolean
public "applyBedrockMask"(arg0: $ProtoChunk$$Type): void
public "hasBedrockHole"(arg0: integer, arg1: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BelowZeroRetrogen$$Type = ($BelowZeroRetrogen);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BelowZeroRetrogen$$Original = $BelowZeroRetrogen;}
declare module "net.minecraft.world.level.timers.TimerCallbacks" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TimerCallback, $TimerCallback$$Type} from "net.minecraft.world.level.timers.TimerCallback"
import {$TimerCallback$Serializer$$Type} from "net.minecraft.world.level.timers.TimerCallback$Serializer"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"

export class $TimerCallbacks<C> {
static readonly "SERVER_CALLBACKS": $TimerCallbacks<($MinecraftServer)>

constructor()

public "register"(arg0: $TimerCallback$Serializer$$Type<(C), (never)>): $TimerCallbacks<(C)>
public "serialize"<T extends $TimerCallback<(object)>>(arg0: T): $CompoundTag
public "deserialize"(arg0: $CompoundTag$$Type): $TimerCallback<(C)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimerCallbacks$$Type<C> = ($TimerCallbacks<(C)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TimerCallbacks$$Original<C> = $TimerCallbacks<(C)>;}
declare module "net.minecraft.world.level.GameRules$Type" {
import {$ArgumentType, $ArgumentType$$Type} from "com.mojang.brigadier.arguments.ArgumentType"
import {$RequiredArgumentBuilder} from "com.mojang.brigadier.builder.RequiredArgumentBuilder"
import {$GameRules$Value} from "net.minecraft.world.level.GameRules$Value"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$GameRules$VisitorCaller$$Type} from "net.minecraft.world.level.GameRules$VisitorCaller"
import {$GameRules$GameRuleTypeVisitor$$Type} from "net.minecraft.world.level.GameRules$GameRuleTypeVisitor"
import {$GameRules$Key$$Type} from "net.minecraft.world.level.GameRules$Key"
import {$CommandSourceStack} from "net.minecraft.commands.CommandSourceStack"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export class $GameRules$Type<T extends $GameRules$Value<(object)>> {
readonly "argument": $Supplier<($ArgumentType<(never)>)>
 "constructor": $Function<($GameRules$Type<(T)>), (T)>
readonly "callback": $BiConsumer<($MinecraftServer), (T)>

constructor(arg0: $Supplier$$Type<($ArgumentType$$Type<(never)>)>, arg1: $Function$$Type<($GameRules$Type<(T)>), (T)>, arg2: $BiConsumer$$Type<($MinecraftServer), (T)>, arg3: $GameRules$VisitorCaller$$Type<(T)>)

public "callVisitor"(arg0: $GameRules$GameRuleTypeVisitor$$Type, arg1: $GameRules$Key$$Type<(T)>): void
public "createArgument"(arg0: StringJS): $RequiredArgumentBuilder<($CommandSourceStack), (never)>
public "createRule"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$Type$$Type<T> = ($GameRules$Type<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$Type$$Original<T> = $GameRules$Type<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.FancyTrunkPlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$TrunkPlacerType} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacerType"
import {$List} from "java.util.List"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $FancyTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($FancyTrunkPlacer)>
static readonly "MAX_HEIGHT": integer
readonly "baseHeight": integer
readonly "heightRandA": integer
readonly "heightRandB": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "type"(): $TrunkPlacerType<(never)>
public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FancyTrunkPlacer$$Type = ($FancyTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FancyTrunkPlacer$$Original = $FancyTrunkPlacer;}
declare module "net.minecraft.world.level.levelgen.RandomSupport$Seed128bit" {
import {$Record} from "java.lang.Record"

export class $RandomSupport$Seed128bit extends $Record {
constructor(arg0: long, arg1: long)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "xor"(arg0: long, arg1: long): $RandomSupport$Seed128bit
public "xor"(arg0: $RandomSupport$Seed128bit$$Type): $RandomSupport$Seed128bit
public "mixed"(): $RandomSupport$Seed128bit
public "seedLo"(): long
public "seedHi"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomSupport$Seed128bit$$Type = ({"seedLo"?: long, "seedHi"?: long}) | ([seedLo?: long, seedHi?: long]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomSupport$Seed128bit$$Original = $RandomSupport$Seed128bit;}
declare module "net.minecraft.world.level.block.entity.vault.VaultClientData" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $VaultClientData {
static readonly "ROTATION_SPEED": float

constructor()

public "previousSpin"(): float
public "currentSpin"(): float
public "updateDisplayItemSpin"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VaultClientData$$Type = ($VaultClientData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VaultClientData$$Original = $VaultClientData;}
declare module "net.minecraft.world.level.block.entity.EnderChestBlockEntity" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LidBlockEntity$$Interface} from "net.minecraft.world.level.block.entity.LidBlockEntity"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EnderChestBlockEntity extends $BlockEntity implements $LidBlockEntity$$Interface {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "triggerEvent"(arg0: integer, arg1: integer): boolean
public "stillValid"(arg0: $Player$$Type): boolean
public "stopOpen"(arg0: $Player$$Type): void
public "startOpen"(arg0: $Player$$Type): void
public static "lidAnimateTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $EnderChestBlockEntity$$Type): void
public "recheckOpen"(): void
public "getOpenNess"(arg0: float): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnderChestBlockEntity$$Type = ($EnderChestBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EnderChestBlockEntity$$Original = $EnderChestBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$RuleBasedBlockStateProvider, $RuleBasedBlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.RuleBasedBlockStateProvider"
import {$Record} from "java.lang.Record"

export class $DiskConfiguration extends $Record implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($DiskConfiguration)>

constructor(arg0: $RuleBasedBlockStateProvider$$Type, arg1: $BlockPredicate$$Type, arg2: $IntProvider$$Type, arg3: integer)

public "equals"(arg0: any): boolean
public "target"(): $BlockPredicate
public "toString"(): StringJS
public "hashCode"(): integer
public "stateProvider"(): $RuleBasedBlockStateProvider
public "radius"(): $IntProvider
public "halfHeight"(): integer
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiskConfiguration$$Type = ({"stateProvider"?: $RuleBasedBlockStateProvider$$Type, "halfHeight"?: integer, "target"?: $BlockPredicate$$Type, "radius"?: $IntProvider$$Type}) | ([stateProvider?: $RuleBasedBlockStateProvider$$Type, halfHeight?: integer, target?: $BlockPredicate$$Type, radius?: $IntProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiskConfiguration$$Original = $DiskConfiguration;}
declare module "net.minecraft.world.level.levelgen.structure.pools.FeaturePoolElement" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$StructurePoolElementType} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElementType"
import {$LiquidSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings"
import {$List} from "java.util.List"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructurePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElement"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3i} from "net.minecraft.core.Vec3i"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$StructureTemplatePool$Projection$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool$Projection"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$StructureTemplate$StructureBlockInfo} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $FeaturePoolElement extends $StructurePoolElement {
static readonly "CODEC": $MapCodec<($FeaturePoolElement)>

constructor(arg0: $Holder$$Type<($PlacedFeature)>, arg1: $StructureTemplatePool$Projection$$Type)

public "toString"(): StringJS
public "getType"(): $StructurePoolElementType<(never)>
public "getSize"(arg0: $StructureTemplateManager$$Type, arg1: $Rotation$$Type): $Vec3i
public "getShuffledJigsawBlocks"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type, arg3: $RandomSource$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "place"(arg0: $StructureTemplateManager$$Type, arg1: $WorldGenLevel$$Type, arg2: $StructureManager$$Type, arg3: $ChunkGenerator$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type, arg6: $Rotation$$Type, arg7: $BoundingBox$$Type, arg8: $RandomSource$$Type, arg9: $LiquidSettings$$Type, arg10: boolean): boolean
public "getBoundingBox"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type): $BoundingBox
get "type"(): $StructurePoolElementType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FeaturePoolElement$$Type = ($FeaturePoolElement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FeaturePoolElement$$Original = $FeaturePoolElement;}
declare module "net.minecraft.world.level.storage.loot.LootParams$Builder" {
import {$LootContextParam$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LootParams$DynamicDrop$$Type} from "net.minecraft.world.level.storage.loot.LootParams$DynamicDrop"
import {$LootParams} from "net.minecraft.world.level.storage.loot.LootParams"
import {$LootContextParamSet$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet"

export class $LootParams$Builder {
constructor(arg0: $ServerLevel$$Type)

public "create"(arg0: $LootContextParamSet$$Type): $LootParams
public "getLevel"(): $ServerLevel
public "withOptionalParameter"<T>(arg0: $LootContextParam$$Type<(T)>, arg1: T): $LootParams$Builder
public "withDynamicDrop"(arg0: $ResourceLocation$$Type, arg1: $LootParams$DynamicDrop$$Type): $LootParams$Builder
public "getParameter"<T>(arg0: $LootContextParam$$Type<(T)>): T
public "getOptionalParameter"<T>(arg0: $LootContextParam$$Type<(T)>): T
public "withLuck"(arg0: float): $LootParams$Builder
public "withParameter"<T>(arg0: $LootContextParam$$Type<(T)>, arg1: T): $LootParams$Builder
get "level"(): $ServerLevel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootParams$Builder$$Type = ($LootParams$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootParams$Builder$$Original = $LootParams$Builder;}
declare module "net.minecraft.world.level.portal.DimensionTransition$PostDimensionTransition" {
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"

export interface $DimensionTransition$PostDimensionTransition$$Interface {

(arg0: $Entity): void
}

export class $DimensionTransition$PostDimensionTransition implements $DimensionTransition$PostDimensionTransition$$Interface {
 "onTransition"(arg0: $Entity$$Type): void
 "then"(arg0: $DimensionTransition$PostDimensionTransition$$Type): $DimensionTransition$PostDimensionTransition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionTransition$PostDimensionTransition$$Type = ((arg0: $Entity) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DimensionTransition$PostDimensionTransition$$Original = $DimensionTransition$PostDimensionTransition;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Record} from "java.lang.Record"

export class $StructureTemplate$StructureBlockInfo extends $Record {
constructor(pos: $BlockPos$$Type, state: $BlockState$$Type, nbt: $CompoundTag$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "state"(): $BlockState
public "pos"(): $BlockPos
public "nbt"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureTemplate$StructureBlockInfo$$Type = ({"pos"?: $BlockPos$$Type, "nbt"?: $CompoundTag$$Type, "state"?: $BlockState$$Type}) | ([pos?: $BlockPos$$Type, nbt?: $CompoundTag$$Type, state?: $BlockState$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureTemplate$StructureBlockInfo$$Original = $StructureTemplate$StructureBlockInfo;}
declare module "net.minecraft.world.level.levelgen.structure.pieces.StructurePieceType" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$StructurePiece, $StructurePiece$$Type} from "net.minecraft.world.level.levelgen.structure.StructurePiece"
import {$StructurePieceSerializationContext, $StructurePieceSerializationContext$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext"

export interface $StructurePieceType$$Interface {

(arg0: $StructurePieceSerializationContext, arg1: $CompoundTag): $StructurePiece$$Type
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenStructurePiece
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenStructurePieceTag
}

export class $StructurePieceType implements $StructurePieceType$$Interface {
static readonly "NETHER_FORTRESS_BRIDGE_STRAIGHT": $StructurePieceType
static readonly "NETHER_FORTRESS_STAIRS_ROOM": $StructurePieceType
static readonly "STRONGHOLD_LEFT_TURN": $StructurePieceType
static readonly "STRONGHOLD_FIVE_CROSSING": $StructurePieceType
static readonly "NETHER_FORTRESS_BRIDGE_END_FILLER": $StructurePieceType
static readonly "OCEAN_MONUMENT_WING_ROOM": $StructurePieceType
static readonly "JIGSAW": $StructurePieceType
static readonly "OCEAN_MONUMENT_DOUBLE_YZ_ROOM": $StructurePieceType
static readonly "BURIED_TREASURE_PIECE": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_CORRIDOR_STAIRS": $StructurePieceType
static readonly "OCEAN_MONUMENT_BUILDING": $StructurePieceType
static readonly "NETHER_FORTRESS_MONSTER_THRONE": $StructurePieceType
static readonly "STRONGHOLD_LIBRARY": $StructurePieceType
static readonly "STRONGHOLD_ROOM_CROSSING": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_SMALL_CORRIDOR_CROSSING": $StructurePieceType
static readonly "OCEAN_MONUMENT_ENTRY_ROOM": $StructurePieceType
static readonly "STRONGHOLD_FILLER_CORRIDOR": $StructurePieceType
static readonly "JUNGLE_PYRAMID_PIECE": $StructurePieceType
static readonly "MINE_SHAFT_CROSSING": $StructurePieceType
static readonly "NETHER_FORTRESS_BRIDGE_CROSSING": $StructurePieceType
static readonly "RUINED_PORTAL": $StructurePieceType
static readonly "STRONGHOLD_STRAIGHT_STAIRS_DOWN": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_SMALL_CORRIDOR_RIGHT_TURN": $StructurePieceType
static readonly "STRONGHOLD_PORTAL_ROOM": $StructurePieceType
static readonly "OCEAN_MONUMENT_CORE_ROOM": $StructurePieceType
static readonly "WOODLAND_MANSION_PIECE": $StructurePieceType
static readonly "NETHER_FORTRESS_START": $StructurePieceType
static readonly "OCEAN_MONUMENT_DOUBLE_X_ROOM": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_SMALL_CORRIDOR": $StructurePieceType
static readonly "STRONGHOLD_CHEST_CORRIDOR": $StructurePieceType
static readonly "NETHER_FORTRESS_ROOM_CROSSING": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_ENTRANCE": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_SMALL_CORRIDOR_LEFT_TURN": $StructurePieceType
static readonly "OCEAN_MONUMENT_SIMPLE_ROOM": $StructurePieceType
static readonly "STRONGHOLD_STRAIGHT": $StructurePieceType
static readonly "MINE_SHAFT_STAIRS": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_STALK_ROOM": $StructurePieceType
static readonly "MINE_SHAFT_CORRIDOR": $StructurePieceType
static readonly "OCEAN_MONUMENT_DOUBLE_XY_ROOM": $StructurePieceType
static readonly "SHIPWRECK_PIECE": $StructurePieceType
static readonly "OCEAN_MONUMENT_DOUBLE_Z_ROOM": $StructurePieceType
static readonly "MINE_SHAFT_ROOM": $StructurePieceType
static readonly "OCEAN_RUIN": $StructurePieceType
static readonly "STRONGHOLD_PRISON_HALL": $StructurePieceType
static readonly "NETHER_FORTRESS_CASTLE_CORRIDOR_T_BALCONY": $StructurePieceType
static readonly "OCEAN_MONUMENT_DOUBLE_Y_ROOM": $StructurePieceType
static readonly "NETHER_FOSSIL": $StructurePieceType
static readonly "IGLOO": $StructurePieceType
static readonly "OCEAN_MONUMENT_SIMPLE_TOP_ROOM": $StructurePieceType
static readonly "STRONGHOLD_STAIRS_DOWN": $StructurePieceType
static readonly "SWAMPLAND_HUT": $StructurePieceType
static readonly "DESERT_PYRAMID_PIECE": $StructurePieceType
static readonly "END_CITY_PIECE": $StructurePieceType
static readonly "STRONGHOLD_START": $StructurePieceType
static readonly "OCEAN_MONUMENT_PENTHOUSE": $StructurePieceType
static readonly "STRONGHOLD_RIGHT_TURN": $StructurePieceType

 "load"(arg0: $StructurePieceSerializationContext$$Type, arg1: $CompoundTag$$Type): $StructurePiece
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePieceType$$Type = (Special.WorldgenStructurePiece) | ((arg0: $StructurePieceSerializationContext, arg1: $CompoundTag) => $StructurePiece$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePieceType$$Original = $StructurePieceType;}
declare module "net.minecraft.world.level.levelgen.structure.StructureStart" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$List} from "java.util.List"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$StructurePiece} from "net.minecraft.world.level.levelgen.structure.StructurePiece"
import {$Structure, $Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$StructurePieceSerializationContext$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext"
import {$PiecesContainer$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer"

export class $StructureStart {
static readonly "INVALID_START": $StructureStart
static readonly "INVALID_START_ID": StringJS

constructor(arg0: $Structure$$Type, arg1: $ChunkPos$$Type, arg2: integer, arg3: $PiecesContainer$$Type)

public "isValid"(): boolean
public static "loadStaticStart"(arg0: $StructurePieceSerializationContext$$Type, arg1: $CompoundTag$$Type, arg2: long): $StructureStart
public "addReference"(): void
public "createTag"(arg0: $StructurePieceSerializationContext$$Type, arg1: $ChunkPos$$Type): $CompoundTag
public "getPieces"(): $List<($StructurePiece)>
public "getChunkPos"(): $ChunkPos
public "canBeReferenced"(): boolean
public "placeInChunk"(arg0: $WorldGenLevel$$Type, arg1: $StructureManager$$Type, arg2: $ChunkGenerator$$Type, arg3: $RandomSource$$Type, arg4: $BoundingBox$$Type, arg5: $ChunkPos$$Type): void
public "getReferences"(): integer
public "getStructure"(): $Structure
public "getBoundingBox"(): $BoundingBox
public "getMaxReferences"(): integer
get "valid"(): boolean
get "pieces"(): $List<($StructurePiece)>
get "chunkPos"(): $ChunkPos
get "references"(): integer
get "structure"(): $Structure
get "boundingBox"(): $BoundingBox
get "maxReferences"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureStart$$Type = ($StructureStart);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureStart$$Original = $StructureStart;}
declare module "net.minecraft.world.level.saveddata.maps.MapDecoration" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MapDecorationType, $MapDecorationType$$Type} from "net.minecraft.world.level.saveddata.maps.MapDecorationType"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $MapDecoration extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($MapDecoration)>

constructor(arg0: $Holder$$Type<($MapDecorationType)>, arg1: byte, arg2: byte, arg3: byte, arg4: ($Component$$Type)?)

public "name"(): $Optional<($Component)>
public "type"(): $Holder<($MapDecorationType)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "x"(): byte
public "y"(): byte
public "rot"(): byte
public "getSpriteLocation"(): $ResourceLocation
public "renderOnFrame"(): boolean
get "spriteLocation"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapDecoration$$Type = ({"type"?: $Holder$$Type<($MapDecorationType)>, "y"?: byte, "rot"?: byte, "x"?: byte, "name"?: ($Component$$Type)?}) | ([type?: $Holder$$Type<($MapDecorationType)>, y?: byte, rot?: byte, x?: byte, name?: ($Component$$Type)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapDecoration$$Original = $MapDecoration;}
declare module "net.minecraft.world.level.CollisionGetter" {
import {$Iterable} from "java.lang.Iterable"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$List} from "java.util.List"
import {$Holder} from "net.minecraft.core.Holder"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$BlockGetter, $BlockGetter$$Interface} from "net.minecraft.world.level.BlockGetter"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"

export interface $CollisionGetter$$Interface extends $BlockGetter$$Interface {
get "worldBorder"(): $WorldBorder
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "maxSection"(): integer
get "minSection"(): integer
get "sectionsCount"(): integer
get "height"(): integer
get "minBuildHeight"(): integer
}

export class $CollisionGetter implements $CollisionGetter$$Interface {
 "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
 "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
 "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
 "getWorldBorder"(): $WorldBorder
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
 "isUnobstructed"(arg0: $Entity$$Type): boolean
 "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "noCollision"(arg0: $Entity$$Type): boolean
 "noCollision"(arg0: $AABB$$Type): boolean
 "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
 "getMaxLightLevel"(): integer
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getMaxBuildHeight"(): integer
 "getSectionIndex"(arg0: integer): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionsCount"(): integer
 "getHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getMinBuildHeight"(): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
 "getBlockEntityRenderData"(arg0: $BlockPos$$Type): any
 "hasBiomes"(): boolean
 "getBiomeFabric"(arg0: $BlockPos$$Type): $Holder<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollisionGetter$$Type = ($CollisionGetter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CollisionGetter$$Original = $CollisionGetter;}
declare module "net.minecraft.world.level.gameevent.PositionSourceType" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$BlockPositionSource} from "net.minecraft.world.level.gameevent.BlockPositionSource"
import {$PositionSource} from "net.minecraft.world.level.gameevent.PositionSource"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$EntityPositionSource} from "net.minecraft.world.level.gameevent.EntityPositionSource"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export interface $PositionSourceType$$Interface<T extends $PositionSource> {
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.PositionSourceType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.PositionSourceTypeTag
}

export class $PositionSourceType<T extends $PositionSource> implements $PositionSourceType$$Interface {
static readonly "ENTITY": $PositionSourceType<($EntityPositionSource)>
static readonly "BLOCK": $PositionSourceType<($BlockPositionSource)>

static "register"<S extends $PositionSourceType<(object)>, T extends $PositionSource>(arg0: StringJS, arg1: S): S
 "codec"(): $MapCodec<(T)>
 "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PositionSourceType$$Type<T> = (Special.PositionSourceType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PositionSourceType$$Original<T> = $PositionSourceType<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ReplaceSphereConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($ReplaceSphereConfiguration)>
readonly "targetState": $BlockState
readonly "replaceState": $BlockState

constructor(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $IntProvider$$Type)

public "radius"(): $IntProvider
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplaceSphereConfiguration$$Type = ($ReplaceSphereConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReplaceSphereConfiguration$$Original = $ReplaceSphereConfiguration;}
declare module "net.minecraft.world.level.block.entity.CalibratedSculkSensorBlockEntity" {
import {$GameEvent, $GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$SculkSensorBlockEntity} from "net.minecraft.world.level.block.entity.SculkSensorBlockEntity"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$VibrationSystem$User} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$User"

export class $CalibratedSculkSensorBlockEntity extends $SculkSensorBlockEntity {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "createVibrationUser"(): $VibrationSystem$User
public "getListener"(): $GameEventListener
public static "getResonanceEventByFrequency"(arg0: integer): $ResourceKey<($GameEvent)>
public static "getRedstoneStrengthForDistance"(arg0: float, arg1: integer): integer
public static "getGameEventFrequency"(arg0: $ResourceKey$$Type<($GameEvent)>): integer
public static "getGameEventFrequency"(arg0: $Holder$$Type<($GameEvent)>): integer
get "listener"(): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CalibratedSculkSensorBlockEntity$$Type = ($CalibratedSculkSensorBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CalibratedSculkSensorBlockEntity$$Original = $CalibratedSculkSensorBlockEntity;}
declare module "net.minecraft.world.level.validation.DirectoryValidator" {
import {$PathMatcher$$Type} from "java.nio.file.PathMatcher"
import {$List, $List$$Type} from "java.util.List"
import {$ForbiddenSymlinkInfo, $ForbiddenSymlinkInfo$$Type} from "net.minecraft.world.level.validation.ForbiddenSymlinkInfo"
import {$Path$$Type} from "java.nio.file.Path"

export class $DirectoryValidator {
constructor(arg0: $PathMatcher$$Type)

public "validateSymlink"(arg0: $Path$$Type): $List<($ForbiddenSymlinkInfo)>
public "validateSymlink"(arg0: $Path$$Type, arg1: $List$$Type<($ForbiddenSymlinkInfo$$Type)>): void
public "validateDirectory"(arg0: $Path$$Type, arg1: boolean): $List<($ForbiddenSymlinkInfo)>
public "validateKnownDirectory"(arg0: $Path$$Type, arg1: $List$$Type<($ForbiddenSymlinkInfo$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectoryValidator$$Type = ($DirectoryValidator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectoryValidator$$Original = $DirectoryValidator;}
declare module "net.minecraft.world.level.levelgen.GeodeLayerSettings" {
import {$Codec} from "com.mojang.serialization.Codec"

export class $GeodeLayerSettings {
readonly "filling": double
static readonly "CODEC": $Codec<($GeodeLayerSettings)>
readonly "outerLayer": double
readonly "innerLayer": double
readonly "middleLayer": double

constructor(arg0: double, arg1: double, arg2: double, arg3: double)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeodeLayerSettings$$Type = ($GeodeLayerSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeodeLayerSettings$$Original = $GeodeLayerSettings;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration" {
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $RandomPatchConfiguration extends $Record implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($RandomPatchConfiguration)>

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $Holder$$Type<($PlacedFeature)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "feature"(): $Holder<($PlacedFeature)>
public "tries"(): integer
public "xzSpread"(): integer
public "ySpread"(): integer
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomPatchConfiguration$$Type = ({"tries"?: integer, "feature"?: $Holder$$Type<($PlacedFeature)>, "xzSpread"?: integer, "ySpread"?: integer}) | ([tries?: integer, feature?: $Holder$$Type<($PlacedFeature)>, xzSpread?: integer, ySpread?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomPatchConfiguration$$Original = $RandomPatchConfiguration;}
declare module "net.minecraft.world.level.levelgen.structure.structures.BuriedTreasureStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $BuriedTreasureStructure extends $Structure {
static readonly "CODEC": $MapCodec<($BuriedTreasureStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "type"(): $StructureType<(never)>
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuriedTreasureStructure$$Type = ($BuriedTreasureStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BuriedTreasureStructure$$Original = $BuriedTreasureStructure;}
declare module "net.minecraft.world.level.block.entity.DispenserBlockEntity" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LithiumInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumInventory"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RandomizableContainerBlockEntity} from "net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity"
import {$ReferenceArraySet} from "it.unimi.dsi.fastutil.objects.ReferenceArraySet"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Type, $InventoryChangeTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $DispenserBlockEntity extends $RandomizableContainerBlockEntity implements $LithiumInventory$$Interface, $InventoryChangeTracker$$Interface {
 "inventoryChangeListeners": $ReferenceArraySet
 "worldPosition": $BlockPos
 "lootTable": $ResourceKey<($LootTable)>
 "level": $Level
static readonly "CONTAINER_SIZE": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventoryHandlingTypeListeners": $ReferenceArraySet
 "lockKey": $LockCode
 "hasComparators": byte
 "lootTableSeed": long
 "remove": boolean

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)
constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getDefaultName"(): $Component
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getContainerSize"(): integer
public "handler$bpl002$lithium$setInventoryStackListReplacement"(arg0: $NonNullList$$Type, arg1: $CallbackInfo$$Type): void
public "getItems"(): $NonNullList<($ItemStack)>
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "insertItem"(arg0: $ItemStack$$Type): $ItemStack
public "setItems"(arg0: $NonNullList$$Type<($ItemStack$$Type)>): void
public "getRandomSlot"(arg0: $RandomSource$$Type): integer
public "getInventoryLithium"(): $NonNullList
public "setInventoryLithium"(arg0: $NonNullList$$Type): void
public "createMenu"(arg0: integer, arg1: $Inventory$$Type): $AbstractContainerMenu
public "generateLootLithium"(): void
public "stopListenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "listenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "listenForContentChangesOnce"(arg0: $LithiumStackList$$Type, arg1: $InventoryChangeListener$$Type): void
public "stillValid"(arg0: $Player$$Type): boolean
public "setChanged"(): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitContentModified"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$emitRemoved"(): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public static "tryClear"(arg0: any): void
get "defaultName"(): $Component
get "containerSize"(): integer
get "items"(): $NonNullList<($ItemStack)>
set "items"(value: $NonNullList$$Type<($ItemStack$$Type)>)
get "inventoryLithium"(): $NonNullList
set "inventoryLithium"(value: $NonNullList$$Type)
get "changed"(): void
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DispenserBlockEntity$$Type = ($DispenserBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DispenserBlockEntity$$Original = $DispenserBlockEntity;}
declare module "net.minecraft.world.level.levelgen.blending.BlendingData" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlendingData$DensityConsumer$$Type} from "net.minecraft.world.level.levelgen.blending.BlendingData$DensityConsumer"
import {$WorldGenRegion$$Type} from "net.minecraft.server.level.WorldGenRegion"
import {$Set} from "java.util.Set"
import {$Direction8} from "net.minecraft.core.Direction8"
import {$BlendingData$BiomeConsumer$$Type} from "net.minecraft.world.level.levelgen.blending.BlendingData$BiomeConsumer"
import {$BlendingData$HeightConsumer$$Type} from "net.minecraft.world.level.levelgen.blending.BlendingData$HeightConsumer"

export class $BlendingData {
static readonly "CELL_RATIO": integer
static readonly "CODEC": $Codec<($BlendingData)>
static readonly "CELL_HEIGHT": integer
static readonly "NO_VALUE": double
static readonly "CELL_WIDTH": integer

public static "sideByGenerationAge"(arg0: $WorldGenLevel$$Type, arg1: integer, arg2: integer, arg3: boolean): $Set<($Direction8)>
public static "getOrUpdateBlendingData"(arg0: $WorldGenRegion$$Type, arg1: integer, arg2: integer): $BlendingData
public "getAreaWithOldGeneration"(): $LevelHeightAccessor
public "getHeight"(arg0: integer, arg1: integer, arg2: integer): double
public "getDensity"(arg0: integer, arg1: integer, arg2: integer): double
public "iterateHeights"(arg0: integer, arg1: integer, arg2: $BlendingData$HeightConsumer$$Type): void
public "iterateDensities"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $BlendingData$DensityConsumer$$Type): void
public "iterateBiomes"(arg0: integer, arg1: integer, arg2: integer, arg3: $BlendingData$BiomeConsumer$$Type): void
get "areaWithOldGeneration"(): $LevelHeightAccessor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlendingData$$Type = ($BlendingData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlendingData$$Original = $BlendingData;}
declare module "net.minecraft.world.level.gameevent.BlockPositionSource" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$PositionSource$$Interface} from "net.minecraft.world.level.gameevent.PositionSource"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PositionSourceType} from "net.minecraft.world.level.gameevent.PositionSourceType"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $BlockPositionSource implements $PositionSource$$Interface {
static readonly "CODEC": $MapCodec<($BlockPositionSource)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($BlockPositionSource)>

constructor(arg0: $BlockPos$$Type)

public "getPosition"(arg0: $Level$$Type): $Optional<($Vec3)>
public "getType"(): $PositionSourceType<($BlockPositionSource)>
get "type"(): $PositionSourceType<($BlockPositionSource)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPositionSource$$Type = ($BlockPositionSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPositionSource$$Original = $BlockPositionSource;}
declare module "net.minecraft.world.level.levelgen.PositionalRandomFactory" {
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$StringBuilder$$Type} from "java.lang.StringBuilder"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export interface $PositionalRandomFactory$$Interface {
}

export class $PositionalRandomFactory implements $PositionalRandomFactory$$Interface {
 "at"(arg0: integer, arg1: integer, arg2: integer): $RandomSource
 "at"(arg0: $BlockPos$$Type): $RandomSource
 "fromHashOf"(arg0: $ResourceLocation$$Type): $RandomSource
 "fromHashOf"(arg0: StringJS): $RandomSource
 "fromSeed"(arg0: long): $RandomSource
 "parityConfigString"(arg0: $StringBuilder$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PositionalRandomFactory$$Type = ($PositionalRandomFactory);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PositionalRandomFactory$$Original = $PositionalRandomFactory;}
declare module "net.minecraft.world.level.storage.loot.functions.LootItemFunction" {
import {$BiFunction, $BiFunction$$Type, $BiFunction$$Interface} from "java.util.function.BiFunction"
import {$LootContextParam} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$LootContext, $LootContext$$Type} from "net.minecraft.world.level.storage.loot.LootContext"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Function$$Type} from "java.util.function.Function"
import {$LootItemFunctionType} from "net.minecraft.world.level.storage.loot.functions.LootItemFunctionType"
import {$Set} from "java.util.Set"
import {$LootContextUser$$Interface} from "net.minecraft.world.level.storage.loot.LootContextUser"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $LootItemFunction$$Interface extends $LootContextUser$$Interface, $BiFunction$$Interface<($ItemStack), ($LootContext), ($ItemStack)> {
get "type"(): $LootItemFunctionType<($LootItemFunction)>
get "referencedContextParams"(): $Set<($LootContextParam<(never)>)>
}

export class $LootItemFunction implements $LootItemFunction$$Interface {
 "getType"(): $LootItemFunctionType<($LootItemFunction)>
static "decorate"(arg0: $BiFunction$$Type<($ItemStack), ($LootContext), ($ItemStack$$Type)>, arg1: $Consumer$$Type<($ItemStack)>, arg2: $LootContext$$Type): $Consumer<($ItemStack)>
 "validate"(arg0: $ValidationContext$$Type): void
 "getReferencedContextParams"(): $Set<($LootContextParam<(never)>)>
 "apply"(arg0: $ItemStack$$Type, arg1: $LootContext$$Type): $ItemStack
 "andThen"<V>(arg0: $Function$$Type<($ItemStack), (V)>): $BiFunction<($ItemStack), ($LootContext), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootItemFunction$$Type = ($LootItemFunction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootItemFunction$$Original = $LootItemFunction;}
declare module "net.minecraft.world.level.biome.BiomeSpecialEffects$GrassColorModifier" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$ExtensionInfo} from "net.neoforged.fml.common.asm.enumextension.ExtensionInfo"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$IExtensibleEnum$$Interface} from "net.neoforged.fml.common.asm.enumextension.IExtensibleEnum"

export class $BiomeSpecialEffects$GrassColorModifier extends $Enum<($BiomeSpecialEffects$GrassColorModifier)> implements $StringRepresentable$$Interface, $IExtensibleEnum$$Interface {
static readonly "CODEC": $Codec<($BiomeSpecialEffects$GrassColorModifier)>
static readonly "SWAMP": $BiomeSpecialEffects$GrassColorModifier
static readonly "NONE": $BiomeSpecialEffects$GrassColorModifier
static readonly "DARK_FOREST": $BiomeSpecialEffects$GrassColorModifier

public "getName"(): StringJS
public static "values"(): ($BiomeSpecialEffects$GrassColorModifier)[]
public static "valueOf"(arg0: StringJS): $BiomeSpecialEffects$GrassColorModifier
public static "getExtensionInfo"(): $ExtensionInfo
public "modifyColor"(arg0: double, arg1: double, arg2: integer): integer
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "name"(): StringJS
get "extensionInfo"(): $ExtensionInfo
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeSpecialEffects$GrassColorModifier$$Type = (("none") | ("dark_forest") | ("swamp"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeSpecialEffects$GrassColorModifier$$Original = $BiomeSpecialEffects$GrassColorModifier;}
declare module "net.minecraft.world.level.chunk.PalettedContainerRO" {
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$PalettedContainer$CountConsumer$$Type} from "net.minecraft.world.level.chunk.PalettedContainer$CountConsumer"
import {$PalettedContainerRO$PackedData} from "net.minecraft.world.level.chunk.PalettedContainerRO$PackedData"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$PalettedContainer$Strategy$$Type} from "net.minecraft.world.level.chunk.PalettedContainer$Strategy"
import {$PalettedContainer} from "net.minecraft.world.level.chunk.PalettedContainer"
import {$IdMap$$Type} from "net.minecraft.core.IdMap"
import {$Consumer$$Type} from "java.util.function.Consumer"

export interface $PalettedContainerRO$$Interface<T> {
get "serializedSize"(): integer
}

export class $PalettedContainerRO<T> implements $PalettedContainerRO$$Interface {
 "maybeHas"(arg0: $Predicate$$Type<(T)>): boolean
 "get"(arg0: integer, arg1: integer, arg2: integer): T
 "count"(arg0: $PalettedContainer$CountConsumer$$Type<(T)>): void
 "write"(arg0: $FriendlyByteBuf$$Type): void
 "getAll"(arg0: $Consumer$$Type<(T)>): void
 "pack"(arg0: $IdMap$$Type<(T)>, arg1: $PalettedContainer$Strategy$$Type): $PalettedContainerRO$PackedData<(T)>
 "getSerializedSize"(): integer
 "recreate"(): $PalettedContainer<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PalettedContainerRO$$Type<T> = ($PalettedContainerRO<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PalettedContainerRO$$Original<T> = $PalettedContainerRO<(T)>;}
declare module "net.minecraft.world.level.block.entity.SpawnerBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BaseSpawner} from "net.minecraft.world.level.BaseSpawner"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Spawner$$Interface} from "net.minecraft.world.level.Spawner"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $SpawnerBlockEntity extends $BlockEntity implements $Spawner$$Interface {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public static "clientTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $SpawnerBlockEntity$$Type): void
public "onlyOpCanSetNbt"(): boolean
public "getSpawner"(): $BaseSpawner
public "triggerEvent"(arg0: integer, arg1: integer): boolean
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdatePacket"(): $Packet
public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $SpawnerBlockEntity$$Type): void
public "setEntityId"(arg0: $EntityType$$Type<(never)>, arg1: $RandomSource$$Type): void
public static "appendHoverText"(arg0: $ItemStack$$Type, arg1: $List$$Type<($Component$$Type)>, arg2: StringJS): void
public static "getSpawnEntityDisplayName"(arg0: $ItemStack$$Type, arg1: StringJS): $Component
get "spawner"(): $BaseSpawner
get "updatePacket"(): $Packet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpawnerBlockEntity$$Type = ($SpawnerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpawnerBlockEntity$$Original = $SpawnerBlockEntity;}
declare module "net.minecraft.world.level.NoiseColumn" {
import {$BlockColumn$$Interface} from "net.minecraft.world.level.chunk.BlockColumn"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $NoiseColumn implements $BlockColumn$$Interface {
constructor(arg0: integer, arg1: ($BlockState$$Type)[])

public "getBlock"(arg0: integer): $BlockState
public "setBlock"(arg0: integer, arg1: $BlockState$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseColumn$$Type = ($NoiseColumn);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseColumn$$Original = $NoiseColumn;}
declare module "net.minecraft.world.level.storage.loot.LootContextUser" {
import {$LootContextParam} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$Set} from "java.util.Set"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"

export interface $LootContextUser$$Interface {
get "referencedContextParams"(): $Set<($LootContextParam<(never)>)>
}

export class $LootContextUser implements $LootContextUser$$Interface {
 "validate"(arg0: $ValidationContext$$Type): void
 "getReferencedContextParams"(): $Set<($LootContextParam<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootContextUser$$Type = ($LootContextUser);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootContextUser$$Original = $LootContextUser;}
declare module "net.minecraft.world.level.block.SculkSpreader" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$SculkSpreader$ChargeCursor} from "net.minecraft.world.level.block.SculkSpreader$ChargeCursor"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"

export class $SculkSpreader {
static readonly "MAX_DECAY_FACTOR": float
static readonly "SHRIEKER_PLACEMENT_RATE": integer
static readonly "MAX_CHARGE": integer
static readonly "MAX_GROWTH_RATE_RADIUS": integer

constructor(arg0: boolean, arg1: $TagKey$$Type<($Block)>, arg2: integer, arg3: integer, arg4: integer, arg5: integer)

public "load"(arg0: $CompoundTag$$Type): void
public "clear"(): void
public "save"(arg0: $CompoundTag$$Type): void
public "replaceableBlocks"(): $TagKey<($Block)>
public "growthSpawnCost"(): integer
public "noGrowthRadius"(): integer
public "isWorldGeneration"(): boolean
public "chargeDecayRate"(): integer
public "updateCursors"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type, arg3: boolean): void
public "additionalDecayRate"(): integer
public static "createWorldGenSpreader"(): $SculkSpreader
public "addCursors"(arg0: $BlockPos$$Type, arg1: integer): void
public static "createLevelSpreader"(): $SculkSpreader
public "getCursors"(): $List<($SculkSpreader$ChargeCursor)>
get "worldGeneration"(): boolean
get "cursors"(): $List<($SculkSpreader$ChargeCursor)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkSpreader$$Type = ($SculkSpreader);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkSpreader$$Original = $SculkSpreader;}
declare module "net.minecraft.world.level.BaseSpawner" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SimpleWeightedRandomList} from "net.minecraft.util.random.SimpleWeightedRandomList"
import {$IOwnedSpawner$$Interface} from "net.neoforged.neoforge.common.extensions.IOwnedSpawner"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Either} from "com.mojang.datafixers.util.Either"
import {$SpawnData, $SpawnData$$Type} from "net.minecraft.world.level.SpawnData"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $BaseSpawner implements $IOwnedSpawner$$Interface {
 "spawnDelay": integer
static readonly "SPAWN_DATA_TAG": StringJS
 "spawnPotentials": $SimpleWeightedRandomList<($SpawnData)>
 "nextSpawnData": $SpawnData

constructor()

public "load"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $CompoundTag$$Type): void
public "save"(arg0: $CompoundTag$$Type): $CompoundTag
public "getOwner"(): $Either<($BlockEntity), ($Entity)>
public "broadcastEvent"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: integer): void
public "setNextSpawnData"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $SpawnData$$Type): void
public "getSpin"(): double
public "clientTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getOrCreateDisplayEntity"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $Entity
public "serverTick"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type): void
public "getoSpin"(): double
public "onEventTriggered"(arg0: $Level$$Type, arg1: integer): boolean
public "setEntityId"(arg0: $EntityType$$Type<(never)>, arg1: $Level$$Type, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type): void
get "owner"(): $Either<($BlockEntity), ($Entity)>
get "spin"(): double
get "oSpin"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseSpawner$$Type = ($BaseSpawner);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BaseSpawner$$Original = $BaseSpawner;}
declare module "net.minecraft.world.level.block.state.properties.DirectionProperty" {
import {$Collection$$Type} from "java.util.Collection"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"

export class $DirectionProperty extends $EnumProperty<($Direction)> {
constructor(arg0: StringJS, arg1: $Collection$$Type<($Direction$$Type)>)

public static "create"(arg0: StringJS, arg1: $Collection$$Type<($Direction$$Type)>): $DirectionProperty
public static "create"(arg0: StringJS, ...arg1: ($Direction$$Type)[]): $DirectionProperty
public static "create"(arg0: StringJS, arg1: $Predicate$$Type<($Direction)>): $DirectionProperty
public static "create"(arg0: StringJS): $DirectionProperty
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectionProperty$$Type = ($DirectionProperty);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectionProperty$$Original = $DirectionProperty;}
declare module "net.minecraft.world.level.block.state.properties.NoteBlockInstrument" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$Holder} from "net.minecraft.core.Holder"

export class $NoteBlockInstrument extends $Enum<($NoteBlockInstrument)> implements $StringRepresentable$$Interface {
static readonly "BASS": $NoteBlockInstrument
static readonly "DIDGERIDOO": $NoteBlockInstrument
static readonly "BASEDRUM": $NoteBlockInstrument
static readonly "XYLOPHONE": $NoteBlockInstrument
static readonly "PIGLIN": $NoteBlockInstrument
static readonly "IRON_XYLOPHONE": $NoteBlockInstrument
static readonly "BIT": $NoteBlockInstrument
static readonly "CHIME": $NoteBlockInstrument
static readonly "PLING": $NoteBlockInstrument
static readonly "SNARE": $NoteBlockInstrument
static readonly "SKELETON": $NoteBlockInstrument
static readonly "WITHER_SKELETON": $NoteBlockInstrument
static readonly "GUITAR": $NoteBlockInstrument
static readonly "CUSTOM_HEAD": $NoteBlockInstrument
static readonly "BANJO": $NoteBlockInstrument
static readonly "CREEPER": $NoteBlockInstrument
static readonly "HARP": $NoteBlockInstrument
static readonly "ZOMBIE": $NoteBlockInstrument
static readonly "DRAGON": $NoteBlockInstrument
static readonly "HAT": $NoteBlockInstrument
static readonly "BELL": $NoteBlockInstrument
static readonly "COW_BELL": $NoteBlockInstrument
static readonly "FLUTE": $NoteBlockInstrument

public static "values"(): ($NoteBlockInstrument)[]
public static "valueOf"(arg0: StringJS): $NoteBlockInstrument
public "worksAboveNoteBlock"(): boolean
public "getSerializedName"(): StringJS
public "getSoundEvent"(): $Holder<($SoundEvent)>
public "hasCustomSound"(): boolean
public "isTunable"(): boolean
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "soundEvent"(): $Holder<($SoundEvent)>
get "tunable"(): boolean
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoteBlockInstrument$$Type = (("harp") | ("basedrum") | ("snare") | ("hat") | ("bass") | ("flute") | ("bell") | ("guitar") | ("chime") | ("xylophone") | ("iron_xylophone") | ("cow_bell") | ("didgeridoo") | ("bit") | ("banjo") | ("pling") | ("zombie") | ("skeleton") | ("creeper") | ("dragon") | ("wither_skeleton") | ("piglin") | ("custom_head"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoteBlockInstrument$$Original = $NoteBlockInstrument;}
declare module "net.minecraft.world.level.biome.FeatureSorter$StepFeatureData" {
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$List, $List$$Type} from "java.util.List"
import {$Record} from "java.lang.Record"

export class $FeatureSorter$StepFeatureData extends $Record {
constructor(arg0: $List$$Type<($PlacedFeature$$Type)>)
constructor(arg0: $List$$Type<($PlacedFeature$$Type)>, arg1: $ToIntFunction$$Type<($PlacedFeature)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "features"(): $List<($PlacedFeature)>
public "indexMapping"(): $ToIntFunction<($PlacedFeature)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FeatureSorter$StepFeatureData$$Type = ({"features"?: $List$$Type<($PlacedFeature$$Type)>, "indexMapping"?: $ToIntFunction$$Type<($PlacedFeature$$Type)>}) | ([features?: $List$$Type<($PlacedFeature$$Type)>, indexMapping?: $ToIntFunction$$Type<($PlacedFeature$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FeatureSorter$StepFeatureData$$Original = $FeatureSorter$StepFeatureData;}
declare module "net.minecraft.world.level.ColorResolver" {
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"

export interface $ColorResolver$$Interface {

(arg0: $Biome, arg1: double, arg2: double): integer
}

export class $ColorResolver implements $ColorResolver$$Interface {
 "getColor"(arg0: $Biome$$Type, arg1: double, arg2: double): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColorResolver$$Type = ((arg0: $Biome, arg1: double, arg2: double) => integer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ColorResolver$$Original = $ColorResolver;}
declare module "net.minecraft.world.level.LevelSimulatedReader" {
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Optional} from "java.util.Optional"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $LevelSimulatedReader$$Interface {
}

export class $LevelSimulatedReader implements $LevelSimulatedReader$$Interface {
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "isStateAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($BlockState)>): boolean
 "isFluidAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($FluidState)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelSimulatedReader$$Type = ($LevelSimulatedReader);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelSimulatedReader$$Original = $LevelSimulatedReader;}
declare module "net.minecraft.world.level.material.Fluid" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Optional} from "java.util.Optional"
import {$FluidKJS$$Interface} from "dev.latvian.mods.kubejs.core.FluidKJS"
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$StateDefinition$Builder$$Type} from "net.minecraft.world.level.block.state.StateDefinition$Builder"
import {$Holder} from "net.minecraft.core.Holder"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$InjectedFluidExtension$$Interface} from "dev.architectury.extensions.injected.InjectedFluidExtension"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$PathType, $PathType$$Type} from "net.minecraft.world.level.pathfinder.PathType"
import {$Item} from "net.minecraft.world.item.Item"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$StateDefinition} from "net.minecraft.world.level.block.state.StateDefinition"
import {$FluidLike} from "dev.latvian.mods.kubejs.fluid.FluidLike"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidType} from "net.neoforged.neoforge.fluids.FluidType"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$FluidVariantCache$$Interface} from "net.fabricmc.fabric.impl.transfer.fluid.FluidVariantCache"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Registry} from "net.minecraft.core.Registry"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$FluidVariant} from "net.fabricmc.fabric.api.transfer.v1.fluid.FluidVariant"
import {$IFluidExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IFluidExtension"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$Boat$$Type} from "net.minecraft.world.entity.vehicle.Boat"
import {$ParticleOptions} from "net.minecraft.core.particles.ParticleOptions"

export class $Fluid implements $IFluidExtension$$Interface, $InjectedFluidExtension$$Interface, $FluidVariantCache$$Interface, $FluidKJS$$Interface {
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>
readonly "stateDefinition": $StateDefinition<($Fluid), ($FluidState)>

constructor()

public "toString"(): StringJS
public "isEmpty"(): boolean
/**
 * 
 * @deprecated
 */
public "is"(arg0: $TagKey$$Type<($Fluid)>): boolean
public "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type): void
public "getShape"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "handler$emj000$fabric_transfer_api_v1$hookGetBucketFillSound"(arg0: $CallbackInfoReturnable$$Type): void
public "animateTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type, arg3: $RandomSource$$Type): void
public "createLegacyBlock"(arg0: $FluidState$$Type): $BlockState
public "defaultFluidState"(): $FluidState
public "fabric_getCachedFluidVariant"(): $FluidVariant
public "getId"(): StringJS
public "getStateDefinition"(): $StateDefinition<($Fluid), ($FluidState)>
public "getDripParticle"(): $ParticleOptions
public "getFlow"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type): $Vec3
public "getAmount"(arg0: $FluidState$$Type): integer
public "getKey"(): $ResourceKey
public "getBucket"(): $Item
public "getHeight"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): float
public "isSource"(arg0: $FluidState$$Type): boolean
public "isSame"(arg0: $Fluid$$Type): boolean
public "randomTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type, arg3: $RandomSource$$Type): void
public "asHolder"(): $Holder$Reference
public "isRandomlyTicking"(): boolean
public "getPickupSound"(): $Optional<($SoundEvent)>
public "getOwnHeight"(arg0: $FluidState$$Type): float
public "getTickDelay"(arg0: $LevelReader$$Type): integer
public "canBeReplacedWith"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Fluid$$Type, arg4: $Direction$$Type): boolean
public "createFluidStateDefinition"(arg0: $StateDefinition$Builder$$Type<($Fluid$$Type), ($FluidState$$Type)>): void
public "registerDefaultState"(arg0: $FluidState$$Type): void
public "getExplosionResistance"(): float
public "getFluidType"(): $FluidType
/**
 * 
 * @deprecated
 */
public "builtInRegistryHolder"(): $Holder$Reference<($Fluid)>
public "move"(arg0: $FluidState$$Type, arg1: $LivingEntity$$Type, arg2: $Vec3$$Type, arg3: double): boolean
public "canHydrate"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $BlockPos$$Type): boolean
public "supportsBoating"(arg0: $FluidState$$Type, arg1: $Boat$$Type): boolean
public "canConvertToSource"(arg0: $FluidState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): boolean
public "getBlockPathType"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Mob$$Type, arg4: boolean): $PathType
public "getExplosionResistance"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Explosion$$Type): float
public "canExtinguish"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "getAdjacentBlockPathType"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Mob$$Type, arg4: $PathType$$Type): $PathType
public "arch$holder"(): $Holder<($Fluid)>
public "isEmpty"(): boolean
public "getRegistry"(): $Registry<($Fluid)>
public "getRegistryId"(): $ResourceKey<($Registry<($Fluid)>)>
public "getAmount"(): integer
public "getFluid"(): $Fluid
public "arch$registryName"(): $ResourceLocation
public "specialEquals"(o: any, shallow: boolean): boolean
public "getMod"(): StringJS
public "hasTag"(tag: $ResourceLocation$$Type): boolean
public "getIdLocation"(): $ResourceLocation
public "getTagKeys"(): $List<($TagKey<($Fluid)>)>
public "getTags"(): $List<($ResourceLocation)>
public "copy"(amount: integer): $FluidLike
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static "wrap"(o: any): $ReplacementMatch
get "empty"(): boolean
get "id"(): StringJS
get "dripParticle"(): $ParticleOptions
get "key"(): $ResourceKey
get "bucket"(): $Item
get "randomlyTicking"(): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
get "explosionResistance"(): float
get "fluidType"(): $FluidType
get "empty"(): boolean
get "registry"(): $Registry<($Fluid)>
get "registryId"(): $ResourceKey<($Registry<($Fluid)>)>
get "amount"(): integer
get "fluid"(): $Fluid
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Fluid)>)>
get "tags"(): $List<($ResourceLocation)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.Fluid
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.FluidTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Fluid$$Type = (Special.Fluid);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Fluid$$Original = $Fluid;}
declare module "net.minecraft.world.level.levelgen.feature.rootplacers.MangroveRootPlacer" {
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RootPlacerType} from "net.minecraft.world.level.levelgen.feature.rootplacers.RootPlacerType"
import {$AboveRootPlacement, $AboveRootPlacement$$Type} from "net.minecraft.world.level.levelgen.feature.rootplacers.AboveRootPlacement"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$MangroveRootPlacement$$Type} from "net.minecraft.world.level.levelgen.feature.rootplacers.MangroveRootPlacement"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$RootPlacer} from "net.minecraft.world.level.levelgen.feature.rootplacers.RootPlacer"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MangroveRootPlacer extends $RootPlacer {
static readonly "CODEC": $MapCodec<($MangroveRootPlacer)>
static readonly "ROOT_WIDTH_LIMIT": integer
readonly "aboveRootPlacement": $Optional<($AboveRootPlacement)>
readonly "trunkOffsetY": $IntProvider
static readonly "ROOT_LENGTH_LIMIT": integer
readonly "rootProvider": $BlockStateProvider

constructor(arg0: $IntProvider$$Type, arg1: $BlockStateProvider$$Type, arg2: ($AboveRootPlacement$$Type)?, arg3: $MangroveRootPlacement$$Type)

public "type"(): $RootPlacerType<(never)>
public "placeRoot"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type, arg4: $TreeConfiguration$$Type): void
public "potentialRootPositions"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type): $List<($BlockPos)>
public "canPlaceRoot"(arg0: $LevelSimulatedReader$$Type, arg1: $BlockPos$$Type): boolean
public "placeRoots"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MangroveRootPlacer$$Type = ($MangroveRootPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MangroveRootPlacer$$Original = $MangroveRootPlacer;}
declare module "net.minecraft.world.level.levelgen.structure.placement.RandomSpreadStructurePlacement" {
import {$ChunkGeneratorStructureState$$Type} from "net.minecraft.world.level.chunk.ChunkGeneratorStructureState"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$Optional$$Type} from "java.util.Optional"
import {$StructurePlacement$ExclusionZone$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement$ExclusionZone"
import {$StructurePlacementType} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacementType"
import {$RandomSpreadType, $RandomSpreadType$$Type} from "net.minecraft.world.level.levelgen.structure.placement.RandomSpreadType"
import {$StructurePlacement} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement"
import {$ChunkPos} from "net.minecraft.world.level.ChunkPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructurePlacement$FrequencyReductionMethod$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement$FrequencyReductionMethod"

export class $RandomSpreadStructurePlacement extends $StructurePlacement {
static readonly "CODEC": $MapCodec<($RandomSpreadStructurePlacement)>

constructor(arg0: integer, arg1: integer, arg2: $RandomSpreadType$$Type, arg3: integer)
constructor(arg0: $Vec3i$$Type, arg1: $StructurePlacement$FrequencyReductionMethod$$Type, arg2: float, arg3: integer, arg4: ($StructurePlacement$ExclusionZone$$Type)?, arg5: integer, arg6: integer, arg7: $RandomSpreadType$$Type)

public "type"(): $StructurePlacementType<(never)>
public "spreadType"(): $RandomSpreadType
public "isPlacementChunk"(arg0: $ChunkGeneratorStructureState$$Type, arg1: integer, arg2: integer): boolean
public "getPotentialStructureChunk"(arg0: long, arg1: integer, arg2: integer): $ChunkPos
public "spacing"(): integer
public "separation"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomSpreadStructurePlacement$$Type = ($RandomSpreadStructurePlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomSpreadStructurePlacement$$Original = $RandomSpreadStructurePlacement;}
declare module "net.minecraft.world.level.block.entity.SmokerBlockEntity" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ReferenceArraySet} from "it.unimi.dsi.fastutil.objects.ReferenceArraySet"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$NonNullList} from "net.minecraft.core.NonNullList"
import {$ContainerData} from "net.minecraft.world.inventory.ContainerData"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AbstractFurnaceBlockEntity} from "net.minecraft.world.level.block.entity.AbstractFurnaceBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SmokerBlockEntity extends $AbstractFurnaceBlockEntity {
 "inventoryChangeListeners": $ReferenceArraySet
readonly "dataAccess": $ContainerData
static readonly "DATA_LIT_DURATION": integer
 "level": $Level
 "cookingTotalTime": integer
static readonly "SLOT_INPUT": integer
static readonly "DATA_COOKING_PROGRESS": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventoryHandlingTypeListeners": $ReferenceArraySet
static readonly "BURN_COOL_SPEED": integer
 "remove": boolean
 "cookingProgress": integer
 "litDuration": integer
 "worldPosition": $BlockPos
static readonly "DATA_COOKING_TOTAL_TIME": integer
static readonly "BURN_TIME_STANDARD": integer
static readonly "SLOT_RESULT": integer
 "lockKey": $LockCode
 "hasComparators": byte
static readonly "NUM_DATA_VALUES": integer
 "litTime": integer
static readonly "DATA_LIT_TIME": integer
 "items": $NonNullList<($ItemStack)>
static readonly "SLOT_FUEL": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getDefaultName"(): $Component
public "getBurnDuration"(arg0: $ItemStack$$Type): integer
public "createMenu"(arg0: integer, arg1: $Inventory$$Type): $AbstractContainerMenu
public "setChanged"(): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public static "tryClear"(arg0: any): void
get "defaultName"(): $Component
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmokerBlockEntity$$Type = ($SmokerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SmokerBlockEntity$$Original = $SmokerBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.rootplacers.RootPlacer" {
import {$RecordCodecBuilder$Instance$$Type} from "com.mojang.serialization.codecs.RecordCodecBuilder$Instance"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RootPlacerType} from "net.minecraft.world.level.levelgen.feature.rootplacers.RootPlacerType"
import {$AboveRootPlacement, $AboveRootPlacement$$Type} from "net.minecraft.world.level.levelgen.feature.rootplacers.AboveRootPlacement"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$Products$P3} from "com.mojang.datafixers.Products$P3"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RecordCodecBuilder$Mu} from "com.mojang.serialization.codecs.RecordCodecBuilder$Mu"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RootPlacer {
static readonly "CODEC": $Codec<($RootPlacer)>
readonly "aboveRootPlacement": $Optional<($AboveRootPlacement)>
readonly "trunkOffsetY": $IntProvider
readonly "rootProvider": $BlockStateProvider

constructor(arg0: $IntProvider$$Type, arg1: $BlockStateProvider$$Type, arg2: ($AboveRootPlacement$$Type)?)

public "type"(): $RootPlacerType<(never)>
public "placeRoot"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type, arg4: $TreeConfiguration$$Type): void
public "getTrunkOrigin"(arg0: $BlockPos$$Type, arg1: $RandomSource$$Type): $BlockPos
public "getPotentiallyWaterloggedState"(arg0: $LevelSimulatedReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $BlockState
public static "rootPlacerParts"<P extends $RootPlacer>(arg0: $RecordCodecBuilder$Instance$$Type<(P)>): $Products$P3<($RecordCodecBuilder$Mu<(P)>), ($IntProvider), ($BlockStateProvider), ($Optional<($AboveRootPlacement)>)>
public "canPlaceRoot"(arg0: $LevelSimulatedReader$$Type, arg1: $BlockPos$$Type): boolean
public "placeRoots"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RootPlacer$$Type = ($RootPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RootPlacer$$Original = $RootPlacer;}
declare module "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Record} from "java.lang.Record"

export class $LakeFeature$Configuration extends $Record implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($LakeFeature$Configuration)>

constructor(arg0: $BlockStateProvider$$Type, arg1: $BlockStateProvider$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "fluid"(): $BlockStateProvider
public "barrier"(): $BlockStateProvider
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LakeFeature$Configuration$$Type = ({"barrier"?: $BlockStateProvider$$Type, "fluid"?: $BlockStateProvider$$Type}) | ([barrier?: $BlockStateProvider$$Type, fluid?: $BlockStateProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LakeFeature$Configuration$$Original = $LakeFeature$Configuration;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LayerConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($LayerConfiguration)>
readonly "state": $BlockState
readonly "height": integer

constructor(arg0: integer, arg1: $BlockState$$Type)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LayerConfiguration$$Type = ($LayerConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LayerConfiguration$$Original = $LayerConfiguration;}
declare module "net.minecraft.world.level.levelgen.DensityFunction" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$Holder} from "net.minecraft.core.Holder"

export interface $DensityFunction$$Interface {
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenDensityFunction
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenDensityFunctionTag
}

export class $DensityFunction implements $DensityFunction$$Interface {
static readonly "CODEC": $Codec<($Holder<($DensityFunction)>)>
static readonly "DIRECT_CODEC": $Codec<($DensityFunction)>
static readonly "HOLDER_HELPER_CODEC": $Codec<($DensityFunction)>

 "abs"(): $DensityFunction
 "clamp"(arg0: double, arg1: double): $DensityFunction
 "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
 "maxValue"(): double
 "square"(): $DensityFunction
 "halfNegative"(): $DensityFunction
 "quarterNegative"(): $DensityFunction
 "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
 "minValue"(): double
 "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
 "cube"(): $DensityFunction
 "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
 "squeeze"(): $DensityFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunction$$Type = (Special.WorldgenDensityFunction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunction$$Original = $DensityFunction;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $HugeMushroomFeatureConfiguration implements $FeatureConfiguration$$Interface {
readonly "capProvider": $BlockStateProvider
static readonly "CODEC": $Codec<($HugeMushroomFeatureConfiguration)>
readonly "stemProvider": $BlockStateProvider
readonly "foliageRadius": integer

constructor(arg0: $BlockStateProvider$$Type, arg1: $BlockStateProvider$$Type, arg2: integer)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HugeMushroomFeatureConfiguration$$Type = ($HugeMushroomFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HugeMushroomFeatureConfiguration$$Original = $HugeMushroomFeatureConfiguration;}
declare module "net.minecraft.world.level.block.state.pattern.BlockInWorld" {
import {$LevelReader, $LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockInWorld {
constructor(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: boolean)

public "getState"(): $BlockState
public "getLevel"(): $LevelReader
public "getPos"(): $BlockPos
public "getEntity"(): $BlockEntity
public static "hasState"(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockInWorld)>
get "state"(): $BlockState
get "level"(): $LevelReader
get "pos"(): $BlockPos
get "entity"(): $BlockEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockInWorld$$Type = ($BlockInWorld);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockInWorld$$Original = $BlockInWorld;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $NoneFeatureConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($NoneFeatureConfiguration)>
static readonly "INSTANCE": $NoneFeatureConfiguration

constructor()

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoneFeatureConfiguration$$Type = ($NoneFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoneFeatureConfiguration$$Original = $NoneFeatureConfiguration;}
declare module "net.minecraft.world.level.storage.loot.functions.FunctionUserBuilder" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$Function$$Type} from "java.util.function.Function"
import {$LootItemFunction$Builder$$Type} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction$Builder"

export interface $FunctionUserBuilder$$Interface<T extends $FunctionUserBuilder<(object)>> {
}

export class $FunctionUserBuilder<T extends $FunctionUserBuilder<(object)>> implements $FunctionUserBuilder$$Interface {
 "apply"<E>(arg0: (E)[], arg1: $Function$$Type<(E), ($LootItemFunction$Builder$$Type)>): T
 "apply"<E>(arg0: $Iterable$$Type<(E)>, arg1: $Function$$Type<(E), ($LootItemFunction$Builder$$Type)>): T
 "apply"(arg0: $LootItemFunction$Builder$$Type): T
 "unwrap"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionUserBuilder$$Type<T> = ($FunctionUserBuilder<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FunctionUserBuilder$$Original<T> = $FunctionUserBuilder<(T)>;}
declare module "net.minecraft.world.level.block.entity.TickingBlockEntity" {
import {$BlockPos} from "net.minecraft.core.BlockPos"

export interface $TickingBlockEntity$$Interface {
get "type"(): StringJS
get "pos"(): $BlockPos
get "removed"(): boolean
}

export class $TickingBlockEntity implements $TickingBlockEntity$$Interface {
 "getType"(): StringJS
 "tick"(): void
 "getPos"(): $BlockPos
 "isRemoved"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickingBlockEntity$$Type = ($TickingBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TickingBlockEntity$$Original = $TickingBlockEntity;}
declare module "net.minecraft.world.level.chunk.storage.ChunkIOErrorReporter" {
import {$RegionStorageInfo$$Type} from "net.minecraft.world.level.chunk.storage.RegionStorageInfo"
import {$ReportedException} from "net.minecraft.ReportedException"
import {$Throwable$$Type} from "java.lang.Throwable"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"

export interface $ChunkIOErrorReporter$$Interface {
}

export class $ChunkIOErrorReporter implements $ChunkIOErrorReporter$$Interface {
 "reportMisplacedChunk"(arg0: $ChunkPos$$Type, arg1: $ChunkPos$$Type, arg2: $RegionStorageInfo$$Type): void
static "createMisplacedChunkReport"(arg0: $ChunkPos$$Type, arg1: $ChunkPos$$Type): $ReportedException
 "reportChunkLoadFailure"(arg0: $Throwable$$Type, arg1: $RegionStorageInfo$$Type, arg2: $ChunkPos$$Type): void
 "reportChunkSaveFailure"(arg0: $Throwable$$Type, arg1: $RegionStorageInfo$$Type, arg2: $ChunkPos$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkIOErrorReporter$$Type = ($ChunkIOErrorReporter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkIOErrorReporter$$Original = $ChunkIOErrorReporter;}
declare module "net.minecraft.world.level.GameRules$Key" {
import {$CustomGameRuleCategory, $CustomGameRuleCategory$$Type} from "net.fabricmc.fabric.api.gamerule.v1.CustomGameRuleCategory"
import {$GameRules$Value} from "net.minecraft.world.level.GameRules$Value"
import {$GameRules$Category, $GameRules$Category$$Type} from "net.minecraft.world.level.GameRules$Category"
import {$RuleKeyExtensions$$Interface} from "net.fabricmc.fabric.impl.gamerule.RuleKeyExtensions"

export class $GameRules$Key<T extends $GameRules$Value<(object)>> implements $RuleKeyExtensions$$Interface {
readonly "id": StringJS

constructor(arg0: StringJS, arg1: $GameRules$Category$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getId"(): StringJS
public "getCategory"(): $GameRules$Category
public "getDescriptionId"(): StringJS
public "fabric_getCustomCategory"(): $CustomGameRuleCategory
public "fabric_setCustomCategory"(arg0: $CustomGameRuleCategory$$Type): void
get "category"(): $GameRules$Category
get "descriptionId"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$Key$$Type<T> = ($GameRules$Key<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$Key$$Original<T> = $GameRules$Key<(T)>;}
declare module "net.minecraft.world.level.levelgen.DensityFunctions$MarkerOrMarked" {
import {$DensityFunctions$Marker$Type} from "net.minecraft.world.level.levelgen.DensityFunctions$Marker$Type"
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$DensityFunction, $DensityFunction$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction"

export interface $DensityFunctions$MarkerOrMarked$$Interface extends $DensityFunction$$Interface {
}

export class $DensityFunctions$MarkerOrMarked implements $DensityFunctions$MarkerOrMarked$$Interface {
 "type"(): $DensityFunctions$Marker$Type
 "wrapped"(): $DensityFunction
 "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
 "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
 "abs"(): $DensityFunction
 "clamp"(arg0: double, arg1: double): $DensityFunction
 "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
 "maxValue"(): double
 "square"(): $DensityFunction
 "halfNegative"(): $DensityFunction
 "quarterNegative"(): $DensityFunction
 "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
 "minValue"(): double
 "cube"(): $DensityFunction
 "squeeze"(): $DensityFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunctions$MarkerOrMarked$$Type = ($DensityFunctions$MarkerOrMarked);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunctions$MarkerOrMarked$$Original = $DensityFunctions$MarkerOrMarked;}
declare module "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$Listener" {
import {$PositionSource} from "net.minecraft.world.level.gameevent.PositionSource"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$VibrationSystem$$Type} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem"
import {$GameEventListener$$Interface} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$GameEventListener$DeliveryMode} from "net.minecraft.world.level.gameevent.GameEventListener$DeliveryMode"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export class $VibrationSystem$Listener implements $GameEventListener$$Interface {
constructor(arg0: $VibrationSystem$$Type)

public "forceScheduleVibration"(arg0: $ServerLevel$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $GameEvent$Context$$Type, arg3: $Vec3$$Type): void
public "getListenerRadius"(): integer
public "handleGameEvent"(arg0: $ServerLevel$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $GameEvent$Context$$Type, arg3: $Vec3$$Type): boolean
public "getListenerSource"(): $PositionSource
public static "distanceBetweenInBlocks"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): float
public "handler$ehh000$deeperdarker$handleGameEvent"(arg0: $ServerLevel$$Type, arg1: $Holder$$Type, arg2: $GameEvent$Context$$Type, arg3: $Vec3$$Type, arg4: $CallbackInfoReturnable$$Type): void
public "getDeliveryMode"(): $GameEventListener$DeliveryMode
get "listenerRadius"(): integer
get "listenerSource"(): $PositionSource
get "deliveryMode"(): $GameEventListener$DeliveryMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VibrationSystem$Listener$$Type = ($VibrationSystem$Listener);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VibrationSystem$Listener$$Original = $VibrationSystem$Listener;}
declare module "net.minecraft.world.level.block.entity.ShulkerBoxBlockEntity" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LithiumInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumInventory"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$ShulkerBoxBlockEntity$AnimationStatus} from "net.minecraft.world.level.block.entity.ShulkerBoxBlockEntity$AnimationStatus"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WrappedBlockEntityTickInvokerAccessor, $WrappedBlockEntityTickInvokerAccessor$$Type} from "net.caffeinemc.mods.lithium.mixin.world.block_entity_ticking.sleeping.WrappedBlockEntityTickInvokerAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TickingBlockEntity, $TickingBlockEntity$$Type} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$RandomizableContainerBlockEntity} from "net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity"
import {$ReferenceArraySet} from "it.unimi.dsi.fastutil.objects.ReferenceArraySet"
import {$WorldlyContainer$$Interface} from "net.minecraft.world.WorldlyContainer"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Type, $InventoryChangeTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$SleepingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SleepingBlockEntity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB} from "net.minecraft.world.phys.AABB"

export class $ShulkerBoxBlockEntity extends $RandomizableContainerBlockEntity implements $WorldlyContainer$$Interface, $LithiumInventory$$Interface, $InventoryChangeTracker$$Interface, $SleepingBlockEntity$$Interface {
 "inventoryChangeListeners": $ReferenceArraySet
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventoryHandlingTypeListeners": $ReferenceArraySet
 "remove": boolean
 "worldPosition": $BlockPos
 "lootTable": $ResourceKey<($LootTable)>
static readonly "EVENT_SET_OPEN_COUNT": integer
static readonly "CONTAINER_SIZE": integer
static readonly "COLUMNS": integer
static readonly "OPENING_TICK_LENGTH": integer
 "openCount": integer
 "lockKey": $LockCode
 "hasComparators": byte
static readonly "MAX_LID_HEIGHT": float
static readonly "MAX_LID_ROTATION": float
 "lootTableSeed": long
static readonly "ROWS": integer

constructor(arg0: $DyeColor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)
constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $ShulkerBoxBlockEntity$$Type): void
public "getDefaultName"(): $Component
public "isClosed"(): boolean
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "handler$bpn004$lithium$setInventoryStackListReplacement"(arg0: $NonNullList$$Type, arg1: $CallbackInfo$$Type): void
public "loadFromTag"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getContainerSize"(): integer
public "getItems"(): $NonNullList<($ItemStack)>
public "triggerEvent"(arg0: integer, arg1: integer): boolean
public "lithium$setTickWrapper"(arg0: $WrappedBlockEntityTickInvokerAccessor$$Type): void
public "lithium$getSleepingTicker"(): $TickingBlockEntity
public "canTakeItemThroughFace"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "lithium$getTickWrapper"(): $WrappedBlockEntityTickInvokerAccessor
public "canPlaceItemThroughFace"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "lithium$setSleepingTicker"(arg0: $TickingBlockEntity$$Type): void
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getAnimationStatus"(): $ShulkerBoxBlockEntity$AnimationStatus
public "getProgress"(arg0: float): float
public "getColor"(): $DyeColor
public "handler$zpd000$quickrightclick$stopOpen"(arg0: $Player$$Type, arg1: $CallbackInfo$$Type): void
public "setItems"(arg0: $NonNullList$$Type<($ItemStack$$Type)>): void
public "stopOpen"(arg0: $Player$$Type): void
public "startOpen"(arg0: $Player$$Type): void
public "getBoundingBox"(arg0: $BlockState$$Type): $AABB
public "getInventoryLithium"(): $NonNullList
public "setInventoryLithium"(arg0: $NonNullList$$Type): void
public "getSlotsForFace"(arg0: $Direction$$Type): (integer)[]
public "createMenu"(arg0: integer, arg1: $Inventory$$Type): $AbstractContainerMenu
public "generateLootLithium"(): void
public "stopListenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "listenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "listenForContentChangesOnce"(arg0: $LithiumStackList$$Type, arg1: $InventoryChangeListener$$Type): void
public "isSleeping"(): boolean
public "setTicker"(arg0: $TickingBlockEntity$$Type): void
public "wakeUpNow"(): void
public "sleepOnlyCurrentTick"(): void
public "lithium$startSleeping"(): boolean
public "stillValid"(arg0: $Player$$Type): boolean
public "setChanged"(): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitContentModified"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$emitRemoved"(): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public static "tryClear"(arg0: any): void
get "defaultName"(): $Component
get "closed"(): boolean
get "containerSize"(): integer
get "items"(): $NonNullList<($ItemStack)>
get "animationStatus"(): $ShulkerBoxBlockEntity$AnimationStatus
get "color"(): $DyeColor
set "items"(value: $NonNullList$$Type<($ItemStack$$Type)>)
get "inventoryLithium"(): $NonNullList
set "inventoryLithium"(value: $NonNullList$$Type)
get "sleeping"(): boolean
set "ticker"(value: $TickingBlockEntity$$Type)
get "changed"(): void
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShulkerBoxBlockEntity$$Type = ($ShulkerBoxBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShulkerBoxBlockEntity$$Original = $ShulkerBoxBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.RuleBasedBlockStateProvider$Rule" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Record} from "java.lang.Record"

export class $RuleBasedBlockStateProvider$Rule extends $Record {
static readonly "CODEC": $Codec<($RuleBasedBlockStateProvider$Rule)>

constructor(arg0: $BlockPredicate$$Type, arg1: $BlockStateProvider$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "ifTrue"(): $BlockPredicate
public "then"(): $BlockStateProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuleBasedBlockStateProvider$Rule$$Type = ({"then"?: $BlockStateProvider$$Type, "ifTrue"?: $BlockPredicate$$Type}) | ([then?: $BlockStateProvider$$Type, ifTrue?: $BlockPredicate$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuleBasedBlockStateProvider$Rule$$Original = $RuleBasedBlockStateProvider$Rule;}
declare module "net.minecraft.world.level.chunk.LevelChunkSection" {
import {$Climate$Sampler$$Type} from "net.minecraft.world.level.biome.Climate$Sampler"
import {$BiomeResolver$$Type} from "net.minecraft.world.level.biome.BiomeResolver"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$PalettedContainer, $PalettedContainer$$Type} from "net.minecraft.world.level.chunk.PalettedContainer"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$PalettedContainerRO, $PalettedContainerRO$$Type} from "net.minecraft.world.level.chunk.PalettedContainerRO"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $LevelChunkSection {
static readonly "SECTION_WIDTH": integer
static readonly "SECTION_HEIGHT": integer
static readonly "BIOME_CONTAINER_BITS": integer
static readonly "SECTION_SIZE": integer

constructor(arg0: $PalettedContainer$$Type<($BlockState$$Type)>, arg1: $PalettedContainerRO$$Type<($Holder$$Type<($Biome$$Type)>)>)
constructor(arg0: $Registry$$Type<($Biome$$Type)>)

public "maybeHas"(arg0: $Predicate$$Type<($BlockState)>): boolean
public "write"(arg0: $FriendlyByteBuf$$Type): void
public "read"(arg0: $FriendlyByteBuf$$Type): void
public "release"(): void
public "acquire"(): void
public "fillBiomesFromNoise"(arg0: $BiomeResolver$$Type, arg1: $Climate$Sampler$$Type, arg2: integer, arg3: integer, arg4: integer): void
public "getFluidState"(arg0: integer, arg1: integer, arg2: integer): $FluidState
public "readBiomes"(arg0: $FriendlyByteBuf$$Type): void
public "getBiomes"(): $PalettedContainerRO<($Holder<($Biome)>)>
public "setBlockState"(arg0: integer, arg1: integer, arg2: integer, arg3: $BlockState$$Type, arg4: boolean): $BlockState
public "setBlockState"(arg0: integer, arg1: integer, arg2: integer, arg3: $BlockState$$Type): $BlockState
public "getBlockState"(arg0: integer, arg1: integer, arg2: integer): $BlockState
public "hasOnlyAir"(): boolean
public "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
public "getStates"(): $PalettedContainer<($BlockState)>
public "getSerializedSize"(): integer
public "isRandomlyTicking"(): boolean
public "recalcBlockCounts"(): void
public "isRandomlyTickingFluids"(): boolean
public "isRandomlyTickingBlocks"(): boolean
get "biomes"(): $PalettedContainerRO<($Holder<($Biome)>)>
get "states"(): $PalettedContainer<($BlockState)>
get "serializedSize"(): integer
get "randomlyTicking"(): boolean
get "randomlyTickingFluids"(): boolean
get "randomlyTickingBlocks"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelChunkSection$$Type = ($LevelChunkSection);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelChunkSection$$Original = $LevelChunkSection;}
declare module "net.minecraft.world.level.biome.BiomeSource" {
import {$Pair} from "com.mojang.datafixers.util.Pair"
import {$List$$Type} from "java.util.List"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Climate$Sampler$$Type} from "net.minecraft.world.level.biome.Climate$Sampler"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$BiomeResolver$$Interface} from "net.minecraft.world.level.biome.BiomeResolver"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Set, $Set$$Type} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$Stream} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $BiomeSource implements $BiomeResolver$$Interface {
static readonly "CODEC": $Codec<($BiomeSource)>

constructor()

public "collectPossibleBiomes"(): $Stream<($Holder<($Biome)>)>
public "findBiomeHorizontal"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: $Predicate$$Type<($Holder<($Biome)>)>, arg6: $RandomSource$$Type, arg7: boolean, arg8: $Climate$Sampler$$Type): $Pair<($BlockPos), ($Holder<($Biome)>)>
public "findBiomeHorizontal"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $Predicate$$Type<($Holder<($Biome)>)>, arg5: $RandomSource$$Type, arg6: $Climate$Sampler$$Type): $Pair<($BlockPos), ($Holder<($Biome)>)>
public "fabric_modifyBiomeSet"(arg0: $Set$$Type): $Set
public "findClosestBiome3d"(arg0: $BlockPos$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: $Predicate$$Type<($Holder<($Biome)>)>, arg5: $Climate$Sampler$$Type, arg6: $LevelReader$$Type): $Pair<($BlockPos), ($Holder<($Biome)>)>
public "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer, arg3: $Climate$Sampler$$Type): $Holder<($Biome)>
public "codec"(): $MapCodec<($BiomeSource)>
public "getBiomesWithin"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $Climate$Sampler$$Type): $Set<($Holder<($Biome)>)>
public "addDebugInfo"(arg0: $List$$Type<(StringJS)>, arg1: $BlockPos$$Type, arg2: $Climate$Sampler$$Type): void
public "possibleBiomes"(): $Set<($Holder<($Biome)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeSource$$Type = ($BiomeSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeSource$$Original = $BiomeSource;}
declare module "net.minecraft.world.level.block.entity.DaylightDetectorBlockEntity" {
import {$Level} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DaylightDetectorBlockEntity extends $BlockEntity {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DaylightDetectorBlockEntity$$Type = ($DaylightDetectorBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DaylightDetectorBlockEntity$$Original = $DaylightDetectorBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"

export class $NetherForestVegetationConfig extends $BlockPileConfiguration {
static readonly "CODEC": $Codec<($NetherForestVegetationConfig)>
readonly "spreadHeight": integer
readonly "spreadWidth": integer
readonly "stateProvider": $BlockStateProvider

constructor(arg0: $BlockStateProvider$$Type, arg1: integer, arg2: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetherForestVegetationConfig$$Type = ($NetherForestVegetationConfig);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NetherForestVegetationConfig$$Original = $NetherForestVegetationConfig;}
declare module "net.minecraft.world.level.block.state.properties.ComparatorMode" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $ComparatorMode extends $Enum<($ComparatorMode)> implements $StringRepresentable$$Interface {
static readonly "COMPARE": $ComparatorMode
static readonly "SUBTRACT": $ComparatorMode

public "toString"(): StringJS
public static "values"(): ($ComparatorMode)[]
public static "valueOf"(arg0: StringJS): $ComparatorMode
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComparatorMode$$Type = (("compare") | ("subtract"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComparatorMode$$Original = $ComparatorMode;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacerType" {
import {$CherryTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.CherryTrunkPlacer"
import {$MegaJungleTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.MegaJungleTrunkPlacer"
import {$DarkOakTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.DarkOakTrunkPlacer"
import {$StraightTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.StraightTrunkPlacer"
import {$FancyTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.FancyTrunkPlacer"
import {$GiantTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.GiantTrunkPlacer"
import {$UpwardsBranchingTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.UpwardsBranchingTrunkPlacer"
import {$BendingTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.BendingTrunkPlacer"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$ForkingTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.ForkingTrunkPlacer"

export class $TrunkPlacerType<P extends $TrunkPlacer> {
static readonly "GIANT_TRUNK_PLACER": $TrunkPlacerType<($GiantTrunkPlacer)>
static readonly "BENDING_TRUNK_PLACER": $TrunkPlacerType<($BendingTrunkPlacer)>
static readonly "UPWARDS_BRANCHING_TRUNK_PLACER": $TrunkPlacerType<($UpwardsBranchingTrunkPlacer)>
static readonly "DARK_OAK_TRUNK_PLACER": $TrunkPlacerType<($DarkOakTrunkPlacer)>
static readonly "FANCY_TRUNK_PLACER": $TrunkPlacerType<($FancyTrunkPlacer)>
static readonly "CHERRY_TRUNK_PLACER": $TrunkPlacerType<($CherryTrunkPlacer)>
static readonly "STRAIGHT_TRUNK_PLACER": $TrunkPlacerType<($StraightTrunkPlacer)>
static readonly "FORKING_TRUNK_PLACER": $TrunkPlacerType<($ForkingTrunkPlacer)>
static readonly "MEGA_JUNGLE_TRUNK_PLACER": $TrunkPlacerType<($MegaJungleTrunkPlacer)>

constructor(arg0: $MapCodec$$Type<(P)>)

public "codec"(): $MapCodec<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenTrunkPlacerType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenTrunkPlacerTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrunkPlacerType$$Type<P> = (Special.WorldgenTrunkPlacerType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrunkPlacerType$$Original<P> = $TrunkPlacerType<(P)>;}
declare module "net.minecraft.world.level.levelgen.VerticalAnchor" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$WorldGenerationContext, $WorldGenerationContext$$Type} from "net.minecraft.world.level.levelgen.WorldGenerationContext"

export interface $VerticalAnchor$$Interface {

(arg0: $WorldGenerationContext): integer
}

export class $VerticalAnchor implements $VerticalAnchor$$Interface {
static readonly "CODEC": $Codec<($VerticalAnchor)>
static readonly "TOP": $VerticalAnchor
static readonly "BOTTOM": $VerticalAnchor

static "bottom"(): $VerticalAnchor
static "top"(): $VerticalAnchor
static "absolute"(arg0: integer): $VerticalAnchor
static "aboveBottom"(arg0: integer): $VerticalAnchor
 "resolveY"(arg0: $WorldGenerationContext$$Type): integer
static "belowTop"(arg0: integer): $VerticalAnchor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VerticalAnchor$$Type = ((arg0: $WorldGenerationContext) => integer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VerticalAnchor$$Original = $VerticalAnchor;}
declare module "net.minecraft.world.level.storage.DataVersion" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DataVersion {
static "MAIN_SERIES": StringJS

constructor(arg0: integer)
constructor(arg0: integer, arg1: StringJS)

public "getVersion"(): integer
public "getSeries"(): StringJS
public "isSideSeries"(): boolean
public "isCompatible"(arg0: $DataVersion$$Type): boolean
get "version"(): integer
get "series"(): StringJS
get "sideSeries"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataVersion$$Type = ($DataVersion);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataVersion$$Original = $DataVersion;}
declare module "net.minecraft.world.level.Level$ExplosionInteraction" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $Level$ExplosionInteraction extends $Enum<($Level$ExplosionInteraction)> implements $StringRepresentable$$Interface {
static readonly "MOB": $Level$ExplosionInteraction
static readonly "CODEC": $Codec<($Level$ExplosionInteraction)>
static readonly "TRIGGER": $Level$ExplosionInteraction
static readonly "BLOCK": $Level$ExplosionInteraction
static readonly "TNT": $Level$ExplosionInteraction
static readonly "NONE": $Level$ExplosionInteraction

public static "values"(): ($Level$ExplosionInteraction)[]
public static "valueOf"(arg0: StringJS): $Level$ExplosionInteraction
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Level$ExplosionInteraction$$Type = (("none") | ("block") | ("mob") | ("tnt") | ("trigger"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Level$ExplosionInteraction$$Original = $Level$ExplosionInteraction;}
declare module "net.minecraft.world.level.levelgen.structure.placement.StructurePlacementType" {
import {$ConcentricRingsStructurePlacement} from "net.minecraft.world.level.levelgen.structure.placement.ConcentricRingsStructurePlacement"
import {$StructurePlacement} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$RandomSpreadStructurePlacement} from "net.minecraft.world.level.levelgen.structure.placement.RandomSpreadStructurePlacement"

export interface $StructurePlacementType$$Interface<SP extends $StructurePlacement> {

(): $MapCodec$$Type<(SP)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenStructurePlacement
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenStructurePlacementTag
}

export class $StructurePlacementType<SP extends $StructurePlacement> implements $StructurePlacementType$$Interface {
static readonly "RANDOM_SPREAD": $StructurePlacementType<($RandomSpreadStructurePlacement)>
static readonly "CONCENTRIC_RINGS": $StructurePlacementType<($ConcentricRingsStructurePlacement)>

 "codec"(): $MapCodec<(SP)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePlacementType$$Type<SP> = (Special.WorldgenStructurePlacement) | (() => $MapCodec$$Type<(SP)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePlacementType$$Original<SP> = $StructurePlacementType<(SP)>;}
declare module "net.minecraft.world.level.levelgen.structure.structures.OceanRuinStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$OceanRuinStructure$Type, $OceanRuinStructure$Type$$Type} from "net.minecraft.world.level.levelgen.structure.structures.OceanRuinStructure$Type"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $OceanRuinStructure extends $Structure {
readonly "largeProbability": float
readonly "clusterProbability": float
static readonly "CODEC": $MapCodec<($OceanRuinStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>
readonly "biomeTemp": $OceanRuinStructure$Type

constructor(arg0: $Structure$StructureSettings$$Type, arg1: $OceanRuinStructure$Type$$Type, arg2: float, arg3: float)

public "type"(): $StructureType<(never)>
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OceanRuinStructure$$Type = ($OceanRuinStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OceanRuinStructure$$Original = $OceanRuinStructure;}
declare module "net.minecraft.world.level.block.state.properties.BlockSetType" {
import {$BlockSetType$PressurePlateSensitivity, $BlockSetType$PressurePlateSensitivity$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType$PressurePlateSensitivity"
import {$Codec} from "com.mojang.serialization.Codec"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Stream} from "java.util.stream.Stream"
import {$Record} from "java.lang.Record"

export class $BlockSetType extends $Record {
static readonly "GOLD": $BlockSetType
static readonly "MANGROVE": $BlockSetType
static readonly "CODEC": $Codec<($BlockSetType)>
static readonly "BAMBOO": $BlockSetType
static readonly "ACACIA": $BlockSetType
static readonly "JUNGLE": $BlockSetType
static readonly "CRIMSON": $BlockSetType
static readonly "IRON": $BlockSetType
static readonly "COPPER": $BlockSetType
static readonly "DARK_OAK": $BlockSetType
static readonly "SPRUCE": $BlockSetType
static readonly "CHERRY": $BlockSetType
static readonly "BIRCH": $BlockSetType
static readonly "WARPED": $BlockSetType
static readonly "OAK": $BlockSetType
static readonly "POLISHED_BLACKSTONE": $BlockSetType
static readonly "STONE": $BlockSetType

constructor(arg0: StringJS)
constructor(arg0: StringJS, arg1: boolean, arg2: boolean, arg3: boolean, arg4: $BlockSetType$PressurePlateSensitivity$$Type, arg5: $SoundType$$Type, arg6: $SoundEvent$$Type, arg7: $SoundEvent$$Type, arg8: $SoundEvent$$Type, arg9: $SoundEvent$$Type, arg10: $SoundEvent$$Type, arg11: $SoundEvent$$Type, arg12: $SoundEvent$$Type, arg13: $SoundEvent$$Type)

public "name"(): StringJS
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public static "values"(): $Stream<($BlockSetType)>
public "hashCode"(): integer
public static "register"(arg0: $BlockSetType$$Type): $BlockSetType
public "canOpenByWindCharge"(): boolean
public "pressurePlateClickOn"(): $SoundEvent
public "pressurePlateClickOff"(): $SoundEvent
public "pressurePlateSensitivity"(): $BlockSetType$PressurePlateSensitivity
public "buttonClickOn"(): $SoundEvent
public "buttonClickOff"(): $SoundEvent
public "canButtonBeActivatedByArrows"(): boolean
public "doorOpen"(): $SoundEvent
public "doorClose"(): $SoundEvent
public "canOpenByHand"(): boolean
public "trapdoorClose"(): $SoundEvent
public "soundType"(): $SoundType
public "trapdoorOpen"(): $SoundEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockSetType$$Type = ({"trapdoorOpen"?: $SoundEvent$$Type, "pressurePlateSensitivity"?: $BlockSetType$PressurePlateSensitivity$$Type, "buttonClickOff"?: $SoundEvent$$Type, "canButtonBeActivatedByArrows"?: boolean, "pressurePlateClickOn"?: $SoundEvent$$Type, "canOpenByWindCharge"?: boolean, "trapdoorClose"?: $SoundEvent$$Type, "doorClose"?: $SoundEvent$$Type, "pressurePlateClickOff"?: $SoundEvent$$Type, "canOpenByHand"?: boolean, "soundType"?: $SoundType$$Type, "buttonClickOn"?: $SoundEvent$$Type, "doorOpen"?: $SoundEvent$$Type, "name"?: StringJS}) | ([trapdoorOpen?: $SoundEvent$$Type, pressurePlateSensitivity?: $BlockSetType$PressurePlateSensitivity$$Type, buttonClickOff?: $SoundEvent$$Type, canButtonBeActivatedByArrows?: boolean, pressurePlateClickOn?: $SoundEvent$$Type, canOpenByWindCharge?: boolean, trapdoorClose?: $SoundEvent$$Type, doorClose?: $SoundEvent$$Type, pressurePlateClickOff?: $SoundEvent$$Type, canOpenByHand?: boolean, soundType?: $SoundType$$Type, buttonClickOn?: $SoundEvent$$Type, doorOpen?: $SoundEvent$$Type, name?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockSetType$$Original = $BlockSetType;}
declare module "net.minecraft.world.level.gameevent.GameEventListenerRegistry$ListenerVisitor" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$GameEventListener, $GameEventListener$$Type} from "net.minecraft.world.level.gameevent.GameEventListener"

export interface $GameEventListenerRegistry$ListenerVisitor$$Interface {

(arg0: $GameEventListener, arg1: $Vec3): void
}

export class $GameEventListenerRegistry$ListenerVisitor implements $GameEventListenerRegistry$ListenerVisitor$$Interface {
 "visit"(arg0: $GameEventListener$$Type, arg1: $Vec3$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameEventListenerRegistry$ListenerVisitor$$Type = ((arg0: $GameEventListener, arg1: $Vec3) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameEventListenerRegistry$ListenerVisitor$$Original = $GameEventListenerRegistry$ListenerVisitor;}
declare module "net.minecraft.world.level.chunk.ProtoChunk" {
import {$LevelLightEngine$$Type} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$LevelHeightAccessor, $LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$UpgradeData, $UpgradeData$$Type} from "net.minecraft.world.level.chunk.UpgradeData"
import {$NoiseChunk} from "net.minecraft.world.level.levelgen.NoiseChunk"
import {$List} from "java.util.List"
import {$BelowZeroRetrogen, $BelowZeroRetrogen$$Type} from "net.minecraft.world.level.levelgen.BelowZeroRetrogen"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ChunkAccess$TicksToSave} from "net.minecraft.world.level.chunk.ChunkAccess$TicksToSave"
import {$Holder} from "net.minecraft.core.Holder"
import {$ProtoChunkTicks$$Type} from "net.minecraft.world.ticks.ProtoChunkTicks"
import {$TickContainerAccess} from "net.minecraft.world.ticks.TickContainerAccess"
import {$BlendingData, $BlendingData$$Type} from "net.minecraft.world.level.levelgen.blending.BlendingData"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Function$$Type} from "java.util.function.Function"
import {$CarvingMask, $CarvingMask$$Type} from "net.minecraft.world.level.chunk.CarvingMask"
import {$LevelChunkTicks} from "net.minecraft.world.ticks.LevelChunkTicks"
import {$Heightmap} from "net.minecraft.world.level.levelgen.Heightmap"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ChunkSkyLightSources} from "net.minecraft.world.level.lighting.ChunkSkyLightSources"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$LevelChunkSection, $LevelChunkSection$$Type} from "net.minecraft.world.level.chunk.LevelChunkSection"
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$ChunkStatus, $ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$GenerationStep$Carving$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Carving"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Heightmap$Types} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$StructureStart$$Type} from "net.minecraft.world.level.levelgen.structure.StructureStart"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$ShortList} from "it.unimi.dsi.fastutil.shorts.ShortList"

export class $ProtoChunk extends $ChunkAccess {
readonly "upgradeData": $UpgradeData
readonly "chunkPos": $ChunkPos
readonly "pendingBlockEntities": $Map<($BlockPos), ($CompoundTag)>
 "noiseChunk": $NoiseChunk
readonly "sections": ($LevelChunkSection)[]
 "skyLightSources": $ChunkSkyLightSources
readonly "postProcessing": ($ShortList)[]
 "blendingData": $BlendingData
readonly "levelHeightAccessor": $LevelHeightAccessor
readonly "blockEntities": $Map<($BlockPos), ($BlockEntity)>
 "saveTimePoint": long
 "unsaved": boolean
readonly "heightmaps": $Map<($Heightmap$Types), ($Heightmap)>
static readonly "NO_FILLED_SECTION": integer

constructor(arg0: $ChunkPos$$Type, arg1: $UpgradeData$$Type, arg2: $LevelHeightAccessor$$Type, arg3: $Registry$$Type<($Biome$$Type)>, arg4: $BlendingData$$Type)
constructor(arg0: $ChunkPos$$Type, arg1: $UpgradeData$$Type, arg2: ($LevelChunkSection$$Type)[], arg3: $ProtoChunkTicks$$Type<($Block$$Type)>, arg4: $ProtoChunkTicks$$Type<($Fluid$$Type)>, arg5: $LevelHeightAccessor$$Type, arg6: $Registry$$Type<($Biome$$Type)>, arg7: $BlendingData$$Type)

public "getBlockEntityNbtForSaving"(arg0: $BlockPos$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public "getBelowZeroRetrogen"(): $BelowZeroRetrogen
public "getTicksForSerialization"(): $ChunkAccess$TicksToSave
public "setStartForStructure"(arg0: $Structure$$Type, arg1: $StructureStart$$Type): void
public "addPackedPostProcess"(arg0: short, arg1: integer): void
public "getFluidState"(arg0: $BlockPos$$Type): $FluidState
public "markPosForPostprocessing"(arg0: $BlockPos$$Type): void
public "getEntities"(): $List<($CompoundTag)>
public "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
public "getOrCreateCarvingMask"(arg0: $GenerationStep$Carving$$Type): $CarvingMask
public "setBlockState"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: boolean): $BlockState
public "setBlockEntity"(arg0: $BlockEntity$$Type): void
public "removeBlockEntity"(arg0: $BlockPos$$Type): void
public static "packOffsetCoordinates"(arg0: $BlockPos$$Type): short
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "getPersistedStatus"(): $ChunkStatus
public "getBlockEntities"(): $Map<($BlockPos), ($BlockEntity)>
public "addEntity"(arg0: $Entity$$Type): void
public "addEntity"(arg0: $CompoundTag$$Type): void
public "getBlockTicks"(): $TickContainerAccess<($Block)>
public "getFluidTicks"(): $TickContainerAccess<($Fluid)>
public "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
public "getHeightAccessorForGeneration"(): $LevelHeightAccessor
public "getCarvingMask"(arg0: $GenerationStep$Carving$$Type): $CarvingMask
public static "unpackOffsetCoordinates"(arg0: short, arg1: integer, arg2: $ChunkPos$$Type): $BlockPos
public "unpackBlockTicks"(): $LevelChunkTicks<($Block)>
public "unpackFluidTicks"(): $LevelChunkTicks<($Fluid)>
public "getBlockEntityNbts"(): $Map<($BlockPos), ($CompoundTag)>
public "setLightEngine"(arg0: $LevelLightEngine$$Type): void
public "setBelowZeroRetrogen"(arg0: $BelowZeroRetrogen$$Type): void
public "setPersistedStatus"(arg0: $ChunkStatus$$Type): void
public "setCarvingMask"(arg0: $GenerationStep$Carving$$Type, arg1: $CarvingMask$$Type): void
public static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
public static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
get "belowZeroRetrogen"(): $BelowZeroRetrogen
get "ticksForSerialization"(): $ChunkAccess$TicksToSave
get "entities"(): $List<($CompoundTag)>
set "blockEntity"(value: $BlockEntity$$Type)
get "persistedStatus"(): $ChunkStatus
get "blockTicks"(): $TickContainerAccess<($Block)>
get "fluidTicks"(): $TickContainerAccess<($Fluid)>
get "heightAccessorForGeneration"(): $LevelHeightAccessor
get "blockEntityNbts"(): $Map<($BlockPos), ($CompoundTag)>
set "lightEngine"(value: $LevelLightEngine$$Type)
set "belowZeroRetrogen"(value: $BelowZeroRetrogen$$Type)
set "persistedStatus"(value: $ChunkStatus$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProtoChunk$$Type = ($ProtoChunk);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ProtoChunk$$Original = $ProtoChunk;}
declare module "net.minecraft.world.level.chunk.status.WorldGenContext" {
import {$ChunkTaskPriorityQueueSorter$Message, $ChunkTaskPriorityQueueSorter$Message$$Type} from "net.minecraft.server.level.ChunkTaskPriorityQueueSorter$Message"
import {$ChunkGenerator, $ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$ThreadedLevelLightEngine, $ThreadedLevelLightEngine$$Type} from "net.minecraft.server.level.ThreadedLevelLightEngine"
import {$Runnable, $Runnable$$Type} from "java.lang.Runnable"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$ProcessorHandle, $ProcessorHandle$$Type} from "net.minecraft.util.thread.ProcessorHandle"
import {$StructureTemplateManager, $StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$Record} from "java.lang.Record"

export class $WorldGenContext extends $Record {
constructor(arg0: $ServerLevel$$Type, arg1: $ChunkGenerator$$Type, arg2: $StructureTemplateManager$$Type, arg3: $ThreadedLevelLightEngine$$Type, arg4: $ProcessorHandle$$Type<($ChunkTaskPriorityQueueSorter$Message$$Type<($Runnable$$Type)>)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "generator"(): $ChunkGenerator
public "level"(): $ServerLevel
public "lightEngine"(): $ThreadedLevelLightEngine
public "structureManager"(): $StructureTemplateManager
public "mainThreadMailBox"(): $ProcessorHandle<($ChunkTaskPriorityQueueSorter$Message<($Runnable)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldGenContext$$Type = ({"generator"?: $ChunkGenerator$$Type, "lightEngine"?: $ThreadedLevelLightEngine$$Type, "mainThreadMailBox"?: $ProcessorHandle$$Type<($ChunkTaskPriorityQueueSorter$Message$$Type<($Runnable$$Type)>)>, "structureManager"?: $StructureTemplateManager$$Type, "level"?: $ServerLevel$$Type}) | ([generator?: $ChunkGenerator$$Type, lightEngine?: $ThreadedLevelLightEngine$$Type, mainThreadMailBox?: $ProcessorHandle$$Type<($ChunkTaskPriorityQueueSorter$Message$$Type<($Runnable$$Type)>)>, structureManager?: $StructureTemplateManager$$Type, level?: $ServerLevel$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldGenContext$$Original = $WorldGenContext;}
declare module "net.minecraft.world.level.block.entity.BaseContainerBlockEntity" {
import {$AccessorMixinBaseContainerBlockEntity$$Interface} from "noobanidus.mods.lootr.common.mixins.AccessorMixinBaseContainerBlockEntity"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TransactionContext$$Type} from "net.fabricmc.fabric.api.transfer.v1.transaction.TransactionContext"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$MenuProvider$$Interface} from "net.minecraft.world.MenuProvider"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$LockCode, $LockCode$$Type} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$Set$$Type} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$ReferenceArraySet} from "it.unimi.dsi.fastutil.objects.ReferenceArraySet"
import {$SpecialLogicInventory$$Interface} from "net.fabricmc.fabric.impl.transfer.item.SpecialLogicInventory"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$InventoryChangeEmitter$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeEmitter"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Nameable$$Interface} from "net.minecraft.world.Nameable"
import {$Operation$$Type} from "com.llamalad7.mixinextras.injector.wrapoperation.Operation"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$Container, $Container$$Type, $Container$$Interface} from "net.minecraft.world.Container"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $BaseContainerBlockEntity extends $BlockEntity implements $Container$$Interface, $MenuProvider$$Interface, $Nameable$$Interface, $InventoryChangeEmitter$$Interface, $AccessorMixinBaseContainerBlockEntity$$Interface, $SpecialLogicInventory$$Interface {
 "inventoryChangeListeners": $ReferenceArraySet
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventoryHandlingTypeListeners": $ReferenceArraySet
 "lockKey": $LockCode
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getName"(): $Component
public "isEmpty"(): boolean
public "getDisplayName"(): $Component
public "getItem"(arg0: integer): $ItemStack
public "getDefaultName"(): $Component
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitContentModified"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "getCustomName"(): $Component
public "removeItemNoUpdate"(arg0: integer): $ItemStack
public "getItems"(): $NonNullList<($ItemStack)>
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "fabric_setSuppress"(arg0: boolean): void
public "invokeGetItems"(): $NonNullList
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "stillValid"(arg0: $Player$$Type): boolean
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public "setItems"(arg0: $NonNullList$$Type<($ItemStack$$Type)>): void
public static "canUnlock"(arg0: $Player$$Type, arg1: $LockCode$$Type, arg2: $Component$$Type): boolean
public "getLockKey"(): $LockCode
public "setLockKey"(arg0: $LockCode$$Type): void
public "clearContent"(): void
public "canOpen"(arg0: $Player$$Type): boolean
public "handler$bpj000$lithium$readNbtStackListReplacement"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type, arg2: $CallbackInfo$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "wrapOperation$eml000$fabric_transfer_api_v1$fabric_redirectMarkDirty"(arg0: $BaseContainerBlockEntity$$Type, arg1: $Operation$$Type): void
public "collectImplicitComponents"(arg0: $DataComponentMap$Builder$$Type): void
public "applyImplicitComponents"(arg0: $BlockEntity$DataComponentInput$$Type): void
public "lithium$emitRemoved"(): void
public "fabric_onFinalCommit"(arg0: integer, arg1: $ItemStack$$Type, arg2: $ItemStack$$Type): void
public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "createMenu"(arg0: integer, arg1: $Inventory$$Type): $AbstractContainerMenu
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "getContainerSize"(): integer
public "getMaxStackSize"(): integer
public "getMaxStackSize"(arg0: $ItemStack$$Type): integer
public "hasAnyMatching"(arg0: $Predicate$$Type<($ItemStack)>): boolean
public "setChanged"(): void
public "stopOpen"(arg0: $Player$$Type): void
public "hasAnyOf"(arg0: $Set$$Type<($Item$$Type)>): boolean
public "countItem"(arg0: $Item$$Type): integer
public "startOpen"(arg0: $Player$$Type): void
public "canTakeItem"(arg0: $Container$$Type, arg1: integer, arg2: $ItemStack$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "shouldTriggerClientSideContainerClosingOnOpen"(): boolean
public "hasCustomName"(): boolean
public "emitCallbackReplaced"(): void
public "fabric_onTransfer"(arg0: integer, arg1: $TransactionContext$$Type): void
public static "tryClear"(arg0: any): void
public "canReceiveTransferCooldown"(): boolean
public "setTransferCooldown"(arg0: long): void
public "lithium$itemInsertionTestRequiresStackSize1"(): boolean
public "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "getWidth"(): integer
public "getHeight"(): integer
public "isMutable"(): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
public "getSlots"(): integer
public "getSlotLimit"(slot: integer): integer
public "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
public "setChanged"(): void
public "getStackInSlot"(slot: integer): $ItemStack
public "asContainer"(): $Container
public "clear"(): void
public "self"(): $Container
public "getBlock"(level: $Level$$Type): $LevelBlock
public "writeClientSideData"(arg0: $AbstractContainerMenu$$Type, arg1: $RegistryFriendlyByteBuf$$Type): void
public "shouldCloseCurrentScreen"(): boolean
public "isEmpty"(): boolean
public "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(): integer
public "countNonEmpty"(match: $ItemPredicate$$Type): integer
public "getAllItems"(): $List<($ItemStack)>
public "clear"(match: $ItemPredicate$$Type): void
public "find"(): integer
public "find"(match: $ItemPredicate$$Type): integer
public "count"(): integer
public "count"(match: $ItemPredicate$$Type): integer
get "name"(): $Component
get "empty"(): boolean
get "displayName"(): $Component
get "defaultName"(): $Component
get "customName"(): $Component
get "items"(): $NonNullList<($ItemStack)>
set "items"(value: $NonNullList$$Type<($ItemStack$$Type)>)
get "containerSize"(): integer
get "maxStackSize"(): integer
get "changed"(): void
set "transferCooldown"(value: long)
get "width"(): integer
get "height"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "changed"(): void
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseContainerBlockEntity$$Type = ($BaseContainerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BaseContainerBlockEntity$$Original = $BaseContainerBlockEntity;}
declare module "net.minecraft.world.level.StructureManager" {
import {$StructureCheck$$Type} from "net.minecraft.world.level.levelgen.structure.StructureCheck"
import {$Map} from "java.util.Map"
import {$LongSet, $LongSet$$Type} from "it.unimi.dsi.fastutil.longs.LongSet"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$List} from "java.util.List"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$WorldOptions$$Type} from "net.minecraft.world.level.levelgen.WorldOptions"
import {$StructurePlacement$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$StructureCheckResult} from "net.minecraft.world.level.levelgen.structure.StructureCheckResult"
import {$StructureAccess$$Type} from "net.minecraft.world.level.chunk.StructureAccess"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$StructureStart, $StructureStart$$Type} from "net.minecraft.world.level.levelgen.structure.StructureStart"
import {$Structure, $Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$SectionPos$$Type} from "net.minecraft.core.SectionPos"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$WorldGenRegion$$Type} from "net.minecraft.server.level.WorldGenRegion"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $StructureManager {
constructor(arg0: $LevelAccessor$$Type, arg1: $WorldOptions$$Type, arg2: $StructureCheck$$Type)

public "getStructureAt"(arg0: $BlockPos$$Type, arg1: $Structure$$Type): $StructureStart
public "hasAnyStructureAt"(arg0: $BlockPos$$Type): boolean
public "addReferenceForStructure"(arg0: $SectionPos$$Type, arg1: $Structure$$Type, arg2: long, arg3: $StructureAccess$$Type): void
public "setStartForStructure"(arg0: $SectionPos$$Type, arg1: $Structure$$Type, arg2: $StructureStart$$Type, arg3: $StructureAccess$$Type): void
public "getStartForStructure"(arg0: $SectionPos$$Type, arg1: $Structure$$Type, arg2: $StructureAccess$$Type): $StructureStart
public "registryAccess"(): $RegistryAccess
public "checkStructurePresence"(arg0: $ChunkPos$$Type, arg1: $Structure$$Type, arg2: $StructurePlacement$$Type, arg3: boolean): $StructureCheckResult
public "shouldGenerateStructures"(): boolean
public "fillStartsForStructure"(arg0: $Structure$$Type, arg1: $LongSet$$Type, arg2: $Consumer$$Type<($StructureStart)>): void
public "structureHasPieceAt"(arg0: $BlockPos$$Type, arg1: $StructureStart$$Type): boolean
public "addReference"(arg0: $StructureStart$$Type): void
public "getStructureWithPieceAt"(arg0: $BlockPos$$Type, arg1: $HolderSet$$Type<($Structure)>): $StructureStart
public "getStructureWithPieceAt"(arg0: $BlockPos$$Type, arg1: $TagKey$$Type<($Structure)>): $StructureStart
public "getStructureWithPieceAt"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($Holder<($Structure)>)>): $StructureStart
public "getStructureWithPieceAt"(arg0: $BlockPos$$Type, arg1: $Structure$$Type): $StructureStart
public "getAllStructuresAt"(arg0: $BlockPos$$Type): $Map<($Structure), ($LongSet)>
public "startsForStructure"(arg0: $SectionPos$$Type, arg1: $Structure$$Type): $List<($StructureStart)>
public "startsForStructure"(arg0: $ChunkPos$$Type, arg1: $Predicate$$Type<($Structure)>): $List<($StructureStart)>
public "forWorldGenRegion"(arg0: $WorldGenRegion$$Type): $StructureManager
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureManager$$Type = ($StructureManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureManager$$Original = $StructureManager;}
declare module "net.minecraft.world.level.levelgen.structure.StructurePiece" {
import {$StructurePiece$BlockSelector$$Type} from "net.minecraft.world.level.levelgen.structure.StructurePiece$BlockSelector"
import {$Mirror} from "net.minecraft.world.level.block.Mirror"
import {$List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream$$Type} from "java.util.stream.Stream"
import {$StructurePieceType, $StructurePieceType$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.StructurePieceType"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockPos$MutableBlockPos} from "net.minecraft.core.BlockPos$MutableBlockPos"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$ServerLevelAccessor$$Type} from "net.minecraft.world.level.ServerLevelAccessor"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$Rotation} from "net.minecraft.world.level.block.Rotation"
import {$StructurePieceSerializationContext$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext"
import {$StructurePieceAccessor$$Type} from "net.minecraft.world.level.levelgen.structure.StructurePieceAccessor"

export class $StructurePiece {
 "boundingBox": $BoundingBox
 "genDepth": integer
static readonly "CAVE_AIR": $BlockState

constructor(arg0: $StructurePieceType$$Type, arg1: integer, arg2: $BoundingBox$$Type)
constructor(arg0: $StructurePieceType$$Type, arg1: $CompoundTag$$Type)

public "getType"(): $StructurePieceType
public "move"(arg0: integer, arg1: integer, arg2: integer): void
public "placeBlock"(arg0: $WorldGenLevel$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer, arg4: integer, arg5: $BoundingBox$$Type): void
public "getWorldX"(arg0: integer, arg1: integer): integer
public "getWorldY"(arg0: integer): integer
public "getWorldZ"(arg0: integer, arg1: integer): integer
public "getGenDepth"(): integer
public "generateUpperHalfSphere"(arg0: $WorldGenLevel$$Type, arg1: $BoundingBox$$Type, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: $BlockState$$Type, arg9: boolean): void
public "isReplaceableByStructures"(arg0: $BlockState$$Type): boolean
public "getBlock"(arg0: $BlockGetter$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: $BoundingBox$$Type): $BlockState
public "addAdditionalSaveData"(arg0: $StructurePieceSerializationContext$$Type, arg1: $CompoundTag$$Type): void
public "isInterior"(arg0: $LevelReader$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: $BoundingBox$$Type): boolean
public "getMirror"(): $Mirror
public "createTag"(arg0: $StructurePieceSerializationContext$$Type): $CompoundTag
public static "getRandomHorizontalDirection"(arg0: $RandomSource$$Type): $Direction
public "canBeReplaced"(arg0: $LevelReader$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: $BoundingBox$$Type): boolean
public "postProcess"(arg0: $WorldGenLevel$$Type, arg1: $StructureManager$$Type, arg2: $ChunkGenerator$$Type, arg3: $RandomSource$$Type, arg4: $BoundingBox$$Type, arg5: $ChunkPos$$Type, arg6: $BlockPos$$Type): void
public "generateAirBox"(arg0: $WorldGenLevel$$Type, arg1: $BoundingBox$$Type, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): void
public "generateBox"(arg0: $WorldGenLevel$$Type, arg1: $BoundingBox$$Type, arg2: $BoundingBox$$Type, arg3: $BlockState$$Type, arg4: $BlockState$$Type, arg5: boolean): void
public "generateBox"(arg0: $WorldGenLevel$$Type, arg1: $BoundingBox$$Type, arg2: $BoundingBox$$Type, arg3: boolean, arg4: $RandomSource$$Type, arg5: $StructurePiece$BlockSelector$$Type): void
public "generateBox"(arg0: $WorldGenLevel$$Type, arg1: $BoundingBox$$Type, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: $BlockState$$Type, arg9: $BlockState$$Type, arg10: boolean): void
public "generateBox"(arg0: $WorldGenLevel$$Type, arg1: $BoundingBox$$Type, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: boolean, arg9: $RandomSource$$Type, arg10: $StructurePiece$BlockSelector$$Type): void
public "maybeGenerateBlock"(arg0: $WorldGenLevel$$Type, arg1: $BoundingBox$$Type, arg2: $RandomSource$$Type, arg3: float, arg4: integer, arg5: integer, arg6: integer, arg7: $BlockState$$Type): void
public "createDispenser"(arg0: $WorldGenLevel$$Type, arg1: $BoundingBox$$Type, arg2: $RandomSource$$Type, arg3: integer, arg4: integer, arg5: integer, arg6: $Direction$$Type, arg7: $ResourceKey$$Type<($LootTable)>): boolean
public "isCloseToChunk"(arg0: $ChunkPos$$Type, arg1: integer): boolean
public "getLocatorPosition"(): $BlockPos
public "fillColumnDown"(arg0: $WorldGenLevel$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer, arg4: integer, arg5: $BoundingBox$$Type): void
public "createChest"(arg0: $ServerLevelAccessor$$Type, arg1: $BoundingBox$$Type, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type, arg4: $ResourceKey$$Type<($LootTable)>, arg5: $BlockState$$Type): boolean
public "createChest"(arg0: $WorldGenLevel$$Type, arg1: $BoundingBox$$Type, arg2: $RandomSource$$Type, arg3: integer, arg4: integer, arg5: integer, arg6: $ResourceKey$$Type<($LootTable)>): boolean
public static "findCollisionPiece"(arg0: $List$$Type<($StructurePiece$$Type)>, arg1: $BoundingBox$$Type): $StructurePiece
public static "createBoundingBox"(arg0: $Stream$$Type<($StructurePiece$$Type)>): $BoundingBox
public "setGenDepth"(arg0: integer): void
public "addChildren"(arg0: $StructurePiece$$Type, arg1: $StructurePieceAccessor$$Type, arg2: $RandomSource$$Type): void
public "generateMaybeBox"(arg0: $WorldGenLevel$$Type, arg1: $BoundingBox$$Type, arg2: $RandomSource$$Type, arg3: float, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: $BlockState$$Type, arg11: $BlockState$$Type, arg12: boolean, arg13: boolean): void
public "getWorldPos"(arg0: integer, arg1: integer, arg2: integer): $BlockPos$MutableBlockPos
public "getRotation"(): $Rotation
public "setOrientation"(arg0: $Direction$$Type): void
public "getOrientation"(): $Direction
public "getBoundingBox"(): $BoundingBox
public static "makeBoundingBox"(arg0: integer, arg1: integer, arg2: integer, arg3: $Direction$$Type, arg4: integer, arg5: integer, arg6: integer): $BoundingBox
public static "reorient"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $BlockState
get "type"(): $StructurePieceType
get "mirror"(): $Mirror
get "locatorPosition"(): $BlockPos
get "rotation"(): $Rotation
set "orientation"(value: $Direction$$Type)
get "orientation"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePiece$$Type = ($StructurePiece);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePiece$$Original = $StructurePiece;}
declare module "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerConfig" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$SpawnData, $SpawnData$$Type} from "net.minecraft.world.level.SpawnData"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$SimpleWeightedRandomList, $SimpleWeightedRandomList$$Type} from "net.minecraft.util.random.SimpleWeightedRandomList"
import {$Record} from "java.lang.Record"

export class $TrialSpawnerConfig extends $Record {
static readonly "CODEC": $Codec<($TrialSpawnerConfig)>
static readonly "DEFAULT": $TrialSpawnerConfig

constructor(arg0: integer, arg1: float, arg2: float, arg3: float, arg4: float, arg5: integer, arg6: $SimpleWeightedRandomList$$Type<($SpawnData$$Type)>, arg7: $SimpleWeightedRandomList$$Type<($ResourceKey$$Type<($LootTable$$Type)>)>, arg8: $ResourceKey$$Type<($LootTable)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "spawnRange"(): integer
public "ticksBetweenItemSpawners"(): long
public "spawnPotentialsDefinition"(): $SimpleWeightedRandomList<($SpawnData)>
public "lootTablesToEject"(): $SimpleWeightedRandomList<($ResourceKey<($LootTable)>)>
public "ticksBetweenSpawn"(): integer
public "totalMobs"(): float
public "simultaneousMobsAddedPerPlayer"(): float
public "calculateTargetSimultaneousMobs"(arg0: integer): integer
public "itemsToDropWhenOminous"(): $ResourceKey<($LootTable)>
public "calculateTargetTotalMobs"(arg0: integer): integer
public "totalMobsAddedPerPlayer"(): float
public "simultaneousMobs"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrialSpawnerConfig$$Type = ({"ticksBetweenSpawn"?: integer, "lootTablesToEject"?: $SimpleWeightedRandomList$$Type<($ResourceKey$$Type<($LootTable$$Type)>)>, "spawnRange"?: integer, "spawnPotentialsDefinition"?: $SimpleWeightedRandomList$$Type<($SpawnData$$Type)>, "simultaneousMobs"?: float, "totalMobsAddedPerPlayer"?: float, "itemsToDropWhenOminous"?: $ResourceKey$$Type<($LootTable)>, "simultaneousMobsAddedPerPlayer"?: float, "totalMobs"?: float}) | ([ticksBetweenSpawn?: integer, lootTablesToEject?: $SimpleWeightedRandomList$$Type<($ResourceKey$$Type<($LootTable$$Type)>)>, spawnRange?: integer, spawnPotentialsDefinition?: $SimpleWeightedRandomList$$Type<($SpawnData$$Type)>, simultaneousMobs?: float, totalMobsAddedPerPlayer?: float, itemsToDropWhenOminous?: $ResourceKey$$Type<($LootTable)>, simultaneousMobsAddedPerPlayer?: float, totalMobs?: float]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrialSpawnerConfig$$Original = $TrialSpawnerConfig;}
declare module "net.minecraft.world.level.chunk.CarvingMask$Mask" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $CarvingMask$Mask$$Interface {

(arg0: integer, arg1: integer, arg2: integer): boolean
}

export class $CarvingMask$Mask implements $CarvingMask$Mask$$Interface {
 "test"(arg0: integer, arg1: integer, arg2: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarvingMask$Mask$$Type = ((arg0: integer, arg1: integer, arg2: integer) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarvingMask$Mask$$Original = $CarvingMask$Mask;}
declare module "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet$Builder" {
import {$LootContextParam$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$LootContextParamSet} from "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet"

export class $LootContextParamSet$Builder {
constructor()

public "build"(): $LootContextParamSet
public "optional"(arg0: $LootContextParam$$Type<(never)>): $LootContextParamSet$Builder
public "required"(arg0: $LootContextParam$$Type<(never)>): $LootContextParamSet$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootContextParamSet$Builder$$Type = ($LootContextParamSet$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootContextParamSet$Builder$$Original = $LootContextParamSet$Builder;}
declare module "net.minecraft.world.level.gameevent.vibrations.VibrationSelector" {
import {$VibrationInfo, $VibrationInfo$$Type} from "net.minecraft.world.level.gameevent.vibrations.VibrationInfo"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Optional, $Optional$$Type} from "java.util.Optional"

export class $VibrationSelector {
static readonly "CODEC": $Codec<($VibrationSelector)>

constructor(arg0: ($VibrationInfo$$Type)?, arg1: long)
constructor()

public "addCandidate"(arg0: $VibrationInfo$$Type, arg1: long): void
public "chosenCandidate"(arg0: long): $Optional<($VibrationInfo)>
public "startOver"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VibrationSelector$$Type = ($VibrationSelector);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VibrationSelector$$Original = $VibrationSelector;}
declare module "net.minecraft.world.level.material.PushReaction" {
import {$Enum} from "java.lang.Enum"

export class $PushReaction extends $Enum<($PushReaction)> {
static readonly "DESTROY": $PushReaction
static readonly "BLOCK": $PushReaction
static readonly "PUSH_ONLY": $PushReaction
static readonly "IGNORE": $PushReaction
static readonly "NORMAL": $PushReaction

public static "values"(): ($PushReaction)[]
public static "valueOf"(arg0: StringJS): $PushReaction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PushReaction$$Type = (("normal") | ("destroy") | ("block") | ("ignore") | ("push_only"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PushReaction$$Original = $PushReaction;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.AlterGroundDecorator" {
import {$TreeDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$TreeDecorator$Context$$Type} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context"
import {$BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$TreeDecoratorType} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecoratorType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $AlterGroundDecorator extends $TreeDecorator {
static readonly "CODEC": $MapCodec<($AlterGroundDecorator)>

constructor(arg0: $BlockStateProvider$$Type)

public "type"(): $TreeDecoratorType<(never)>
public "place"(arg0: $TreeDecorator$Context$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlterGroundDecorator$$Type = ($AlterGroundDecorator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AlterGroundDecorator$$Original = $AlterGroundDecorator;}
declare module "net.minecraft.world.level.block.entity.BrewingStandBlockEntity" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$BaseContainerBlockEntity} from "net.minecraft.world.level.block.entity.BaseContainerBlockEntity"
import {$ContainerData} from "net.minecraft.world.inventory.ContainerData"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LithiumInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumInventory"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WrappedBlockEntityTickInvokerAccessor, $WrappedBlockEntityTickInvokerAccessor$$Type} from "net.caffeinemc.mods.lithium.mixin.world.block_entity_ticking.sleeping.WrappedBlockEntityTickInvokerAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TickingBlockEntity, $TickingBlockEntity$$Type} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$ReferenceArraySet} from "it.unimi.dsi.fastutil.objects.ReferenceArraySet"
import {$WorldlyContainer$$Interface} from "net.minecraft.world.WorldlyContainer"
import {$SetChangedHandlingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SetChangedHandlingBlockEntity"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$SleepingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SleepingBlockEntity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $BrewingStandBlockEntity extends $BaseContainerBlockEntity implements $WorldlyContainer$$Interface, $LithiumInventory$$Interface, $InventoryChangeTracker$$Interface, $SleepingBlockEntity$$Interface, $SetChangedHandlingBlockEntity$$Interface {
static readonly "DATA_BREW_TIME": integer
 "inventoryChangeListeners": $ReferenceArraySet
readonly "dataAccess": $ContainerData
static readonly "DATA_FUEL_USES": integer
 "level": $Level
 "fuel": integer
 "brewTime": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventoryHandlingTypeListeners": $ReferenceArraySet
static readonly "FUEL_USES": integer
 "remove": boolean
 "worldPosition": $BlockPos
 "lockKey": $LockCode
 "hasComparators": byte
static readonly "NUM_DATA_VALUES": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "getDefaultName"(): $Component
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getContainerSize"(): integer
public "getItems"(): $NonNullList<($ItemStack)>
public "lithium$setTickWrapper"(arg0: $WrappedBlockEntityTickInvokerAccessor$$Type): void
public "lithium$getSleepingTicker"(): $TickingBlockEntity
public "canTakeItemThroughFace"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "lithium$getTickWrapper"(): $WrappedBlockEntityTickInvokerAccessor
public "canPlaceItemThroughFace"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "lithium$setSleepingTicker"(arg0: $TickingBlockEntity$$Type): void
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BrewingStandBlockEntity$$Type): void
public "setItems"(arg0: $NonNullList$$Type<($ItemStack$$Type)>): void
public "lithium$handleSetChanged"(): void
public "getInventoryLithium"(): $NonNullList
public "setInventoryLithium"(arg0: $NonNullList$$Type): void
public "getSlotsForFace"(arg0: $Direction$$Type): (integer)[]
public "createMenu"(arg0: integer, arg1: $Inventory$$Type): $AbstractContainerMenu
public "generateLootLithium"(): void
public "stopListenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "listenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "listenForContentChangesOnce"(arg0: $LithiumStackList$$Type, arg1: $InventoryChangeListener$$Type): void
public "isSleeping"(): boolean
public "setTicker"(arg0: $TickingBlockEntity$$Type): void
public "wakeUpNow"(): void
public "sleepOnlyCurrentTick"(): void
public "lithium$startSleeping"(): boolean
public "setChanged"(): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public static "tryClear"(arg0: any): void
get "defaultName"(): $Component
get "containerSize"(): integer
get "items"(): $NonNullList<($ItemStack)>
set "items"(value: $NonNullList$$Type<($ItemStack$$Type)>)
get "inventoryLithium"(): $NonNullList
set "inventoryLithium"(value: $NonNullList$$Type)
get "sleeping"(): boolean
set "ticker"(value: $TickingBlockEntity$$Type)
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BrewingStandBlockEntity$$Type = ($BrewingStandBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BrewingStandBlockEntity$$Original = $BrewingStandBlockEntity;}
declare module "net.minecraft.world.level.block.entity.vault.VaultSharedData" {
import {$VaultServerData$$Type} from "net.minecraft.world.level.block.entity.vault.VaultServerData"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Codec} from "com.mojang.serialization.Codec"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Set, $Set$$Type} from "java.util.Set"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$VaultConfig$$Type} from "net.minecraft.world.level.block.entity.vault.VaultConfig"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $VaultSharedData {
static "CODEC": $Codec<($VaultSharedData)>
 "isDirty": boolean
static readonly "TAG_NAME": StringJS

constructor(arg0: $ItemStack$$Type, arg1: $Set$$Type<($UUID$$Type)>, arg2: double)
constructor()

public "set"(arg0: $VaultSharedData$$Type): void
public "setDisplayItem"(arg0: $ItemStack$$Type): void
public "getDisplayItem"(): $ItemStack
public "hasDisplayItem"(): boolean
public "hasConnectedPlayers"(): boolean
public "connectedParticlesRange"(): double
public "getConnectedPlayers"(): $Set<($UUID)>
public "updateConnectedPlayersWithinRange"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $VaultServerData$$Type, arg3: $VaultConfig$$Type, arg4: double): void
set "displayItem"(value: $ItemStack$$Type)
get "displayItem"(): $ItemStack
get "connectedPlayers"(): $Set<($UUID)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VaultSharedData$$Type = ($VaultSharedData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VaultSharedData$$Original = $VaultSharedData;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment" {
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $FoliagePlacer$FoliageAttachment {
constructor(arg0: $BlockPos$$Type, arg1: integer, arg2: boolean)

public "pos"(): $BlockPos
public "doubleTrunk"(): boolean
public "radiusOffset"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoliagePlacer$FoliageAttachment$$Type = ($FoliagePlacer$FoliageAttachment);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FoliagePlacer$FoliageAttachment$$Original = $FoliagePlacer$FoliageAttachment;}
declare module "net.minecraft.world.level.block.SoundType" {
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"

export class $SoundType {
static readonly "CANDLE": $SoundType
static readonly "MUD_BRICKS": $SoundType
static readonly "HANGING_ROOTS": $SoundType
static readonly "NYLIUM": $SoundType
static readonly "COPPER_GRATE": $SoundType
static readonly "NETHERITE_BLOCK": $SoundType
static readonly "PACKED_MUD": $SoundType
static readonly "MOSS_CARPET": $SoundType
static readonly "SMALL_AMETHYST_BUD": $SoundType
static readonly "ANVIL": $SoundType
static readonly "CHERRY_SAPLING": $SoundType
static readonly "ROOTS": $SoundType
static readonly "WART_BLOCK": $SoundType
static readonly "SCULK_VEIN": $SoundType
static readonly "WET_SPONGE": $SoundType
readonly "pitch": float
static readonly "LARGE_AMETHYST_BUD": $SoundType
static readonly "FUNGUS": $SoundType
static readonly "TUFF": $SoundType
static readonly "BAMBOO_SAPLING": $SoundType
static readonly "DEEPSLATE": $SoundType
static readonly "NETHER_GOLD_ORE": $SoundType
static readonly "TWISTING_VINES": $SoundType
static readonly "PINK_PETALS": $SoundType
static readonly "SLIME_BLOCK": $SoundType
static readonly "SCULK_SENSOR": $SoundType
static readonly "HONEY_BLOCK": $SoundType
static readonly "TUFF_BRICKS": $SoundType
static readonly "LILY_PAD": $SoundType
static readonly "AZALEA": $SoundType
static readonly "MEDIUM_AMETHYST_BUD": $SoundType
static readonly "SMALL_DRIPLEAF": $SoundType
static readonly "LADDER": $SoundType
static readonly "CHISELED_BOOKSHELF": $SoundType
static readonly "DECORATED_POT": $SoundType
static readonly "BASALT": $SoundType
static readonly "GILDED_BLACKSTONE": $SoundType
static readonly "POINTED_DRIPSTONE": $SoundType
static readonly "GLASS": $SoundType
static readonly "POLISHED_DEEPSLATE": $SoundType
static readonly "CHERRY_WOOD_HANGING_SIGN": $SoundType
static readonly "ROOTED_DIRT": $SoundType
static readonly "DEEPSLATE_BRICKS": $SoundType
static readonly "SOUL_SAND": $SoundType
static readonly "AMETHYST": $SoundType
static readonly "SCULK_CATALYST": $SoundType
static readonly "BAMBOO_WOOD": $SoundType
static readonly "CORAL_BLOCK": $SoundType
static readonly "SCULK_SHRIEKER": $SoundType
static readonly "SCAFFOLDING": $SoundType
static readonly "CHAIN": $SoundType
static readonly "TRIAL_SPAWNER": $SoundType
static readonly "SOUL_SOIL": $SoundType
static readonly "CALCITE": $SoundType
static readonly "VINE": $SoundType
static readonly "DRIPSTONE_BLOCK": $SoundType
static readonly "WOOD": $SoundType
static readonly "CHERRY_WOOD": $SoundType
static readonly "NETHER_SPROUTS": $SoundType
static readonly "SUSPICIOUS_SAND": $SoundType
static readonly "SUSPICIOUS_GRAVEL": $SoundType
static readonly "FROGLIGHT": $SoundType
static readonly "CROP": $SoundType
static readonly "DECORATED_POT_CRACKED": $SoundType
static readonly "NETHER_WOOD": $SoundType
static readonly "GRASS": $SoundType
static readonly "GLOW_LICHEN": $SoundType
static readonly "WOOL": $SoundType
static readonly "MUD": $SoundType
static readonly "SAND": $SoundType
static readonly "BAMBOO": $SoundType
static readonly "SNOW": $SoundType
static readonly "MOSS": $SoundType
static readonly "WEEPING_VINES": $SoundType
static readonly "CHERRY_LEAVES": $SoundType
static readonly "BONE_BLOCK": $SoundType
static readonly "SPORE_BLOSSOM": $SoundType
readonly "volume": float
static readonly "NETHER_WART": $SoundType
static readonly "FLOWERING_AZALEA": $SoundType
static readonly "DEEPSLATE_TILES": $SoundType
static readonly "METAL": $SoundType
static readonly "AZALEA_LEAVES": $SoundType
static readonly "SHROOMLIGHT": $SoundType
static readonly "NETHER_ORE": $SoundType
static readonly "HANGING_SIGN": $SoundType
static readonly "BAMBOO_WOOD_HANGING_SIGN": $SoundType
static readonly "AMETHYST_CLUSTER": $SoundType
static readonly "VAULT": $SoundType
static readonly "COPPER": $SoundType
static readonly "GRAVEL": $SoundType
static readonly "MANGROVE_ROOTS": $SoundType
static readonly "LANTERN": $SoundType
static readonly "COBWEB": $SoundType
static readonly "POWDER_SNOW": $SoundType
static readonly "ANCIENT_DEBRIS": $SoundType
static readonly "EMPTY": $SoundType
static readonly "NETHER_BRICKS": $SoundType
static readonly "MUDDY_MANGROVE_ROOTS": $SoundType
static readonly "BIG_DRIPLEAF": $SoundType
static readonly "HEAVY_CORE": $SoundType
static readonly "POLISHED_TUFF": $SoundType
static readonly "HARD_CROP": $SoundType
static readonly "LODESTONE": $SoundType
static readonly "STEM": $SoundType
static readonly "NETHER_WOOD_HANGING_SIGN": $SoundType
static readonly "CAVE_VINES": $SoundType
static readonly "NETHERRACK": $SoundType
static readonly "WET_GRASS": $SoundType
static readonly "SPONGE": $SoundType
static readonly "COPPER_BULB": $SoundType
static readonly "SCULK": $SoundType
static readonly "FROGSPAWN": $SoundType
static readonly "SWEET_BERRY_BUSH": $SoundType
static readonly "STONE": $SoundType

/**
 * 
 * @deprecated
 */
constructor(arg0: float, arg1: float, arg2: $SoundEvent$$Type, arg3: $SoundEvent$$Type, arg4: $SoundEvent$$Type, arg5: $SoundEvent$$Type, arg6: $SoundEvent$$Type)

public "getPlaceSound"(): $SoundEvent
public "getStepSound"(): $SoundEvent
public "getBreakSound"(): $SoundEvent
public "getHitSound"(): $SoundEvent
public "getPitch"(): float
public "getVolume"(): float
public "getFallSound"(): $SoundEvent
get "placeSound"(): $SoundEvent
get "stepSound"(): $SoundEvent
get "breakSound"(): $SoundEvent
get "hitSound"(): $SoundEvent
get "fallSound"(): $SoundEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundType$$Type = (StringJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoundType$$Original = $SoundType;}
declare module "net.minecraft.world.level.chunk.StructureAccess" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Structure, $Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$StructureStart, $StructureStart$$Type} from "net.minecraft.world.level.levelgen.structure.StructureStart"
import {$LongSet, $LongSet$$Type} from "it.unimi.dsi.fastutil.longs.LongSet"

export interface $StructureAccess$$Interface {
get "allReferences"(): $Map<($Structure), ($LongSet)>
set "allReferences"(value: $Map$$Type<($Structure$$Type), ($LongSet$$Type)>)
}

export class $StructureAccess implements $StructureAccess$$Interface {
 "getReferencesForStructure"(arg0: $Structure$$Type): $LongSet
 "addReferenceForStructure"(arg0: $Structure$$Type, arg1: long): void
 "setStartForStructure"(arg0: $Structure$$Type, arg1: $StructureStart$$Type): void
 "getStartForStructure"(arg0: $Structure$$Type): $StructureStart
 "getAllReferences"(): $Map<($Structure), ($LongSet)>
 "setAllReferences"(arg0: $Map$$Type<($Structure$$Type), ($LongSet$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureAccess$$Type = ($StructureAccess);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureAccess$$Original = $StructureAccess;}
declare module "net.minecraft.world.level.block.state.properties.Property$Value" {
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"
import {$Record} from "java.lang.Record"

export class $Property$Value<T extends $Comparable<(object)>> extends $Record {
constructor(arg0: $Property$$Type<(T)>, arg1: T)

public "value"(): T
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "property"(): $Property<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Property$Value$$Type<T> = ({"property"?: $Property$$Type<(T)>, "value"?: T}) | ([property?: $Property$$Type<(T)>, value?: T]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Property$Value$$Original<T> = $Property$Value<(T)>;}
declare module "net.minecraft.world.level.ItemLike" {
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export interface $ItemLike$$Interface {

(): $Item$$Type
}

export class $ItemLike implements $ItemLike$$Interface {
 "asItem"(): $Item
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemLike$$Type = ($Item$$Type) | (() => $Item$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemLike$$Original = $ItemLike;}
declare module "net.minecraft.world.level.GameRules$IntegerValue" {
import {$GameRulesIntRuleAccessor$$Interface} from "net.fabricmc.fabric.mixin.gamerule.GameRulesIntRuleAccessor"
import {$CommandContext$$Type} from "com.mojang.brigadier.context.CommandContext"
import {$GameRules$Type, $GameRules$Type$$Type} from "net.minecraft.world.level.GameRules$Type"
import {$GameRules$Value, $GameRules$Value$$Type} from "net.minecraft.world.level.GameRules$Value"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"
import {$MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export class $GameRules$IntegerValue extends $GameRules$Value<($GameRules$IntegerValue)> implements $GameRulesIntRuleAccessor$$Interface {
readonly "type": $GameRules$Type<(T)>

constructor(arg0: $GameRules$Type$$Type<($GameRules$IntegerValue$$Type)>, arg1: integer)

public "get"(): integer
public "getValue"(): integer
public "set"(arg0: integer, arg1: $MinecraftServer$$Type): void
public "setValue"(arg0: integer): void
public "copy"(): $GameRules$IntegerValue
public static "create"(arg0: integer, arg1: $BiConsumer$$Type<($MinecraftServer), ($GameRules$IntegerValue)>): $GameRules$Type<($GameRules$IntegerValue)>
public static "create"(arg0: integer): $GameRules$Type<($GameRules$IntegerValue)>
public static "create"(arg0: integer, arg1: integer, arg2: integer, arg3: $BiConsumer$$Type<($MinecraftServer), ($GameRules$IntegerValue)>): $GameRules$Type<($GameRules$IntegerValue)>
public "setFrom"(arg0: $GameRules$Value$$Type, arg1: $MinecraftServer$$Type): void
public "setFrom"(arg0: $GameRules$IntegerValue$$Type, arg1: $MinecraftServer$$Type): void
public "serialize"(): StringJS
public "deserialize"(arg0: StringJS): void
public "getSelf"(): $GameRules$IntegerValue
public "updateFromArgument"(arg0: $CommandContext$$Type<($CommandSourceStack$$Type)>, arg1: StringJS): void
public "getCommandResult"(): integer
public "tryDeserialize"(arg0: StringJS): boolean
get "value"(): integer
set "value"(value: integer)
get "self"(): $GameRules$IntegerValue
get "commandResult"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$IntegerValue$$Type = ($GameRules$IntegerValue);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$IntegerValue$$Original = $GameRules$IntegerValue;}
declare module "net.minecraft.world.level.chunk.storage.RegionStorageInfo" {
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Record} from "java.lang.Record"

export class $RegionStorageInfo extends $Record {
constructor(arg0: StringJS, arg1: $ResourceKey$$Type<($Level)>, arg2: StringJS)

public "type"(): StringJS
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "level"(): StringJS
public "dimension"(): $ResourceKey<($Level)>
public "withTypeSuffix"(arg0: StringJS): $RegionStorageInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegionStorageInfo$$Type = ({"level"?: StringJS, "type"?: StringJS, "dimension"?: $ResourceKey$$Type<($Level)>}) | ([level?: StringJS, type?: StringJS, dimension?: $ResourceKey$$Type<($Level)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegionStorageInfo$$Original = $RegionStorageInfo;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor" {
import {$ServerLevelAccessor$$Type} from "net.minecraft.world.level.ServerLevelAccessor"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$StructureTemplate$StructureEntityInfo, $StructureTemplate$StructureEntityInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureEntityInfo"
import {$List, $List$$Type} from "java.util.List"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$StructureProcessorType} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessorType"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$StructureTemplate$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate"
import {$StructurePlaceSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"

export class $StructureProcessor {
constructor()

public "getType"(): $StructureProcessorType<(never)>
public "process"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructureTemplate$StructureBlockInfo$$Type, arg4: $StructureTemplate$StructureBlockInfo$$Type, arg5: $StructurePlaceSettings$$Type, arg6: $StructureTemplate$$Type): $StructureTemplate$StructureBlockInfo
/**
 * 
 * @deprecated
 */
public "processBlock"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructureTemplate$StructureBlockInfo$$Type, arg4: $StructureTemplate$StructureBlockInfo$$Type, arg5: $StructurePlaceSettings$$Type): $StructureTemplate$StructureBlockInfo
public "processEntity"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $StructureTemplate$StructureEntityInfo$$Type, arg3: $StructureTemplate$StructureEntityInfo$$Type, arg4: $StructurePlaceSettings$$Type, arg5: $StructureTemplate$$Type): $StructureTemplate$StructureEntityInfo
public "finalizeProcessing"(arg0: $ServerLevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $List$$Type<($StructureTemplate$StructureBlockInfo$$Type)>, arg4: $List$$Type<($StructureTemplate$StructureBlockInfo$$Type)>, arg5: $StructurePlaceSettings$$Type): $List<($StructureTemplate$StructureBlockInfo)>
get "type"(): $StructureProcessorType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureProcessor$$Type = ($StructureProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureProcessor$$Original = $StructureProcessor;}
declare module "net.minecraft.world.level.block.Blocks" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$ToIntFunction} from "java.util.function.ToIntFunction"
import {$MapColor$$Type} from "net.minecraft.world.level.material.MapColor"
import {$SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $Blocks {
static readonly "GREEN_CONCRETE_POWDER": $Block
static readonly "PIGLIN_HEAD": $Block
static readonly "TUBE_CORAL_WALL_FAN": $Block
static readonly "PURPLE_CARPET": $Block
static readonly "SMALL_AMETHYST_BUD": $Block
static readonly "DEAD_TUBE_CORAL": $Block
static readonly "JUNGLE_PRESSURE_PLATE": $Block
static readonly "GREEN_GLAZED_TERRACOTTA": $Block
static readonly "EXPOSED_CUT_COPPER": $Block
static readonly "WATER_CAULDRON": $Block
static readonly "POTTED_AZALEA": $Block
static readonly "TRAPPED_CHEST": $Block
static readonly "STONE_BRICK_STAIRS": $Block
static readonly "SANDSTONE_WALL": $Block
static readonly "WATER": $Block
static readonly "MELON_STEM": $Block
static readonly "OAK_WOOD": $Block
static readonly "WHITE_TULIP": $Block
static readonly "GRAY_STAINED_GLASS": $Block
static readonly "BLUE_ORCHID": $Block
static readonly "SPRUCE_DOOR": $Block
static readonly "STRIPPED_BIRCH_LOG": $Block
static readonly "LIGHT_BLUE_TERRACOTTA": $Block
static readonly "ZOMBIE_HEAD": $Block
static readonly "BROWN_WOOL": $Block
static readonly "GRANITE_WALL": $Block
static readonly "SHORT_GRASS": $Block
static readonly "ORANGE_SHULKER_BOX": $Block
static readonly "GREEN_CANDLE": $Block
static readonly "CRACKED_STONE_BRICKS": $Block
static readonly "BRICK_SLAB": $Block
static readonly "CYAN_CANDLE_CAKE": $Block
static readonly "BLUE_CANDLE": $Block
static readonly "LAPIS_BLOCK": $Block
static readonly "PURPLE_BED": $Block
static readonly "JUNGLE_SLAB": $Block
static readonly "END_STONE_BRICK_STAIRS": $Block
static readonly "JUNGLE_PLANKS": $Block
static readonly "TURTLE_EGG": $Block
static readonly "WHITE_CANDLE": $Block
static readonly "VERDANT_FROGLIGHT": $Block
static readonly "COBBLESTONE": $Block
static readonly "TUBE_CORAL": $Block
static readonly "GILDED_BLACKSTONE": $Block
static readonly "CYAN_STAINED_GLASS_PANE": $Block
static readonly "WAXED_COPPER_BULB": $Block
static readonly "SMOOTH_RED_SANDSTONE_SLAB": $Block
static readonly "CHISELED_SANDSTONE": $Block
static readonly "LIGHT_BLUE_SHULKER_BOX": $Block
static readonly "NETHER_BRICK_WALL": $Block
static readonly "RED_WOOL": $Block
static readonly "WAXED_WEATHERED_CUT_COPPER_STAIRS": $Block
static readonly "COMMAND_BLOCK": $Block
static readonly "ROOTED_DIRT": $Block
static readonly "PRISMARINE_STAIRS": $Block
static readonly "DEEPSLATE_TILE_STAIRS": $Block
static readonly "POLISHED_ANDESITE": $Block
static readonly "CRAFTING_TABLE": $Block
static readonly "CORNFLOWER": $Block
static readonly "SCULK_SHRIEKER": $Block
static readonly "RED_WALL_BANNER": $Block
static readonly "INFESTED_COBBLESTONE": $Block
static readonly "DIORITE": $Block
static readonly "LIGHT_BLUE_CONCRETE": $Block
static readonly "POLISHED_ANDESITE_SLAB": $Block
static readonly "POLISHED_BLACKSTONE_BUTTON": $Block
static readonly "SPRUCE_WALL_SIGN": $Block
static readonly "MOSSY_STONE_BRICK_WALL": $Block
static readonly "POLISHED_DEEPSLATE_WALL": $Block
static readonly "WARPED_SLAB": $Block
static readonly "STONE_BRICK_WALL": $Block
static readonly "DARK_OAK_WOOD": $Block
static readonly "JUNGLE_WALL_SIGN": $Block
static readonly "CRIMSON_HYPHAE": $Block
static readonly "WAXED_EXPOSED_CUT_COPPER_STAIRS": $Block
static readonly "JUKEBOX": $Block
static readonly "POTTED_RED_MUSHROOM": $Block
static readonly "DARK_OAK_BUTTON": $Block
static readonly "POTTED_ORANGE_TULIP": $Block
static readonly "CRACKED_DEEPSLATE_BRICKS": $Block
static readonly "CHERRY_PRESSURE_PLATE": $Block
static readonly "WARPED_STAIRS": $Block
static readonly "MANGROVE_PLANKS": $Block
static readonly "DEEPSLATE_TILE_WALL": $Block
static readonly "BLACK_CONCRETE_POWDER": $Block
static readonly "DARK_OAK_PRESSURE_PLATE": $Block
static readonly "STRIPPED_SPRUCE_WOOD": $Block
static readonly "MANGROVE_LOG": $Block
static readonly "OAK_BUTTON": $Block
static readonly "GRANITE": $Block
static readonly "SAND": $Block
static readonly "LIGHT": $Block
static readonly "OAK_WALL_SIGN": $Block
static readonly "BROWN_TERRACOTTA": $Block
static readonly "ORANGE_STAINED_GLASS_PANE": $Block
static readonly "REINFORCED_DEEPSLATE": $Block
static readonly "WHITE_WALL_BANNER": $Block
static readonly "NETHER_WART": $Block
static readonly "YELLOW_CARPET": $Block
static readonly "LILY_OF_THE_VALLEY": $Block
static readonly "DEEPSLATE_TILES": $Block
static readonly "HAY_BLOCK": $Block
static readonly "LECTERN": $Block
static readonly "RAW_COPPER_BLOCK": $Block
static readonly "CRIMSON_FENCE_GATE": $Block
static readonly "BLACK_STAINED_GLASS_PANE": $Block
static readonly "ALLIUM": $Block
static readonly "COBBLESTONE_STAIRS": $Block
static readonly "TUFF_BRICK_WALL": $Block
static readonly "CRYING_OBSIDIAN": $Block
static readonly "DETECTOR_RAIL": $Block
static readonly "SOUL_CAMPFIRE": $Block
static readonly "CUT_SANDSTONE_SLAB": $Block
static readonly "CREEPER_WALL_HEAD": $Block
static readonly "AMETHYST_CLUSTER": $Block
static readonly "PURPLE_STAINED_GLASS": $Block
static readonly "BROWN_CONCRETE_POWDER": $Block
static readonly "TUFF_STAIRS": $Block
static readonly "MANGROVE_ROOTS": $Block
static readonly "TERRACOTTA": $Block
static readonly "REDSTONE_WIRE": $Block
static readonly "YELLOW_WALL_BANNER": $Block
static readonly "END_STONE_BRICKS": $Block
static readonly "COARSE_DIRT": $Block
static readonly "LIGHT_GRAY_GLAZED_TERRACOTTA": $Block
static readonly "GLOWSTONE": $Block
static readonly "MANGROVE_HANGING_SIGN": $Block
static readonly "DIORITE_SLAB": $Block
static readonly "ANCIENT_DEBRIS": $Block
static readonly "WAXED_EXPOSED_COPPER_TRAPDOOR": $Block
static readonly "PINK_SHULKER_BOX": $Block
static readonly "CARROTS": $Block
static readonly "CRIMSON_DOOR": $Block
static readonly "GLASS_PANE": $Block
static readonly "POLISHED_TUFF": $Block
static readonly "DIAMOND_ORE": $Block
static readonly "CHIPPED_ANVIL": $Block
static readonly "DEEPSLATE_COPPER_ORE": $Block
static readonly "OAK_LEAVES": $Block
static readonly "CYAN_BANNER": $Block
static readonly "BAMBOO_STAIRS": $Block
static readonly "MAGENTA_BED": $Block
static readonly "WAXED_OXIDIZED_CUT_COPPER_SLAB": $Block
static readonly "SPONGE": $Block
static readonly "RED_BED": $Block
static readonly "SCULK": $Block
static readonly "POTTED_BROWN_MUSHROOM": $Block
static readonly "WARPED_WALL_SIGN": $Block
static readonly "MANGROVE_TRAPDOOR": $Block
static readonly "CANDLE": $Block
static readonly "STRIPPED_SPRUCE_LOG": $Block
static readonly "WAXED_EXPOSED_COPPER_DOOR": $Block
static readonly "COPPER_GRATE": $Block
static readonly "CHORUS_PLANT": $Block
static readonly "ANDESITE_STAIRS": $Block
static readonly "WAXED_WEATHERED_COPPER_BULB": $Block
static readonly "SPRUCE_WALL_HANGING_SIGN": $Block
static readonly "BRICKS": $Block
static readonly "PISTON_HEAD": $Block
static readonly "CRIMSON_WALL_SIGN": $Block
static readonly "RED_NETHER_BRICK_WALL": $Block
static readonly "WET_SPONGE": $Block
static readonly "STRUCTURE_BLOCK": $Block
static readonly "CHERRY_BUTTON": $Block
static readonly "RED_CARPET": $Block
static readonly "ENCHANTING_TABLE": $Block
static readonly "YELLOW_STAINED_GLASS": $Block
static readonly "SOUL_FIRE": $Block
static readonly "DEEPSLATE": $Block
static readonly "RED_BANNER": $Block
static readonly "BLUE_STAINED_GLASS_PANE": $Block
static readonly "SPRUCE_LOG": $Block
static readonly "COPPER_TRAPDOOR": $Block
static readonly "POTTED_RED_TULIP": $Block
static readonly "BIRCH_FENCE": $Block
static readonly "SOUL_LANTERN": $Block
static readonly "POLISHED_BLACKSTONE_BRICKS": $Block
static readonly "POTTED_AZURE_BLUET": $Block
static readonly "WHITE_STAINED_GLASS_PANE": $Block
static readonly "LIME_STAINED_GLASS": $Block
static readonly "DIORITE_WALL": $Block
static readonly "MAGMA_BLOCK": $Block
static readonly "DARK_OAK_SIGN": $Block
static readonly "POLISHED_DEEPSLATE": $Block
static readonly "BLUE_CONCRETE_POWDER": $Block
static readonly "CHORUS_FLOWER": $Block
static readonly "BLACK_GLAZED_TERRACOTTA": $Block
static readonly "RED_STAINED_GLASS": $Block
static readonly "BARRIER": $Block
static readonly "WARPED_FENCE_GATE": $Block
static readonly "DEEPSLATE_REDSTONE_ORE": $Block
static readonly "BAMBOO_MOSAIC_STAIRS": $Block
static readonly "DEEPSLATE_BRICK_STAIRS": $Block
static readonly "GRAY_CANDLE": $Block
static readonly "FARMLAND": $Block
static readonly "TRIAL_SPAWNER": $Block
static readonly "SKELETON_WALL_SKULL": $Block
static readonly "PRISMARINE_BRICKS": $Block
static readonly "SMOOTH_BASALT": $Block
static readonly "DARK_OAK_LOG": $Block
static readonly "BRAIN_CORAL_FAN": $Block
static readonly "WEATHERED_CUT_COPPER_SLAB": $Block
static readonly "ACACIA_HANGING_SIGN": $Block
static readonly "MAGENTA_SHULKER_BOX": $Block
static readonly "QUARTZ_PILLAR": $Block
static readonly "WARPED_TRAPDOOR": $Block
static readonly "BROWN_CANDLE_CAKE": $Block
static readonly "STRIPPED_BAMBOO_BLOCK": $Block
static readonly "PURPLE_WALL_BANNER": $Block
static readonly "REDSTONE_BLOCK": $Block
static readonly "COBBLED_DEEPSLATE_WALL": $Block
static readonly "DEAD_BUBBLE_CORAL_WALL_FAN": $Block
static readonly "CHISELED_POLISHED_BLACKSTONE": $Block
static readonly "BIRCH_SLAB": $Block
static readonly "EXPOSED_CHISELED_COPPER": $Block
static readonly "LIME_SHULKER_BOX": $Block
static readonly "QUARTZ_SLAB": $Block
static readonly "OXIDIZED_COPPER_GRATE": $Block
static readonly "QUARTZ_BLOCK": $Block
static readonly "SNOW": $Block
static readonly "SUGAR_CANE": $Block
static readonly "BRAIN_CORAL_WALL_FAN": $Block
static readonly "ACACIA_FENCE": $Block
static readonly "DARK_OAK_FENCE": $Block
static readonly "HORN_CORAL": $Block
static readonly "TUBE_CORAL_FAN": $Block
static readonly "POTTED_CHERRY_SAPLING": $Block
static readonly "MOSSY_COBBLESTONE": $Block
static readonly "DAYLIGHT_DETECTOR": $Block
static readonly "WARPED_FENCE": $Block
static readonly "POLISHED_TUFF_WALL": $Block
static readonly "BUBBLE_CORAL": $Block
static readonly "JUNGLE_STAIRS": $Block
static readonly "CYAN_CARPET": $Block
static readonly "OXIDIZED_COPPER_DOOR": $Block
static readonly "OBSERVER": $Block
static readonly "DEEPSLATE_DIAMOND_ORE": $Block
static readonly "AMETHYST_BLOCK": $Block
static readonly "SPRUCE_TRAPDOOR": $Block
static readonly "CHERRY_STAIRS": $Block
static readonly "CUT_COPPER": $Block
static readonly "BLAST_FURNACE": $Block
static readonly "OBSIDIAN": $Block
static readonly "RED_SANDSTONE_SLAB": $Block
static readonly "FIRE_CORAL_FAN": $Block
static readonly "AZURE_BLUET": $Block
static readonly "BAMBOO_WALL_SIGN": $Block
static readonly "PURPLE_STAINED_GLASS_PANE": $Block
static readonly "LIME_GLAZED_TERRACOTTA": $Block
static readonly "CARTOGRAPHY_TABLE": $Block
static readonly "ORANGE_CANDLE": $Block
static readonly "WITHER_ROSE": $Block
static readonly "PISTON": $Block
static readonly "DEAD_BRAIN_CORAL_FAN": $Block
static readonly "BLACK_CANDLE": $Block
static readonly "YELLOW_BANNER": $Block
static readonly "CUT_RED_SANDSTONE": $Block
static readonly "BIRCH_SAPLING": $Block
static readonly "LIME_CONCRETE": $Block
static readonly "BEETROOTS": $Block
static readonly "PURPUR_SLAB": $Block
static readonly "PURPLE_BANNER": $Block
static readonly "PURPLE_CONCRETE_POWDER": $Block
static readonly "BIRCH_LOG": $Block
static readonly "DEEPSLATE_BRICK_WALL": $Block
static readonly "DARK_PRISMARINE_SLAB": $Block
static readonly "ACACIA_PLANKS": $Block
static readonly "MYCELIUM": $Block
static readonly "RED_SANDSTONE": $Block
static readonly "BROWN_CONCRETE": $Block
static readonly "PRISMARINE_BRICK_STAIRS": $Block
static readonly "CAVE_VINES": $Block
static readonly "STONE_SLAB": $Block
static readonly "LIME_WALL_BANNER": $Block
static readonly "MANGROVE_WALL_SIGN": $Block
static readonly "BIRCH_LEAVES": $Block
static readonly "CHERRY_WALL_HANGING_SIGN": $Block
static readonly "BLUE_CANDLE_CAKE": $Block
static readonly "BAMBOO_FENCE_GATE": $Block
static readonly "DEEPSLATE_GOLD_ORE": $Block
static readonly "NETHER_BRICK_FENCE": $Block
static readonly "BROWN_MUSHROOM": $Block
static readonly "TUFF_BRICK_SLAB": $Block
static readonly "CYAN_SHULKER_BOX": $Block
static readonly "POLISHED_BLACKSTONE_SLAB": $Block
static readonly "WAXED_EXPOSED_CHISELED_COPPER": $Block
static readonly "JUNGLE_WALL_HANGING_SIGN": $Block
static readonly "NETHERITE_BLOCK": $Block
static readonly "ACACIA_PRESSURE_PLATE": $Block
static readonly "RED_SAND": $Block
static readonly "PACKED_MUD": $Block
static readonly "POLISHED_GRANITE_STAIRS": $Block
static readonly "MAGENTA_BANNER": $Block
static readonly "QUARTZ_STAIRS": $Block
static readonly "DRIED_KELP_BLOCK": $Block
static readonly "SCULK_VEIN": $Block
static readonly "BREWING_STAND": $Block
static readonly "CACTUS": $Block
static readonly "CAKE": $Block
static readonly "SMOOTH_QUARTZ_SLAB": $Block
static readonly "STRIPPED_ACACIA_WOOD": $Block
static readonly "BAMBOO_MOSAIC_SLAB": $Block
static readonly "LIGHT_GRAY_BANNER": $Block
static readonly "GREEN_BANNER": $Block
static readonly "SPRUCE_SIGN": $Block
static readonly "BLUE_STAINED_GLASS": $Block
static readonly "CHISELED_TUFF_BRICKS": $Block
static readonly "STRIPPED_BIRCH_WOOD": $Block
static readonly "SLIME_BLOCK": $Block
static readonly "RED_MUSHROOM": $Block
static readonly "BAMBOO_FENCE": $Block
static readonly "SPRUCE_SAPLING": $Block
static readonly "LIGHT_BLUE_STAINED_GLASS": $Block
static readonly "EXPOSED_COPPER_DOOR": $Block
static readonly "POLISHED_GRANITE_SLAB": $Block
static readonly "SMOOTH_RED_SANDSTONE_STAIRS": $Block
static readonly "WAXED_COPPER_TRAPDOOR": $Block
static readonly "BRAIN_CORAL": $Block
static readonly "COMPARATOR": $Block
static readonly "REDSTONE_ORE": $Block
static readonly "STRIPPED_CRIMSON_HYPHAE": $Block
static readonly "DRAGON_WALL_HEAD": $Block
static readonly "PINK_CANDLE": $Block
static readonly "DEAD_FIRE_CORAL_BLOCK": $Block
static readonly "MAGENTA_CANDLE_CAKE": $Block
static readonly "WITHER_SKELETON_SKULL": $Block
static readonly "RED_SANDSTONE_WALL": $Block
static readonly "LIGHT_GRAY_TERRACOTTA": $Block
static readonly "LIGHT_BLUE_STAINED_GLASS_PANE": $Block
static readonly "GRASS_BLOCK": $Block
static readonly "EXPOSED_COPPER_TRAPDOOR": $Block
static readonly "MAGENTA_STAINED_GLASS": $Block
static readonly "CRIMSON_PRESSURE_PLATE": $Block
static readonly "COAL_ORE": $Block
static readonly "DEEPSLATE_BRICKS": $Block
static readonly "WAXED_EXPOSED_COPPER_BULB": $Block
static readonly "ICE": $Block
static readonly "PURPLE_SHULKER_BOX": $Block
static readonly "GRAY_CANDLE_CAKE": $Block
static readonly "LIGHT_GRAY_CONCRETE_POWDER": $Block
static readonly "STRIPPED_OAK_WOOD": $Block
static readonly "DEEPSLATE_BRICK_SLAB": $Block
static readonly "GOLD_ORE": $Block
static readonly "GREEN_CARPET": $Block
static readonly "OCHRE_FROGLIGHT": $Block
static readonly "POLISHED_BLACKSTONE": $Block
static readonly "CLAY": $Block
static readonly "TUBE_CORAL_BLOCK": $Block
static readonly "LILAC": $Block
static readonly "RED_SANDSTONE_STAIRS": $Block
static readonly "STRIPPED_CHERRY_LOG": $Block
static readonly "DEAD_BRAIN_CORAL_WALL_FAN": $Block
static readonly "WAXED_CUT_COPPER_STAIRS": $Block
static readonly "DARK_PRISMARINE": $Block
static readonly "WAXED_EXPOSED_COPPER_GRATE": $Block
static readonly "NETHER_SPROUTS": $Block
static readonly "BUBBLE_CORAL_BLOCK": $Block
static readonly "BLUE_GLAZED_TERRACOTTA": $Block
static readonly "ACACIA_FENCE_GATE": $Block
static readonly "BRICK_WALL": $Block
static readonly "GLOW_LICHEN": $Block
static readonly "CHERRY_DOOR": $Block
static readonly "WITHER_SKELETON_WALL_SKULL": $Block
static readonly "BIRCH_FENCE_GATE": $Block
static readonly "LIGHT_GRAY_CONCRETE": $Block
static readonly "MOSSY_COBBLESTONE_STAIRS": $Block
static readonly "OXIDIZED_CUT_COPPER_SLAB": $Block
static readonly "DARK_OAK_TRAPDOOR": $Block
static readonly "YELLOW_TERRACOTTA": $Block
static readonly "PITCHER_CROP": $Block
static readonly "WEATHERED_CHISELED_COPPER": $Block
static readonly "CHISELED_RED_SANDSTONE": $Block
static readonly "JUNGLE_WOOD": $Block
static readonly "CRACKED_DEEPSLATE_TILES": $Block
static readonly "WHITE_BANNER": $Block
static readonly "ACACIA_DOOR": $Block
static readonly "FLOWERING_AZALEA": $Block
static readonly "MOSSY_STONE_BRICKS": $Block
static readonly "PRISMARINE": $Block
static readonly "WARPED_BUTTON": $Block
static readonly "DEAD_TUBE_CORAL_BLOCK": $Block
static readonly "TUFF_SLAB": $Block
static readonly "SMOOTH_SANDSTONE": $Block
static readonly "DIAMOND_BLOCK": $Block
static readonly "OAK_SAPLING": $Block
static readonly "POLISHED_DEEPSLATE_SLAB": $Block
static readonly "LAVA": $Block
static readonly "MANGROVE_FENCE_GATE": $Block
static readonly "CHISELED_DEEPSLATE": $Block
static readonly "STONE_BRICK_SLAB": $Block
static readonly "CUT_COPPER_STAIRS": $Block
static readonly "GRAY_CONCRETE": $Block
static readonly "DARK_OAK_LEAVES": $Block
static readonly "EXPOSED_COPPER_GRATE": $Block
static readonly "BAMBOO_PRESSURE_PLATE": $Block
static readonly "MELON": $Block
static readonly "SEA_LANTERN": $Block
static readonly "GREEN_CONCRETE": $Block
static readonly "LANTERN": $Block
static readonly "ORANGE_WALL_BANNER": $Block
static readonly "VOID_AIR": $Block
static readonly "SMOOTH_STONE_SLAB": $Block
static readonly "SMOOTH_STONE": $Block
static readonly "GREEN_STAINED_GLASS_PANE": $Block
static readonly "ORANGE_CONCRETE": $Block
static readonly "RED_NETHER_BRICKS": $Block
static readonly "MANGROVE_DOOR": $Block
static readonly "CYAN_CONCRETE_POWDER": $Block
static readonly "WAXED_COPPER_BLOCK": $Block
static readonly "SMOKER": $Block
static readonly "BIRCH_PLANKS": $Block
static readonly "TRIPWIRE": $Block
static readonly "REPEATING_COMMAND_BLOCK": $Block
static readonly "RED_CONCRETE_POWDER": $Block
static readonly "BIRCH_DOOR": $Block
static readonly "CRIMSON_SIGN": $Block
static readonly "CRIMSON_TRAPDOOR": $Block
static readonly "CHISELED_COPPER": $Block
static readonly "WEATHERED_COPPER_TRAPDOOR": $Block
static readonly "BLUE_CARPET": $Block
static readonly "DEEPSLATE_TILE_SLAB": $Block
static readonly "DRAGON_EGG": $Block
static readonly "SANDSTONE": $Block
static readonly "CRIMSON_STAIRS": $Block
static readonly "EXPOSED_COPPER": $Block
static readonly "WEATHERED_CUT_COPPER_STAIRS": $Block
static readonly "COBBLED_DEEPSLATE_SLAB": $Block
static readonly "MOSS_CARPET": $Block
static readonly "ANVIL": $Block
static readonly "REPEATER": $Block
static readonly "CRIMSON_HANGING_SIGN": $Block
static readonly "OXIDIZED_COPPER_BULB": $Block
static readonly "DEAD_BRAIN_CORAL": $Block
static readonly "BOOKSHELF": $Block
static readonly "SMOOTH_QUARTZ_STAIRS": $Block
static readonly "LIGHT_BLUE_CANDLE": $Block
static readonly "SPRUCE_WOOD": $Block
static readonly "BLACK_TERRACOTTA": $Block
static readonly "STONE_STAIRS": $Block
static readonly "POLISHED_TUFF_SLAB": $Block
static readonly "LIME_WOOL": $Block
static readonly "SPRUCE_FENCE": $Block
static readonly "OAK_PRESSURE_PLATE": $Block
static readonly "HONEY_BLOCK": $Block
static readonly "STRIPPED_DARK_OAK_WOOD": $Block
static readonly "MEDIUM_AMETHYST_BUD": $Block
static readonly "BIRCH_STAIRS": $Block
static readonly "POTTED_BAMBOO": $Block
static readonly "MANGROVE_BUTTON": $Block
static readonly "BIRCH_TRAPDOOR": $Block
static readonly "COMPOSTER": $Block
static readonly "ORANGE_STAINED_GLASS": $Block
static readonly "DECORATED_POT": $Block
static readonly "GLASS": $Block
static readonly "STRIPPED_MANGROVE_LOG": $Block
static readonly "CHERRY_PLANKS": $Block
static readonly "SOUL_SAND": $Block
static readonly "GREEN_STAINED_GLASS": $Block
static readonly "GRAY_STAINED_GLASS_PANE": $Block
static readonly "POTTED_FLOWERING_AZALEA": $Block
static readonly "BLUE_WOOL": $Block
static readonly "MAGENTA_WOOL": $Block
static readonly "BAMBOO_DOOR": $Block
static readonly "PITCHER_PLANT": $Block
static readonly "DEAD_HORN_CORAL": $Block
static readonly "PINK_BED": $Block
static readonly "CYAN_CANDLE": $Block
static readonly "POPPY": $Block
static readonly "CYAN_TERRACOTTA": $Block
static readonly "TRIPWIRE_HOOK": $Block
static readonly "PACKED_ICE": $Block
static readonly "YELLOW_CONCRETE": $Block
static readonly "WEATHERED_COPPER_DOOR": $Block
static readonly "ACACIA_STAIRS": $Block
static readonly "VINE": $Block
static readonly "POTTED_SPRUCE_SAPLING": $Block
static readonly "BUBBLE_COLUMN": $Block
static readonly "INFESTED_STONE_BRICKS": $Block
static readonly "COPPER_ORE": $Block
static readonly "BAMBOO_TRAPDOOR": $Block
static readonly "PODZOL": $Block
static readonly "WARPED_WART_BLOCK": $Block
static readonly "POLISHED_BLACKSTONE_WALL": $Block
static readonly "WARPED_NYLIUM": $Block
static readonly "STRIPPED_CRIMSON_STEM": $Block
static readonly "POTTED_ALLIUM": $Block
static readonly "BLUE_BED": $Block
static readonly "DEAD_FIRE_CORAL": $Block
static readonly "BLACK_WALL_BANNER": $Block
static readonly "BLACK_CARPET": $Block
static readonly "MUD": $Block
static readonly "PINK_TERRACOTTA": $Block
static readonly "POTTED_LILY_OF_THE_VALLEY": $Block
static readonly "FIRE_CORAL_BLOCK": $Block
static readonly "WARPED_WALL_HANGING_SIGN": $Block
static readonly "GRAY_GLAZED_TERRACOTTA": $Block
static readonly "CHERRY_LEAVES": $Block
static readonly "WEATHERED_COPPER_GRATE": $Block
static readonly "JUNGLE_FENCE": $Block
static readonly "SPAWNER": $Block
static readonly "POLISHED_BASALT": $Block
static readonly "WARPED_FUNGUS": $Block
static readonly "GRAY_WALL_BANNER": $Block
static readonly "WHITE_CONCRETE_POWDER": $Block
static readonly "RAIL": $Block
static readonly "GRAY_TERRACOTTA": $Block
static readonly "NETHER_PORTAL": $Block
static readonly "BEDROCK": $Block
static readonly "INFESTED_DEEPSLATE": $Block
static readonly "SHROOMLIGHT": $Block
static readonly "CHAIN_COMMAND_BLOCK": $Block
static readonly "CYAN_GLAZED_TERRACOTTA": $Block
static readonly "WAXED_WEATHERED_CUT_COPPER_SLAB": $Block
static readonly "STRIPPED_DARK_OAK_LOG": $Block
static readonly "GRAY_WOOL": $Block
static readonly "CYAN_WALL_BANNER": $Block
static readonly "DARK_OAK_SLAB": $Block
static readonly "OAK_SIGN": $Block
static readonly "RED_CONCRETE": $Block
static readonly "CRACKED_POLISHED_BLACKSTONE_BRICKS": $Block
static readonly "BEEHIVE": $Block
static readonly "WAXED_OXIDIZED_COPPER_DOOR": $Block
static readonly "GRAY_SHULKER_BOX": $Block
static readonly "WARPED_DOOR": $Block
static readonly "OAK_FENCE": $Block
static readonly "NETHER_BRICKS": $Block
static readonly "RED_CANDLE": $Block
static readonly "PURPLE_CANDLE_CAKE": $Block
static readonly "FLETCHING_TABLE": $Block
static readonly "BIG_DRIPLEAF_STEM": $Block
static readonly "GRAY_BANNER": $Block
static readonly "JUNGLE_FENCE_GATE": $Block
static readonly "MAGENTA_CONCRETE": $Block
static readonly "LIGHT_BLUE_WALL_BANNER": $Block
static readonly "BLACK_SHULKER_BOX": $Block
static readonly "BUBBLE_CORAL_WALL_FAN": $Block
static readonly "FROGSPAWN": $Block
static readonly "JUNGLE_TRAPDOOR": $Block
static readonly "ACTIVATOR_RAIL": $Block
static readonly "OXIDIZED_CUT_COPPER_STAIRS": $Block
static readonly "DIRT_PATH": $Block
static readonly "FROSTED_ICE": $Block
static readonly "ORANGE_CARPET": $Block
static readonly "PINK_CARPET": $Block
static readonly "STRUCTURE_VOID": $Block
static readonly "POWDER_SNOW_CAULDRON": $Block
static readonly "POTTED_ACACIA_SAPLING": $Block
static readonly "STONECUTTER": $Block
static readonly "LIME_CONCRETE_POWDER": $Block
static readonly "PINK_BANNER": $Block
static readonly "POLISHED_BLACKSTONE_PRESSURE_PLATE": $Block
static readonly "GREEN_WOOL": $Block
static readonly "HORN_CORAL_FAN": $Block
static readonly "POTTED_WARPED_ROOTS": $Block
static readonly "DEAD_HORN_CORAL_WALL_FAN": $Block
static readonly "CHERRY_FENCE": $Block
static readonly "OAK_WALL_HANGING_SIGN": $Block
static readonly "MOSSY_COBBLESTONE_SLAB": $Block
static readonly "BAMBOO_SAPLING": $Block
static readonly "DARK_PRISMARINE_STAIRS": $Block
static readonly "TWISTING_VINES": $Block
static readonly "LIME_BANNER": $Block
static readonly "PINK_CONCRETE": $Block
static readonly "RED_CANDLE_CAKE": $Block
static readonly "JUNGLE_BUTTON": $Block
static readonly "WAXED_WEATHERED_COPPER": $Block
static readonly "MUSHROOM_STEM": $Block
static readonly "BLUE_TERRACOTTA": $Block
static readonly "BROWN_MUSHROOM_BLOCK": $Block
static readonly "DEAD_TUBE_CORAL_FAN": $Block
static readonly "MAGENTA_GLAZED_TERRACOTTA": $Block
static readonly "CHISELED_BOOKSHELF": $Block
static readonly "TUFF_WALL": $Block
static readonly "POTTED_CACTUS": $Block
static readonly "DEAD_BUBBLE_CORAL": $Block
static readonly "WHITE_GLAZED_TERRACOTTA": $Block
static readonly "POTTED_BIRCH_SAPLING": $Block
static readonly "DEAD_FIRE_CORAL_WALL_FAN": $Block
static readonly "WAXED_OXIDIZED_COPPER": $Block
static readonly "GREEN_BED": $Block
static readonly "BROWN_WALL_BANNER": $Block
static readonly "CAULDRON": $Block
static readonly "POLISHED_ANDESITE_STAIRS": $Block
static readonly "POTTED_OAK_SAPLING": $Block
static readonly "CHERRY_FENCE_GATE": $Block
static readonly "EMERALD_BLOCK": $Block
static readonly "POTTED_TORCHFLOWER": $Block
static readonly "LIME_STAINED_GLASS_PANE": $Block
static readonly "ORANGE_BANNER": $Block
static readonly "WAXED_WEATHERED_CHISELED_COPPER": $Block
static readonly "CAVE_AIR": $Block
static readonly "LIGHT_BLUE_GLAZED_TERRACOTTA": $Block
static readonly "PINK_STAINED_GLASS": $Block
static readonly "OXIDIZED_COPPER": $Block
static readonly "SPRUCE_STAIRS": $Block
static readonly "BLUE_ICE": $Block
static readonly "SCAFFOLDING": $Block
static readonly "BLUE_SHULKER_BOX": $Block
static readonly "HORN_CORAL_BLOCK": $Block
static readonly "CRIMSON_SLAB": $Block
static readonly "RESPAWN_ANCHOR": $Block
static readonly "POTTED_JUNGLE_SAPLING": $Block
static readonly "KELP": $Block
static readonly "COPPER_BLOCK": $Block
static readonly "STRIPPED_WARPED_HYPHAE": $Block
static readonly "STRIPPED_JUNGLE_LOG": $Block
static readonly "ANDESITE_SLAB": $Block
static readonly "SUSPICIOUS_GRAVEL": $Block
static readonly "ATTACHED_MELON_STEM": $Block
static readonly "POTTED_CRIMSON_ROOTS": $Block
static readonly "GOLD_BLOCK": $Block
static readonly "CRIMSON_PLANKS": $Block
static readonly "DARK_OAK_FENCE_GATE": $Block
static readonly "SPRUCE_PRESSURE_PLATE": $Block
static readonly "ACACIA_LEAVES": $Block
static readonly "COBBLESTONE_SLAB": $Block
static readonly "HEAVY_WEIGHTED_PRESSURE_PLATE": $Block
static readonly "PINK_CONCRETE_POWDER": $Block
static readonly "WAXED_COPPER_GRATE": $Block
static readonly "LIGHT_BLUE_CONCRETE_POWDER": $Block
static readonly "WHITE_BED": $Block
static readonly "CHISELED_TUFF": $Block
static readonly "BUBBLE_CORAL_FAN": $Block
static readonly "YELLOW_CANDLE_CAKE": $Block
static readonly "ACACIA_WALL_HANGING_SIGN": $Block
static readonly "JUNGLE_LOG": $Block
static readonly "NOTE_BLOCK": $Block
static readonly "MANGROVE_SIGN": $Block
static readonly "WARPED_HYPHAE": $Block
static readonly "CHERRY_SIGN": $Block
static readonly "TORCHFLOWER_CROP": $Block
static readonly "SPRUCE_SLAB": $Block
static readonly "PEONY": $Block
static readonly "OXEYE_DAISY": $Block
static readonly "OAK_HANGING_SIGN": $Block
static readonly "ACACIA_SIGN": $Block
static readonly "STRIPPED_WARPED_STEM": $Block
static readonly "BEACON": $Block
static readonly "WAXED_OXIDIZED_CUT_COPPER": $Block
static readonly "MOSS_BLOCK": $Block
static readonly "HONEYCOMB_BLOCK": $Block
static readonly "POTTED_FERN": $Block
static readonly "NETHER_BRICK_STAIRS": $Block
static readonly "COBWEB": $Block
static readonly "POTTED_WITHER_ROSE": $Block
static readonly "DARK_OAK_WALL_SIGN": $Block
static readonly "OAK_LOG": $Block
static readonly "STRIPPED_JUNGLE_WOOD": $Block
static readonly "DEAD_BRAIN_CORAL_BLOCK": $Block
static readonly "MUDDY_MANGROVE_ROOTS": $Block
static readonly "TINTED_GLASS": $Block
static readonly "MAGENTA_CANDLE": $Block
static readonly "YELLOW_BED": $Block
static readonly "LIGHT_GRAY_CANDLE": $Block
static readonly "END_GATEWAY": $Block
static readonly "POTTED_WARPED_FUNGUS": $Block
static readonly "POTTED_DARK_OAK_SAPLING": $Block
static readonly "CHISELED_QUARTZ_BLOCK": $Block
static readonly "LIME_CARPET": $Block
static readonly "DEEPSLATE_EMERALD_ORE": $Block
static readonly "MUD_BRICK_SLAB": $Block
static readonly "PURPLE_GLAZED_TERRACOTTA": $Block
static readonly "IRON_BARS": $Block
static readonly "WHITE_CONCRETE": $Block
static readonly "STONE": $Block
static readonly "YELLOW_WOOL": $Block
static readonly "CAVE_VINES_PLANT": $Block
static readonly "ROSE_BUSH": $Block
static readonly "MUD_BRICKS": $Block
static readonly "BROWN_CARPET": $Block
static readonly "WAXED_CHISELED_COPPER": $Block
static readonly "STRIPPED_CHERRY_WOOD": $Block
static readonly "BLACKSTONE_STAIRS": $Block
static readonly "WHITE_CANDLE_CAKE": $Block
static readonly "REDSTONE_WALL_TORCH": $Block
static readonly "BLACK_CANDLE_CAKE": $Block
static readonly "ACACIA_LOG": $Block
static readonly "INFESTED_MOSSY_STONE_BRICKS": $Block
static readonly "ORANGE_GLAZED_TERRACOTTA": $Block
static readonly "MUD_BRICK_STAIRS": $Block
static readonly "MAGENTA_CONCRETE_POWDER": $Block
static readonly "TNT": $Block
static readonly "BELL": $Block
static readonly "TWISTING_VINES_PLANT": $Block
static readonly "BLACKSTONE_SLAB": $Block
static readonly "TORCHFLOWER": $Block
static readonly "SPRUCE_HANGING_SIGN": $Block
static readonly "STRIPPED_ACACIA_LOG": $Block
static readonly "RAW_IRON_BLOCK": $Block
static readonly "BROWN_BANNER": $Block
static readonly "AIR": $Block
static readonly "GRANITE_STAIRS": $Block
static readonly "BEE_NEST": $Block
static readonly "CHEST": $Block
static readonly "PINK_PETALS": $Block
static readonly "SCULK_SENSOR": $Block
static readonly "OAK_DOOR": $Block
static readonly "MANGROVE_FENCE": $Block
static readonly "LILY_PAD": $Block
static readonly "SMALL_DRIPLEAF": $Block
static readonly "PURPUR_STAIRS": $Block
static readonly "EXPOSED_CUT_COPPER_SLAB": $Block
static readonly "LADDER": $Block
static readonly "RED_MUSHROOM_BLOCK": $Block
static readonly "WALL_TORCH": $Block
static readonly "CRAFTER": $Block
static readonly "BASALT": $Block
static readonly "MAGENTA_WALL_BANNER": $Block
static readonly "BAMBOO_SIGN": $Block
static readonly "TALL_GRASS": $Block
static readonly "DEAD_BUSH": $Block
static readonly "EXPOSED_CUT_COPPER_STAIRS": $Block
static readonly "PETRIFIED_OAK_SLAB": $Block
static readonly "MUD_BRICK_WALL": $Block
static readonly "LIGHT_BLUE_CARPET": $Block
static readonly "MANGROVE_WALL_HANGING_SIGN": $Block
static readonly "CALIBRATED_SCULK_SENSOR": $Block
static readonly "SCULK_CATALYST": $Block
static readonly "WAXED_OXIDIZED_CUT_COPPER_STAIRS": $Block
static readonly "WARPED_ROOTS": $Block
static readonly "CHAIN": $Block
static readonly "FIRE_CORAL": $Block
static readonly "DEEPSLATE_IRON_ORE": $Block
static readonly "WAXED_OXIDIZED_COPPER_BULB": $Block
static readonly "CHISELED_NETHER_BRICKS": $Block
static readonly "LIGHT_GRAY_STAINED_GLASS_PANE": $Block
static readonly "COAL_BLOCK": $Block
static readonly "WHITE_STAINED_GLASS": $Block
static readonly "WEATHERED_CUT_COPPER": $Block
static readonly "PURPUR_PILLAR": $Block
static readonly "CALCITE": $Block
static readonly "ACACIA_TRAPDOOR": $Block
static readonly "CHERRY_WOOD": $Block
static readonly "WHITE_CARPET": $Block
static readonly "CRIMSON_STEM": $Block
static readonly "CHISELED_STONE_BRICKS": $Block
static readonly "RAW_GOLD_BLOCK": $Block
static readonly "JIGSAW": $Block
static readonly "PURPUR_BLOCK": $Block
static readonly "FURNACE": $Block
static readonly "JACK_O_LANTERN": $Block
static readonly "BLACK_BED": $Block
static readonly "BIRCH_PRESSURE_PLATE": $Block
static readonly "DEEPSLATE_LAPIS_ORE": $Block
static readonly "WAXED_OXIDIZED_CHISELED_COPPER": $Block
static readonly "LARGE_FERN": $Block
static readonly "SNIFFER_EGG": $Block
static readonly "BAMBOO_WALL_HANGING_SIGN": $Block
static readonly "PURPLE_TERRACOTTA": $Block
static readonly "CUT_RED_SANDSTONE_SLAB": $Block
static readonly "DIRT": $Block
static readonly "WEEPING_VINES": $Block
static readonly "COBBLED_DEEPSLATE": $Block
static readonly "GRAY_BED": $Block
static readonly "BONE_BLOCK": $Block
static readonly "LIGHT_BLUE_CANDLE_CAKE": $Block
static readonly "POLISHED_DIORITE": $Block
static readonly "CUT_SANDSTONE": $Block
static readonly "WHITE_TERRACOTTA": $Block
static readonly "MOSSY_COBBLESTONE_WALL": $Block
static readonly "GRINDSTONE": $Block
static readonly "POWERED_RAIL": $Block
static readonly "JUNGLE_SIGN": $Block
static readonly "DARK_OAK_PLANKS": $Block
static readonly "ACACIA_WOOD": $Block
static readonly "END_STONE_BRICK_SLAB": $Block
static readonly "MANGROVE_WOOD": $Block
static readonly "LIGHT_GRAY_STAINED_GLASS": $Block
static readonly "PIGLIN_WALL_HEAD": $Block
static readonly "POTTED_OXEYE_DAISY": $Block
static readonly "CHERRY_WALL_SIGN": $Block
static readonly "SEAGRASS": $Block
static readonly "WEATHERED_COPPER": $Block
static readonly "WAXED_WEATHERED_COPPER_GRATE": $Block
static readonly "OAK_PLANKS": $Block
static readonly "DEAD_TUBE_CORAL_WALL_FAN": $Block
static readonly "END_PORTAL_FRAME": $Block
static readonly "WAXED_OXIDIZED_COPPER_TRAPDOOR": $Block
static readonly "DEEPSLATE_COAL_ORE": $Block
static readonly "FLOWER_POT": $Block
static readonly "HEAVY_CORE": $Block
static readonly "RED_TERRACOTTA": $Block
static readonly "WAXED_EXPOSED_CUT_COPPER": $Block
static readonly "WARPED_SIGN": $Block
static readonly "COPPER_BULB": $Block
static readonly "SWEET_BERRY_BUSH": $Block
static readonly "SNOW_BLOCK": $Block
static readonly "CRIMSON_FENCE": $Block
static readonly "POLISHED_DIORITE_SLAB": $Block
static readonly "LAVA_CAULDRON": $Block
static readonly "BRAIN_CORAL_BLOCK": $Block
static readonly "MOSSY_STONE_BRICK_SLAB": $Block
static readonly "STONE_BRICKS": $Block
static readonly "SANDSTONE_STAIRS": $Block
static readonly "BROWN_BED": $Block
static readonly "MANGROVE_LEAVES": $Block
static readonly "POTTED_DANDELION": $Block
static readonly "SMOOTH_SANDSTONE_SLAB": $Block
static readonly "CHERRY_TRAPDOOR": $Block
static readonly "ATTACHED_PUMPKIN_STEM": $Block
static readonly "MAGENTA_TERRACOTTA": $Block
static readonly "SMOOTH_SANDSTONE_STAIRS": $Block
static readonly "SPRUCE_PLANKS": $Block
static readonly "DRAGON_HEAD": $Block
static readonly "CHERRY_SAPLING": $Block
static readonly "FIRE": $Block
static readonly "ANDESITE_WALL": $Block
static readonly "BLACK_WOOL": $Block
static readonly "LIGHT_GRAY_CARPET": $Block
static readonly "PURPLE_CONCRETE": $Block
static readonly "LIGHTNING_ROD": $Block
static readonly "CYAN_BED": $Block
static readonly "CHERRY_HANGING_SIGN": $Block
static readonly "LARGE_AMETHYST_BUD": $Block
static readonly "RED_SHULKER_BOX": $Block
static readonly "PEARLESCENT_FROGLIGHT": $Block
static readonly "REDSTONE_TORCH": $Block
static readonly "MAGENTA_CARPET": $Block
static readonly "STICKY_PISTON": $Block
static readonly "CRIMSON_ROOTS": $Block
static readonly "PUMPKIN": $Block
static readonly "SMOOTH_QUARTZ": $Block
static readonly "FLOWERING_AZALEA_LEAVES": $Block
static readonly "NETHER_WART_BLOCK": $Block
static readonly "COBBLED_DEEPSLATE_STAIRS": $Block
static readonly "COBBLESTONE_WALL": $Block
static readonly "WHEAT": $Block
static readonly "BLUE_WALL_BANNER": $Block
static readonly "DEAD_FIRE_CORAL_FAN": $Block
static readonly "LIME_CANDLE": $Block
static readonly "ACACIA_SLAB": $Block
static readonly "CRIMSON_NYLIUM": $Block
static readonly "ORANGE_CANDLE_CAKE": $Block
static readonly "OXIDIZED_COPPER_TRAPDOOR": $Block
static readonly "ORANGE_TERRACOTTA": $Block
static readonly "BLACK_CONCRETE": $Block
static readonly "DROPPER": $Block
static readonly "AZALEA": $Block
static readonly "POTTED_POPPY": $Block
static readonly "MOSSY_STONE_BRICK_STAIRS": $Block
static readonly "WARPED_HANGING_SIGN": $Block
static readonly "OAK_STAIRS": $Block
static readonly "BLACK_STAINED_GLASS": $Block
static readonly "IRON_TRAPDOOR": $Block
static readonly "KELP_PLANT": $Block
static readonly "PINK_CANDLE_CAKE": $Block
static readonly "INFESTED_CHISELED_STONE_BRICKS": $Block
static readonly "BLUE_BANNER": $Block
static readonly "POLISHED_DIORITE_STAIRS": $Block
static readonly "WARPED_PRESSURE_PLATE": $Block
static readonly "HORN_CORAL_WALL_FAN": $Block
static readonly "BAMBOO_HANGING_SIGN": $Block
static readonly "OAK_SLAB": $Block
static readonly "POINTED_DRIPSTONE": $Block
static readonly "WAXED_EXPOSED_COPPER": $Block
static readonly "PURPLE_CANDLE": $Block
static readonly "CRIMSON_FUNGUS": $Block
static readonly "DARK_OAK_HANGING_SIGN": $Block
static readonly "DARK_OAK_SAPLING": $Block
static readonly "ACACIA_BUTTON": $Block
static readonly "EMERALD_ORE": $Block
static readonly "POLISHED_DEEPSLATE_STAIRS": $Block
static readonly "LIGHT_GRAY_CANDLE_CAKE": $Block
static readonly "OAK_FENCE_GATE": $Block
static readonly "POTTED_WHITE_TULIP": $Block
static readonly "POLISHED_BLACKSTONE_STAIRS": $Block
static readonly "WAXED_CUT_COPPER_SLAB": $Block
static readonly "BAMBOO_BLOCK": $Block
static readonly "SUNFLOWER": $Block
static readonly "CAMPFIRE": $Block
static readonly "SANDSTONE_SLAB": $Block
static readonly "MANGROVE_PRESSURE_PLATE": $Block
static readonly "SPRUCE_BUTTON": $Block
static readonly "POTTED_MANGROVE_PROPAGULE": $Block
static readonly "CYAN_WOOL": $Block
static readonly "JUNGLE_HANGING_SIGN": $Block
static readonly "ZOMBIE_WALL_HEAD": $Block
static readonly "TARGET": $Block
static readonly "PRISMARINE_BRICK_SLAB": $Block
static readonly "LOOM": $Block
static readonly "DRIPSTONE_BLOCK": $Block
static readonly "CREEPER_HEAD": $Block
static readonly "BAMBOO_PLANKS": $Block
static readonly "NETHER_QUARTZ_ORE": $Block
static readonly "DEAD_BUBBLE_CORAL_FAN": $Block
static readonly "SUSPICIOUS_SAND": $Block
static readonly "BLACK_BANNER": $Block
static readonly "COPPER_DOOR": $Block
static readonly "WAXED_COPPER_DOOR": $Block
static readonly "LIGHT_BLUE_BED": $Block
static readonly "BIRCH_WALL_SIGN": $Block
static readonly "PRISMARINE_WALL": $Block
static readonly "PINK_STAINED_GLASS_PANE": $Block
static readonly "WEATHERED_COPPER_BULB": $Block
static readonly "DIORITE_STAIRS": $Block
static readonly "BLACKSTONE_WALL": $Block
static readonly "BRICK_STAIRS": $Block
static readonly "END_PORTAL": $Block
static readonly "PLAYER_WALL_HEAD": $Block
static readonly "BIRCH_HANGING_SIGN": $Block
static readonly "DAMAGED_ANVIL": $Block
static readonly "PINK_WALL_BANNER": $Block
static readonly "BAMBOO": $Block
static readonly "CONDUIT": $Block
static readonly "JUNGLE_LEAVES": $Block
static readonly "RED_TULIP": $Block
static readonly "SPORE_BLOSSOM": $Block
static readonly "WAXED_WEATHERED_COPPER_DOOR": $Block
static readonly "DARK_OAK_STAIRS": $Block
static readonly "YELLOW_SHULKER_BOX": $Block
static readonly "PINK_GLAZED_TERRACOTTA": $Block
static readonly "CANDLE_CAKE": $Block
static readonly "DANDELION": $Block
static readonly "AZALEA_LEAVES": $Block
static readonly "COCOA": $Block
static readonly "RED_GLAZED_TERRACOTTA": $Block
static readonly "BAMBOO_MOSAIC": $Block
static readonly "WARPED_STEM": $Block
static readonly "OAK_TRAPDOOR": $Block
static readonly "YELLOW_CONCRETE_POWDER": $Block
static readonly "BAMBOO_BUTTON": $Block
static readonly "PURPLE_WOOL": $Block
static readonly "VAULT": $Block
static readonly "LIGHT_BLUE_BANNER": $Block
static readonly "END_STONE": $Block
static readonly "SPRUCE_FENCE_GATE": $Block
static readonly "GRAVEL": $Block
static readonly "BUDDING_AMETHYST": $Block
static readonly "CYAN_STAINED_GLASS": $Block
static readonly "LAPIS_ORE": $Block
static readonly "ORANGE_BED": $Block
static readonly "WAXED_WEATHERED_COPPER_TRAPDOOR": $Block
static readonly "BIG_DRIPLEAF": $Block
static readonly "POTTED_CORNFLOWER": $Block
static readonly "DISPENSER": $Block
static readonly "NETHER_BRICK_SLAB": $Block
static readonly "CYAN_CONCRETE": $Block
static readonly "SMITHING_TABLE": $Block
static readonly "IRON_ORE": $Block
static readonly "POLISHED_BLACKSTONE_BRICK_SLAB": $Block
static readonly "NETHERRACK": $Block
static readonly "RED_STAINED_GLASS_PANE": $Block
static readonly "GREEN_CANDLE_CAKE": $Block
static readonly "BROWN_SHULKER_BOX": $Block
static readonly "HANGING_ROOTS": $Block
static readonly "PRISMARINE_SLAB": $Block
static readonly "SMOOTH_RED_SANDSTONE": $Block
static readonly "BROWN_STAINED_GLASS": $Block
static readonly "BIRCH_WALL_HANGING_SIGN": $Block
static readonly "SKELETON_SKULL": $Block
static readonly "GREEN_WALL_BANNER": $Block
static readonly "END_STONE_BRICK_WALL": $Block
static readonly "POLISHED_TUFF_STAIRS": $Block
static readonly "TORCH": $Block
static readonly "ENDER_CHEST": $Block
static readonly "WAXED_OXIDIZED_COPPER_GRATE": $Block
static readonly "FERN": $Block
static readonly "BIRCH_SIGN": $Block
static readonly "POLISHED_GRANITE": $Block
static readonly "PINK_TULIP": $Block
static readonly "INFESTED_CRACKED_STONE_BRICKS": $Block
static readonly "JUNGLE_SAPLING": $Block
static readonly "TALL_SEAGRASS": $Block
static readonly "LEVER": $Block
static readonly "DEAD_BUBBLE_CORAL_BLOCK": $Block
static readonly "STONE_PRESSURE_PLATE": $Block
static readonly "TUFF": $Block
static readonly "POLISHED_BLACKSTONE_BRICK_STAIRS": $Block
static readonly "NETHER_GOLD_ORE": $Block
static readonly "LIME_BED": $Block
static readonly "POTTED_DEAD_BUSH": $Block
static readonly "QUARTZ_BRICKS": $Block
static readonly "POTTED_PINK_TULIP": $Block
static readonly "STRIPPED_OAK_LOG": $Block
static readonly "MANGROVE_SLAB": $Block
static readonly "END_ROD": $Block
static readonly "WARPED_PLANKS": $Block
static readonly "CHERRY_SLAB": $Block
static readonly "ORANGE_CONCRETE_POWDER": $Block
static readonly "ORANGE_WOOL": $Block
static readonly "PLAYER_HEAD": $Block
static readonly "LIME_TERRACOTTA": $Block
static readonly "MANGROVE_STAIRS": $Block
static readonly "TUFF_BRICKS": $Block
static readonly "WHITE_WOOL": $Block
static readonly "GRAY_CARPET": $Block
static readonly "GREEN_TERRACOTTA": $Block
static readonly "BROWN_CANDLE": $Block
static readonly "DARK_OAK_DOOR": $Block
static readonly "GREEN_SHULKER_BOX": $Block
static readonly "GRAY_CONCRETE_POWDER": $Block
static readonly "OXIDIZED_CUT_COPPER": $Block
static readonly "LIGHT_GRAY_WALL_BANNER": $Block
static readonly "WHITE_SHULKER_BOX": $Block
static readonly "CRIMSON_BUTTON": $Block
static readonly "IRON_BLOCK": $Block
static readonly "BLUE_CONCRETE": $Block
static readonly "REDSTONE_LAMP": $Block
static readonly "POLISHED_BLACKSTONE_BRICK_WALL": $Block
static readonly "PUMPKIN_STEM": $Block
static readonly "POTTED_BLUE_ORCHID": $Block
static readonly "POTATOES": $Block
static readonly "BIRCH_BUTTON": $Block
static readonly "HOPPER": $Block
static readonly "DARK_OAK_WALL_HANGING_SIGN": $Block
static readonly "LIGHT_WEIGHTED_PRESSURE_PLATE": $Block
static readonly "SOUL_SOIL": $Block
static readonly "YELLOW_CANDLE": $Block
static readonly "SOUL_TORCH": $Block
static readonly "LIGHT_BLUE_WOOL": $Block
static readonly "TUFF_BRICK_STAIRS": $Block
static readonly "ACACIA_WALL_SIGN": $Block
static readonly "POTTED_CRIMSON_FUNGUS": $Block
static readonly "LIGHT_GRAY_SHULKER_BOX": $Block
static readonly "WAXED_CUT_COPPER": $Block
static readonly "STRIPPED_MANGROVE_WOOD": $Block
static readonly "FIRE_CORAL_WALL_FAN": $Block
static readonly "CHERRY_LOG": $Block
static readonly "WAXED_WEATHERED_CUT_COPPER": $Block
static readonly "YELLOW_STAINED_GLASS_PANE": $Block
static readonly "CUT_COPPER_SLAB": $Block
static readonly "BLACKSTONE": $Block
static readonly "RED_NETHER_BRICK_SLAB": $Block
static readonly "LIME_CANDLE_CAKE": $Block
static readonly "MAGENTA_STAINED_GLASS_PANE": $Block
static readonly "DEAD_HORN_CORAL_FAN": $Block
static readonly "SHULKER_BOX": $Block
static readonly "DEAD_HORN_CORAL_BLOCK": $Block
static readonly "CARVED_PUMPKIN": $Block
static readonly "PINK_WOOL": $Block
static readonly "WEEPING_VINES_PLANT": $Block
static readonly "LIGHT_GRAY_WOOL": $Block
static readonly "JUNGLE_DOOR": $Block
static readonly "STONE_BUTTON": $Block
static readonly "GRANITE_SLAB": $Block
static readonly "CRACKED_NETHER_BRICKS": $Block
static readonly "LIGHT_GRAY_BED": $Block
static readonly "ACACIA_SAPLING": $Block
static readonly "POWDER_SNOW": $Block
static readonly "EXPOSED_COPPER_BULB": $Block
static readonly "BAMBOO_SLAB": $Block
static readonly "CRIMSON_WALL_HANGING_SIGN": $Block
static readonly "IRON_DOOR": $Block
static readonly "BROWN_STAINED_GLASS_PANE": $Block
static readonly "MOVING_PISTON": $Block
static readonly "WAXED_EXPOSED_CUT_COPPER_SLAB": $Block
static readonly "SOUL_WALL_TORCH": $Block
static readonly "BIRCH_WOOD": $Block
static readonly "LODESTONE": $Block
static readonly "SEA_PICKLE": $Block
static readonly "SPRUCE_LEAVES": $Block
static readonly "ORANGE_TULIP": $Block
static readonly "ANDESITE": $Block
static readonly "RED_NETHER_BRICK_STAIRS": $Block
static readonly "MANGROVE_PROPAGULE": $Block
static readonly "BROWN_GLAZED_TERRACOTTA": $Block
static readonly "BARREL": $Block
static readonly "OXIDIZED_CHISELED_COPPER": $Block
static readonly "INFESTED_STONE": $Block
static readonly "YELLOW_GLAZED_TERRACOTTA": $Block

constructor()

public static "log"(arg0: $MapColor$$Type, arg1: $MapColor$$Type): $Block
public static "log"(arg0: $MapColor$$Type, arg1: $MapColor$$Type, arg2: $SoundType$$Type): $Block
public static "register"(arg0: StringJS, arg1: $Block$$Type): $Block
public static "register"(arg0: $ResourceKey$$Type<($Block)>, arg1: $Block$$Type): $Block
public static "rebuildCache"(): void
public static "ocelotOrParrot"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $EntityType$$Type<(never)>): boolean
public static "stoneButton"(): $Block
public static "woodenButton"(arg0: $BlockSetType$$Type): $Block
public static "litBlockEmission"(arg0: integer): $ToIntFunction<($BlockState)>
public static "netherStem"(arg0: $MapColor$$Type): $Block
public static "flowerPot"(arg0: $Block$$Type): $Block
public static "always"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public static "always"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $EntityType$$Type<(never)>): boolean
public static "never"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $EntityType$$Type<(never)>): boolean
public static "never"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public static "leaves"(arg0: $SoundType$$Type): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Blocks$$Type = ($Blocks);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Blocks$$Original = $Blocks;}
declare module "net.minecraft.world.level.block.state.properties.Tilt" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $Tilt extends $Enum<($Tilt)> implements $StringRepresentable$$Interface {
static readonly "PARTIAL": $Tilt
static readonly "NONE": $Tilt
static readonly "UNSTABLE": $Tilt
static readonly "FULL": $Tilt

public static "values"(): ($Tilt)[]
public static "valueOf"(arg0: StringJS): $Tilt
public "getSerializedName"(): StringJS
public "causesVibration"(): boolean
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Tilt$$Type = (("none") | ("unstable") | ("partial") | ("full"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Tilt$$Original = $Tilt;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.StraightTrunkPlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$TrunkPlacerType} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacerType"
import {$List} from "java.util.List"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $StraightTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($StraightTrunkPlacer)>
static readonly "MAX_HEIGHT": integer
readonly "baseHeight": integer
readonly "heightRandA": integer
readonly "heightRandB": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "type"(): $TrunkPlacerType<(never)>
public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StraightTrunkPlacer$$Type = ($StraightTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StraightTrunkPlacer$$Original = $StraightTrunkPlacer;}
declare module "net.minecraft.world.level.gameevent.GameEventListener$DeliveryMode" {
import {$Enum} from "java.lang.Enum"

export class $GameEventListener$DeliveryMode extends $Enum<($GameEventListener$DeliveryMode)> {
static readonly "UNSPECIFIED": $GameEventListener$DeliveryMode
static readonly "BY_DISTANCE": $GameEventListener$DeliveryMode

public static "values"(): ($GameEventListener$DeliveryMode)[]
public static "valueOf"(arg0: StringJS): $GameEventListener$DeliveryMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameEventListener$DeliveryMode$$Type = (("unspecified") | ("by_distance"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameEventListener$DeliveryMode$$Original = $GameEventListener$DeliveryMode;}
declare module "net.minecraft.world.level.block.BucketPickup" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$IBucketPickupExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IBucketPickupExtension"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BucketPickup$$Interface extends $IBucketPickupExtension$$Interface {
get "pickupSound"(): $Optional<($SoundEvent)>
}

export class $BucketPickup implements $BucketPickup$$Interface {
 "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
/**
 * 
 * @deprecated
 */
 "getPickupSound"(): $Optional<($SoundEvent)>
 "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BucketPickup$$Type = ($BucketPickup);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BucketPickup$$Original = $BucketPickup;}
declare module "net.minecraft.world.level.material.FlowingFluid" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$StateDefinition$Builder$$Type} from "net.minecraft.world.level.block.state.StateDefinition$Builder"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$StateDefinition} from "net.minecraft.world.level.block.state.StateDefinition"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$FlowingFluidAccessor$$Interface as $FlowingFluidAccessor$0$$Interface} from "com.lightning.northstar.mixin.accessor.FlowingFluidAccessor"
import {$Short2ObjectMap$$Type} from "it.unimi.dsi.fastutil.shorts.Short2ObjectMap"
import {$FlowingFluidAccessor$$Interface} from "com.simibubi.create.foundation.mixin.accessor.FlowingFluidAccessor"
import {$Map} from "java.util.Map"
import {$Pair$$Type} from "com.mojang.datafixers.util.Pair"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$Short2BooleanMap$$Type} from "it.unimi.dsi.fastutil.shorts.Short2BooleanMap"

export class $FlowingFluid extends $Fluid implements $FlowingFluidAccessor$$Interface, $FlowingFluidAccessor$0$$Interface {
static readonly "FLUID_STATE_REGISTRY": $IdMapper<($FluidState)>
static readonly "FALLING": $BooleanProperty
static readonly "LEVEL": $IntegerProperty
readonly "stateDefinition": $StateDefinition<($Fluid), ($FluidState)>

constructor()

public "spread"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type): void
public "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type): void
public "getShape"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getSource"(): $Fluid
public "getSource"(arg0: boolean): $FluidState
public "northstar$beforeDestroyingBlock"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "beforeDestroyingBlock"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "getDropOff"(arg0: $LevelReader$$Type): integer
public "spreadTo"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type, arg4: $FluidState$$Type): void
public "isSolidFace"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "getNewLiquid"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $FluidState
public "getSpreadDelay"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type, arg3: $FluidState$$Type): integer
public "getSlopeDistance"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: integer, arg3: $Direction$$Type, arg4: $BlockState$$Type, arg5: $BlockPos$$Type, arg6: $Short2ObjectMap$$Type<($Pair$$Type<($BlockState$$Type), ($FluidState$$Type)>)>, arg7: $Short2BooleanMap$$Type): integer
public static "getLegacyLevel"(arg0: $FluidState$$Type): integer
public "canSpreadTo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type, arg4: $BlockPos$$Type, arg5: $BlockState$$Type, arg6: $FluidState$$Type, arg7: $Fluid$$Type): boolean
public "getSpread"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $Map<($Direction), ($FluidState)>
public "create$getNewLiquid"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $FluidState
public "getFlow"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type): $Vec3
public "getAmount"(arg0: $FluidState$$Type): integer
public "getHeight"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): float
public "getSlopeFindDistance"(arg0: $LevelReader$$Type): integer
/**
 * 
 * @deprecated
 */
public "canConvertToSource"(arg0: $Level$$Type): boolean
public "canConvertToSource"(arg0: $FluidState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): boolean
public "getFlowing"(arg0: integer, arg1: boolean): $FluidState
public "getFlowing"(): $Fluid
public "getOwnHeight"(arg0: $FluidState$$Type): float
public "createFluidStateDefinition"(arg0: $StateDefinition$Builder$$Type<($Fluid$$Type), ($FluidState$$Type)>): void
public "handler$bkp000$lithium$getSpread"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $CallbackInfoReturnable$$Type): void
public "handler$geo000$create$canPassThroughOnWaterWheel"(arg0: $BlockGetter$$Type, arg1: $Fluid$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Direction$$Type, arg5: $BlockPos$$Type, arg6: $BlockState$$Type, arg7: $FluidState$$Type, arg8: $CallbackInfoReturnable$$Type): void
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
public static "wrap"(o: any): $ReplacementMatch
get "source"(): $Fluid
get "flowing"(): $Fluid
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlowingFluid$$Type = ($FlowingFluid);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlowingFluid$$Original = $FlowingFluid;}
declare module "net.minecraft.world.level.storage.loot.LootDataType$Validator" {
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ValidationContext, $ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"

export interface $LootDataType$Validator$$Interface<T> {

(arg0: $ValidationContext, arg1: $ResourceKey<(T)>, arg2: T): void
}

export class $LootDataType$Validator<T> implements $LootDataType$Validator$$Interface {
 "run"(arg0: $ValidationContext$$Type, arg1: $ResourceKey$$Type<(T)>, arg2: T): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootDataType$Validator$$Type<T> = ((arg0: $ValidationContext, arg1: $ResourceKey<(T)>, arg2: T) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootDataType$Validator$$Original<T> = $LootDataType$Validator<(T)>;}
declare module "net.minecraft.world.level.ClipContext$ShapeGetter" {
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$CollisionContext, $CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $ClipContext$ShapeGetter$$Interface {

(arg0: $BlockState, arg1: $BlockGetter, arg2: $BlockPos, arg3: $CollisionContext): $VoxelShape$$Type
}

export class $ClipContext$ShapeGetter implements $ClipContext$ShapeGetter$$Interface {
 "get"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClipContext$ShapeGetter$$Type = ((arg0: $BlockState, arg1: $BlockGetter, arg2: $BlockPos, arg3: $CollisionContext) => $VoxelShape$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClipContext$ShapeGetter$$Original = $ClipContext$ShapeGetter;}
declare module "net.minecraft.world.level.storage.loot.LootPool" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$LootContext$$Type} from "net.minecraft.world.level.storage.loot.LootContext"
import {$Optional$$Type} from "java.util.Optional"
import {$LootItemFunction, $LootItemFunction$$Type} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction"
import {$LootPoolEntryContainer, $LootPoolEntryContainer$$Type} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer"
import {$List, $List$$Type} from "java.util.List"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$LootPoolAccess$$Interface} from "com.blackgear.platform.common.data.neoforge.LootPoolAccess"
import {$LootPoolAccessor$$Interface} from "net.fabricmc.fabric.mixin.loot.LootPoolAccessor"
import {$NumberProvider, $NumberProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.number.NumberProvider"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LootPool$Builder} from "net.minecraft.world.level.storage.loot.LootPool$Builder"
import {$Codec} from "com.mojang.serialization.Codec"
import {$LootPoolAccessor$$Interface as $LootPoolAccessor$0$$Interface} from "fzzyhmstrs.emi_loot.mixins.LootPoolAccessor"
import {$LootPoolAccessor$$Interface as $LootPoolAccessor$1$$Interface} from "com.jesz.createdieselgenerators.mixins.LootPoolAccessor"
import {$LootItemCondition, $LootItemCondition$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"

export class $LootPool implements $LootPoolAccessor$0$$Interface, $LootPoolAccessor$$Interface, $LootPoolAccess$$Interface, $LootPoolAccessor$1$$Interface {
 "entries": $List<($LootPoolEntryContainer)>
static readonly "CODEC": $Codec<($LootPool)>
readonly "functions": $List<($LootItemFunction)>
readonly "conditions": $List<($LootItemCondition)>
 "rolls": $NumberProvider
 "bonusRolls": $NumberProvider

constructor(arg0: $List$$Type<($LootPoolEntryContainer$$Type)>, arg1: $List$$Type<($LootItemCondition$$Type)>, arg2: $List$$Type<($LootItemFunction$$Type)>, arg3: $NumberProvider$$Type, arg4: $NumberProvider$$Type, arg5: (StringJS)?)

public "getName"(): StringJS
public "validate"(arg0: $ValidationContext$$Type): void
public "setName"(arg0: StringJS): void
public "isFrozen"(): boolean
public "getEntries"(): $List
public "freeze"(): void
public "addRandomItems"(arg0: $Consumer$$Type<($ItemStack)>, arg1: $LootContext$$Type): void
public "getBonusRolls"(): $NumberProvider
public "fabric_getRolls"(): $NumberProvider
public "setBonusRolls"(arg0: $NumberProvider$$Type): void
public "fabric_getEntries"(): $List
public "fabric_getBonusRolls"(): $NumberProvider
public "fabric_getFunctions"(): $List
public "fabric_getConditions"(): $List
public "getConditions"(): $List
public "setRolls"(arg0: $NumberProvider$$Type): void
public static "lootPool"(): $LootPool$Builder
public "setEntries"(entries: $List$$Type): void
public "getRolls"(): $NumberProvider
public "getFunctions"(): $List
get "name"(): StringJS
set "name"(value: StringJS)
get "frozen"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootPool$$Type = ($LootPool);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootPool$$Original = $LootPool;}
declare module "net.minecraft.world.level.block.entity.HopperBlockEntity" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LithiumInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumInventory"
import {$Hopper$$Type, $Hopper$$Interface} from "net.minecraft.world.level.block.entity.Hopper"
import {$SectionedEntityMovementListener$$Interface} from "net.caffeinemc.mods.lithium.common.tracking.entity.SectionedEntityMovementListener"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$Class$$Type} from "java.lang.Class"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WrappedBlockEntityTickInvokerAccessor, $WrappedBlockEntityTickInvokerAccessor$$Type} from "net.caffeinemc.mods.lithium.mixin.world.block_entity_ticking.sleeping.WrappedBlockEntityTickInvokerAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TickingBlockEntity, $TickingBlockEntity$$Type} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$RandomizableContainerBlockEntity} from "net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity"
import {$UpdateReceiver$$Interface} from "net.caffeinemc.mods.lithium.common.hopper.UpdateReceiver"
import {$ReferenceArraySet} from "it.unimi.dsi.fastutil.objects.ReferenceArraySet"
import {$InventoryChangeListener$$Type, $InventoryChangeListener$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$InventoryChangeTracker$$Type, $InventoryChangeTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$SleepingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SleepingBlockEntity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB} from "net.minecraft.world.phys.AABB"

export class $HopperBlockEntity extends $RandomizableContainerBlockEntity implements $Hopper$$Interface, $LithiumInventory$$Interface, $InventoryChangeListener$$Interface, $UpdateReceiver$$Interface, $SectionedEntityMovementListener$$Interface, $InventoryChangeTracker$$Interface, $SleepingBlockEntity$$Interface {
 "inventoryChangeListeners": $ReferenceArraySet
 "level": $Level
static readonly "$assertionsDisabled": boolean
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventoryHandlingTypeListeners": $ReferenceArraySet
static readonly "HOPPER_CONTAINER_SIZE": integer
 "remove": boolean
 "worldPosition": $BlockPos
 "lootTable": $ResourceKey<($LootTable)>
static readonly "MOVE_ITEM_SPEED": integer
 "lockKey": $LockCode
 "hasComparators": byte
 "lootTableSeed": long

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getDefaultName"(): $Component
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public static "getContainerAt"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $Container
public static "pushItemsTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $HopperBlockEntity$$Type): void
public "lithium$handleInventoryRemoved"(arg0: $Container$$Type): void
public "lithium$handleComparatorAdded"(arg0: $Container$$Type): boolean
public "handler$bpm003$lithium$setInventoryStackListReplacement"(arg0: $NonNullList$$Type, arg1: $CallbackInfo$$Type): void
public "getLastUpdateTime"(): long
public "isGridAligned"(): boolean
public static "suckInItems"(arg0: $Level$$Type, arg1: $Hopper$$Type): boolean
public static "getItemsAtAndAbove"(arg0: $Level$$Type, arg1: $Hopper$$Type): $List<($ItemEntity)>
public "isOnCustomCooldown"(): boolean
public "setCooldown"(arg0: integer): void
public "getInsertInventory"(arg0: $Level$$Type): $Container
public static "addItem"(arg0: $Container$$Type, arg1: $ItemEntity$$Type): boolean
public static "addItem"(arg0: $Container$$Type, arg1: $Container$$Type, arg2: $ItemStack$$Type, arg3: $Direction$$Type): $ItemStack
public static "entityInside"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Entity$$Type, arg4: $HopperBlockEntity$$Type): void
public "getContainerSize"(): integer
public "setBlockState"(arg0: $BlockState$$Type): void
public "getItems"(): $NonNullList<($ItemStack)>
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "getLevelX"(): double
public "getLevelY"(): double
public "getLevelZ"(): double
public "lithium$setTickWrapper"(arg0: $WrappedBlockEntityTickInvokerAccessor$$Type): void
public "lithium$startSleeping"(): boolean
public "lithium$getSleepingTicker"(): $TickingBlockEntity
public "lithium$getTickWrapper"(): $WrappedBlockEntityTickInvokerAccessor
public "lithium$setSleepingTicker"(arg0: $TickingBlockEntity$$Type): void
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "lithium$handleInventoryContentModified"(arg0: $Container$$Type): void
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public "lithium$invalidateCacheOnNeighborUpdate"(arg0: $Direction$$Type): void
public "lithium$invalidateCacheOnNeighborUpdate"(arg0: boolean): void
public "setItems"(arg0: $NonNullList$$Type<($ItemStack$$Type)>): void
public "lithium$handleEntityMovement"(arg0: $Class$$Type): void
public "lithium$invalidateCacheOnUndirectedNeighborUpdate"(): void
public "getExtractBlockInventory"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $Container
public "getInsertBlockInventory"(arg0: $Level$$Type): $Container
public "getInventoryLithium"(): $NonNullList
public "setInventoryLithium"(arg0: $NonNullList$$Type): void
public "createMenu"(arg0: integer, arg1: $Inventory$$Type): $AbstractContainerMenu
public "getSuckAabb"(): $AABB
public "generateLootLithium"(): void
public "handleStackListReplaced"(arg0: $Container$$Type): void
public "stopListenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "listenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "listenForContentChangesOnce"(arg0: $LithiumStackList$$Type, arg1: $InventoryChangeListener$$Type): void
public "isSleeping"(): boolean
public "setTicker"(arg0: $TickingBlockEntity$$Type): void
public "wakeUpNow"(): void
public "sleepOnlyCurrentTick"(): void
public "stillValid"(arg0: $Player$$Type): boolean
public "setChanged"(): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitContentModified"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$emitRemoved"(): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public static "tryClear"(arg0: any): void
get "defaultName"(): $Component
get "lastUpdateTime"(): long
get "gridAligned"(): boolean
get "onCustomCooldown"(): boolean
set "cooldown"(value: integer)
get "containerSize"(): integer
set "blockState"(value: $BlockState$$Type)
get "items"(): $NonNullList<($ItemStack)>
get "levelX"(): double
get "levelY"(): double
get "levelZ"(): double
set "items"(value: $NonNullList$$Type<($ItemStack$$Type)>)
get "inventoryLithium"(): $NonNullList
set "inventoryLithium"(value: $NonNullList$$Type)
get "suckAabb"(): $AABB
get "sleeping"(): boolean
set "ticker"(value: $TickingBlockEntity$$Type)
get "changed"(): void
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HopperBlockEntity$$Type = ($HopperBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HopperBlockEntity$$Original = $HopperBlockEntity;}
declare module "net.minecraft.world.level.block.state.properties.DoorHingeSide" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $DoorHingeSide extends $Enum<($DoorHingeSide)> implements $StringRepresentable$$Interface {
static readonly "LEFT": $DoorHingeSide
static readonly "RIGHT": $DoorHingeSide

public "toString"(): StringJS
public static "values"(): ($DoorHingeSide)[]
public static "valueOf"(arg0: StringJS): $DoorHingeSide
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoorHingeSide$$Type = (("left") | ("right"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoorHingeSide$$Original = $DoorHingeSide;}
declare module "net.minecraft.world.level.block.entity.DecoratedPotBlockEntity$WobbleStyle" {
import {$Enum} from "java.lang.Enum"

export class $DecoratedPotBlockEntity$WobbleStyle extends $Enum<($DecoratedPotBlockEntity$WobbleStyle)> {
readonly "duration": integer
static readonly "POSITIVE": $DecoratedPotBlockEntity$WobbleStyle
static readonly "NEGATIVE": $DecoratedPotBlockEntity$WobbleStyle

public static "values"(): ($DecoratedPotBlockEntity$WobbleStyle)[]
public static "valueOf"(arg0: StringJS): $DecoratedPotBlockEntity$WobbleStyle
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DecoratedPotBlockEntity$WobbleStyle$$Type = (("positive") | ("negative"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DecoratedPotBlockEntity$WobbleStyle$$Original = $DecoratedPotBlockEntity$WobbleStyle;}
declare module "net.minecraft.world.level.storage.ServerLevelData" {
import {$GameRules} from "net.minecraft.world.level.GameRules"
import {$WorldBorder$Settings, $WorldBorder$Settings$$Type} from "net.minecraft.world.level.border.WorldBorder$Settings"
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$TimerQueue} from "net.minecraft.world.level.timers.TimerQueue"
import {$WritableLevelData$$Interface} from "net.minecraft.world.level.storage.WritableLevelData"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Difficulty} from "net.minecraft.world.Difficulty"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameType, $GameType$$Type} from "net.minecraft.world.level.GameType"
import {$CrashReportCategory$$Type} from "net.minecraft.CrashReportCategory"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"

export interface $ServerLevelData$$Interface extends $WritableLevelData$$Interface {
get "levelName"(): StringJS
set "clearWeatherTime"(value: integer)
get "clearWeatherTime"(): integer
get "dayTimeFraction"(): float
set "thunderTime"(value: integer)
set "gameType"(value: $GameType$$Type)
get "scheduledEvents"(): $TimerQueue<($MinecraftServer)>
set "rainTime"(value: integer)
set "thundering"(value: boolean)
get "rainTime"(): integer
get "thunderTime"(): integer
set "dayTimePerTick"(value: float)
get "dayTimePerTick"(): float
set "dayTimeFraction"(value: float)
set "dayTime"(value: long)
set "initialized"(value: boolean)
get "initialized"(): boolean
get "gameType"(): $GameType
get "worldBorder"(): $WorldBorder$Settings
set "gameTime"(value: long)
get "allowCommands"(): boolean
set "worldBorder"(value: $WorldBorder$Settings$$Type)
get "wanderingTraderSpawnDelay"(): integer
set "wanderingTraderSpawnChance"(value: integer)
set "wanderingTraderSpawnDelay"(value: integer)
get "wanderingTraderSpawnChance"(): integer
get "wanderingTraderId"(): $UUID
set "wanderingTraderId"(value: $UUID$$Type)
set "raining"(value: boolean)
get "difficultyLocked"(): boolean
get "raining"(): boolean
get "hardcore"(): boolean
get "gameTime"(): long
get "spawnPos"(): $BlockPos
get "spawnAngle"(): float
get "thundering"(): boolean
get "dayTime"(): long
get "difficulty"(): $Difficulty
get "gameRules"(): $GameRules
}

export class $ServerLevelData implements $ServerLevelData$$Interface {
 "getLevelName"(): StringJS
 "fillCrashReportCategory"(arg0: $CrashReportCategory$$Type, arg1: $LevelHeightAccessor$$Type): void
 "setClearWeatherTime"(arg0: integer): void
 "getClearWeatherTime"(): integer
 "getDayTimeFraction"(): float
 "setThunderTime"(arg0: integer): void
 "setGameType"(arg0: $GameType$$Type): void
 "getScheduledEvents"(): $TimerQueue<($MinecraftServer)>
 "setRainTime"(arg0: integer): void
 "setThundering"(arg0: boolean): void
 "getRainTime"(): integer
 "getThunderTime"(): integer
 "setDayTimePerTick"(arg0: float): void
 "getDayTimePerTick"(): float
 "setDayTimeFraction"(arg0: float): void
 "setDayTime"(arg0: long): void
 "setInitialized"(arg0: boolean): void
 "isInitialized"(): boolean
 "getGameType"(): $GameType
 "getWorldBorder"(): $WorldBorder$Settings
 "setGameTime"(arg0: long): void
 "isAllowCommands"(): boolean
 "setWorldBorder"(arg0: $WorldBorder$Settings$$Type): void
 "getWanderingTraderSpawnDelay"(): integer
 "setWanderingTraderSpawnChance"(arg0: integer): void
 "setWanderingTraderSpawnDelay"(arg0: integer): void
 "getWanderingTraderSpawnChance"(): integer
 "getWanderingTraderId"(): $UUID
 "setWanderingTraderId"(arg0: $UUID$$Type): void
 "setSpawn"(arg0: $BlockPos$$Type, arg1: float): void
 "setRaining"(arg0: boolean): void
 "isDifficultyLocked"(): boolean
 "isRaining"(): boolean
 "isHardcore"(): boolean
 "getGameTime"(): long
 "getSpawnPos"(): $BlockPos
 "getSpawnAngle"(): float
 "isThundering"(): boolean
 "getDayTime"(): long
 "getDifficulty"(): $Difficulty
 "getGameRules"(): $GameRules
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerLevelData$$Type = ($ServerLevelData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerLevelData$$Original = $ServerLevelData;}
declare module "net.minecraft.world.level.border.BorderChangeListener" {
import {$WorldBorder$$Type} from "net.minecraft.world.level.border.WorldBorder"

export interface $BorderChangeListener$$Interface {
}

export class $BorderChangeListener implements $BorderChangeListener$$Interface {
 "onBorderSetWarningTime"(arg0: $WorldBorder$$Type, arg1: integer): void
 "onBorderSetDamageSafeZOne"(arg0: $WorldBorder$$Type, arg1: double): void
 "onBorderSizeLerping"(arg0: $WorldBorder$$Type, arg1: double, arg2: double, arg3: long): void
 "onBorderSetWarningBlocks"(arg0: $WorldBorder$$Type, arg1: integer): void
 "onBorderSetDamagePerBlock"(arg0: $WorldBorder$$Type, arg1: double): void
 "onBorderCenterSet"(arg0: $WorldBorder$$Type, arg1: double, arg2: double): void
 "onBorderSizeSet"(arg0: $WorldBorder$$Type, arg1: double): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BorderChangeListener$$Type = ($BorderChangeListener);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BorderChangeListener$$Original = $BorderChangeListener;}
declare module "net.minecraft.world.level.block.state.properties.RailShape" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $RailShape extends $Enum<($RailShape)> implements $StringRepresentable$$Interface {
static readonly "NORTH_WEST": $RailShape
static readonly "ASCENDING_WEST": $RailShape
static readonly "NORTH_EAST": $RailShape
static readonly "NORTH_SOUTH": $RailShape
static readonly "SOUTH_EAST": $RailShape
static readonly "EAST_WEST": $RailShape
static readonly "SOUTH_WEST": $RailShape
static readonly "ASCENDING_EAST": $RailShape
static readonly "ASCENDING_SOUTH": $RailShape
static readonly "ASCENDING_NORTH": $RailShape

public "getName"(): StringJS
public "toString"(): StringJS
public static "values"(): ($RailShape)[]
public static "valueOf"(arg0: StringJS): $RailShape
public "isAscending"(): boolean
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "name"(): StringJS
get "ascending"(): boolean
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RailShape$$Type = (("north_south") | ("east_west") | ("ascending_east") | ("ascending_west") | ("ascending_north") | ("ascending_south") | ("south_east") | ("south_west") | ("north_west") | ("north_east"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RailShape$$Original = $RailShape;}
declare module "net.minecraft.world.level.border.WorldBorder$BorderExtent" {
import {$BorderStatus} from "net.minecraft.world.level.border.BorderStatus"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"

export interface $WorldBorder$BorderExtent$$Interface {
get "maxX"(): double
get "maxZ"(): double
get "minX"(): double
get "minZ"(): double
get "size"(): double
get "lerpRemainingTime"(): long
get "collisionShape"(): $VoxelShape
get "status"(): $BorderStatus
get "lerpTarget"(): double
get "lerpSpeed"(): double
}

export class $WorldBorder$BorderExtent implements $WorldBorder$BorderExtent$$Interface {
 "getMaxX"(): double
 "getMaxZ"(): double
 "getMinX"(): double
 "getMinZ"(): double
 "update"(): $WorldBorder$BorderExtent
 "getSize"(): double
 "getLerpRemainingTime"(): long
 "onAbsoluteMaxSizeChange"(): void
 "getCollisionShape"(): $VoxelShape
 "getStatus"(): $BorderStatus
 "getLerpTarget"(): double
 "onCenterChange"(): void
 "getLerpSpeed"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldBorder$BorderExtent$$Type = ($WorldBorder$BorderExtent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldBorder$BorderExtent$$Original = $WorldBorder$BorderExtent;}
declare module "net.minecraft.world.level.block.entity.ComparatorBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Level} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ComparatorBlockEntity extends $BlockEntity {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getOutputSignal"(): integer
public "setOutputSignal"(arg0: integer): void
get "outputSignal"(): integer
set "outputSignal"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComparatorBlockEntity$$Type = ($ComparatorBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComparatorBlockEntity$$Original = $ComparatorBlockEntity;}
declare module "net.minecraft.world.level.block.SkullBlock$Type" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Map} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export interface $SkullBlock$Type$$Interface extends $StringRepresentable$$Interface {

(): StringJS
get "remappedEnumConstantName"(): StringJS
get "serializedName"(): StringJS
}

export class $SkullBlock$Type implements $SkullBlock$Type$$Interface {
static readonly "TYPES": $Map<(StringJS), ($SkullBlock$Type)>
static readonly "CODEC": $Codec<($SkullBlock$Type)>

static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
 "getRemappedEnumConstantName"(): StringJS
 "getSerializedName"(): StringJS
static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SkullBlock$Type$$Type = (() => StringJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SkullBlock$Type$$Original = $SkullBlock$Type;}
declare module "net.minecraft.world.level.biome.MobSpawnSettings" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$MobCategory, $MobCategory$$Type} from "net.minecraft.world.entity.MobCategory"
import {$WeightedRandomList, $WeightedRandomList$$Type} from "net.minecraft.util.random.WeightedRandomList"
import {$Set} from "java.util.Set"
import {$MobSpawnSettings$SpawnerData, $MobSpawnSettings$SpawnerData$$Type} from "net.minecraft.world.level.biome.MobSpawnSettings$SpawnerData"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$MobSpawnSettings$MobSpawnCost, $MobSpawnSettings$MobSpawnCost$$Type} from "net.minecraft.world.level.biome.MobSpawnSettings$MobSpawnCost"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $MobSpawnSettings {
static readonly "CODEC": $MapCodec<($MobSpawnSettings)>
 "creatureGenerationProbability": float
 "mobSpawnCosts": $Map<($EntityType<(never)>), ($MobSpawnSettings$MobSpawnCost)>
 "spawners": $Map<($MobCategory), ($WeightedRandomList<($MobSpawnSettings$SpawnerData)>)>
static readonly "EMPTY": $MobSpawnSettings
static readonly "EMPTY_MOB_LIST": $WeightedRandomList<($MobSpawnSettings$SpawnerData)>

constructor(arg0: float, arg1: $Map$$Type<($MobCategory$$Type), ($WeightedRandomList$$Type<($MobSpawnSettings$SpawnerData$$Type)>)>, arg2: $Map$$Type<($EntityType$$Type<(never)>), ($MobSpawnSettings$MobSpawnCost$$Type)>)

public "getCreatureProbability"(): float
public "getEntityTypes"(): $Set<($EntityType<(never)>)>
public "getMobs"(arg0: $MobCategory$$Type): $WeightedRandomList<($MobSpawnSettings$SpawnerData)>
public "getMobSpawnCost"(arg0: $EntityType$$Type<(never)>): $MobSpawnSettings$MobSpawnCost
public "getSpawnerTypes"(): $Set<($MobCategory)>
get "creatureProbability"(): float
get "entityTypes"(): $Set<($EntityType<(never)>)>
get "spawnerTypes"(): $Set<($MobCategory)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobSpawnSettings$$Type = ($MobSpawnSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobSpawnSettings$$Original = $MobSpawnSettings;}
declare module "net.minecraft.world.level.PathNavigationRegion" {
import {$Iterable} from "java.lang.Iterable"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$Holder} from "net.minecraft.core.Holder"
import {$CollisionGetter$$Interface} from "net.minecraft.world.level.CollisionGetter"
import {$ProfilerFiller} from "net.minecraft.util.profiling.ProfilerFiller"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$ChunkView$$Interface} from "net.caffeinemc.mods.lithium.common.world.ChunkView"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$BlockGetter, $BlockGetter$$Interface} from "net.minecraft.world.level.BlockGetter"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"

export class $PathNavigationRegion implements $BlockGetter$$Interface, $CollisionGetter$$Interface, $ChunkView$$Interface {
 "allEmpty": boolean
readonly "centerZ": integer
readonly "centerX": integer
readonly "level": $Level
readonly "chunks": (($ChunkAccess)[])[]

constructor(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type)

public "getFluidState"(arg0: $BlockPos$$Type): $FluidState
public "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
public "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
public "getProfiler"(): $ProfilerFiller
public "getWorldBorder"(): $WorldBorder
public "getHeight"(): integer
public "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
public "getMinBuildHeight"(): integer
public "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
public "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
public "getLightEmission"(arg0: $BlockPos$$Type): integer
public "clip"(arg0: $ClipContext$$Type): $BlockHitResult
public "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
public "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
public "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
public "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
public "getMaxLightLevel"(): integer
public static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
public "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
public "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
public "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
public "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
public "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
public "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
public "isUnobstructed"(arg0: $Entity$$Type): boolean
public "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
public "noCollision"(arg0: $Entity$$Type): boolean
public "noCollision"(arg0: $AABB$$Type): boolean
public "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
public "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
public static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
public "getSectionYFromSectionIndex"(arg0: integer): integer
public "getSectionIndexFromSectionY"(arg0: integer): integer
public "getMaxBuildHeight"(): integer
public "getSectionIndex"(arg0: integer): integer
public "getMaxSection"(): integer
public "getMinSection"(): integer
public "getSectionsCount"(): integer
public "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
public "isOutsideBuildHeight"(arg0: integer): boolean
public "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
public "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
public "getModelData"(arg0: $BlockPos$$Type): $ModelData
public "getBlockEntityRenderData"(arg0: $BlockPos$$Type): any
public "hasBiomes"(): boolean
public "getBiomeFabric"(arg0: $BlockPos$$Type): $Holder<($Biome)>
get "profiler"(): $ProfilerFiller
get "worldBorder"(): $WorldBorder
get "height"(): integer
get "minBuildHeight"(): integer
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "maxSection"(): integer
get "minSection"(): integer
get "sectionsCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathNavigationRegion$$Type = ($PathNavigationRegion);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PathNavigationRegion$$Original = $PathNavigationRegion;}
declare module "net.minecraft.world.level.saveddata.maps.MapDecorationType" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Holder} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $MapDecorationType extends $Record {
static readonly "CODEC": $Codec<($Holder<($MapDecorationType)>)>
static readonly "NO_MAP_COLOR": integer
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($Holder<($MapDecorationType)>)>

constructor(arg0: $ResourceLocation$$Type, arg1: boolean, arg2: integer, arg3: boolean, arg4: boolean)

public "trackCount"(): boolean
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "explorationMapElement"(): boolean
public "hasMapColor"(): boolean
public "showOnItemFrame"(): boolean
public "assetId"(): $ResourceLocation
public "mapColor"(): integer
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.MapDecorationType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.MapDecorationTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapDecorationType$$Type = (Special.MapDecorationType) | ({"assetId"?: $ResourceLocation$$Type, "explorationMapElement"?: boolean, "trackCount"?: boolean, "showOnItemFrame"?: boolean, "mapColor"?: integer}) | ([assetId?: $ResourceLocation$$Type, explorationMapElement?: boolean, trackCount?: boolean, showOnItemFrame?: boolean, mapColor?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapDecorationType$$Original = $MapDecorationType;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.RuleBasedBlockStateProvider" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$List, $List$$Type} from "java.util.List"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"
import {$RuleBasedBlockStateProvider$Rule, $RuleBasedBlockStateProvider$Rule$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.RuleBasedBlockStateProvider$Rule"
import {$Record} from "java.lang.Record"

export class $RuleBasedBlockStateProvider extends $Record {
static readonly "CODEC": $Codec<($RuleBasedBlockStateProvider)>

constructor(arg0: $BlockStateProvider$$Type, arg1: $List$$Type<($RuleBasedBlockStateProvider$Rule$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getState"(arg0: $WorldGenLevel$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type): $BlockState
public "fallback"(): $BlockStateProvider
public "rules"(): $List<($RuleBasedBlockStateProvider$Rule)>
public static "simple"(arg0: $Block$$Type): $RuleBasedBlockStateProvider
public static "simple"(arg0: $BlockStateProvider$$Type): $RuleBasedBlockStateProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuleBasedBlockStateProvider$$Type = ({"rules"?: $List$$Type<($RuleBasedBlockStateProvider$Rule$$Type)>, "fallback"?: $BlockStateProvider$$Type}) | ([rules?: $List$$Type<($RuleBasedBlockStateProvider$Rule$$Type)>, fallback?: $BlockStateProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuleBasedBlockStateProvider$$Original = $RuleBasedBlockStateProvider;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.CherryFoliagePlacer" {
import {$FoliagePlacerType} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacerType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$FoliagePlacer$FoliageSetter$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageSetter"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$FoliagePlacer$FoliageAttachment$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $CherryFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($CherryFoliagePlacer)>
readonly "offset": $IntProvider
readonly "radius": $IntProvider

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: $IntProvider$$Type, arg3: float, arg4: float, arg5: float, arg6: float)

public "type"(): $FoliagePlacerType<(never)>
public "createFoliage"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: integer, arg5: $FoliagePlacer$FoliageAttachment$$Type, arg6: integer, arg7: integer, arg8: integer): void
public "shouldSkipLocation"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: boolean): boolean
public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CherryFoliagePlacer$$Type = ($CherryFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CherryFoliagePlacer$$Original = $CherryFoliagePlacer;}
declare module "net.minecraft.world.level.block.entity.BlockEntityType$BlockEntitySupplier" {
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockEntityType$BlockEntitySupplier$$Interface<T extends $BlockEntity> {

(arg0: $BlockPos, arg1: $BlockState): T
}

export class $BlockEntityType$BlockEntitySupplier<T extends $BlockEntity> implements $BlockEntityType$BlockEntitySupplier$$Interface {
 "create"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityType$BlockEntitySupplier$$Type<T> = ((arg0: $BlockPos, arg1: $BlockState) => T);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityType$BlockEntitySupplier$$Original<T> = $BlockEntityType$BlockEntitySupplier<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.LeaveVineDecorator" {
import {$TreeDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$TreeDecorator$Context$$Type} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context"
import {$TreeDecoratorType} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecoratorType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $LeaveVineDecorator extends $TreeDecorator {
static readonly "CODEC": $MapCodec<($LeaveVineDecorator)>

constructor(arg0: float)

public "type"(): $TreeDecoratorType<(never)>
public "place"(arg0: $TreeDecorator$Context$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LeaveVineDecorator$$Type = ($LeaveVineDecorator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LeaveVineDecorator$$Original = $LeaveVineDecorator;}
declare module "net.minecraft.world.level.chunk.storage.ChunkStorage" {
import {$DimensionDataStorage$$Type} from "net.minecraft.world.level.storage.DimensionDataStorage"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$RegionStorageInfo, $RegionStorageInfo$$Type} from "net.minecraft.world.level.chunk.storage.RegionStorageInfo"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$DataFixer, $DataFixer$$Type} from "com.mojang.datafixers.DataFixer"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$ChunkScanAccess} from "net.minecraft.world.level.chunk.storage.ChunkScanAccess"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$IOWorker} from "net.minecraft.world.level.chunk.storage.IOWorker"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Path$$Type} from "java.nio.file.Path"
import {$MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $ChunkStorage implements $AutoCloseable$$Interface {
readonly "fixerUpper": $DataFixer
static readonly "LAST_MONOLYTH_STRUCTURE_DATA_VERSION": integer
readonly "worker": $IOWorker

constructor(arg0: $RegionStorageInfo$$Type, arg1: $Path$$Type, arg2: $DataFixer$$Type, arg3: boolean)

public "write"(arg0: $ChunkPos$$Type, arg1: $CompoundTag$$Type): $CompletableFuture<(void)>
public "read"(arg0: $ChunkPos$$Type): $CompletableFuture<($Optional<($CompoundTag)>)>
public "close"(): void
public static "getVersion"(arg0: $CompoundTag$$Type): integer
public "storageInfo"(): $RegionStorageInfo
public "upgradeChunkTag"(arg0: $ResourceKey$$Type<($Level)>, arg1: $Supplier$$Type<($DimensionDataStorage$$Type)>, arg2: $CompoundTag$$Type, arg3: ($ResourceKey$$Type<($MapCodec$$Type<($ChunkGenerator$$Type)>)>)?): $CompoundTag
public "isOldChunkAround"(arg0: $ChunkPos$$Type, arg1: integer): boolean
public "chunkScanner"(): $ChunkScanAccess
public static "injectDatafixingContext"(arg0: $CompoundTag$$Type, arg1: $ResourceKey$$Type<($Level)>, arg2: ($ResourceKey$$Type<($MapCodec$$Type<($ChunkGenerator$$Type)>)>)?): void
public "handleLegacyStructureIndex"(arg0: $ChunkPos$$Type): void
public "flushWorker"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkStorage$$Type = ($ChunkStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkStorage$$Original = $ChunkStorage;}
declare module "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $BlockEntity$DataComponentInput$$Interface {
}

export class $BlockEntity$DataComponentInput implements $BlockEntity$DataComponentInput$$Interface {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntity$DataComponentInput$$Type = ($BlockEntity$DataComponentInput);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntity$DataComponentInput$$Original = $BlockEntity$DataComponentInput;}
declare module "net.minecraft.world.level.block.piston.PistonStructureResolver" {
import {$List} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $PistonStructureResolver {
static readonly "MAX_PUSH_DEPTH": integer

constructor(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: boolean)

public "resolve"(): boolean
public "getToDestroy"(): $List<($BlockPos)>
public "getPushDirection"(): $Direction
public "getToPush"(): $List<($BlockPos)>
get "toDestroy"(): $List<($BlockPos)>
get "pushDirection"(): $Direction
get "toPush"(): $List<($BlockPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PistonStructureResolver$$Type = ($PistonStructureResolver);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PistonStructureResolver$$Original = $PistonStructureResolver;}
declare module "net.minecraft.world.level.levelgen.structure.BoundingBox" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$Vec3i, $Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$ChunkPos} from "net.minecraft.world.level.ChunkPos"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $BoundingBox {
static readonly "CODEC": $Codec<($BoundingBox)>

constructor(arg0: $BlockPos$$Type)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer)

public "moved"(arg0: integer, arg1: integer, arg2: integer): $BoundingBox
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getLength"(): $Vec3i
/**
 * 
 * @deprecated
 */
public "move"(arg0: integer, arg1: integer, arg2: integer): $BoundingBox
/**
 * 
 * @deprecated
 */
public "move"(arg0: $Vec3i$$Type): $BoundingBox
public "intersects"(arg0: $BoundingBox$$Type): boolean
public "intersects"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
public "inflatedBy"(arg0: integer): $BoundingBox
public "inflatedBy"(arg0: integer, arg1: integer, arg2: integer): $BoundingBox
public "forAllCorners"(arg0: $Consumer$$Type<($BlockPos)>): void
public static "fromCorners"(arg0: $Vec3i$$Type, arg1: $Vec3i$$Type): $BoundingBox
public "maxX"(): integer
public "minX"(): integer
/**
 * 
 * @deprecated
 */
public "encapsulate"(arg0: $BlockPos$$Type): $BoundingBox
/**
 * 
 * @deprecated
 */
public "encapsulate"(arg0: $BoundingBox$$Type): $BoundingBox
public static "infinite"(): $BoundingBox
public "getCenter"(): $BlockPos
public "maxZ"(): integer
public "maxY"(): integer
public "minY"(): integer
public "minZ"(): integer
public static "orientBox"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: $Direction$$Type): $BoundingBox
public "intersectingChunks"(): $Stream<($ChunkPos)>
public "isInside"(arg0: integer, arg1: integer, arg2: integer): boolean
public "isInside"(arg0: $Vec3i$$Type): boolean
public static "encapsulatingBoxes"(arg0: $Iterable$$Type<($BoundingBox$$Type)>): $Optional<($BoundingBox)>
public static "encapsulatingPositions"(arg0: $Iterable$$Type<($BlockPos$$Type)>): $Optional<($BoundingBox)>
public "getXSpan"(): integer
public "getZSpan"(): integer
public "getYSpan"(): integer
get "length"(): $Vec3i
get "center"(): $BlockPos
get "XSpan"(): integer
get "ZSpan"(): integer
get "YSpan"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoundingBox$$Type = ($BoundingBox);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BoundingBox$$Original = $BoundingBox;}
declare module "net.minecraft.world.level.block.entity.CommandBlockEntity$Mode" {
import {$Enum} from "java.lang.Enum"

export class $CommandBlockEntity$Mode extends $Enum<($CommandBlockEntity$Mode)> {
static readonly "AUTO": $CommandBlockEntity$Mode
static readonly "REDSTONE": $CommandBlockEntity$Mode
static readonly "SEQUENCE": $CommandBlockEntity$Mode

public static "values"(): ($CommandBlockEntity$Mode)[]
public static "valueOf"(arg0: StringJS): $CommandBlockEntity$Mode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandBlockEntity$Mode$$Type = (("sequence") | ("auto") | ("redstone"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CommandBlockEntity$Mode$$Original = $CommandBlockEntity$Mode;}
declare module "net.minecraft.world.level.block.entity.SignText" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$FormattedCharSequence, $FormattedCharSequence$$Type} from "net.minecraft.util.FormattedCharSequence"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function$$Type} from "java.util.function.Function"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export class $SignText {
static readonly "DIRECT_CODEC": $Codec<($SignText)>
static readonly "LINES": integer

constructor()
constructor(arg0: ($Component$$Type)[], arg1: ($Component$$Type)[], arg2: $DyeColor$$Type, arg3: boolean)

public "getMessage"(arg0: integer, arg1: boolean): $Component
public "setColor"(arg0: $DyeColor$$Type): $SignText
public "setHasGlowingText"(arg0: boolean): $SignText
public "setMessage"(arg0: integer, arg1: $Component$$Type, arg2: $Component$$Type): $SignText
public "setMessage"(arg0: integer, arg1: $Component$$Type): $SignText
public "hasAnyClickCommands"(arg0: $Player$$Type): boolean
public "hasGlowingText"(): boolean
public "getRenderMessages"(arg0: boolean, arg1: $Function$$Type<($Component), ($FormattedCharSequence$$Type)>): ($FormattedCharSequence)[]
public "getMessages"(arg0: boolean): ($Component)[]
public "getColor"(): $DyeColor
public "hasMessage"(arg0: $Player$$Type): boolean
set "color"(value: $DyeColor$$Type)
get "color"(): $DyeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignText$$Type = ($SignText);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SignText$$Original = $SignText;}
declare module "net.minecraft.world.level.levelgen.structure.pools.ListPoolElement" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$StructurePoolElementType} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElementType"
import {$LiquidSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings"
import {$List, $List$$Type} from "java.util.List"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructurePoolElement, $StructurePoolElement$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElement"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3i} from "net.minecraft.core.Vec3i"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$StructureTemplatePool$Projection$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool$Projection"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$StructureTemplate$StructureBlockInfo} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $ListPoolElement extends $StructurePoolElement {
static readonly "CODEC": $MapCodec<($ListPoolElement)>

constructor(arg0: $List$$Type<($StructurePoolElement$$Type)>, arg1: $StructureTemplatePool$Projection$$Type)

public "toString"(): StringJS
public "getType"(): $StructurePoolElementType<(never)>
public "getSize"(arg0: $StructureTemplateManager$$Type, arg1: $Rotation$$Type): $Vec3i
public "getShuffledJigsawBlocks"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type, arg3: $RandomSource$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "place"(arg0: $StructureTemplateManager$$Type, arg1: $WorldGenLevel$$Type, arg2: $StructureManager$$Type, arg3: $ChunkGenerator$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type, arg6: $Rotation$$Type, arg7: $BoundingBox$$Type, arg8: $RandomSource$$Type, arg9: $LiquidSettings$$Type, arg10: boolean): boolean
public "setProjection"(arg0: $StructureTemplatePool$Projection$$Type): $StructurePoolElement
public "getBoundingBox"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type): $BoundingBox
get "type"(): $StructurePoolElementType<(never)>
set "projection"(value: $StructureTemplatePool$Projection$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListPoolElement$$Type = ($ListPoolElement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ListPoolElement$$Original = $ListPoolElement;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.MegaJungleTrunkPlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$TrunkPlacerType} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacerType"
import {$List} from "java.util.List"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$GiantTrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.GiantTrunkPlacer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $MegaJungleTrunkPlacer extends $GiantTrunkPlacer {
static readonly "CODEC": $MapCodec<($MegaJungleTrunkPlacer)>
static readonly "MAX_HEIGHT": integer
readonly "baseHeight": integer
readonly "heightRandA": integer
readonly "heightRandB": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "type"(): $TrunkPlacerType<(never)>
public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MegaJungleTrunkPlacer$$Type = ($MegaJungleTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MegaJungleTrunkPlacer$$Original = $MegaJungleTrunkPlacer;}
declare module "net.minecraft.world.level.block.entity.PotDecorations" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Record} from "java.lang.Record"

export class $PotDecorations extends $Record {
static readonly "CODEC": $Codec<($PotDecorations)>
static readonly "EMPTY": $PotDecorations
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($PotDecorations)>

constructor(arg0: ($Item$$Type)?, arg1: ($Item$$Type)?, arg2: ($Item$$Type)?, arg3: ($Item$$Type)?)
constructor(arg0: $Item$$Type, arg1: $Item$$Type, arg2: $Item$$Type, arg3: $Item$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "load"(arg0: $CompoundTag$$Type): $PotDecorations
public "save"(arg0: $CompoundTag$$Type): $CompoundTag
public "left"(): $Optional<($Item)>
public "right"(): $Optional<($Item)>
public "front"(): $Optional<($Item)>
public "back"(): $Optional<($Item)>
public "ordered"(): $List<($Item)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotDecorations$$Type = ({"front"?: ($Item$$Type)?, "back"?: ($Item$$Type)?, "left"?: ($Item$$Type)?, "right"?: ($Item$$Type)?}) | ([front?: ($Item$$Type)?, back?: ($Item$$Type)?, left?: ($Item$$Type)?, right?: ($Item$$Type)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PotDecorations$$Original = $PotDecorations;}
declare module "net.minecraft.world.level.block.entity.FurnaceBlockEntity" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$ReferenceArraySet} from "it.unimi.dsi.fastutil.objects.ReferenceArraySet"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$NonNullList} from "net.minecraft.core.NonNullList"
import {$ContainerData} from "net.minecraft.world.inventory.ContainerData"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AbstractFurnaceBlockEntity} from "net.minecraft.world.level.block.entity.AbstractFurnaceBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $FurnaceBlockEntity extends $AbstractFurnaceBlockEntity {
 "inventoryChangeListeners": $ReferenceArraySet
readonly "dataAccess": $ContainerData
static readonly "DATA_LIT_DURATION": integer
 "level": $Level
 "cookingTotalTime": integer
static readonly "SLOT_INPUT": integer
static readonly "DATA_COOKING_PROGRESS": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventoryHandlingTypeListeners": $ReferenceArraySet
static readonly "BURN_COOL_SPEED": integer
 "remove": boolean
 "cookingProgress": integer
 "litDuration": integer
 "worldPosition": $BlockPos
static readonly "DATA_COOKING_TOTAL_TIME": integer
static readonly "BURN_TIME_STANDARD": integer
static readonly "SLOT_RESULT": integer
 "lockKey": $LockCode
 "hasComparators": byte
static readonly "NUM_DATA_VALUES": integer
 "litTime": integer
static readonly "DATA_LIT_TIME": integer
 "items": $NonNullList<($ItemStack)>
static readonly "SLOT_FUEL": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getDefaultName"(): $Component
public "createMenu"(arg0: integer, arg1: $Inventory$$Type): $AbstractContainerMenu
public "setChanged"(): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public static "tryClear"(arg0: any): void
get "defaultName"(): $Component
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FurnaceBlockEntity$$Type = ($FurnaceBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FurnaceBlockEntity$$Original = $FurnaceBlockEntity;}
declare module "net.minecraft.world.level.storage.loot.LootContext$VisitedEntry" {
import {$LootDataType, $LootDataType$$Type} from "net.minecraft.world.level.storage.loot.LootDataType"
import {$Record} from "java.lang.Record"

export class $LootContext$VisitedEntry<T> extends $Record {
constructor(type: $LootDataType$$Type<(T)>, value: T)

public "type"(): $LootDataType<(T)>
public "value"(): T
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootContext$VisitedEntry$$Type<T> = ({"value"?: T, "type"?: $LootDataType$$Type<(T)>}) | ([value?: T, type?: $LootDataType$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootContext$VisitedEntry$$Original<T> = $LootContext$VisitedEntry<(T)>;}
declare module "net.minecraft.world.level.block.state.BlockBehaviour$StatePredicate" {
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockBehaviour$StatePredicate$$Interface {

(arg0: $BlockState, arg1: $BlockGetter, arg2: $BlockPos): boolean
}

export class $BlockBehaviour$StatePredicate implements $BlockBehaviour$StatePredicate$$Interface {
 "test"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviour$StatePredicate$$Type = ((arg0: $BlockState, arg1: $BlockGetter, arg2: $BlockPos) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviour$StatePredicate$$Original = $BlockBehaviour$StatePredicate;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.BeehiveDecorator" {
import {$TreeDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$TreeDecorator$Context$$Type} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context"
import {$TreeDecoratorType} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecoratorType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $BeehiveDecorator extends $TreeDecorator {
static readonly "CODEC": $MapCodec<($BeehiveDecorator)>

constructor(arg0: float)

public "type"(): $TreeDecoratorType<(never)>
public "place"(arg0: $TreeDecorator$Context$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeehiveDecorator$$Type = ($BeehiveDecorator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeehiveDecorator$$Original = $BeehiveDecorator;}
declare module "net.minecraft.world.level.entity.EntitySectionStorage" {
import {$Iterable} from "java.lang.Iterable"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$LongSet} from "it.unimi.dsi.fastutil.longs.LongSet"
import {$Visibility$$Type} from "net.minecraft.world.level.entity.Visibility"
import {$LongStream} from "java.util.stream.LongStream"
import {$EntitySection, $EntitySection$$Type} from "net.minecraft.world.level.entity.EntitySection"
import {$AbortableIterationConsumer$$Type} from "net.minecraft.util.AbortableIterationConsumer"
import {$EntityAccess} from "net.minecraft.world.level.entity.EntityAccess"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$Class$$Type} from "java.lang.Class"
import {$ChunkAwareEntityIterable$$Interface} from "net.caffeinemc.mods.lithium.common.world.ChunkAwareEntityIterable"
import {$Stream} from "java.util.stream.Stream"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$Long2ObjectFunction$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectFunction"

export class $EntitySectionStorage<T extends $EntityAccess> implements $ChunkAwareEntityIterable$$Interface {
constructor(arg0: $Class$$Type<(T)>, arg1: $Long2ObjectFunction$$Type<($Visibility$$Type)>)

public "remove"(arg0: long): void
public "count"(): integer
public "getOrCreateSection"(arg0: long): $EntitySection<(T)>
public "getAllChunksWithExistingSections"(): $LongSet
public "getExistingSectionPositionsInChunk"(arg0: long): $LongStream
public "forEachAccessibleNonEmptySection"(arg0: $AABB$$Type, arg1: $AbortableIterationConsumer$$Type<($EntitySection<(T)>)>): void
public "getEntities"<U extends $EntityAccess>(arg0: $EntityTypeTest$$Type<(T), (U)>, arg1: $AABB$$Type, arg2: $AbortableIterationConsumer$$Type<(U)>): void
public "getEntities"(arg0: $AABB$$Type, arg1: $AbortableIterationConsumer$$Type<(T)>): void
public "getSection"(arg0: long): $EntitySection<(T)>
public "getExistingSectionsInChunk"(arg0: long): $Stream<($EntitySection<(T)>)>
public "lithium$IterateEntitiesInTrackedSections"(): $Iterable
public "handler$bnh000$lithium$forEachInBox"(arg0: $AABB$$Type, arg1: $AbortableIterationConsumer$$Type, arg2: $CallbackInfo$$Type, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): void
get "allChunksWithExistingSections"(): $LongSet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySectionStorage$$Type<T> = ($EntitySectionStorage<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntitySectionStorage$$Original<T> = $EntitySectionStorage<(T)>;}
declare module "net.minecraft.world.level.block.state.properties.SculkSensorPhase" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $SculkSensorPhase extends $Enum<($SculkSensorPhase)> implements $StringRepresentable$$Interface {
static readonly "COOLDOWN": $SculkSensorPhase
static readonly "ACTIVE": $SculkSensorPhase
static readonly "INACTIVE": $SculkSensorPhase

public "toString"(): StringJS
public static "values"(): ($SculkSensorPhase)[]
public static "valueOf"(arg0: StringJS): $SculkSensorPhase
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkSensorPhase$$Type = (("inactive") | ("active") | ("cooldown"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkSensorPhase$$Original = $SculkSensorPhase;}
declare module "net.minecraft.world.level.pathfinder.PathFinder" {
import {$NodeEvaluator$$Type} from "net.minecraft.world.level.pathfinder.NodeEvaluator"
import {$Path} from "net.minecraft.world.level.pathfinder.Path"
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$PathNavigationRegion$$Type} from "net.minecraft.world.level.PathNavigationRegion"
import {$Set$$Type} from "java.util.Set"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Node$$Type} from "net.minecraft.world.level.pathfinder.Node"

export class $PathFinder {
constructor(arg0: $NodeEvaluator$$Type, arg1: integer)

public "distance"(arg0: $Node$$Type, arg1: $Node$$Type): float
public "findPath"(arg0: $PathNavigationRegion$$Type, arg1: $Mob$$Type, arg2: $Set$$Type<($BlockPos$$Type)>, arg3: float, arg4: integer, arg5: float): $Path
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathFinder$$Type = ($PathFinder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PathFinder$$Original = $PathFinder;}
declare module "net.minecraft.world.level.LevelSettings" {
import {$GameRules, $GameRules$$Type} from "net.minecraft.world.level.GameRules"
import {$Dynamic$$Type} from "com.mojang.serialization.Dynamic"
import {$Difficulty, $Difficulty$$Type} from "net.minecraft.world.Difficulty"
import {$Lifecycle, $Lifecycle$$Type} from "com.mojang.serialization.Lifecycle"
import {$GameType, $GameType$$Type} from "net.minecraft.world.level.GameType"
import {$WorldDataConfiguration, $WorldDataConfiguration$$Type} from "net.minecraft.world.level.WorldDataConfiguration"

export class $LevelSettings {
constructor(arg0: StringJS, arg1: $GameType$$Type, arg2: boolean, arg3: $Difficulty$$Type, arg4: boolean, arg5: $GameRules$$Type, arg6: $WorldDataConfiguration$$Type)
constructor(arg0: StringJS, arg1: $GameType$$Type, arg2: boolean, arg3: $Difficulty$$Type, arg4: boolean, arg5: $GameRules$$Type, arg6: $WorldDataConfiguration$$Type, arg7: $Lifecycle$$Type)

public static "parse"(arg0: $Dynamic$$Type<(never)>, arg1: $WorldDataConfiguration$$Type): $LevelSettings
public "copy"(): $LevelSettings
public "levelName"(): StringJS
public "gameType"(): $GameType
public "hardcore"(): boolean
public "difficulty"(): $Difficulty
public "getLifecycle"(): $Lifecycle
public "withLifecycle"(arg0: $Lifecycle$$Type): $LevelSettings
public "gameRules"(): $GameRules
public "allowCommands"(): boolean
public "getDataConfiguration"(): $WorldDataConfiguration
public "withDataConfiguration"(arg0: $WorldDataConfiguration$$Type): $LevelSettings
public "withGameType"(arg0: $GameType$$Type): $LevelSettings
public "withDifficulty"(arg0: $Difficulty$$Type): $LevelSettings
get "lifecycle"(): $Lifecycle
get "dataConfiguration"(): $WorldDataConfiguration
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelSettings$$Type = ($LevelSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelSettings$$Original = $LevelSettings;}
declare module "net.minecraft.world.level.biome.AmbientParticleSettings" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

export class $AmbientParticleSettings {
static readonly "CODEC": $Codec<($AmbientParticleSettings)>

constructor(arg0: $ParticleOptions$$Type, arg1: float)

public "getOptions"(): $ParticleOptions
public "canSpawn"(arg0: $RandomSource$$Type): boolean
get "options"(): $ParticleOptions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AmbientParticleSettings$$Type = ($AmbientParticleSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AmbientParticleSettings$$Original = $AmbientParticleSettings;}
declare module "net.minecraft.world.level.levelgen.WorldOptions" {
import {$OptionalLong, $OptionalLong$$Type} from "java.util.OptionalLong"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $WorldOptions {
static readonly "CODEC": $MapCodec<($WorldOptions)>
static readonly "DEMO_OPTIONS": $WorldOptions

constructor(arg0: long, arg1: boolean, arg2: boolean)

public "seed"(): long
public "withSeed"(arg0: $OptionalLong$$Type): $WorldOptions
public "generateStructures"(): boolean
public "withBonusChest"(arg0: boolean): $WorldOptions
public "withStructures"(arg0: boolean): $WorldOptions
public "generateBonusChest"(): boolean
public static "defaultWithRandomSeed"(): $WorldOptions
public static "parseSeed"(arg0: StringJS): $OptionalLong
public "isOldCustomizedWorld"(): boolean
public static "randomSeed"(): long
get "oldCustomizedWorld"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldOptions$$Type = ($WorldOptions);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldOptions$$Original = $WorldOptions;}
declare module "net.minecraft.world.level.chunk.storage.RegionFileStorage" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$Long2ObjectLinkedOpenHashMap} from "it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap"
import {$RegionFile} from "net.minecraft.world.level.chunk.storage.RegionFile"
import {$RegionStorageInfo, $RegionStorageInfo$$Type} from "net.minecraft.world.level.chunk.storage.RegionStorageInfo"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$StreamTagVisitor$$Type} from "net.minecraft.nbt.StreamTagVisitor"

export class $RegionFileStorage implements $AutoCloseable$$Interface {
readonly "folder": $Path
readonly "regionCache": $Long2ObjectLinkedOpenHashMap<($RegionFile)>
static readonly "ANVIL_EXTENSION": StringJS

constructor(arg0: $RegionStorageInfo$$Type, arg1: $Path$$Type, arg2: boolean)

public "flush"(): void
public "info"(): $RegionStorageInfo
public "write"(arg0: $ChunkPos$$Type, arg1: $CompoundTag$$Type): void
public "read"(arg0: $ChunkPos$$Type): $CompoundTag
public "close"(): void
public "scanChunk"(arg0: $ChunkPos$$Type, arg1: $StreamTagVisitor$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegionFileStorage$$Type = ($RegionFileStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegionFileStorage$$Original = $RegionFileStorage;}
declare module "net.minecraft.world.level.block.Rotation" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$List} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$OctahedralGroup} from "com.mojang.math.OctahedralGroup"

export class $Rotation extends $Enum<($Rotation)> implements $StringRepresentable$$Interface {
static readonly "COUNTERCLOCKWISE_90": $Rotation
static readonly "CODEC": $Codec<($Rotation)>
static readonly "CLOCKWISE_90": $Rotation
static readonly "CLOCKWISE_180": $Rotation
static readonly "NONE": $Rotation

public static "values"(): ($Rotation)[]
public static "valueOf"(arg0: StringJS): $Rotation
public "rotate"(arg0: $Direction$$Type): $Direction
public "rotate"(arg0: integer, arg1: integer): integer
public "getRotated"(arg0: $Rotation$$Type): $Rotation
public static "getRandom"(arg0: $RandomSource$$Type): $Rotation
public "getSerializedName"(): StringJS
public "rotation"(): $OctahedralGroup
public static "getShuffled"(arg0: $RandomSource$$Type): $List<($Rotation)>
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Rotation$$Type = (("none") | ("clockwise_90") | ("180") | ("counterclockwise_90"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Rotation$$Original = $Rotation;}
declare module "net.minecraft.world.level.levelgen.XoroshiroRandomSource" {
import {$RandomSource, $RandomSource$$Interface} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RandomSupport$Seed128bit$$Type} from "net.minecraft.world.level.levelgen.RandomSupport$Seed128bit"
import {$PositionalRandomFactory} from "net.minecraft.world.level.levelgen.PositionalRandomFactory"

export class $XoroshiroRandomSource implements $RandomSource$$Interface {
static readonly "CODEC": $Codec<($XoroshiroRandomSource)>

constructor(arg0: long, arg1: long)
constructor(arg0: $RandomSupport$Seed128bit$$Type)
constructor(arg0: long)

public "nextDouble"(): double
public "nextInt"(arg0: integer): integer
public "nextInt"(): integer
public "setSeed"(arg0: long): void
public "nextLong"(): long
public "nextBoolean"(): boolean
public "nextFloat"(): float
public "nextGaussian"(): double
public "fork"(): $RandomSource
public "forkPositional"(): $PositionalRandomFactory
public "consumeCount"(arg0: integer): void
public static "create"(arg0: long): $RandomSource
public static "create"(): $RandomSource
public "nextInt"(arg0: integer, arg1: integer): integer
public "triangle"(arg0: double, arg1: double): double
public static "createNewThreadLocalInstance"(): $RandomSource
public "nextIntBetweenInclusive"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public static "createThreadSafe"(): $RandomSource
set "seed"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $XoroshiroRandomSource$$Type = ($XoroshiroRandomSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $XoroshiroRandomSource$$Original = $XoroshiroRandomSource;}
declare module "net.minecraft.world.level.biome.Climate$Parameter" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Record} from "java.lang.Record"

export class $Climate$Parameter extends $Record {
static readonly "CODEC": $Codec<($Climate$Parameter)>

constructor(arg0: long, arg1: long)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "min"(): long
public "max"(): long
public "distance"(arg0: long): long
public "distance"(arg0: $Climate$Parameter$$Type): long
public static "point"(arg0: float): $Climate$Parameter
public static "span"(arg0: float, arg1: float): $Climate$Parameter
public static "span"(arg0: $Climate$Parameter$$Type, arg1: $Climate$Parameter$$Type): $Climate$Parameter
public "span"(arg0: $Climate$Parameter$$Type): $Climate$Parameter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Climate$Parameter$$Type = ({"max"?: long, "min"?: long}) | ([max?: long, min?: long]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Climate$Parameter$$Original = $Climate$Parameter;}
declare module "net.minecraft.world.level.material.FluidState" {
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Holder} from "net.minecraft.core.Holder"
import {$Map$Entry} from "java.util.Map$Entry"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function} from "java.util.function.Function"
import {$PathType, $PathType$$Type} from "net.minecraft.world.level.pathfinder.PathType"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$FluidType} from "net.neoforged.neoforge.fluids.FluidType"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Reference2ObjectArrayMap$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectArrayMap"
import {$NorthstarFluidState$$Interface} from "com.lightning.northstar.accessor.NorthstarFluidState"
import {$SealingMode$$Type} from "com.lightning.northstar.world.sealer.SealingMode"
import {$IFluidStateExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IFluidStateExtension"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$StateHolder} from "net.minecraft.world.level.block.state.StateHolder"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Boat$$Type} from "net.minecraft.world.entity.vehicle.Boat"
import {$ParticleOptions} from "net.minecraft.core.particles.ParticleOptions"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $FluidState extends $StateHolder<($Fluid), ($FluidState)> implements $IFluidStateExtension$$Interface, $NorthstarFluidState$$Interface {
static readonly "PROPERTIES_TAG": StringJS
readonly "owner": O
static readonly "AMOUNT_MAX": integer
static readonly "CODEC": $Codec<($FluidState)>
static readonly "PROPERTY_ENTRY_TO_STRING_FUNCTION": $Function<($Map$Entry<($Property<(never)>), ($Comparable<(never)>)>), (StringJS)>
static readonly "AMOUNT_FULL": integer
static readonly "NAME_TAG": StringJS
readonly "propertiesCodec": $MapCodec<(S)>

constructor(arg0: $Fluid$$Type, arg1: $Reference2ObjectArrayMap$$Type<($Property$$Type<(never)>), ($Comparable$$Type<(never)>)>, arg2: $MapCodec$$Type<($FluidState$$Type)>)

public "isEmpty"(): boolean
public "holder"(): $Holder<($Fluid)>
public "getType"(): $Fluid
public "is"(arg0: $Fluid$$Type): boolean
public "is"(arg0: $HolderSet$$Type<($Fluid)>): boolean
public "is"(arg0: $TagKey$$Type<($Fluid)>): boolean
public "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type): void
public "getShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $VoxelShape
public "animateTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type): void
public "createLegacyBlock"(): $BlockState
public "northstar$onSealUpdated"(level: $Level$$Type, pos: $BlockPos$$Type, mode: $SealingMode$$Type): void
public "northstar$combust"(level: $Level$$Type, pos: $BlockPos$$Type): void
public "getTags"(): $Stream<($TagKey<($Fluid)>)>
public "getDripParticle"(): $ParticleOptions
public "getFlow"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Vec3
public "getAmount"(): integer
public "getHeight"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): float
public "isSource"(): boolean
public "isSourceOfType"(arg0: $Fluid$$Type): boolean
public "randomTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type): void
public "isRandomlyTicking"(): boolean
public "getOwnHeight"(): float
public "canBeReplacedWith"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Fluid$$Type, arg3: $Direction$$Type): boolean
/**
 * 
 * @deprecated
 */
public "getExplosionResistance"(): float
public "handler$ghh000$northstar$tick"(level: $Level$$Type, pos: $BlockPos$$Type, info: $CallbackInfo$$Type): void
public "shouldRenderBackwardUpFace"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "move"(arg0: $LivingEntity$$Type, arg1: $Vec3$$Type, arg2: double): boolean
public "canHydrate"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockPos$$Type): boolean
public "supportsBoating"(arg0: $Boat$$Type): boolean
public "canConvertToSource"(arg0: $Level$$Type, arg1: $BlockPos$$Type): boolean
public "getBlockPathType"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Mob$$Type, arg3: boolean): $PathType
public "getExplosionResistance"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Explosion$$Type): float
public "canExtinguish"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "getFluidType"(): $FluidType
public "getAdjacentBlockPathType"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Mob$$Type, arg3: $PathType$$Type): $PathType
get "empty"(): boolean
get "type"(): $Fluid
get "tags"(): $Stream<($TagKey<($Fluid)>)>
get "dripParticle"(): $ParticleOptions
get "amount"(): integer
get "source"(): boolean
get "randomlyTicking"(): boolean
get "ownHeight"(): float
get "explosionResistance"(): float
get "fluidType"(): $FluidType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidState$$Type = ($FluidState);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidState$$Original = $FluidState;}
declare module "net.minecraft.world.level.storage.DimensionDataStorage" {
import {$MixinDimensionDataStorage$$Interface} from "noobanidus.mods.lootr.common.mixins.MixinDimensionDataStorage"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$AccessorMixinDimensionDataStorage$$Interface} from "noobanidus.mods.lootr.common.mixins.AccessorMixinDimensionDataStorage"
import {$Map} from "java.util.Map"
import {$File, $File$$Type} from "java.io.File"
import {$DataFixTypes$$Type} from "net.minecraft.util.datafix.DataFixTypes"
import {$SavedData, $SavedData$$Type} from "net.minecraft.world.level.saveddata.SavedData"
import {$SavedData$Factory$$Type} from "net.minecraft.world.level.saveddata.SavedData$Factory"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$DataFixer$$Type} from "com.mojang.datafixers.DataFixer"

export class $DimensionDataStorage implements $AccessorMixinDimensionDataStorage$$Interface, $MixinDimensionDataStorage$$Interface {
readonly "dataFolder": $File

constructor(arg0: $File$$Type, arg1: $DataFixer$$Type, arg2: $HolderLookup$Provider$$Type)

public "get"<T extends $SavedData>(arg0: $SavedData$Factory$$Type<(T)>, arg1: StringJS): T
public "set"(arg0: StringJS, arg1: $SavedData$$Type): void
public "computeIfAbsent"<T extends $SavedData>(arg0: $SavedData$Factory$$Type<(T)>, arg1: StringJS): T
public "save"(): void
public "getCache"(): $Map
public "readTagFromDisk"(arg0: StringJS, arg1: $DataFixTypes$$Type, arg2: integer): $CompoundTag
get "cache"(): $Map
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionDataStorage$$Type = ($DimensionDataStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DimensionDataStorage$$Original = $DimensionDataStorage;}
declare module "net.minecraft.world.level.block.MultifaceBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$StateDefinition$Builder$$Type} from "net.minecraft.world.level.block.state.StateDefinition$Builder"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$Set} from "java.util.Set"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$StateDefinition} from "net.minecraft.world.level.block.state.StateDefinition"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$Collection$$Type} from "java.util.Collection"
import {$SoundType} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$MultifaceSpreader} from "net.minecraft.world.level.block.MultifaceSpreader"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $MultifaceBlock extends $Block {
 "explosionResistance": float
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "UPDATE_ALL": integer
 "drops": $ResourceKey<($LootTable)>
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
readonly "dynamicShape": boolean
static readonly "DIRECTIONS": ($Direction)[]
 "soundType": $SoundType
 "jumpFactor": float
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
 "speedFactor": float
 "friction": float
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
 "hasCollision": boolean

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "isValidStateForPlacement"(arg0: $BlockGetter$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public static "unpack"(arg0: byte): $Set<($Direction)>
public static "pack"(arg0: $Collection$$Type<($Direction$$Type)>): byte
public "canBeReplaced"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): boolean
public "codec"(): $MapCodec<($MultifaceBlock)>
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public static "hasAnyFace"(arg0: $BlockState$$Type): boolean
public static "hasFace"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public static "canAttachTo"(arg0: $BlockGetter$$Type, arg1: $Direction$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public static "availableFaces"(arg0: $BlockState$$Type): $Set<($Direction)>
public "getSpreader"(): $MultifaceSpreader
public static "getFaceProperty"(arg0: $Direction$$Type): $BooleanProperty
public "isFaceSupported"(arg0: $Direction$$Type): boolean
public "createBlockStateDefinition"(arg0: $StateDefinition$Builder$$Type<($Block$$Type), ($BlockState$$Type)>): void
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "getStateForPlacement"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): $BlockState
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "spreader"(): $MultifaceSpreader
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultifaceBlock$$Type = ($MultifaceBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultifaceBlock$$Original = $MultifaceBlock;}
declare module "net.minecraft.world.level.lighting.LightEventListener" {
import {$SectionPos$$Type} from "net.minecraft.core.SectionPos"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"

export interface $LightEventListener$$Interface {
}

export class $LightEventListener implements $LightEventListener$$Interface {
 "checkBlock"(arg0: $BlockPos$$Type): void
 "setLightEnabled"(arg0: $ChunkPos$$Type, arg1: boolean): void
 "runLightUpdates"(): integer
 "updateSectionStatus"(arg0: $SectionPos$$Type, arg1: boolean): void
 "updateSectionStatus"(arg0: $BlockPos$$Type, arg1: boolean): void
 "hasLightWork"(): boolean
 "propagateLightSources"(arg0: $ChunkPos$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LightEventListener$$Type = ($LightEventListener);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LightEventListener$$Original = $LightEventListener;}
declare module "net.minecraft.world.level.entity.EntityTypeTest" {
import {$Class, $Class$$Type} from "java.lang.Class"

export interface $EntityTypeTest$$Interface<B, T> {
get "baseClass"(): $Class<(B)>
}

export class $EntityTypeTest<B, T> implements $EntityTypeTest$$Interface {
static "forClass"<B, T>(arg0: $Class$$Type<(T)>): $EntityTypeTest<(B), (T)>
 "tryCast"(arg0: B): T
 "getBaseClass"(): $Class<(B)>
static "forExactClass"<B, T>(arg0: $Class$$Type<(T)>): $EntityTypeTest<(B), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityTypeTest$$Type<B, T> = ($EntityTypeTest<(B), (T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityTypeTest$$Original<B, T> = $EntityTypeTest<(B), (T)>;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecoratorType" {
import {$TreeDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$AlterGroundDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.AlterGroundDecorator"
import {$LeaveVineDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.LeaveVineDecorator"
import {$TreeDecoratorTypeAccessor$$Interface} from "com.blackgear.vanillabackport.core.mixin.access.TreeDecoratorTypeAccessor"
import {$AttachedToLeavesDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.AttachedToLeavesDecorator"
import {$CocoaDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.CocoaDecorator"
import {$TrunkVineDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TrunkVineDecorator"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BeehiveDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.BeehiveDecorator"

export class $TreeDecoratorType<P extends $TreeDecorator> implements $TreeDecoratorTypeAccessor$$Interface {
static readonly "BEEHIVE": $TreeDecoratorType<($BeehiveDecorator)>
static readonly "LEAVE_VINE": $TreeDecoratorType<($LeaveVineDecorator)>
static readonly "TRUNK_VINE": $TreeDecoratorType<($TrunkVineDecorator)>
static readonly "ATTACHED_TO_LEAVES": $TreeDecoratorType<($AttachedToLeavesDecorator)>
static readonly "COCOA": $TreeDecoratorType<($CocoaDecorator)>
static readonly "ALTER_GROUND": $TreeDecoratorType<($AlterGroundDecorator)>

constructor(arg0: $MapCodec$$Type<(P)>)

public "codec"(): $MapCodec<(P)>
public static "createTreeDecorator$vanillabackport_$md$6d3b50$0"(arg0: $MapCodec$$Type): $TreeDecoratorType
public static "createTreeDecorator"<T extends $TreeDecorator>(codec: $MapCodec$$Type<(T)>): $TreeDecoratorType<(T)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenTreeDecoratorType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenTreeDecoratorTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TreeDecoratorType$$Type<P> = (Special.WorldgenTreeDecoratorType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TreeDecoratorType$$Original<P> = $TreeDecoratorType<(P)>;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.DarkOakFoliagePlacer" {
import {$FoliagePlacerType} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacerType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$FoliagePlacer$FoliageSetter$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageSetter"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$FoliagePlacer$FoliageAttachment$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $DarkOakFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($DarkOakFoliagePlacer)>
readonly "offset": $IntProvider
readonly "radius": $IntProvider

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type)

public "type"(): $FoliagePlacerType<(never)>
public "createFoliage"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: integer, arg5: $FoliagePlacer$FoliageAttachment$$Type, arg6: integer, arg7: integer, arg8: integer): void
public "shouldSkipLocation"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: boolean): boolean
public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
public "shouldSkipLocationSigned"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DarkOakFoliagePlacer$$Type = ($DarkOakFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DarkOakFoliagePlacer$$Original = $DarkOakFoliagePlacer;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicateType" {
import {$AllOfPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.AllOfPredicate"
import {$TrueBlockPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.TrueBlockPredicate"
import {$MatchingBlocksPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.MatchingBlocksPredicate"
import {$HasSturdyFacePredicate} from "net.minecraft.world.level.levelgen.blockpredicates.HasSturdyFacePredicate"
import {$MatchingFluidsPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.MatchingFluidsPredicate"
import {$SolidPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.SolidPredicate"
import {$UnobstructedPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.UnobstructedPredicate"
import {$ReplaceablePredicate} from "net.minecraft.world.level.levelgen.blockpredicates.ReplaceablePredicate"
import {$InsideWorldBoundsPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.InsideWorldBoundsPredicate"
import {$WouldSurvivePredicate} from "net.minecraft.world.level.levelgen.blockpredicates.WouldSurvivePredicate"
import {$BlockPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$NotPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.NotPredicate"
import {$MatchingBlockTagPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.MatchingBlockTagPredicate"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$AnyOfPredicate} from "net.minecraft.world.level.levelgen.blockpredicates.AnyOfPredicate"

export interface $BlockPredicateType$$Interface<P extends $BlockPredicate> {

(): $MapCodec$$Type<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.BlockPredicateType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.BlockPredicateTypeTag
}

export class $BlockPredicateType<P extends $BlockPredicate> implements $BlockPredicateType$$Interface {
static readonly "UNOBSTRUCTED": $BlockPredicateType<($UnobstructedPredicate)>
static readonly "MATCHING_BLOCK_TAG": $BlockPredicateType<($MatchingBlockTagPredicate)>
static readonly "MATCHING_BLOCKS": $BlockPredicateType<($MatchingBlocksPredicate)>
static readonly "INSIDE_WORLD_BOUNDS": $BlockPredicateType<($InsideWorldBoundsPredicate)>
static readonly "ALL_OF": $BlockPredicateType<($AllOfPredicate)>
static readonly "TRUE": $BlockPredicateType<($TrueBlockPredicate)>
static readonly "ANY_OF": $BlockPredicateType<($AnyOfPredicate)>
static readonly "HAS_STURDY_FACE": $BlockPredicateType<($HasSturdyFacePredicate)>
static readonly "NOT": $BlockPredicateType<($NotPredicate)>
static readonly "REPLACEABLE": $BlockPredicateType<($ReplaceablePredicate)>
static readonly "WOULD_SURVIVE": $BlockPredicateType<($WouldSurvivePredicate)>
static readonly "MATCHING_FLUIDS": $BlockPredicateType<($MatchingFluidsPredicate)>
static readonly "SOLID": $BlockPredicateType<($SolidPredicate)>

 "codec"(): $MapCodec<(P)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPredicateType$$Type<P> = (Special.BlockPredicateType) | (() => $MapCodec$$Type<(P)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPredicateType$$Original<P> = $BlockPredicateType<(P)>;}
declare module "net.minecraft.world.level.levelgen.Heightmap$Types" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Predicate} from "java.util.function.Predicate"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $Heightmap$Types extends $Enum<($Heightmap$Types)> implements $StringRepresentable$$Interface {
static readonly "OCEAN_FLOOR": $Heightmap$Types
static readonly "MOTION_BLOCKING_NO_LEAVES": $Heightmap$Types
static readonly "CODEC": $Codec<($Heightmap$Types)>
static readonly "MOTION_BLOCKING": $Heightmap$Types
static readonly "WORLD_SURFACE": $Heightmap$Types
static readonly "OCEAN_FLOOR_WG": $Heightmap$Types
static readonly "WORLD_SURFACE_WG": $Heightmap$Types

public static "values"(): ($Heightmap$Types)[]
public static "valueOf"(arg0: StringJS): $Heightmap$Types
public "isOpaque"(): $Predicate<($BlockState)>
public "sendToClient"(): boolean
public "getSerializedName"(): StringJS
public "keepAfterWorldgen"(): boolean
public "getSerializationKey"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "opaque"(): $Predicate<($BlockState)>
get "serializedName"(): StringJS
get "serializationKey"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Heightmap$Types$$Type = (("world_surface_wg") | ("world_surface") | ("ocean_floor_wg") | ("ocean_floor") | ("motion_blocking") | ("motion_blocking_no_leaves"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Heightmap$Types$$Original = $Heightmap$Types;}
declare module "net.minecraft.world.level.block.Block$BlockStatePairKey" {
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $Block$BlockStatePairKey {
constructor(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type)

public "equals"(arg0: any): boolean
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Block$BlockStatePairKey$$Type = ($Block$BlockStatePairKey);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Block$BlockStatePairKey$$Original = $Block$BlockStatePairKey;}
declare module "net.minecraft.world.level.block.entity.JukeboxBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$SpecialLogicInventory$$Interface} from "net.fabricmc.fabric.impl.transfer.item.SpecialLogicInventory"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TransactionContext$$Type} from "net.fabricmc.fabric.api.transfer.v1.transaction.TransactionContext"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$Set$$Type} from "java.util.Set"
import {$ContainerSingleItem$BlockContainerSingleItem$$Interface} from "net.minecraft.world.ticks.ContainerSingleItem$BlockContainerSingleItem"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$JukeboxSongPlayer} from "net.minecraft.world.item.JukeboxSongPlayer"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $JukeboxBlockEntity extends $BlockEntity implements $Clearable$$Interface, $ContainerSingleItem$BlockContainerSingleItem$$Interface, $SpecialLogicInventory$$Interface {
 "worldPosition": $BlockPos
static readonly "SONG_ITEM_TAG_ID": StringJS
 "level": $Level
readonly "jukeboxSongPlayer": $JukeboxSongPlayer
static readonly "TICKS_SINCE_SONG_STARTED_TAG_ID": StringJS
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $JukeboxBlockEntity$$Type): void
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getComparatorOutput"(): integer
public "setSongItemWithoutPlaying"(arg0: $ItemStack$$Type): void
public "getContainerBlockEntity"(): $BlockEntity
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getMaxStackSize"(): integer
public "fabric_setSuppress"(arg0: boolean): void
public "popOutTheItem"(): void
public "getSongPlayer"(): $JukeboxSongPlayer
public "getTheItem"(): $ItemStack
public "setTheItem"(arg0: $ItemStack$$Type): void
public "canTakeItem"(arg0: $Container$$Type, arg1: integer, arg2: $ItemStack$$Type): boolean
public "fabric_onFinalCommit"(arg0: integer, arg1: $ItemStack$$Type, arg2: $ItemStack$$Type): void
public "tryForcePlaySong"(): void
public "splitTheItem"(arg0: integer): $ItemStack
public "onSongChanged"(): void
public static "tryClear"(arg0: any): void
public "clearContent"(): void
public "stillValid"(arg0: $Player$$Type): boolean
public "fabric_onTransfer"(arg0: integer, arg1: $TransactionContext$$Type): void
public "isEmpty"(): boolean
public "getItem"(arg0: integer): $ItemStack
public "removeItemNoUpdate"(arg0: integer): $ItemStack
public "getContainerSize"(): integer
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public "removeTheItem"(): $ItemStack
public "getMaxStackSize"(arg0: $ItemStack$$Type): integer
public "hasAnyMatching"(arg0: $Predicate$$Type<($ItemStack)>): boolean
public "stopOpen"(arg0: $Player$$Type): void
public "hasAnyOf"(arg0: $Set$$Type<($Item$$Type)>): boolean
public "countItem"(arg0: $Item$$Type): integer
public "startOpen"(arg0: $Player$$Type): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "canReceiveTransferCooldown"(): boolean
public "setTransferCooldown"(arg0: long): void
public "lithium$itemInsertionTestRequiresStackSize1"(): boolean
public "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "getWidth"(): integer
public "getHeight"(): integer
public "isMutable"(): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
public "getSlots"(): integer
public "getSlotLimit"(slot: integer): integer
public "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
public "setChanged"(): void
public "getStackInSlot"(slot: integer): $ItemStack
public "asContainer"(): $Container
public "clear"(): void
public "self"(): $Container
public "getBlock"(level: $Level$$Type): $LevelBlock
public "isEmpty"(): boolean
public "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(): integer
public "countNonEmpty"(match: $ItemPredicate$$Type): integer
public "getAllItems"(): $List<($ItemStack)>
public "clear"(match: $ItemPredicate$$Type): void
public "find"(): integer
public "find"(match: $ItemPredicate$$Type): integer
public "count"(): integer
public "count"(match: $ItemPredicate$$Type): integer
get "comparatorOutput"(): integer
set "songItemWithoutPlaying"(value: $ItemStack$$Type)
get "containerBlockEntity"(): $BlockEntity
get "maxStackSize"(): integer
get "songPlayer"(): $JukeboxSongPlayer
get "theItem"(): $ItemStack
set "theItem"(value: $ItemStack$$Type)
get "empty"(): boolean
get "containerSize"(): integer
set "transferCooldown"(value: long)
get "width"(): integer
get "height"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "changed"(): void
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JukeboxBlockEntity$$Type = ($JukeboxBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JukeboxBlockEntity$$Original = $JukeboxBlockEntity;}
declare module "net.minecraft.world.level.levelgen.carver.CarvingContext" {
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$NoiseChunk$$Type} from "net.minecraft.world.level.levelgen.NoiseChunk"
import {$Optional} from "java.util.Optional"
import {$RandomState, $RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$SurfaceRules$RuleSource$$Type} from "net.minecraft.world.level.levelgen.SurfaceRules$RuleSource"
import {$NoiseBasedChunkGenerator$$Type} from "net.minecraft.world.level.levelgen.NoiseBasedChunkGenerator"
import {$Function$$Type} from "java.util.function.Function"
import {$WorldGenerationContext} from "net.minecraft.world.level.levelgen.WorldGenerationContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $CarvingContext extends $WorldGenerationContext {
constructor(arg0: $NoiseBasedChunkGenerator$$Type, arg1: $RegistryAccess$$Type, arg2: $LevelHeightAccessor$$Type, arg3: $NoiseChunk$$Type, arg4: $RandomState$$Type, arg5: $SurfaceRules$RuleSource$$Type)

/**
 * 
 * @deprecated
 */
public "topMaterial"(arg0: $Function$$Type<($BlockPos), ($Holder$$Type<($Biome$$Type)>)>, arg1: $ChunkAccess$$Type, arg2: $BlockPos$$Type, arg3: boolean): $Optional<($BlockState)>
/**
 * 
 * @deprecated
 */
public "registryAccess"(): $RegistryAccess
public "randomState"(): $RandomState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarvingContext$$Type = ($CarvingContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarvingContext$$Original = $CarvingContext;}
declare module "net.minecraft.world.level.levelgen.synth.NormalNoise$NoiseParameters" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$List$$Type} from "java.util.List"
import {$DoubleList, $DoubleList$$Type} from "it.unimi.dsi.fastutil.doubles.DoubleList"
import {$Holder} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $NormalNoise$NoiseParameters extends $Record {
static readonly "CODEC": $Codec<($Holder<($NormalNoise$NoiseParameters)>)>
static readonly "DIRECT_CODEC": $Codec<($NormalNoise$NoiseParameters)>

constructor(arg0: integer, arg1: $DoubleList$$Type)
constructor(arg0: integer, arg1: double, ...arg2: (double)[])
constructor(arg0: integer, arg1: $List$$Type<(double)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "amplitudes"(): $DoubleList
public "firstOctave"(): integer
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenNoise
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenNoiseTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NormalNoise$NoiseParameters$$Type = (Special.WorldgenNoise) | ({"firstOctave"?: integer, "amplitudes"?: $DoubleList$$Type}) | ([firstOctave?: integer, amplitudes?: $DoubleList$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NormalNoise$NoiseParameters$$Original = $NormalNoise$NoiseParameters;}
declare module "net.minecraft.world.level.levelgen.WorldGenSettings" {
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Codec} from "com.mojang.serialization.Codec"
import {$DataResult} from "com.mojang.serialization.DataResult"
import {$WorldDimensions, $WorldDimensions$$Type} from "net.minecraft.world.level.levelgen.WorldDimensions"
import {$WorldOptions, $WorldOptions$$Type} from "net.minecraft.world.level.levelgen.WorldOptions"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"
import {$Record} from "java.lang.Record"

export class $WorldGenSettings extends $Record {
static readonly "CODEC": $Codec<($WorldGenSettings)>

constructor(arg0: $WorldOptions$$Type, arg1: $WorldDimensions$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "encode"<T>(arg0: $DynamicOps$$Type<(T)>, arg1: $WorldOptions$$Type, arg2: $RegistryAccess$$Type): $DataResult<(T)>
public static "encode"<T>(arg0: $DynamicOps$$Type<(T)>, arg1: $WorldOptions$$Type, arg2: $WorldDimensions$$Type): $DataResult<(T)>
public "dimensions"(): $WorldDimensions
public "options"(): $WorldOptions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldGenSettings$$Type = ({"dimensions"?: $WorldDimensions$$Type, "options"?: $WorldOptions$$Type}) | ([dimensions?: $WorldDimensions$$Type, options?: $WorldOptions$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldGenSettings$$Original = $WorldGenSettings;}
declare module "net.minecraft.world.level.entity.ChunkStatusUpdateListener" {
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$FullChunkStatus, $FullChunkStatus$$Type} from "net.minecraft.server.level.FullChunkStatus"

export interface $ChunkStatusUpdateListener$$Interface {

(arg0: $ChunkPos, arg1: $FullChunkStatus): void
}

export class $ChunkStatusUpdateListener implements $ChunkStatusUpdateListener$$Interface {
 "onChunkStatusChange"(arg0: $ChunkPos$$Type, arg1: $FullChunkStatus$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkStatusUpdateListener$$Type = ((arg0: $ChunkPos, arg1: $FullChunkStatus) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkStatusUpdateListener$$Original = $ChunkStatusUpdateListener;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.BlockMatchTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$RuleTestType} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTestType"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockMatchTest extends $RuleTest {
static readonly "CODEC": $MapCodec<($BlockMatchTest)>

constructor(arg0: $Block$$Type)

public "test"(arg0: $BlockState$$Type, arg1: $RandomSource$$Type): boolean
public "getType"(): $RuleTestType<(never)>
get "type"(): $RuleTestType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockMatchTest$$Type = ($BlockMatchTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockMatchTest$$Original = $BlockMatchTest;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.WeightedStateProvider" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BlockStateProviderType} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProviderType"
import {$BlockStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SimpleWeightedRandomList$Builder$$Type} from "net.minecraft.util.random.SimpleWeightedRandomList$Builder"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$SimpleWeightedRandomList$$Type} from "net.minecraft.util.random.SimpleWeightedRandomList"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WeightedStateProvider extends $BlockStateProvider {
static readonly "CODEC": $MapCodec<($WeightedStateProvider)>

constructor(arg0: $SimpleWeightedRandomList$Builder$$Type<($BlockState$$Type)>)
constructor(arg0: $SimpleWeightedRandomList$$Type<($BlockState$$Type)>)

public "type"(): $BlockStateProviderType<(never)>
public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WeightedStateProvider$$Type = ($WeightedStateProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WeightedStateProvider$$Original = $WeightedStateProvider;}
declare module "net.minecraft.world.level.saveddata.maps.MapItemSavedData$MapPatch" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Optional} from "java.util.Optional"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$MapItemSavedData$$Type} from "net.minecraft.world.level.saveddata.maps.MapItemSavedData"
import {$Record} from "java.lang.Record"

export class $MapItemSavedData$MapPatch extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($Optional<($MapItemSavedData$MapPatch)>)>

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: (byte)[])

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "width"(): integer
public "startY"(): integer
public "startX"(): integer
public "height"(): integer
public "applyToMap"(arg0: $MapItemSavedData$$Type): void
public "mapColors"(): (byte)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapItemSavedData$MapPatch$$Type = ({"width"?: integer, "startY"?: integer, "startX"?: integer, "height"?: integer, "mapColors"?: (byte)[]}) | ([width?: integer, startY?: integer, startX?: integer, height?: integer, mapColors?: (byte)[]]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapItemSavedData$MapPatch$$Original = $MapItemSavedData$MapPatch;}
declare module "net.minecraft.world.level.levelgen.carver.WorldCarver" {
import {$BlockPos$MutableBlockPos$$Type} from "net.minecraft.core.BlockPos$MutableBlockPos"
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ConfiguredWorldCarver} from "net.minecraft.world.level.levelgen.carver.ConfiguredWorldCarver"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$CaveCarverConfiguration} from "net.minecraft.world.level.levelgen.carver.CaveCarverConfiguration"
import {$Aquifer$$Type} from "net.minecraft.world.level.levelgen.Aquifer"
import {$CanyonCarverConfiguration} from "net.minecraft.world.level.levelgen.carver.CanyonCarverConfiguration"
import {$CarvingContext$$Type} from "net.minecraft.world.level.levelgen.carver.CarvingContext"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$Function$$Type} from "java.util.function.Function"
import {$CarvingMask$$Type} from "net.minecraft.world.level.chunk.CarvingMask"
import {$CarverConfiguration, $CarverConfiguration$$Type} from "net.minecraft.world.level.levelgen.carver.CarverConfiguration"
import {$WorldCarver$CarveSkipChecker$$Type} from "net.minecraft.world.level.levelgen.carver.WorldCarver$CarveSkipChecker"
import {$Set} from "java.util.Set"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$MutableBoolean$$Type} from "org.apache.commons.lang3.mutable.MutableBoolean"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $WorldCarver<C extends $CarverConfiguration> {
static readonly "CAVE": $WorldCarver<($CaveCarverConfiguration)>
static readonly "LAVA": $FluidState
static readonly "CANYON": $WorldCarver<($CanyonCarverConfiguration)>
static readonly "CAVE_AIR": $BlockState
static readonly "AIR": $BlockState
 "liquids": $Set<($Fluid)>
static readonly "NETHER_CAVE": $WorldCarver<($CaveCarverConfiguration)>
static readonly "WATER": $FluidState

constructor(arg0: $Codec$$Type<(C)>)

public "configuredCodec"(): $MapCodec<($ConfiguredWorldCarver<(C)>)>
public "carveEllipsoid"(arg0: $CarvingContext$$Type, arg1: C, arg2: $ChunkAccess$$Type, arg3: $Function$$Type<($BlockPos), ($Holder$$Type<($Biome$$Type)>)>, arg4: $Aquifer$$Type, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: $CarvingMask$$Type, arg11: $WorldCarver$CarveSkipChecker$$Type): boolean
public "canReplaceBlock"(arg0: C, arg1: $BlockState$$Type): boolean
public "isStartChunk"(arg0: C, arg1: $RandomSource$$Type): boolean
public "getRange"(): integer
public static "canReach"(arg0: $ChunkPos$$Type, arg1: double, arg2: double, arg3: integer, arg4: integer, arg5: float): boolean
public "configured"(arg0: C): $ConfiguredWorldCarver<(C)>
public "carveBlock"(arg0: $CarvingContext$$Type, arg1: C, arg2: $ChunkAccess$$Type, arg3: $Function$$Type<($BlockPos), ($Holder$$Type<($Biome$$Type)>)>, arg4: $CarvingMask$$Type, arg5: $BlockPos$MutableBlockPos$$Type, arg6: $BlockPos$MutableBlockPos$$Type, arg7: $Aquifer$$Type, arg8: $MutableBoolean$$Type): boolean
public "carve"(arg0: $CarvingContext$$Type, arg1: C, arg2: $ChunkAccess$$Type, arg3: $Function$$Type<($BlockPos), ($Holder$$Type<($Biome$$Type)>)>, arg4: $RandomSource$$Type, arg5: $Aquifer$$Type, arg6: $ChunkPos$$Type, arg7: $CarvingMask$$Type): boolean
get "range"(): integer
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenCarver
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenCarverTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldCarver$$Type<C> = (Special.WorldgenCarver);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldCarver$$Original<C> = $WorldCarver<(C)>;}
declare module "net.minecraft.world.level.levelgen.feature.BonusChestFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration, $NoneFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $BonusChestFeature extends $Feature<($NoneFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($NoneFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($NoneFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BonusChestFeature$$Type = ($BonusChestFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BonusChestFeature$$Original = $BonusChestFeature;}
declare module "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerData" {
import {$TrialSpawnerState$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerState"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$TrialSpawner$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawner"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$SimpleWeightedRandomList} from "net.minecraft.util.random.SimpleWeightedRandomList"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$SpawnData, $SpawnData$$Type} from "net.minecraft.world.level.SpawnData"
import {$Set, $Set$$Type} from "java.util.Set"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$TrialSpawnerConfig$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerConfig"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $TrialSpawnerData {
 "nextMobSpawnsAt": long
 "oSpin": double
 "totalMobsSpawned": integer
static "MAP_CODEC": $MapCodec<($TrialSpawnerData)>
readonly "detectedPlayers": $Set<($UUID)>
 "ejectingLootTable": $Optional<($ResourceKey<($LootTable)>)>
 "spin": double
 "displayEntity": $Entity
static readonly "TAG_SPAWN_DATA": StringJS
 "cooldownEndsAt": long
readonly "currentMobs": $Set<($UUID)>
 "nextSpawnData": $Optional<($SpawnData)>

constructor()
constructor(arg0: $Set$$Type<($UUID$$Type)>, arg1: $Set$$Type<($UUID$$Type)>, arg2: long, arg3: long, arg4: integer, arg5: ($SpawnData$$Type)?, arg6: ($ResourceKey$$Type<($LootTable$$Type)>)?)

public "reset"(): void
public "getUpdateTag"(arg0: $TrialSpawnerState$$Type): $CompoundTag
public "getSpin"(): double
public "getOSpin"(): double
public "getOrCreateNextSpawnData"(arg0: $TrialSpawner$$Type, arg1: $RandomSource$$Type): $SpawnData
public "resetAfterBecomingOminous"(arg0: $TrialSpawner$$Type, arg1: $ServerLevel$$Type): void
public "isReadyToSpawnNextMob"(arg0: $ServerLevel$$Type, arg1: $TrialSpawnerConfig$$Type, arg2: integer): boolean
public "haveAllCurrentMobsDied"(): boolean
public "hasFinishedSpawningAllMobs"(arg0: $TrialSpawnerConfig$$Type, arg1: integer): boolean
public "countAdditionalPlayers"(arg0: $BlockPos$$Type): integer
public "isReadyToOpenShutter"(arg0: $ServerLevel$$Type, arg1: float, arg2: integer): boolean
public "getOrCreateDisplayEntity"(arg0: $TrialSpawner$$Type, arg1: $Level$$Type, arg2: $TrialSpawnerState$$Type): $Entity
public "isReadyToEjectItems"(arg0: $ServerLevel$$Type, arg1: float, arg2: integer): boolean
public "isCooldownFinished"(arg0: $ServerLevel$$Type): boolean
public "getDispensingItems"(arg0: $ServerLevel$$Type, arg1: $TrialSpawnerConfig$$Type, arg2: $BlockPos$$Type): $SimpleWeightedRandomList<($ItemStack)>
public "hasMobToSpawn"(arg0: $TrialSpawner$$Type, arg1: $RandomSource$$Type): boolean
public "tryDetectPlayers"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $TrialSpawner$$Type): void
public "setEntityId"(arg0: $TrialSpawner$$Type, arg1: $RandomSource$$Type, arg2: $EntityType$$Type<(never)>): void
get "OSpin"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrialSpawnerData$$Type = ($TrialSpawnerData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrialSpawnerData$$Original = $TrialSpawnerData;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings" {
import {$StructureTemplate$Palette, $StructureTemplate$Palette$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$Palette"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$StructureProcessor, $StructureProcessor$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$Mirror, $Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$LiquidSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings"
import {$Rotation, $Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$List, $List$$Type} from "java.util.List"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $StructurePlaceSettings {
constructor()

public "copy"(): $StructurePlaceSettings
public "clearProcessors"(): $StructurePlaceSettings
public "addProcessor"(arg0: $StructureProcessor$$Type): $StructurePlaceSettings
public "setRotation"(arg0: $Rotation$$Type): $StructurePlaceSettings
public "setIgnoreEntities"(arg0: boolean): $StructurePlaceSettings
public "isIgnoreEntities"(): boolean
public "getProcessors"(): $List<($StructureProcessor)>
public "setBoundingBox"(arg0: $BoundingBox$$Type): $StructurePlaceSettings
public "setFinalizeEntities"(arg0: boolean): $StructurePlaceSettings
public "getRandom"(arg0: $BlockPos$$Type): $RandomSource
public "setMirror"(arg0: $Mirror$$Type): $StructurePlaceSettings
public "setRandom"(arg0: $RandomSource$$Type): $StructurePlaceSettings
public "getMirror"(): $Mirror
public "getRotationPivot"(): $BlockPos
public "setKnownShape"(arg0: boolean): $StructurePlaceSettings
public "popProcessor"(arg0: $StructureProcessor$$Type): $StructurePlaceSettings
public "setLiquidSettings"(arg0: $LiquidSettings$$Type): $StructurePlaceSettings
public "setRotationPivot"(arg0: $BlockPos$$Type): $StructurePlaceSettings
public "getRotation"(): $Rotation
public "getBoundingBox"(): $BoundingBox
public "getKnownShape"(): boolean
public "getRandomPalette"(arg0: $List$$Type<($StructureTemplate$Palette$$Type)>, arg1: $BlockPos$$Type): $StructureTemplate$Palette
public "shouldFinalizeEntities"(): boolean
public "shouldApplyWaterlogging"(): boolean
set "rotation"(value: $Rotation$$Type)
set "ignoreEntities"(value: boolean)
get "ignoreEntities"(): boolean
get "processors"(): $List<($StructureProcessor)>
set "boundingBox"(value: $BoundingBox$$Type)
set "finalizeEntities"(value: boolean)
set "mirror"(value: $Mirror$$Type)
set "random"(value: $RandomSource$$Type)
get "mirror"(): $Mirror
get "rotationPivot"(): $BlockPos
set "knownShape"(value: boolean)
set "liquidSettings"(value: $LiquidSettings$$Type)
set "rotationPivot"(value: $BlockPos$$Type)
get "rotation"(): $Rotation
get "boundingBox"(): $BoundingBox
get "knownShape"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePlaceSettings$$Type = ($StructurePlaceSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePlaceSettings$$Original = $StructurePlaceSettings;}
declare module "net.minecraft.world.level.storage.loot.functions.LootItemFunction$Builder" {
import {$LootItemFunction, $LootItemFunction$$Type} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction"

export interface $LootItemFunction$Builder$$Interface {

(): $LootItemFunction$$Type
}

export class $LootItemFunction$Builder implements $LootItemFunction$Builder$$Interface {
 "build"(): $LootItemFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootItemFunction$Builder$$Type = (() => $LootItemFunction$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootItemFunction$Builder$$Original = $LootItemFunction$Builder;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.AttachedToLeavesDecorator" {
import {$TreeDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$TreeDecorator$Context$$Type} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$TreeDecoratorType} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecoratorType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $AttachedToLeavesDecorator extends $TreeDecorator {
readonly "requiredEmptyBlocks": integer
static readonly "CODEC": $MapCodec<($AttachedToLeavesDecorator)>
readonly "directions": $List<($Direction)>
readonly "probability": float
readonly "exclusionRadiusY": integer
readonly "blockProvider": $BlockStateProvider
readonly "exclusionRadiusXZ": integer

constructor(arg0: float, arg1: integer, arg2: integer, arg3: $BlockStateProvider$$Type, arg4: integer, arg5: $List$$Type<($Direction$$Type)>)

public "type"(): $TreeDecoratorType<(never)>
public "place"(arg0: $TreeDecorator$Context$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedToLeavesDecorator$$Type = ($AttachedToLeavesDecorator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttachedToLeavesDecorator$$Original = $AttachedToLeavesDecorator;}
declare module "net.minecraft.world.level.block.state.BlockBehaviour$BlockStateBase" {
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$LootParams$Builder$$Type} from "net.minecraft.world.level.storage.loot.LootParams$Builder"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Projectile$$Type} from "net.minecraft.world.entity.projectile.Projectile"
import {$RelativeURL} from "dev.latvian.mods.kubejs.web.RelativeURL"
import {$Map$Entry} from "java.util.Map$Entry"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Stream} from "java.util.stream.Stream"
import {$IBlockState$$Interface} from "org.embeddedt.modernfix.duck.IBlockState"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$SoundType} from "net.minecraft.world.level.block.SoundType"
import {$PathComputationType$$Type} from "net.minecraft.world.level.pathfinder.PathComputationType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$StateHolder} from "net.minecraft.world.level.block.state.StateHolder"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$SupportType$$Type} from "net.minecraft.world.level.block.SupportType"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"
import {$MapColor} from "net.minecraft.world.level.material.MapColor"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$BlockStateBase$Cache} from "net.minecraft.world.level.block.state.BlockBehaviour$BlockStateBase$Cache"
import {$NoteBlockInstrument} from "net.minecraft.world.level.block.state.properties.NoteBlockInstrument"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$MenuProvider} from "net.minecraft.world.MenuProvider"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function} from "java.util.function.Function"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Reference2ObjectArrayMap$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectArrayMap"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult} from "net.minecraft.world.ItemInteractionResult"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$BlockStateKJS$$Interface} from "dev.latvian.mods.kubejs.core.BlockStateKJS"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"

export class $BlockBehaviour$BlockStateBase extends $StateHolder<($Block), ($BlockState)> implements $IBlockState$$Interface, $BlockStateKJS$$Interface {
static readonly "PROPERTIES_TAG": StringJS
readonly "owner": O
 "cache": $BlockBehaviour$BlockStateBase$Cache
static readonly "PROPERTY_ENTRY_TO_STRING_FUNCTION": $Function<($Map$Entry<($Property<(never)>), ($Comparable<(never)>)>), (StringJS)>
static readonly "NAME_TAG": StringJS
readonly "propertiesCodec": $MapCodec<(S)>

constructor(arg0: $Block$$Type, arg1: $Reference2ObjectArrayMap$$Type<($Property$$Type<(never)>), ($Comparable$$Type<(never)>)>, arg2: $MapCodec$$Type<($BlockState$$Type)>)

public "is"(arg0: $HolderSet$$Type<($Block)>): boolean
public "is"(arg0: $TagKey$$Type<($Block)>): boolean
public "is"(arg0: $TagKey$$Type<($Block)>, arg1: $Predicate$$Type<($BlockBehaviour$BlockStateBase)>): boolean
public "is"(arg0: $Block$$Type): boolean
public "is"(arg0: $Holder$$Type<($Block)>): boolean
public "is"(arg0: $ResourceKey$$Type<($Block)>): boolean
public "getOffset"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $Vec3
/**
 * 
 * @deprecated
 */
public "rotate"(arg0: $Rotation$$Type): $BlockState
public "tick"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type): void
public "initCache"(): void
public "clearCache"(): void
public "getSeed"(arg0: $BlockPos$$Type): long
public "getShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): $VoxelShape
public "getShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $VoxelShape
public "attack"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Player$$Type): void
public "instrument"(): $NoteBlockInstrument
public "mirror"(arg0: $Mirror$$Type): $BlockState
public "asState"(): $BlockState
public "getTicker"<T extends $BlockEntity>(arg0: $Level$$Type, arg1: $BlockEntityType$$Type<(T)>): $BlockEntityTicker<(T)>
public "requiresCorrectToolForDrops"(): boolean
public "getFluidState"(): $FluidState
public "useItemOn"(arg0: $ItemStack$$Type, arg1: $Level$$Type, arg2: $Player$$Type, arg3: $InteractionHand$$Type, arg4: $BlockHitResult$$Type): $ItemInteractionResult
public "isAir"(): boolean
public "isCollisionShapeFullBlock"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "getPistonPushReaction"(): $PushReaction
public "hasBlockEntity"(): boolean
public "getCollisionShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $VoxelShape
public "getCollisionShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): $VoxelShape
public "entityInside"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): void
public "onExplosionHit"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Explosion$$Type, arg3: $BiConsumer$$Type<($ItemStack), ($BlockPos)>): void
public "isSuffocating"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "getDestroySpeed"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): float
public "isCacheInvalid"(): boolean
public "updateNeighbourShapes"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: integer, arg3: integer): void
public "updateNeighbourShapes"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: integer): void
public "entityCanStandOnFace"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type, arg3: $Direction$$Type): boolean
public "isRedstoneConductor"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "getBlock"(): $Block
/**
 * 
 * @deprecated
 */
public "getLightEmission"(): integer
public "getLightBlock"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): integer
public "triggerEvent"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: integer, arg3: integer): boolean
public "handleNeighborChanged"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Block$$Type, arg3: $BlockPos$$Type, arg4: boolean): void
public "hasLargeCollisionShape"(): boolean
public "handler$zif000$iris$getShadeBrightness"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $CallbackInfoReturnable$$Type): void
public "handler$fkj000$ferritecore$cacheStateTail"(arg0: $CallbackInfo$$Type): void
public "handler$fkj000$ferritecore$cacheStateHead"(arg0: $CallbackInfo$$Type): void
public "getBlockHolder"(): $Holder<($Block)>
public "isValidSpawn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $EntityType$$Type<(never)>): boolean
public "entityCanStandOn"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): boolean
public "hasOffsetFunction"(): boolean
public "isViewBlocking"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "hasPostProcess"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "emissiveRendering"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "updateIndirectNeighbourShapes"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: integer): void
public "updateIndirectNeighbourShapes"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: integer, arg3: integer): void
public "getTags"(): $Stream<($TagKey<($Block)>)>
public "getInteractionShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $VoxelShape
/**
 * 
 * @deprecated
 */
public "liquid"(): boolean
public "getSignal"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): integer
public "getRenderShape"(): $RenderShape
public "getDirectSignal"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): integer
public "isSignalSource"(): boolean
public "isFaceSturdy"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "isFaceSturdy"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: $SupportType$$Type): boolean
public "canBeReplaced"(arg0: $BlockPlaceContext$$Type): boolean
public "canBeReplaced"(arg0: $Fluid$$Type): boolean
public "canBeReplaced"(): boolean
public "onRemove"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: boolean): void
public "onProjectileHit"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockHitResult$$Type, arg3: $Projectile$$Type): void
public "skipRendering"(arg0: $BlockState$$Type, arg1: $Direction$$Type): boolean
public "updateShape"(arg0: $Direction$$Type, arg1: $BlockState$$Type, arg2: $LevelAccessor$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type): $BlockState
/**
 * 
 * @deprecated
 */
public "ignitedByLava"(): boolean
public "hasAnalogOutputSignal"(): boolean
public "getDrops"(arg0: $LootParams$Builder$$Type): $List<($ItemStack)>
/**
 * 
 * @deprecated
 */
public "isSolid"(): boolean
public "canOcclude"(): boolean
public "onPlace"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: boolean): void
public "randomTick"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type): void
public "spawnAfterBreak"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type, arg3: boolean): void
public "isSolidRender"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "isRandomlyTicking"(): boolean
public "getMenuProvider"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $MenuProvider
public "useWithoutItem"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $BlockHitResult$$Type): $InteractionResult
public "getVisualShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): $VoxelShape
public "getMapColor"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $MapColor
public "getDestroyProgress"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): float
public "getShadeBrightness"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): float
public "isPathfindable"(arg0: $PathComputationType$$Type): boolean
public "getOcclusionShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $VoxelShape
public "shouldSpawnTerrainParticles"(): boolean
public "setLightEmission"(arg0: integer): void
public "setRequiresTool"(arg0: boolean): void
public "getBlockSupportShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $VoxelShape
public "propagatesSkylightDown"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "setDestroySpeed"(arg0: float): void
public "useShapeForLightOcclusion"(): boolean
public "getAnalogOutputSignal"(arg0: $Level$$Type, arg1: $BlockPos$$Type): integer
public "getFaceOcclusionShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): $VoxelShape
public "canSurvive"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
public "getSoundType"(): $SoundType
/**
 * 
 * @deprecated
 */
public "blocksMotion"(): boolean
public "toString"(): StringJS
public "getWebIconURL"(size: integer): $RelativeURL
public "randomTickOverride"(state: $BlockState$$Type, level: $ServerLevel$$Type, pos: $BlockPos$$Type, random: $RandomSource$$Type): boolean
public "getId"(): StringJS
public "getKey"(): $ResourceKey<($Block)>
public "asHolder"(): $Holder<($Block)>
public "getRegistry"(): $Registry<($Block)>
public "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
public "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
public "specialEquals"(o: any, shallow: boolean): boolean
public "getMod"(): StringJS
public "hasTag"(tag: $ResourceLocation$$Type): boolean
public "getIdLocation"(): $ResourceLocation
public "getTagKeys"(): $List<($TagKey<($Block)>)>
public "getTags"(): $List<($ResourceLocation)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "fluidState"(): $FluidState
get "air"(): boolean
get "pistonPushReaction"(): $PushReaction
get "cacheInvalid"(): boolean
get "block"(): $Block
get "lightEmission"(): integer
get "blockHolder"(): $Holder<($Block)>
get "tags"(): $Stream<($TagKey<($Block)>)>
get "renderShape"(): $RenderShape
get "signalSource"(): boolean
get "solid"(): boolean
get "randomlyTicking"(): boolean
set "lightEmission"(value: integer)
set "requiresTool"(value: boolean)
set "destroySpeed"(value: float)
get "soundType"(): $SoundType
get "id"(): StringJS
get "key"(): $ResourceKey<($Block)>
get "registry"(): $Registry<($Block)>
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviour$BlockStateBase$$Type = ($BlockBehaviour$BlockStateBase);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviour$BlockStateBase$$Original = $BlockBehaviour$BlockStateBase;}
declare module "net.minecraft.world.level.levelgen.feature.Feature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$SeagrassFeature} from "net.minecraft.world.level.levelgen.feature.SeagrassFeature"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$FeatureConfiguration, $FeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$Function$$Type} from "java.util.function.Function"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$LevelWriter$$Type} from "net.minecraft.world.level.LevelWriter"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $Feature<FC extends $FeatureConfiguration> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<(FC)>)

public static "isReplaceable"(arg0: $TagKey$$Type<($Block)>): $Predicate<($BlockState)>
public static "isDirt"(arg0: $BlockState$$Type): boolean
public "configuredCodec"(): $MapCodec<($ConfiguredFeature<(FC), ($Feature<(FC)>)>)>
public static "isGrassOrDirt"(arg0: $LevelSimulatedReader$$Type, arg1: $BlockPos$$Type): boolean
public static "checkNeighbors"(arg0: $Function$$Type<($BlockPos), ($BlockState$$Type)>, arg1: $BlockPos$$Type, arg2: $Predicate$$Type<($BlockState)>): boolean
public static "isAdjacentToAir"(arg0: $Function$$Type<($BlockPos), ($BlockState$$Type)>, arg1: $BlockPos$$Type): boolean
public "safeSetBlock"(arg0: $WorldGenLevel$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Predicate$$Type<($BlockState)>): void
public "place"(arg0: $FeaturePlaceContext$$Type<(FC)>): boolean
public "place"(arg0: FC, arg1: $WorldGenLevel$$Type, arg2: $ChunkGenerator$$Type, arg3: $RandomSource$$Type, arg4: $BlockPos$$Type): boolean
public "setBlock"(arg0: $LevelWriter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "markAboveForPostProcessing"(arg0: $WorldGenLevel$$Type, arg1: $BlockPos$$Type): void
public static "isStone"(arg0: $BlockState$$Type): boolean
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenFeature
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenFeatureTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Feature$$Type<FC> = (Special.WorldgenFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Feature$$Original<FC> = $Feature<(FC)>;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $BlockPileConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($BlockPileConfiguration)>
readonly "stateProvider": $BlockStateProvider

constructor(arg0: $BlockStateProvider$$Type)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPileConfiguration$$Type = ($BlockPileConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPileConfiguration$$Original = $BlockPileConfiguration;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.BlobFoliagePlacer" {
import {$FoliagePlacer$FoliageSetter$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageSetter"
import {$RecordCodecBuilder$Instance$$Type} from "com.mojang.serialization.codecs.RecordCodecBuilder$Instance"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$FoliagePlacerType} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacerType"
import {$Products$P3} from "com.mojang.datafixers.Products$P3"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$RecordCodecBuilder$Mu} from "com.mojang.serialization.codecs.RecordCodecBuilder$Mu"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$FoliagePlacer$FoliageAttachment$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $BlobFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($BlobFoliagePlacer)>
readonly "offset": $IntProvider
readonly "radius": $IntProvider
readonly "height": integer

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: integer)

public "type"(): $FoliagePlacerType<(never)>
public static "blobParts"<P extends $BlobFoliagePlacer>(arg0: $RecordCodecBuilder$Instance$$Type<(P)>): $Products$P3<($RecordCodecBuilder$Mu<(P)>), ($IntProvider), ($IntProvider), (integer)>
public "createFoliage"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: integer, arg5: $FoliagePlacer$FoliageAttachment$$Type, arg6: integer, arg7: integer, arg8: integer): void
public "shouldSkipLocation"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: boolean): boolean
public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlobFoliagePlacer$$Type = ($BlobFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlobFoliagePlacer$$Original = $BlobFoliagePlacer;}
declare module "net.minecraft.world.level.SpawnData" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$EquipmentTable, $EquipmentTable$$Type} from "net.minecraft.world.entity.EquipmentTable"
import {$SpawnData$CustomSpawnRules, $SpawnData$CustomSpawnRules$$Type} from "net.minecraft.world.level.SpawnData$CustomSpawnRules"
import {$SimpleWeightedRandomList} from "net.minecraft.util.random.SimpleWeightedRandomList"
import {$Record} from "java.lang.Record"

export class $SpawnData extends $Record {
static readonly "CODEC": $Codec<($SpawnData)>
static readonly "ENTITY_TAG": StringJS
static readonly "LIST_CODEC": $Codec<($SimpleWeightedRandomList<($SpawnData)>)>

constructor()
constructor(arg0: $CompoundTag$$Type, arg1: ($SpawnData$CustomSpawnRules$$Type)?, arg2: ($EquipmentTable$$Type)?)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "entityToSpawn"(): $CompoundTag
public "getEntityToSpawn"(): $CompoundTag
public "getEquipment"(): $Optional<($EquipmentTable)>
public "getCustomSpawnRules"(): $Optional<($SpawnData$CustomSpawnRules)>
public "equipment"(): $Optional<($EquipmentTable)>
public "customSpawnRules"(): $Optional<($SpawnData$CustomSpawnRules)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpawnData$$Type = ({"equipment"?: ($EquipmentTable$$Type)?, "entityToSpawn"?: $CompoundTag$$Type, "customSpawnRules"?: ($SpawnData$CustomSpawnRules$$Type)?}) | ([equipment?: ($EquipmentTable$$Type)?, entityToSpawn?: $CompoundTag$$Type, customSpawnRules?: ($SpawnData$CustomSpawnRules$$Type)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpawnData$$Original = $SpawnData;}
declare module "net.minecraft.world.level.block.entity.ChestBlockEntity" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$ContainerOpenersCounter} from "net.minecraft.world.level.block.entity.ContainerOpenersCounter"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LithiumInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumInventory"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RandomizableContainerBlockEntity} from "net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity"
import {$ReferenceArraySet} from "it.unimi.dsi.fastutil.objects.ReferenceArraySet"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Type, $InventoryChangeTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$InventoryChangeEmitter$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeEmitter"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$LidBlockEntity$$Interface} from "net.minecraft.world.level.block.entity.LidBlockEntity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $ChestBlockEntity extends $RandomizableContainerBlockEntity implements $LidBlockEntity$$Interface, $InventoryChangeEmitter$$Interface, $LithiumInventory$$Interface, $InventoryChangeTracker$$Interface {
 "inventoryChangeListeners": $ReferenceArraySet
 "worldPosition": $BlockPos
readonly "openersCounter": $ContainerOpenersCounter
 "lootTable": $ResourceKey<($LootTable)>
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventoryHandlingTypeListeners": $ReferenceArraySet
 "lockKey": $LockCode
 "hasComparators": byte
 "lootTableSeed": long
 "remove": boolean

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)
constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getDefaultName"(): $Component
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getContainerSize"(): integer
public "handler$bpk001$lithium$setInventoryStackListReplacement"(arg0: $NonNullList$$Type, arg1: $CallbackInfo$$Type): void
public "setBlockState"(arg0: $BlockState$$Type): void
public "getItems"(): $NonNullList<($ItemStack)>
public "triggerEvent"(arg0: integer, arg1: integer): boolean
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "setItems"(arg0: $NonNullList$$Type<($ItemStack$$Type)>): void
public "stopOpen"(arg0: $Player$$Type): void
public "startOpen"(arg0: $Player$$Type): void
public static "lidAnimateTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $ChestBlockEntity$$Type): void
public "recheckOpen"(): void
public static "getOpenCount"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): integer
public static "playSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $SoundEvent$$Type): void
public "getInventoryLithium"(): $NonNullList
public "setInventoryLithium"(arg0: $NonNullList$$Type): void
public "signalOpenCount"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: integer, arg4: integer): void
public static "swapContents"(arg0: $ChestBlockEntity$$Type, arg1: $ChestBlockEntity$$Type): void
public "getOpenNess"(arg0: float): float
public "createMenu"(arg0: integer, arg1: $Inventory$$Type): $AbstractContainerMenu
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitContentModified"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$emitRemoved"(): void
public "generateLootLithium"(): void
public "stopListenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "listenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "listenForContentChangesOnce"(arg0: $LithiumStackList$$Type, arg1: $InventoryChangeListener$$Type): void
public "stillValid"(arg0: $Player$$Type): boolean
public "setChanged"(): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public static "tryClear"(arg0: any): void
get "defaultName"(): $Component
get "containerSize"(): integer
set "blockState"(value: $BlockState$$Type)
get "items"(): $NonNullList<($ItemStack)>
set "items"(value: $NonNullList$$Type<($ItemStack$$Type)>)
get "inventoryLithium"(): $NonNullList
set "inventoryLithium"(value: $NonNullList$$Type)
get "changed"(): void
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestBlockEntity$$Type = ($ChestBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestBlockEntity$$Original = $ChestBlockEntity;}
declare module "net.minecraft.world.level.storage.loot.entries.EntryGroup$Builder" {
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$LootPoolEntryContainer} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer"
import {$LootPoolEntryContainer$Builder, $LootPoolEntryContainer$Builder$$Type} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer$Builder"
import {$ConditionUserBuilder} from "net.minecraft.world.level.storage.loot.predicates.ConditionUserBuilder"

export class $EntryGroup$Builder extends $LootPoolEntryContainer$Builder<($EntryGroup$Builder)> {
constructor(...arg0: ($LootPoolEntryContainer$Builder$$Type<(never)>)[])

public "append"(arg0: $LootPoolEntryContainer$Builder$$Type<(never)>): $EntryGroup$Builder
public "build"(): $LootPoolEntryContainer
public "getThis"(): $EntryGroup$Builder
public "when"(arg0: $LootItemCondition$Builder$$Type): $ConditionUserBuilder
get "this"(): $EntryGroup$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntryGroup$Builder$$Type = ($EntryGroup$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntryGroup$Builder$$Original = $EntryGroup$Builder;}
declare module "net.minecraft.world.level.block.entity.Hopper" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Container, $Container$$Type, $Container$$Interface} from "net.minecraft.world.Container"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$Set$$Type} from "java.util.Set"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB} from "net.minecraft.world.phys.AABB"

export interface $Hopper$$Interface extends $Container$$Interface {
get "gridAligned"(): boolean
get "suckAabb"(): $AABB
get "levelX"(): double
get "levelY"(): double
get "levelZ"(): double
get "empty"(): boolean
get "containerSize"(): integer
get "maxStackSize"(): integer
get "changed"(): void
set "transferCooldown"(value: long)
get "width"(): integer
get "height"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "changed"(): void
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
}

export class $Hopper implements $Hopper$$Interface {
static readonly "SUCK_AABB": $AABB

 "isGridAligned"(): boolean
 "getSuckAabb"(): $AABB
 "getLevelX"(): double
 "getLevelY"(): double
 "getLevelZ"(): double
 "isEmpty"(): boolean
 "getItem"(arg0: integer): $ItemStack
 "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
 "removeItemNoUpdate"(arg0: integer): $ItemStack
 "getContainerSize"(): integer
 "removeItem"(arg0: integer, arg1: integer): $ItemStack
 "getMaxStackSize"(): integer
 "getMaxStackSize"(arg0: $ItemStack$$Type): integer
 "hasAnyMatching"(arg0: $Predicate$$Type<($ItemStack)>): boolean
 "stillValid"(arg0: $Player$$Type): boolean
 "setChanged"(): void
 "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
 "stopOpen"(arg0: $Player$$Type): void
 "hasAnyOf"(arg0: $Set$$Type<($Item$$Type)>): boolean
 "countItem"(arg0: $Item$$Type): integer
 "startOpen"(arg0: $Player$$Type): void
 "canTakeItem"(arg0: $Container$$Type, arg1: integer, arg2: $ItemStack$$Type): boolean
static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
static "tryClear"(arg0: any): void
 "clearContent"(): void
 "canReceiveTransferCooldown"(): boolean
 "setTransferCooldown"(arg0: long): void
 "lithium$itemInsertionTestRequiresStackSize1"(): boolean
 "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
 "getWidth"(): integer
 "getHeight"(): integer
 "isMutable"(): boolean
 "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
 "getSlots"(): integer
 "getSlotLimit"(slot: integer): integer
 "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
 "setChanged"(): void
 "getStackInSlot"(slot: integer): $ItemStack
 "asContainer"(): $Container
 "clear"(): void
 "self"(): $Container
 "getBlock"(level: $Level$$Type): $LevelBlock
 "isEmpty"(): boolean
 "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "countNonEmpty"(): integer
 "countNonEmpty"(match: $ItemPredicate$$Type): integer
 "getAllItems"(): $List<($ItemStack)>
 "clear"(match: $ItemPredicate$$Type): void
 "find"(): integer
 "find"(match: $ItemPredicate$$Type): integer
 "count"(): integer
 "count"(match: $ItemPredicate$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Hopper$$Type = ($Hopper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Hopper$$Original = $Hopper;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration$TargetBlockState"
import {$List, $List$$Type} from "java.util.List"
import {$RuleTest$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $OreConfiguration implements $FeatureConfiguration$$Interface {
readonly "discardChanceOnAirExposure": float
static readonly "CODEC": $Codec<($OreConfiguration)>
readonly "size": integer
readonly "targetStates": $List<($OreConfiguration$TargetBlockState)>

constructor(arg0: $RuleTest$$Type, arg1: $BlockState$$Type, arg2: integer)
constructor(arg0: $RuleTest$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: float)
constructor(arg0: $List$$Type<($OreConfiguration$TargetBlockState$$Type)>, arg1: integer)
constructor(arg0: $List$$Type<($OreConfiguration$TargetBlockState$$Type)>, arg1: integer, arg2: float)

public static "target"(arg0: $RuleTest$$Type, arg1: $BlockState$$Type): $OreConfiguration$TargetBlockState
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OreConfiguration$$Type = ($OreConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OreConfiguration$$Original = $OreConfiguration;}
declare module "net.minecraft.world.level.levelgen.feature.featuresize.ThreeLayersFeatureSize" {
import {$FeatureSizeType} from "net.minecraft.world.level.levelgen.feature.featuresize.FeatureSizeType"
import {$OptionalInt$$Type} from "java.util.OptionalInt"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$FeatureSize} from "net.minecraft.world.level.levelgen.feature.featuresize.FeatureSize"

export class $ThreeLayersFeatureSize extends $FeatureSize {
static readonly "CODEC": $MapCodec<($ThreeLayersFeatureSize)>
static readonly "MAX_WIDTH": integer

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: $OptionalInt$$Type)

public "type"(): $FeatureSizeType<(never)>
public "getSizeAtHeight"(arg0: integer, arg1: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThreeLayersFeatureSize$$Type = ($ThreeLayersFeatureSize);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ThreeLayersFeatureSize$$Original = $ThreeLayersFeatureSize;}
declare module "net.minecraft.world.level.block.entity.vault.VaultServerData" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Codec} from "com.mojang.serialization.Codec"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Set, $Set$$Type} from "java.util.Set"

export class $VaultServerData {
static "CODEC": $Codec<($VaultServerData)>
 "isDirty": boolean
static readonly "TAG_NAME": StringJS

constructor(arg0: $Set$$Type<($UUID$$Type)>, arg1: long, arg2: $List$$Type<($ItemStack$$Type)>, arg3: integer)
constructor()

public "set"(arg0: $VaultServerData$$Type): void
public "getRewardedPlayers"(): $Set<($UUID)>
public "hasRewardedPlayer"(arg0: $Player$$Type): boolean
public "getItemsToEject"(): $List<($ItemStack)>
public "popNextItemToEject"(): $ItemStack
public "ejectionProgress"(): float
public "getNextItemToEject"(): $ItemStack
public "setItemsToEject"(arg0: $List$$Type<($ItemStack$$Type)>): void
public "pauseStateUpdatingUntil"(arg0: long): void
public "setLastInsertFailTimestamp"(arg0: long): void
public "markEjectionFinished"(): void
public "stateUpdatingResumesAt"(): long
public "getLastInsertFailTimestamp"(): long
public "addToRewardedPlayers"(arg0: $Player$$Type): void
get "rewardedPlayers"(): $Set<($UUID)>
get "itemsToEject"(): $List<($ItemStack)>
get "nextItemToEject"(): $ItemStack
set "itemsToEject"(value: $List$$Type<($ItemStack$$Type)>)
set "lastInsertFailTimestamp"(value: long)
get "lastInsertFailTimestamp"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VaultServerData$$Type = ($VaultServerData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VaultServerData$$Original = $VaultServerData;}
declare module "net.minecraft.world.level.chunk.storage.SectionStorage" {
import {$Iterable} from "java.lang.Iterable"
import {$LevelHeightAccessor, $LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$Runnable$$Type} from "java.lang.Runnable"
import {$BooleanSupplier$$Type} from "java.util.function.BooleanSupplier"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$Function$$Type} from "java.util.function.Function"
import {$ChunkIOErrorReporter$$Type} from "net.minecraft.world.level.chunk.storage.ChunkIOErrorReporter"
import {$SimpleRegionStorage$$Type} from "net.minecraft.world.level.chunk.storage.SimpleRegionStorage"
import {$Stream} from "java.util.stream.Stream"
import {$RegionBasedStorageSectionExtended$$Interface} from "net.caffeinemc.mods.lithium.common.world.interests.RegionBasedStorageSectionExtended"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $SectionStorage<R> implements $AutoCloseable$$Interface, $RegionBasedStorageSectionExtended$$Interface {
readonly "levelHeightAccessor": $LevelHeightAccessor

constructor(arg0: $SimpleRegionStorage$$Type, arg1: $Function$$Type<($Runnable), ($Codec$$Type<(R)>)>, arg2: $Function$$Type<($Runnable), (R)>, arg3: $RegistryAccess$$Type, arg4: $ChunkIOErrorReporter$$Type, arg5: $LevelHeightAccessor$$Type)

public "getOrCreate"(arg0: long): R
public "remove"(arg0: long): void
public "get"(arg0: long): $Optional<(R)>
public "flush"(arg0: $ChunkPos$$Type): void
public "close"(): void
public "tick"(arg0: $BooleanSupplier$$Type): void
public "getOrLoad"(arg0: long): $Optional<(R)>
public "setDirty"(arg0: long): void
public "hasWork"(): boolean
public "lithium$getInChunkColumn"(arg0: integer, arg1: integer): $Iterable
public "lithium$getWithinChunkColumn"(arg0: integer, arg1: integer): $Stream
public "outsideStoredRange"(arg0: long): boolean
public "onSectionLoad"(arg0: long): void
set "dirty"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SectionStorage$$Type<R> = ($SectionStorage<(R)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SectionStorage$$Original<R> = $SectionStorage<(R)>;}
declare module "net.minecraft.world.level.LevelHeightAccessor" {
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export interface $LevelHeightAccessor$$Interface {
get "maxBuildHeight"(): integer
get "maxSection"(): integer
get "minSection"(): integer
get "sectionsCount"(): integer
get "height"(): integer
get "minBuildHeight"(): integer
}

export class $LevelHeightAccessor implements $LevelHeightAccessor$$Interface {
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getMaxBuildHeight"(): integer
 "getSectionIndex"(arg0: integer): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionsCount"(): integer
 "getHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getMinBuildHeight"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelHeightAccessor$$Type = ($LevelHeightAccessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelHeightAccessor$$Original = $LevelHeightAccessor;}
declare module "net.minecraft.world.level.saveddata.maps.MapItemSavedData$HoldingPlayer" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$MapId$$Type} from "net.minecraft.world.level.saveddata.maps.MapId"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$MapItemSavedData, $MapItemSavedData$$Type} from "net.minecraft.world.level.saveddata.maps.MapItemSavedData"

export class $MapItemSavedData$HoldingPlayer {
readonly "this$0": $MapItemSavedData
 "step": integer
readonly "player": $Player

constructor(arg0: $MapItemSavedData$$Type, arg1: $Player$$Type)

public "nextUpdatePacket"(arg0: $MapId$$Type): $Packet<(never)>
public "markColorsDirty"(arg0: integer, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapItemSavedData$HoldingPlayer$$Type = ($MapItemSavedData$HoldingPlayer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapItemSavedData$HoldingPlayer$$Original = $MapItemSavedData$HoldingPlayer;}
declare module "net.minecraft.world.level.biome.AmbientMoodSettings" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $AmbientMoodSettings {
static readonly "CODEC": $Codec<($AmbientMoodSettings)>
static readonly "LEGACY_CAVE_SETTINGS": $AmbientMoodSettings

constructor(arg0: $Holder$$Type<($SoundEvent)>, arg1: integer, arg2: integer, arg3: double)

public "getBlockSearchExtent"(): integer
public "getSoundPositionOffset"(): double
public "getSoundEvent"(): $Holder<($SoundEvent)>
public "getTickDelay"(): integer
get "blockSearchExtent"(): integer
get "soundPositionOffset"(): double
get "soundEvent"(): $Holder<($SoundEvent)>
get "tickDelay"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AmbientMoodSettings$$Type = ($AmbientMoodSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AmbientMoodSettings$$Original = $AmbientMoodSettings;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $UnderwaterMagmaConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($UnderwaterMagmaConfiguration)>
readonly "floorSearchRange": integer
readonly "placementRadiusAroundFloor": integer
readonly "placementProbabilityPerValidPosition": float

constructor(arg0: integer, arg1: integer, arg2: float)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnderwaterMagmaConfiguration$$Type = ($UnderwaterMagmaConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UnderwaterMagmaConfiguration$$Original = $UnderwaterMagmaConfiguration;}
declare module "net.minecraft.world.level.biome.BiomeGenerationSettings" {
import {$Iterable} from "java.lang.Iterable"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$ConfiguredWorldCarver, $ConfiguredWorldCarver$$Type} from "net.minecraft.world.level.levelgen.carver.ConfiguredWorldCarver"
import {$Holder} from "net.minecraft.core.Holder"
import {$GenerationStep$Carving, $GenerationStep$Carving$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Carving"
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Supplier} from "java.util.function.Supplier"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Set} from "java.util.Set"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $BiomeGenerationSettings {
static readonly "CODEC": $MapCodec<($BiomeGenerationSettings)>
 "carvers": $Map<($GenerationStep$Carving), ($HolderSet<($ConfiguredWorldCarver<(never)>)>)>
 "featureSet": $Supplier<($Set<($PlacedFeature)>)>
static readonly "EMPTY": $BiomeGenerationSettings
 "flowerFeatures": $Supplier<($List<($ConfiguredFeature<(never), (never)>)>)>

constructor(arg0: $Map$$Type<($GenerationStep$Carving$$Type), ($HolderSet$$Type<($ConfiguredWorldCarver$$Type<(never)>)>)>, arg1: $List$$Type<($HolderSet$$Type<($PlacedFeature$$Type)>)>)

public "getCarvers"(arg0: $GenerationStep$Carving$$Type): $Iterable<($Holder<($ConfiguredWorldCarver<(never)>)>)>
public "features"(): $List<($HolderSet<($PlacedFeature)>)>
public "hasFeature"(arg0: $PlacedFeature$$Type): boolean
public "getCarvingStages"(): $Set<($GenerationStep$Carving)>
public "getFlowerFeatures"(): $List<($ConfiguredFeature<(never), (never)>)>
get "carvingStages"(): $Set<($GenerationStep$Carving)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeGenerationSettings$$Type = ($BiomeGenerationSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeGenerationSettings$$Original = $BiomeGenerationSettings;}
declare module "net.minecraft.world.level.storage.loot.predicates.LootItemConditionType" {
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$LootItemCondition, $LootItemCondition$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"
import {$Record} from "java.lang.Record"

export class $LootItemConditionType extends $Record {
constructor(arg0: $MapCodec$$Type<($LootItemCondition$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "codec"(): $MapCodec<($LootItemCondition)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.LootConditionType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.LootConditionTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootItemConditionType$$Type = (Special.LootConditionType) | ({"codec"?: $MapCodec$$Type<($LootItemCondition$$Type)>}) | ([codec?: $MapCodec$$Type<($LootItemCondition$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootItemConditionType$$Original = $LootItemConditionType;}
declare module "net.minecraft.world.level.storage.LevelStorageSource$LevelDirectory" {
import {$LocalDateTime$$Type} from "java.time.LocalDateTime"
import {$LevelResource$$Type} from "net.minecraft.world.level.storage.LevelResource"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$Record} from "java.lang.Record"

export class $LevelStorageSource$LevelDirectory extends $Record {
constructor(path: $Path$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "path"(): $Path
public "iconFile"(): $Path
public "dataFile"(): $Path
public "rawDataFile"(arg0: $LocalDateTime$$Type): $Path
public "resourcePath"(arg0: $LevelResource$$Type): $Path
public "directoryName"(): StringJS
public "oldDataFile"(): $Path
public "lockFile"(): $Path
public "corruptedDataFile"(arg0: $LocalDateTime$$Type): $Path
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelStorageSource$LevelDirectory$$Type = ({"path"?: $Path$$Type}) | ([path?: $Path$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelStorageSource$LevelDirectory$$Original = $LevelStorageSource$LevelDirectory;}
declare module "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext" {
import {$WorldgenRandom, $WorldgenRandom$$Type} from "net.minecraft.world.level.levelgen.WorldgenRandom"
import {$LevelHeightAccessor, $LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$RandomState, $RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$StructureTemplateManager, $StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$BiomeSource, $BiomeSource$$Type} from "net.minecraft.world.level.biome.BiomeSource"
import {$ChunkGenerator, $ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"
import {$Record} from "java.lang.Record"

export class $Structure$GenerationContext extends $Record {
constructor(arg0: $RegistryAccess$$Type, arg1: $ChunkGenerator$$Type, arg2: $BiomeSource$$Type, arg3: $RandomState$$Type, arg4: $StructureTemplateManager$$Type, arg5: long, arg6: $ChunkPos$$Type, arg7: $LevelHeightAccessor$$Type, arg8: $Predicate$$Type<($Holder<($Biome)>)>)
constructor(registryAccess: $RegistryAccess$$Type, chunkGenerator: $ChunkGenerator$$Type, biomeSource: $BiomeSource$$Type, randomState: $RandomState$$Type, structureTemplateManager: $StructureTemplateManager$$Type, random: $WorldgenRandom$$Type, seed: long, chunkPos: $ChunkPos$$Type, heightAccessor: $LevelHeightAccessor$$Type, validBiome: $Predicate$$Type<($Holder<($Biome)>)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "seed"(): long
public "random"(): $WorldgenRandom
public "validBiome"(): $Predicate<($Holder<($Biome)>)>
public "chunkGenerator"(): $ChunkGenerator
public "registryAccess"(): $RegistryAccess
public "structureTemplateManager"(): $StructureTemplateManager
public "randomState"(): $RandomState
public "chunkPos"(): $ChunkPos
public "heightAccessor"(): $LevelHeightAccessor
public "biomeSource"(): $BiomeSource
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Structure$GenerationContext$$Type = ({"chunkPos"?: $ChunkPos$$Type, "randomState"?: $RandomState$$Type, "biomeSource"?: $BiomeSource$$Type, "structureTemplateManager"?: $StructureTemplateManager$$Type, "chunkGenerator"?: $ChunkGenerator$$Type, "heightAccessor"?: $LevelHeightAccessor$$Type, "registryAccess"?: $RegistryAccess$$Type, "seed"?: long, "validBiome"?: $Predicate$$Type<($Holder$$Type<($Biome$$Type)>)>, "random"?: $WorldgenRandom$$Type}) | ([chunkPos?: $ChunkPos$$Type, randomState?: $RandomState$$Type, biomeSource?: $BiomeSource$$Type, structureTemplateManager?: $StructureTemplateManager$$Type, chunkGenerator?: $ChunkGenerator$$Type, heightAccessor?: $LevelHeightAccessor$$Type, registryAccess?: $RegistryAccess$$Type, seed?: long, validBiome?: $Predicate$$Type<($Holder$$Type<($Biome$$Type)>)>, random?: $WorldgenRandom$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Structure$GenerationContext$$Original = $Structure$GenerationContext;}
declare module "net.minecraft.world.level.border.WorldBorder$Settings" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$DynamicLike$$Type} from "com.mojang.serialization.DynamicLike"
import {$WorldBorder$$Type} from "net.minecraft.world.level.border.WorldBorder"

export class $WorldBorder$Settings {
constructor(arg0: double, arg1: double, arg2: double, arg3: double, arg4: integer, arg5: integer, arg6: double, arg7: long, arg8: double)
constructor(arg0: $WorldBorder$$Type)

public "write"(arg0: $CompoundTag$$Type): void
public static "read"(arg0: $DynamicLike$$Type<(never)>, arg1: $WorldBorder$Settings$$Type): $WorldBorder$Settings
public "getSize"(): double
public "getCenterZ"(): double
public "getCenterX"(): double
public "getDamagePerBlock"(): double
public "getSizeLerpTarget"(): double
public "getSafeZone"(): double
public "getWarningTime"(): integer
public "getWarningBlocks"(): integer
public "getSizeLerpTime"(): long
get "size"(): double
get "centerZ"(): double
get "centerX"(): double
get "damagePerBlock"(): double
get "sizeLerpTarget"(): double
get "safeZone"(): double
get "warningTime"(): integer
get "warningBlocks"(): integer
get "sizeLerpTime"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldBorder$Settings$$Type = ($WorldBorder$Settings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldBorder$Settings$$Original = $WorldBorder$Settings;}
declare module "net.minecraft.world.level.levelgen.feature.featuresize.FeatureSize" {
import {$FeatureSizeType} from "net.minecraft.world.level.levelgen.feature.featuresize.FeatureSizeType"
import {$RecordCodecBuilder} from "com.mojang.serialization.codecs.RecordCodecBuilder"
import {$Codec} from "com.mojang.serialization.Codec"
import {$OptionalInt, $OptionalInt$$Type} from "java.util.OptionalInt"

export class $FeatureSize {
static readonly "CODEC": $Codec<($FeatureSize)>
static readonly "MAX_WIDTH": integer

constructor(arg0: $OptionalInt$$Type)

public "type"(): $FeatureSizeType<(never)>
public "getSizeAtHeight"(arg0: integer, arg1: integer): integer
public "minClippedHeight"(): $OptionalInt
public static "minClippedHeightCodec"<S extends $FeatureSize>(): $RecordCodecBuilder<(S), ($OptionalInt)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FeatureSize$$Type = ($FeatureSize);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FeatureSize$$Original = $FeatureSize;}
declare module "net.minecraft.world.level.pathfinder.Node" {
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$PathType} from "net.minecraft.world.level.pathfinder.PathType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $Node {
 "cameFrom": $Node
 "f": float
 "g": float
readonly "x": integer
 "h": float
readonly "y": integer
 "closed": boolean
readonly "z": integer
 "walkedDistance": float
 "costMalus": float
 "type": $PathType
 "heapIdx": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "distanceTo"(arg0: $BlockPos$$Type): float
public "distanceTo"(arg0: $Node$$Type): float
public static "readContents"(arg0: $FriendlyByteBuf$$Type, arg1: $Node$$Type): void
public "writeToStream"(arg0: $FriendlyByteBuf$$Type): void
public static "createFromStream"(arg0: $FriendlyByteBuf$$Type): $Node
public "cloneAndMove"(arg0: integer, arg1: integer, arg2: integer): $Node
public "inOpenSet"(): boolean
public "distanceToSqr"(arg0: $BlockPos$$Type): float
public "distanceToSqr"(arg0: $Node$$Type): float
public static "createHash"(arg0: integer, arg1: integer, arg2: integer): integer
public "asBlockPos"(): $BlockPos
public "asVec3"(): $Vec3
public "distanceManhattan"(arg0: $Node$$Type): float
public "distanceManhattan"(arg0: $BlockPos$$Type): float
public "distanceToXZ"(arg0: $Node$$Type): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Node$$Type = ($Node);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Node$$Original = $Node;}
declare module "net.minecraft.world.level.storage.loot.predicates.LootItemCondition" {
import {$LootContextParam} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$LootContext, $LootContext$$Type} from "net.minecraft.world.level.storage.loot.LootContext"
import {$Codec} from "com.mojang.serialization.Codec"
import {$LootItemConditionType} from "net.minecraft.world.level.storage.loot.predicates.LootItemConditionType"
import {$Predicate, $Predicate$$Type, $Predicate$$Interface} from "java.util.function.Predicate"
import {$Set} from "java.util.Set"
import {$LootContextUser$$Interface} from "net.minecraft.world.level.storage.loot.LootContextUser"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$Holder} from "net.minecraft.core.Holder"

export interface $LootItemCondition$$Interface extends $LootContextUser$$Interface, $Predicate$$Interface<($LootContext)> {
get "type"(): $LootItemConditionType
get "referencedContextParams"(): $Set<($LootContextParam<(never)>)>
}

export class $LootItemCondition implements $LootItemCondition$$Interface {
static readonly "CODEC": $Codec<($Holder<($LootItemCondition)>)>
static readonly "DIRECT_CODEC": $Codec<($LootItemCondition)>
static readonly "TYPED_CODEC": $Codec<($LootItemCondition)>

 "getType"(): $LootItemConditionType
 "validate"(arg0: $ValidationContext$$Type): void
 "getReferencedContextParams"(): $Set<($LootContextParam<(never)>)>
 "test"(arg0: $LootContext$$Type): boolean
 "or"(arg0: $Predicate$$Type<($LootContext)>): $Predicate<($LootContext)>
 "negate"(): $Predicate<($LootContext)>
 "and"(arg0: $Predicate$$Type<($LootContext)>): $Predicate<($LootContext)>
static "not"<T>(arg0: $Predicate$$Type<($LootContext)>): $Predicate<($LootContext)>
static "isEqual"<T>(arg0: any): $Predicate<($LootContext)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootItemCondition$$Type = ($LootItemCondition);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootItemCondition$$Original = $LootItemCondition;}
declare module "net.minecraft.world.level.levelgen.NoiseGeneratorSettings" {
import {$WorldgenRandom$Algorithm} from "net.minecraft.world.level.levelgen.WorldgenRandom$Algorithm"
import {$List, $List$$Type} from "java.util.List"
import {$NoiseSettings, $NoiseSettings$$Type} from "net.minecraft.world.level.levelgen.NoiseSettings"
import {$Holder} from "net.minecraft.core.Holder"
import {$NoiseRouter, $NoiseRouter$$Type} from "net.minecraft.world.level.levelgen.NoiseRouter"
import {$NoiseGeneratorSettingsAccessor$$Interface} from "com.blackgear.vanillabackport.core.mixin.access.NoiseGeneratorSettingsAccessor"
import {$SurfaceRules$RuleSource, $SurfaceRules$RuleSource$$Type} from "net.minecraft.world.level.levelgen.SurfaceRules$RuleSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Climate$ParameterPoint, $Climate$ParameterPoint$$Type} from "net.minecraft.world.level.biome.Climate$ParameterPoint"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Record} from "java.lang.Record"
import {$BootstrapContext$$Type} from "net.minecraft.data.worldgen.BootstrapContext"

export class $NoiseGeneratorSettings extends $Record implements $NoiseGeneratorSettingsAccessor$$Interface {
static readonly "AMPLIFIED": $ResourceKey<($NoiseGeneratorSettings)>
static readonly "CODEC": $Codec<($Holder<($NoiseGeneratorSettings)>)>
static readonly "OVERWORLD": $ResourceKey<($NoiseGeneratorSettings)>
static readonly "NETHER": $ResourceKey<($NoiseGeneratorSettings)>
static readonly "CAVES": $ResourceKey<($NoiseGeneratorSettings)>
static readonly "DIRECT_CODEC": $Codec<($NoiseGeneratorSettings)>
static readonly "END": $ResourceKey<($NoiseGeneratorSettings)>
static readonly "FLOATING_ISLANDS": $ResourceKey<($NoiseGeneratorSettings)>
static readonly "LARGE_BIOMES": $ResourceKey<($NoiseGeneratorSettings)>

constructor(arg0: $NoiseSettings$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $NoiseRouter$$Type, arg4: $SurfaceRules$RuleSource$$Type, arg5: $List$$Type<($Climate$ParameterPoint$$Type)>, arg6: integer, arg7: boolean, arg8: boolean, arg9: boolean, arg10: boolean)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "end"(arg0: $BootstrapContext$$Type<(never)>): $NoiseGeneratorSettings
public static "dummy"(): $NoiseGeneratorSettings
public static "bootstrap"(arg0: $BootstrapContext$$Type<($NoiseGeneratorSettings$$Type)>): void
public "surfaceRule"(): $SurfaceRules$RuleSource
public "useLegacyRandomSource"(): boolean
/**
 * 
 * @deprecated
 */
public "disableMobGeneration"(): boolean
public static "caves"(arg0: $BootstrapContext$$Type<(never)>): $NoiseGeneratorSettings
public static "nether"(arg0: $BootstrapContext$$Type<(never)>): $NoiseGeneratorSettings
public static "overworld"(arg0: $BootstrapContext$$Type<(never)>, arg1: boolean, arg2: boolean): $NoiseGeneratorSettings
public "defaultBlock"(): $BlockState
public "spawnTarget"(): $List<($Climate$ParameterPoint)>
public "defaultFluid"(): $BlockState
public "noiseSettings"(): $NoiseSettings
public static "floatingIslands"(arg0: $BootstrapContext$$Type<(never)>): $NoiseGeneratorSettings
public "aquifersEnabled"(): boolean
public "noiseRouter"(): $NoiseRouter
public "isAquifersEnabled"(): boolean
public "getRandomSource"(): $WorldgenRandom$Algorithm
public "oreVeinsEnabled"(): boolean
public "setSurfaceRule"(arg0: $SurfaceRules$RuleSource$$Type): void
public "seaLevel"(): integer
get "randomSource"(): $WorldgenRandom$Algorithm
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenNoiseSettings
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenNoiseSettingsTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseGeneratorSettings$$Type = (Special.WorldgenNoiseSettings) | ({"disableMobGeneration"?: boolean, "useLegacyRandomSource"?: boolean, "aquifersEnabled"?: boolean, "seaLevel"?: integer, "noiseRouter"?: $NoiseRouter$$Type, "spawnTarget"?: $List$$Type<($Climate$ParameterPoint$$Type)>, "defaultFluid"?: $BlockState$$Type, "noiseSettings"?: $NoiseSettings$$Type, "defaultBlock"?: $BlockState$$Type, "oreVeinsEnabled"?: boolean, "surfaceRule"?: $SurfaceRules$RuleSource$$Type}) | ([disableMobGeneration?: boolean, useLegacyRandomSource?: boolean, aquifersEnabled?: boolean, seaLevel?: integer, noiseRouter?: $NoiseRouter$$Type, spawnTarget?: $List$$Type<($Climate$ParameterPoint$$Type)>, defaultFluid?: $BlockState$$Type, noiseSettings?: $NoiseSettings$$Type, defaultBlock?: $BlockState$$Type, oreVeinsEnabled?: boolean, surfaceRule?: $SurfaceRules$RuleSource$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseGeneratorSettings$$Original = $NoiseGeneratorSettings;}
declare module "net.minecraft.world.level.border.BorderStatus" {
import {$Enum} from "java.lang.Enum"

export class $BorderStatus extends $Enum<($BorderStatus)> {
static readonly "GROWING": $BorderStatus
static readonly "SHRINKING": $BorderStatus
static readonly "STATIONARY": $BorderStatus

public static "values"(): ($BorderStatus)[]
public static "valueOf"(arg0: StringJS): $BorderStatus
public "getColor"(): integer
get "color"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BorderStatus$$Type = (("growing") | ("shrinking") | ("stationary"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BorderStatus$$Original = $BorderStatus;}
declare module "net.minecraft.world.level.levelgen.NoiseSettings" {
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Record} from "java.lang.Record"

export class $NoiseSettings extends $Record {
static readonly "CODEC": $Codec<($NoiseSettings)>
static readonly "END_NOISE_SETTINGS": $NoiseSettings
static readonly "CAVES_NOISE_SETTINGS": $NoiseSettings
static readonly "OVERWORLD_NOISE_SETTINGS": $NoiseSettings
static readonly "FLOATING_ISLANDS_NOISE_SETTINGS": $NoiseSettings
static readonly "NETHER_NOISE_SETTINGS": $NoiseSettings

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "create"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $NoiseSettings
public "clampToHeightAccessor"(arg0: $LevelHeightAccessor$$Type): $NoiseSettings
public "noiseSizeHorizontal"(): integer
public "minY"(): integer
public "height"(): integer
public "getCellHeight"(): integer
public "getCellWidth"(): integer
public "noiseSizeVertical"(): integer
get "cellHeight"(): integer
get "cellWidth"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseSettings$$Type = ({"height"?: integer, "noiseSizeVertical"?: integer, "noiseSizeHorizontal"?: integer, "minY"?: integer}) | ([height?: integer, noiseSizeVertical?: integer, noiseSizeHorizontal?: integer, minY?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseSettings$$Original = $NoiseSettings;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockStateProviderType} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProviderType"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$SimpleStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.SimpleStateProvider"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStateProvider {
static readonly "CODEC": $Codec<($BlockStateProvider)>

constructor()

public "type"(): $BlockStateProviderType<(never)>
public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
public static "simple"(arg0: $BlockState$$Type): $SimpleStateProvider
public static "simple"(arg0: $Block$$Type): $SimpleStateProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateProvider$$Type = ($BlockStateProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateProvider$$Original = $BlockStateProvider;}
declare module "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings" {
import {$GenerationStep$Decoration, $GenerationStep$Decoration$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Decoration"
import {$Map, $Map$$Type} from "java.util.Map"
import {$MobCategory, $MobCategory$$Type} from "net.minecraft.world.entity.MobCategory"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$TerrainAdjustment, $TerrainAdjustment$$Type} from "net.minecraft.world.level.levelgen.structure.TerrainAdjustment"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructureSpawnOverride, $StructureSpawnOverride$$Type} from "net.minecraft.world.level.levelgen.structure.StructureSpawnOverride"
import {$Record} from "java.lang.Record"

export class $Structure$StructureSettings extends $Record {
static readonly "CODEC": $MapCodec<($Structure$StructureSettings)>
static readonly "DEFAULT": $Structure$StructureSettings

constructor(arg0: $HolderSet$$Type<($Biome)>)
constructor(biomes: $HolderSet$$Type<($Biome)>, spawnOverrides: $Map$$Type<($MobCategory$$Type), ($StructureSpawnOverride$$Type)>, step: $GenerationStep$Decoration$$Type, terrainAdaptation: $TerrainAdjustment$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "step"(): $GenerationStep$Decoration
public "spawnOverrides"(): $Map<($MobCategory), ($StructureSpawnOverride)>
public "terrainAdaptation"(): $TerrainAdjustment
public "biomes"(): $HolderSet<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Structure$StructureSettings$$Type = ({"biomes"?: $HolderSet$$Type<($Biome)>, "terrainAdaptation"?: $TerrainAdjustment$$Type, "spawnOverrides"?: $Map$$Type<($MobCategory$$Type), ($StructureSpawnOverride$$Type)>, "step"?: $GenerationStep$Decoration$$Type}) | ([biomes?: $HolderSet$$Type<($Biome)>, terrainAdaptation?: $TerrainAdjustment$$Type, spawnOverrides?: $Map$$Type<($MobCategory$$Type), ($StructureSpawnOverride$$Type)>, step?: $GenerationStep$Decoration$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Structure$StructureSettings$$Original = $Structure$StructureSettings;}
declare module "net.minecraft.world.level.biome.Climate$TargetPoint" {
import {$Record} from "java.lang.Record"

export class $Climate$TargetPoint extends $Record {
constructor(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "depth"(): long
public "temperature"(): long
public "weirdness"(): long
public "erosion"(): long
public "humidity"(): long
public "continentalness"(): long
public "toParameterArray"(): (long)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Climate$TargetPoint$$Type = ({"temperature"?: long, "humidity"?: long, "depth"?: long, "continentalness"?: long, "weirdness"?: long, "erosion"?: long}) | ([temperature?: long, humidity?: long, depth?: long, continentalness?: long, weirdness?: long, erosion?: long]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Climate$TargetPoint$$Original = $Climate$TargetPoint;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.BendingTrunkPlacer" {
import {$List} from "java.util.List"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$TrunkPlacerType} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacerType"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $BendingTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($BendingTrunkPlacer)>
static readonly "MAX_HEIGHT": integer
readonly "baseHeight": integer
readonly "heightRandA": integer
readonly "heightRandB": integer

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $IntProvider$$Type)

public "type"(): $TrunkPlacerType<(never)>
public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BendingTrunkPlacer$$Type = ($BendingTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BendingTrunkPlacer$$Original = $BendingTrunkPlacer;}
declare module "net.minecraft.world.level.block.state.properties.EnumProperty" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Optional} from "java.util.Optional"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Comparable$$Type} from "java.lang.Comparable"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Class$$Type} from "java.lang.Class"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $EnumProperty<T extends $Enum<(object)>> extends $Property<(T)> {
constructor(arg0: StringJS, arg1: $Class$$Type<(T)>, arg2: $Collection$$Type<(T)>)

public "getName"(arg0: T): StringJS
public "getName"(arg0: $Comparable$$Type): StringJS
public "equals"(arg0: any): boolean
public "getValue"(arg0: StringJS): $Optional<(T)>
public static "create"<T extends $Enum<(object)>>(arg0: StringJS, arg1: $Class$$Type<(T)>, arg2: $Predicate$$Type<(T)>): $EnumProperty<(T)>
public static "create"<T extends $Enum<(object)>>(arg0: StringJS, arg1: $Class$$Type<(T)>, ...arg2: (T)[]): $EnumProperty<(T)>
public static "create"<T extends $Enum<(object)>>(arg0: StringJS, arg1: $Class$$Type<(T)>, arg2: $Collection$$Type<(T)>): $EnumProperty<(T)>
public static "create"<T extends $Enum<(object)>>(arg0: StringJS, arg1: $Class$$Type<(T)>): $EnumProperty<(T)>
public "generateHashCode"(): integer
public "getPossibleValues"(): $Collection<(T)>
get "possibleValues"(): $Collection<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumProperty$$Type<T> = ($EnumProperty<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EnumProperty$$Original<T> = $EnumProperty<(T)>;}
declare module "net.minecraft.world.level.portal.PortalShape" {
import {$Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Optional} from "java.util.Optional"
import {$EntityDimensions$$Type} from "net.minecraft.world.entity.EntityDimensions"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockUtil$FoundRectangle$$Type} from "net.minecraft.BlockUtil$FoundRectangle"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"

export class $PortalShape {
static readonly "MAX_WIDTH": integer
static readonly "MAX_HEIGHT": integer

constructor(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $Direction$Axis$$Type)

public "isValid"(): boolean
public static "findPortalShape"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $Predicate$$Type<($PortalShape)>, arg3: $Direction$Axis$$Type): $Optional<($PortalShape)>
public static "getRelativePosition"(arg0: $BlockUtil$FoundRectangle$$Type, arg1: $Direction$Axis$$Type, arg2: $Vec3$$Type, arg3: $EntityDimensions$$Type): $Vec3
public static "findCollisionFreePosition"(arg0: $Vec3$$Type, arg1: $ServerLevel$$Type, arg2: $Entity$$Type, arg3: $EntityDimensions$$Type): $Vec3
public static "findEmptyPortalShape"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $Direction$Axis$$Type): $Optional<($PortalShape)>
public "createPortalBlocks"(): void
public "isComplete"(): boolean
get "valid"(): boolean
get "complete"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PortalShape$$Type = ($PortalShape);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PortalShape$$Original = $PortalShape;}
declare module "net.minecraft.world.level.entity.EntitySection" {
import {$EntitySectionStorage$$Type} from "net.minecraft.world.level.entity.EntitySectionStorage"
import {$ArrayList$$Type} from "java.util.ArrayList"
import {$EntitySectionAccessor$$Interface} from "net.caffeinemc.mods.lithium.mixin.util.accessors.EntitySectionAccessor"
import {$Visibility, $Visibility$$Type} from "net.minecraft.world.level.entity.Visibility"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockCachingEntity$$Type} from "net.caffeinemc.mods.lithium.common.entity.pushable.BlockCachingEntity"
import {$AbortableIterationConsumer$$Type} from "net.minecraft.util.AbortableIterationConsumer"
import {$ClimbingMobCachingSection$$Interface} from "net.caffeinemc.mods.lithium.common.world.ClimbingMobCachingSection"
import {$EntityPushablePredicate$$Type} from "net.caffeinemc.mods.lithium.common.entity.pushable.EntityPushablePredicate"
import {$SectionedEntityMovementTracker$$Type} from "net.caffeinemc.mods.lithium.common.tracking.entity.SectionedEntityMovementTracker"
import {$EntitySectionAccessor$$Interface as $EntitySectionAccessor$1$$Interface} from "net.caffeinemc.mods.lithium.mixin.minimal_nonvanilla.spawning.EntitySectionAccessor"
import {$EntityAccess, $EntityAccess$$Type} from "net.minecraft.world.level.entity.EntityAccess"
import {$AbortableIterationConsumer$Continuation} from "net.minecraft.util.AbortableIterationConsumer$Continuation"
import {$PositionedEntityTrackingSection$$Interface} from "net.caffeinemc.mods.lithium.common.entity.PositionedEntityTrackingSection"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$ClassInstanceMultiMap} from "net.minecraft.util.ClassInstanceMultiMap"
import {$EntityMovementTrackerSection$$Interface} from "net.caffeinemc.mods.lithium.common.tracking.entity.EntityMovementTrackerSection"
import {$Class$$Type} from "java.lang.Class"
import {$EntitySectionAccessor$$Interface as $EntitySectionAccessor$0$$Interface} from "net.caffeinemc.mods.lithium.mixin.block.hopper.EntitySectionAccessor"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$Stream} from "java.util.stream.Stream"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EntitySection<T extends $EntityAccess> implements $EntitySectionAccessor$0$$Interface, $ClimbingMobCachingSection$$Interface, $EntitySectionAccessor$1$$Interface, $EntitySectionAccessor$$Interface, $PositionedEntityTrackingSection$$Interface, $EntityMovementTrackerSection$$Interface {
constructor(arg0: $Class$$Type<(T)>, arg1: $Visibility$$Type)

public "remove"(arg0: T): boolean
public "size"(): integer
public "isEmpty"(): boolean
public "add"(arg0: T): void
public "lithium$setPos"(arg0: long): void
public "lithium$getPos"(): long
public "lithium$trackEntityMovement"(arg0: integer, arg1: long): void
public "getEntities"<U extends $EntityAccess>(arg0: $EntityTypeTest$$Type<(T), (U)>, arg1: $AABB$$Type, arg2: $AbortableIterationConsumer$$Type<(U)>): $AbortableIterationConsumer$Continuation
public "getEntities"(arg0: $AABB$$Type, arg1: $AbortableIterationConsumer$$Type<(T)>): $AbortableIterationConsumer$Continuation
public "getEntities"(): $Stream<(T)>
public "updateChunkStatus"(arg0: $Visibility$$Type): $Visibility
public "localvar$bpe000$lithium$swapStatus"(arg0: $Visibility$$Type): $Visibility
public "lithium$collectPushableEntities"(arg0: $Level$$Type, arg1: $Entity$$Type, arg2: $AABB$$Type, arg3: $EntityPushablePredicate$$Type, arg4: $ArrayList$$Type): $AbortableIterationConsumer$Continuation
public "getStatus"(): $Visibility
public "getCollection"(): $ClassInstanceMultiMap
public "lithium$removeListener"(arg0: $EntitySectionStorage$$Type, arg1: $SectionedEntityMovementTracker$$Type): void
public "lithium$addListener"(arg0: $SectionedEntityMovementTracker$$Type): void
public "lithium$getChangeTime"(arg0: integer): long
public "lithium$removeListenToMovementOnce"(arg0: $SectionedEntityMovementTracker$$Type, arg1: integer): void
public "lithium$listenToMovementOnce"(arg0: $SectionedEntityMovementTracker$$Type, arg1: integer): void
public "lithium$onEntityModifiedCachedBlock"(arg0: $BlockCachingEntity$$Type, arg1: $BlockState$$Type): void
public "modifyReturnValue$bpe000$lithium$modifyIsEmpty"(arg0: boolean): boolean
get "empty"(): boolean
get "entities"(): $Stream<(T)>
get "status"(): $Visibility
get "collection"(): $ClassInstanceMultiMap
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySection$$Type<T> = ($EntitySection<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntitySection$$Original<T> = $EntitySection<(T)>;}
declare module "net.minecraft.world.level.chunk.LightChunk" {
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$Holder} from "net.minecraft.core.Holder"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$ChunkSkyLightSources} from "net.minecraft.world.level.lighting.ChunkSkyLightSources"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter$$Interface} from "net.minecraft.world.level.BlockGetter"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"

export interface $LightChunk$$Interface extends $BlockGetter$$Interface {
get "skyLightSources"(): $ChunkSkyLightSources
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "maxSection"(): integer
get "minSection"(): integer
get "sectionsCount"(): integer
get "height"(): integer
get "minBuildHeight"(): integer
}

export class $LightChunk implements $LightChunk$$Interface {
 "findBlockLightSources"(arg0: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
 "getSkyLightSources"(): $ChunkSkyLightSources
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
 "getMaxLightLevel"(): integer
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getMaxBuildHeight"(): integer
 "getSectionIndex"(arg0: integer): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionsCount"(): integer
 "getHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getMinBuildHeight"(): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
 "getBlockEntityRenderData"(arg0: $BlockPos$$Type): any
 "hasBiomes"(): boolean
 "getBiomeFabric"(arg0: $BlockPos$$Type): $Holder<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LightChunk$$Type = ($LightChunk);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LightChunk$$Original = $LightChunk;}
declare module "net.minecraft.world.level.Explosion" {
import {$Map} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Explosion$BlockInteraction, $Explosion$BlockInteraction$$Type} from "net.minecraft.world.level.Explosion$BlockInteraction"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ExplosionDamageCalculator, $ExplosionDamageCalculator$$Type} from "net.minecraft.world.level.ExplosionDamageCalculator"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

export class $Explosion {
 "blockInteraction": $Explosion$BlockInteraction
readonly "damageSource": $DamageSource
readonly "damageCalculator": $ExplosionDamageCalculator
 "source": $Entity

constructor(arg0: $Level$$Type, arg1: $Entity$$Type, arg2: $DamageSource$$Type, arg3: $ExplosionDamageCalculator$$Type, arg4: double, arg5: double, arg6: double, arg7: float, arg8: boolean, arg9: $Explosion$BlockInteraction$$Type, arg10: $ParticleOptions$$Type, arg11: $ParticleOptions$$Type, arg12: $Holder$$Type<($SoundEvent)>)
constructor(arg0: $Level$$Type, arg1: $Entity$$Type, arg2: double, arg3: double, arg4: double, arg5: float, arg6: boolean, arg7: $Explosion$BlockInteraction$$Type, arg8: $List$$Type<($BlockPos$$Type)>)
constructor(arg0: $Level$$Type, arg1: $Entity$$Type, arg2: double, arg3: double, arg4: double, arg5: float, arg6: $List$$Type<($BlockPos$$Type)>, arg7: $Explosion$BlockInteraction$$Type, arg8: $ParticleOptions$$Type, arg9: $ParticleOptions$$Type, arg10: $Holder$$Type<($SoundEvent)>)
constructor(arg0: $Level$$Type, arg1: $Entity$$Type, arg2: double, arg3: double, arg4: double, arg5: float, arg6: boolean, arg7: $Explosion$BlockInteraction$$Type)

public "explode"(): void
public static "getSeenPercent"(arg0: $Vec3$$Type, arg1: $Entity$$Type): float
public "getSmallExplosionParticles"(): $ParticleOptions
public "interactsWithBlocks"(): boolean
public "clearToBlow"(): void
public "getHitPlayers"(): $Map<($Player), ($Vec3)>
public "getExplosionSound"(): $Holder<($SoundEvent)>
public static "getDefaultDamageSource"(arg0: $Level$$Type, arg1: $Entity$$Type): $DamageSource
public "finalizeExplosion"(arg0: boolean): void
public "center"(): $Vec3
public "radius"(): float
public "getToBlow"(): $List<($BlockPos)>
public "getLargeExplosionParticles"(): $ParticleOptions
public "canTriggerBlocks"(): boolean
public "getDirectSourceEntity"(): $Entity
public "getIndirectSourceEntity"(): $LivingEntity
public "getBlockInteraction"(): $Explosion$BlockInteraction
get "smallExplosionParticles"(): $ParticleOptions
get "hitPlayers"(): $Map<($Player), ($Vec3)>
get "explosionSound"(): $Holder<($SoundEvent)>
get "toBlow"(): $List<($BlockPos)>
get "largeExplosionParticles"(): $ParticleOptions
get "directSourceEntity"(): $Entity
get "indirectSourceEntity"(): $LivingEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Explosion$$Type = ($Explosion);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Explosion$$Original = $Explosion;}
declare module "net.minecraft.world.level.block.entity.EnchantingTableBlockEntity" {
import {$Nameable$$Interface} from "net.minecraft.world.Nameable"
import {$BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EnchantingTableBlockEntity extends $BlockEntity implements $Nameable$$Interface {
 "oFlip": float
 "flipA": float
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "remove": boolean
 "worldPosition": $BlockPos
 "rot": float
 "tRot": float
 "flipT": float
 "oOpen": float
 "time": integer
 "oRot": float
 "hasComparators": byte
 "flip": float
 "open": float

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getName"(): $Component
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getCustomName"(): $Component
public "setCustomName"(arg0: $Component$$Type): void
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public static "bookAnimationTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $EnchantingTableBlockEntity$$Type): void
public "collectImplicitComponents"(arg0: $DataComponentMap$Builder$$Type): void
public "applyImplicitComponents"(arg0: $BlockEntity$DataComponentInput$$Type): void
public "getDisplayName"(): $Component
public "hasCustomName"(): boolean
get "name"(): $Component
get "customName"(): $Component
set "customName"(value: $Component$$Type)
get "displayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnchantingTableBlockEntity$$Type = ($EnchantingTableBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EnchantingTableBlockEntity$$Original = $EnchantingTableBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer" {
import {$RecordCodecBuilder$Instance$$Type} from "com.mojang.serialization.codecs.RecordCodecBuilder$Instance"
import {$BlockPos$MutableBlockPos$$Type} from "net.minecraft.core.BlockPos$MutableBlockPos"
import {$List} from "java.util.List"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$Products$P3} from "com.mojang.datafixers.Products$P3"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RecordCodecBuilder$Mu} from "com.mojang.serialization.codecs.RecordCodecBuilder$Mu"
import {$Function$$Type} from "java.util.function.Function"
import {$TrunkPlacerType} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacerType"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $TrunkPlacer {
static readonly "CODEC": $Codec<($TrunkPlacer)>
static readonly "MAX_HEIGHT": integer
readonly "baseHeight": integer
readonly "heightRandA": integer
readonly "heightRandB": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "type"(): $TrunkPlacerType<(never)>
public static "setDirtAt"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type, arg4: $TreeConfiguration$$Type): void
public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
public "placeLog"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type, arg4: $TreeConfiguration$$Type, arg5: $Function$$Type<($BlockState), ($BlockState$$Type)>): boolean
public "placeLog"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type, arg4: $TreeConfiguration$$Type): boolean
public "validTreePos"(arg0: $LevelSimulatedReader$$Type, arg1: $BlockPos$$Type): boolean
public static "trunkPlacerParts"<P extends $TrunkPlacer>(arg0: $RecordCodecBuilder$Instance$$Type<(P)>): $Products$P3<($RecordCodecBuilder$Mu<(P)>), (integer), (integer), (integer)>
public "getTreeHeight"(arg0: $RandomSource$$Type): integer
public "placeLogIfFree"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: $BlockPos$MutableBlockPos$$Type, arg4: $TreeConfiguration$$Type): void
public "isFree"(arg0: $LevelSimulatedReader$$Type, arg1: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrunkPlacer$$Type = ($TrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrunkPlacer$$Original = $TrunkPlacer;}
declare module "net.minecraft.world.level.block.entity.ContainerOpenersCounter" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ContainerOpenersCounter {
 "maxInteractionRange": double
 "openCount": integer

constructor()

public "onClose"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "getPlayersWithContainerOpen"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $List<($Player)>
public "onOpen"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "openerCountChanged"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: integer, arg4: integer): void
public static "scheduleRecheck"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "isOwnContainer"(arg0: $Player$$Type): boolean
public "getOpenerCount"(): integer
public "recheckOpeners"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "incrementOpeners"(arg0: $Player$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
public "decrementOpeners"(arg0: $Player$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
get "openerCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerOpenersCounter$$Type = ($ContainerOpenersCounter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ContainerOpenersCounter$$Original = $ContainerOpenersCounter;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $ColumnFeatureConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($ColumnFeatureConfiguration)>

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type)

public "height"(): $IntProvider
public "reach"(): $IntProvider
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColumnFeatureConfiguration$$Type = ($ColumnFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ColumnFeatureConfiguration$$Original = $ColumnFeatureConfiguration;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BoundingBox} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$List, $List$$Type} from "java.util.List"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ObjectArrayList} from "it.unimi.dsi.fastutil.objects.ObjectArrayList"
import {$StructurePlaceSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"
import {$HolderGetter$$Type} from "net.minecraft.core.HolderGetter"
import {$ServerLevelAccessor$$Type} from "net.minecraft.world.level.ServerLevelAccessor"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$StructureTemplate$StructureEntityInfo, $StructureTemplate$StructureEntityInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureEntityInfo"
import {$Vec3i, $Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$DiscreteVoxelShape$$Type} from "net.minecraft.world.phys.shapes.DiscreteVoxelShape"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"

export class $StructureTemplate {
static readonly "ENTITY_TAG_POS": StringJS
static readonly "BLOCK_TAG_NBT": StringJS
static readonly "BLOCK_TAG_STATE": StringJS
static readonly "PALETTE_LIST_TAG": StringJS
static readonly "BLOCK_TAG_POS": StringJS
static readonly "BLOCKS_TAG": StringJS
static readonly "SIZE_TAG": StringJS
static readonly "PALETTE_TAG": StringJS
static readonly "ENTITY_TAG_NBT": StringJS
static readonly "ENTITIES_TAG": StringJS
static readonly "ENTITY_TAG_BLOCKPOS": StringJS

constructor()

public "calculateConnectedPosition"(arg0: $StructurePlaceSettings$$Type, arg1: $BlockPos$$Type, arg2: $StructurePlaceSettings$$Type, arg3: $BlockPos$$Type): $BlockPos
public "load"(arg0: $HolderGetter$$Type<($Block$$Type)>, arg1: $CompoundTag$$Type): void
public static "transform"(arg0: $BlockPos$$Type, arg1: $Mirror$$Type, arg2: $Rotation$$Type, arg3: $BlockPos$$Type): $BlockPos
public static "transform"(arg0: $Vec3$$Type, arg1: $Mirror$$Type, arg2: $Rotation$$Type, arg3: $BlockPos$$Type): $Vec3
public "save"(arg0: $CompoundTag$$Type): $CompoundTag
public "getSize"(arg0: $Rotation$$Type): $Vec3i
public "getSize"(): $Vec3i
public static "updateShapeAtEdge"(arg0: $LevelAccessor$$Type, arg1: integer, arg2: $DiscreteVoxelShape$$Type, arg3: integer, arg4: integer, arg5: integer): void
public static "updateShapeAtEdge"(arg0: $LevelAccessor$$Type, arg1: integer, arg2: $DiscreteVoxelShape$$Type, arg3: $BlockPos$$Type): void
public "fillFromWorld"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Vec3i$$Type, arg3: boolean, arg4: $Block$$Type): void
public "placeInWorld"(arg0: $ServerLevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructurePlaceSettings$$Type, arg4: $RandomSource$$Type, arg5: integer): boolean
public static "calculateRelativePosition"(arg0: $StructurePlaceSettings$$Type, arg1: $BlockPos$$Type): $BlockPos
public "getAuthor"(): StringJS
public "setAuthor"(arg0: StringJS): void
public static "transformedVec3d"(arg0: $StructurePlaceSettings$$Type, arg1: $Vec3$$Type): $Vec3
public static "processEntityInfos"(arg0: $StructureTemplate$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $StructurePlaceSettings$$Type, arg4: $List$$Type<($StructureTemplate$StructureEntityInfo$$Type)>): $List<($StructureTemplate$StructureEntityInfo)>
public "getZeroPositionWithTransform"(arg0: $BlockPos$$Type, arg1: $Mirror$$Type, arg2: $Rotation$$Type): $BlockPos
public static "getZeroPositionWithTransform"(arg0: $BlockPos$$Type, arg1: $Mirror$$Type, arg2: $Rotation$$Type, arg3: integer, arg4: integer): $BlockPos
public static "processBlockInfos"(arg0: $ServerLevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructurePlaceSettings$$Type, arg4: $List$$Type<($StructureTemplate$StructureBlockInfo$$Type)>): $List<($StructureTemplate$StructureBlockInfo)>
public static "processBlockInfos"(arg0: $ServerLevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type, arg3: $StructurePlaceSettings$$Type, arg4: $List$$Type<($StructureTemplate$StructureBlockInfo$$Type)>, arg5: $StructureTemplate$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "filterBlocks"(arg0: $BlockPos$$Type, arg1: $StructurePlaceSettings$$Type, arg2: $Block$$Type, arg3: boolean): $ObjectArrayList<($StructureTemplate$StructureBlockInfo)>
public "filterBlocks"(arg0: $BlockPos$$Type, arg1: $StructurePlaceSettings$$Type, arg2: $Block$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "getBoundingBox"(arg0: $StructurePlaceSettings$$Type, arg1: $BlockPos$$Type): $BoundingBox
public "getBoundingBox"(arg0: $BlockPos$$Type, arg1: $Rotation$$Type, arg2: $BlockPos$$Type, arg3: $Mirror$$Type): $BoundingBox
public static "getBoundingBox"(arg0: $BlockPos$$Type, arg1: $Rotation$$Type, arg2: $BlockPos$$Type, arg3: $Mirror$$Type, arg4: $Vec3i$$Type): $BoundingBox
get "size"(): $Vec3i
get "author"(): StringJS
set "author"(value: StringJS)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureTemplate$$Type = ($StructureTemplate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureTemplate$$Original = $StructureTemplate;}
declare module "net.minecraft.world.level.block.piston.PistonMovingBlockEntity" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PistonMovingBlockEntity extends $BlockEntity {
 "worldPosition": $BlockPos
static readonly "TICK_MOVEMENT": double
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)
constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type, arg4: boolean, arg5: boolean)

public static "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $PistonMovingBlockEntity$$Type): void
public "setLevel"(arg0: $Level$$Type): void
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "finalTick"(): void
public "getCollisionShape"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $VoxelShape
public "getXOff"(arg0: float): float
public "getYOff"(arg0: float): float
public "getZOff"(arg0: float): float
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "isExtending"(): boolean
public "getLastTicked"(): long
public "getProgress"(arg0: float): float
public "getDirection"(): $Direction
public "getMovedState"(): $BlockState
public "getMovementDirection"(): $Direction
public "isSourcePiston"(): boolean
get "extending"(): boolean
get "lastTicked"(): long
get "direction"(): $Direction
get "movedState"(): $BlockState
get "movementDirection"(): $Direction
get "sourcePiston"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PistonMovingBlockEntity$$Type = ($PistonMovingBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PistonMovingBlockEntity$$Original = $PistonMovingBlockEntity;}
declare module "net.minecraft.world.level.levelgen.GeodeBlockSettings" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List, $List$$Type} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $GeodeBlockSettings {
static readonly "CODEC": $Codec<($GeodeBlockSettings)>
readonly "outerLayerProvider": $BlockStateProvider
readonly "innerLayerProvider": $BlockStateProvider
readonly "alternateInnerLayerProvider": $BlockStateProvider
readonly "innerPlacements": $List<($BlockState)>
readonly "cannotReplace": $TagKey<($Block)>
readonly "middleLayerProvider": $BlockStateProvider
readonly "invalidBlocks": $TagKey<($Block)>
readonly "fillingProvider": $BlockStateProvider

constructor(arg0: $BlockStateProvider$$Type, arg1: $BlockStateProvider$$Type, arg2: $BlockStateProvider$$Type, arg3: $BlockStateProvider$$Type, arg4: $BlockStateProvider$$Type, arg5: $List$$Type<($BlockState$$Type)>, arg6: $TagKey$$Type<($Block)>, arg7: $TagKey$$Type<($Block)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeodeBlockSettings$$Type = ($GeodeBlockSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeodeBlockSettings$$Original = $GeodeBlockSettings;}
declare module "net.minecraft.world.level.levelgen.structure.SinglePieceStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$SinglePieceStructure$PieceConstructor$$Type} from "net.minecraft.world.level.levelgen.structure.SinglePieceStructure$PieceConstructor"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"
import {$Holder} from "net.minecraft.core.Holder"

export class $SinglePieceStructure extends $Structure {
static readonly "CODEC": $Codec<($Holder<($Structure)>)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $SinglePieceStructure$PieceConstructor$$Type, arg1: integer, arg2: integer, arg3: $Structure$StructureSettings$$Type)

public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SinglePieceStructure$$Type = ($SinglePieceStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SinglePieceStructure$$Original = $SinglePieceStructure;}
declare module "net.minecraft.world.level.levelgen.WorldDimensions$Complete" {
import {$LevelStem, $LevelStem$$Type} from "net.minecraft.world.level.dimension.LevelStem"
import {$RegistryAccess$Frozen} from "net.minecraft.core.RegistryAccess$Frozen"
import {$PrimaryLevelData$SpecialWorldProperty, $PrimaryLevelData$SpecialWorldProperty$$Type} from "net.minecraft.world.level.storage.PrimaryLevelData$SpecialWorldProperty"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Lifecycle} from "com.mojang.serialization.Lifecycle"
import {$Record} from "java.lang.Record"

export class $WorldDimensions$Complete extends $Record {
constructor(dimensions: $Registry$$Type<($LevelStem$$Type)>, specialWorldProperty: $PrimaryLevelData$SpecialWorldProperty$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "dimensions"(): $Registry<($LevelStem)>
public "lifecycle"(): $Lifecycle
public "specialWorldProperty"(): $PrimaryLevelData$SpecialWorldProperty
public "dimensionsRegistryAccess"(): $RegistryAccess$Frozen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldDimensions$Complete$$Type = ({"dimensions"?: $Registry$$Type<($LevelStem$$Type)>, "specialWorldProperty"?: $PrimaryLevelData$SpecialWorldProperty$$Type}) | ([dimensions?: $Registry$$Type<($LevelStem$$Type)>, specialWorldProperty?: $PrimaryLevelData$SpecialWorldProperty$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldDimensions$Complete$$Original = $WorldDimensions$Complete;}
declare module "net.minecraft.world.level.block.LiquidBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$LootParams$Builder$$Type} from "net.minecraft.world.level.storage.loot.LootParams$Builder"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$FlowingFluid, $FlowingFluid$$Type} from "net.minecraft.world.level.material.FlowingFluid"
import {$LiquidBlockAccessor$$Interface} from "dev.architectury.mixin.forge.neoforge.LiquidBlockAccessor"
import {$List} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ImmutableList} from "com.google.common.collect.ImmutableList"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$StateDefinition$Builder$$Type} from "net.minecraft.world.level.block.state.StateDefinition$Builder"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InjectedLiquidBlockExtension$$Interface} from "dev.architectury.extensions.injected.InjectedLiquidBlockExtension"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$StateDefinition} from "net.minecraft.world.level.block.state.StateDefinition"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$SoundType} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$PathComputationType$$Type} from "net.minecraft.world.level.pathfinder.PathComputationType"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BucketPickup$$Interface} from "net.minecraft.world.level.block.BucketPickup"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $LiquidBlock extends $Block implements $BucketPickup$$Interface, $LiquidBlockAccessor$$Interface, $InjectedLiquidBlockExtension$$Interface {
 "explosionResistance": float
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "UPDATE_ALL": integer
 "drops": $ResourceKey<($LootTable)>
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
readonly "dynamicShape": boolean
static readonly "STABLE_SHAPE": $VoxelShape
readonly "fluid": $FlowingFluid
 "soundType": $SoundType
 "jumpFactor": float
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($LiquidBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
 "speedFactor": float
static readonly "LEVEL": $IntegerProperty
 "friction": float
static readonly "POSSIBLE_FLOW_DIRECTIONS": $ImmutableList<($Direction)>
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
 "hasCollision": boolean

constructor(arg0: $FlowingFluid$$Type, arg1: $BlockBehaviour$Properties$$Type)

public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "codec"(): $MapCodec<($LiquidBlock)>
public "skipRendering"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type): boolean
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "getFluid"(): $FlowingFluid
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getDrops"(arg0: $BlockState$$Type, arg1: $LootParams$Builder$$Type): $List<($ItemStack)>
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "randomTick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "isRandomlyTicking"(arg0: $BlockState$$Type): boolean
public "isPathfindable"(arg0: $BlockState$$Type, arg1: $PathComputationType$$Type): boolean
public "getPickupSound"(): $Optional<($SoundEvent)>
public "propagatesSkylightDown"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "createBlockStateDefinition"(arg0: $StateDefinition$Builder$$Type<($Block$$Type), ($BlockState$$Type)>): void
public "arch$getFluid"(): $FlowingFluid
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LiquidBlock$$Type = ($LiquidBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LiquidBlock$$Original = $LiquidBlock;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Optional} from "java.util.Optional"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $EndGatewayConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($EndGatewayConfiguration)>

public "isExitExact"(): boolean
public static "knownExit"(arg0: $BlockPos$$Type, arg1: boolean): $EndGatewayConfiguration
public static "delayedExitSearch"(): $EndGatewayConfiguration
public "getExit"(): $Optional<($BlockPos)>
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "exitExact"(): boolean
get "exit"(): $Optional<($BlockPos)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndGatewayConfiguration$$Type = ($EndGatewayConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EndGatewayConfiguration$$Original = $EndGatewayConfiguration;}
declare module "net.minecraft.world.level.block.entity.SculkCatalystBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$GameEventListener$Provider$$Interface} from "net.minecraft.world.level.gameevent.GameEventListener$Provider"
import {$SculkCatalystBlockEntity$CatalystListener} from "net.minecraft.world.level.block.entity.SculkCatalystBlockEntity$CatalystListener"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SculkCatalystBlockEntity extends $BlockEntity implements $GameEventListener$Provider$$Interface<($SculkCatalystBlockEntity$CatalystListener)> {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getListener"(): $GameEventListener
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $SculkCatalystBlockEntity$$Type): void
get "listener"(): $GameEventListener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkCatalystBlockEntity$$Type = ($SculkCatalystBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkCatalystBlockEntity$$Original = $SculkCatalystBlockEntity;}
declare module "net.minecraft.world.level.block.entity.SculkCatalystBlockEntity$CatalystListener" {
import {$SculkSpreader} from "net.minecraft.world.level.block.SculkSpreader"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$PositionSource, $PositionSource$$Type} from "net.minecraft.world.level.gameevent.PositionSource"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$GameEventListener$$Interface} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$GameEventListener$DeliveryMode} from "net.minecraft.world.level.gameevent.GameEventListener$DeliveryMode"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SculkCatalystBlockEntity$CatalystListener implements $GameEventListener$$Interface {
static readonly "PULSE_TICKS": integer
readonly "sculkSpreader": $SculkSpreader

constructor(arg0: $BlockState$$Type, arg1: $PositionSource$$Type)

public "getSculkSpreader"(): $SculkSpreader
public "getListenerRadius"(): integer
public "handleGameEvent"(arg0: $ServerLevel$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $GameEvent$Context$$Type, arg3: $Vec3$$Type): boolean
public "getListenerSource"(): $PositionSource
public "getDeliveryMode"(): $GameEventListener$DeliveryMode
get "listenerRadius"(): integer
get "listenerSource"(): $PositionSource
get "deliveryMode"(): $GameEventListener$DeliveryMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkCatalystBlockEntity$CatalystListener$$Type = ($SculkCatalystBlockEntity$CatalystListener);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkCatalystBlockEntity$CatalystListener$$Original = $SculkCatalystBlockEntity$CatalystListener;}
declare module "net.minecraft.world.level.entity.LevelCallback" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $LevelCallback$$Interface<T> {
}

export class $LevelCallback<T> implements $LevelCallback$$Interface {
 "onTickingEnd"(arg0: T): void
 "onTrackingStart"(arg0: T): void
 "onTickingStart"(arg0: T): void
 "onTrackingEnd"(arg0: T): void
 "onSectionChange"(arg0: T): void
 "onCreated"(arg0: T): void
 "onDestroyed"(arg0: T): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelCallback$$Type<T> = ($LevelCallback<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelCallback$$Original<T> = $LevelCallback<(T)>;}
declare module "net.minecraft.world.level.levelgen.carver.CaveCarverConfiguration" {
import {$VerticalAnchor, $VerticalAnchor$$Type} from "net.minecraft.world.level.levelgen.VerticalAnchor"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$CarverConfiguration, $CarverConfiguration$$Type} from "net.minecraft.world.level.levelgen.carver.CarverConfiguration"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$FloatProvider, $FloatProvider$$Type} from "net.minecraft.util.valueproviders.FloatProvider"
import {$CarverDebugSettings, $CarverDebugSettings$$Type} from "net.minecraft.world.level.levelgen.carver.CarverDebugSettings"
import {$HeightProvider, $HeightProvider$$Type} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"

export class $CaveCarverConfiguration extends $CarverConfiguration {
readonly "lavaLevel": $VerticalAnchor
readonly "debugSettings": $CarverDebugSettings
static readonly "CODEC": $Codec<($CaveCarverConfiguration)>
readonly "horizontalRadiusMultiplier": $FloatProvider
readonly "verticalRadiusMultiplier": $FloatProvider
readonly "probability": float
readonly "floorLevel": $FloatProvider
readonly "replaceable": $HolderSet<($Block)>
readonly "y": $HeightProvider
readonly "yScale": $FloatProvider

constructor(arg0: $CarverConfiguration$$Type, arg1: $FloatProvider$$Type, arg2: $FloatProvider$$Type, arg3: $FloatProvider$$Type)
constructor(arg0: float, arg1: $HeightProvider$$Type, arg2: $FloatProvider$$Type, arg3: $VerticalAnchor$$Type, arg4: $HolderSet$$Type<($Block)>, arg5: $FloatProvider$$Type, arg6: $FloatProvider$$Type, arg7: $FloatProvider$$Type)
constructor(arg0: float, arg1: $HeightProvider$$Type, arg2: $FloatProvider$$Type, arg3: $VerticalAnchor$$Type, arg4: $CarverDebugSettings$$Type, arg5: $HolderSet$$Type<($Block)>, arg6: $FloatProvider$$Type, arg7: $FloatProvider$$Type, arg8: $FloatProvider$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaveCarverConfiguration$$Type = ($CaveCarverConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CaveCarverConfiguration$$Original = $CaveCarverConfiguration;}
declare module "net.minecraft.world.level.levelgen.carver.CanyonCarverConfiguration" {
import {$VerticalAnchor, $VerticalAnchor$$Type} from "net.minecraft.world.level.levelgen.VerticalAnchor"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$CarverConfiguration, $CarverConfiguration$$Type} from "net.minecraft.world.level.levelgen.carver.CarverConfiguration"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$FloatProvider, $FloatProvider$$Type} from "net.minecraft.util.valueproviders.FloatProvider"
import {$CarverDebugSettings, $CarverDebugSettings$$Type} from "net.minecraft.world.level.levelgen.carver.CarverDebugSettings"
import {$HeightProvider, $HeightProvider$$Type} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"
import {$CanyonCarverConfiguration$CanyonShapeConfiguration, $CanyonCarverConfiguration$CanyonShapeConfiguration$$Type} from "net.minecraft.world.level.levelgen.carver.CanyonCarverConfiguration$CanyonShapeConfiguration"

export class $CanyonCarverConfiguration extends $CarverConfiguration {
readonly "verticalRotation": $FloatProvider
readonly "lavaLevel": $VerticalAnchor
readonly "debugSettings": $CarverDebugSettings
static readonly "CODEC": $Codec<($CanyonCarverConfiguration)>
readonly "shape": $CanyonCarverConfiguration$CanyonShapeConfiguration
readonly "probability": float
readonly "replaceable": $HolderSet<($Block)>
readonly "y": $HeightProvider
readonly "yScale": $FloatProvider

constructor(arg0: float, arg1: $HeightProvider$$Type, arg2: $FloatProvider$$Type, arg3: $VerticalAnchor$$Type, arg4: $CarverDebugSettings$$Type, arg5: $HolderSet$$Type<($Block)>, arg6: $FloatProvider$$Type, arg7: $CanyonCarverConfiguration$CanyonShapeConfiguration$$Type)
constructor(arg0: $CarverConfiguration$$Type, arg1: $FloatProvider$$Type, arg2: $CanyonCarverConfiguration$CanyonShapeConfiguration$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CanyonCarverConfiguration$$Type = ($CanyonCarverConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CanyonCarverConfiguration$$Original = $CanyonCarverConfiguration;}
declare module "net.minecraft.world.level.levelgen.Heightmap" {
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Predicate} from "java.util.function.Predicate"
import {$Set$$Type} from "java.util.Set"
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$HeightmapAccessor$$Interface} from "net.caffeinemc.mods.lithium.mixin.world.combined_heightmap_update.HeightmapAccessor"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $Heightmap implements $HeightmapAccessor$$Interface {
static readonly "MATERIAL_MOTION_BLOCKING": $Predicate<($BlockState)>
static readonly "NOT_AIR": $Predicate<($BlockState)>

constructor(arg0: $ChunkAccess$$Type, arg1: $Heightmap$Types$$Type)

public "setRawData"(arg0: $ChunkAccess$$Type, arg1: $Heightmap$Types$$Type, arg2: (long)[]): void
public "update"(arg0: integer, arg1: integer, arg2: integer, arg3: $BlockState$$Type): boolean
public "callSet"(arg0: integer, arg1: integer, arg2: integer): void
public "getRawData"(): (long)[]
public "getHighestTaken"(arg0: integer, arg1: integer): integer
public "getBlockPredicate"(): $Predicate
public static "primeHeightmaps"(arg0: $ChunkAccess$$Type, arg1: $Set$$Type<($Heightmap$Types$$Type)>): void
public "getFirstAvailable"(arg0: integer, arg1: integer): integer
get "rawData"(): (long)[]
get "blockPredicate"(): $Predicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Heightmap$$Type = ($Heightmap);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Heightmap$$Original = $Heightmap;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration" {
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $RandomBooleanFeatureConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($RandomBooleanFeatureConfiguration)>
readonly "featureTrue": $Holder<($PlacedFeature)>
readonly "featureFalse": $Holder<($PlacedFeature)>

constructor(arg0: $Holder$$Type<($PlacedFeature)>, arg1: $Holder$$Type<($PlacedFeature)>)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomBooleanFeatureConfiguration$$Type = ($RandomBooleanFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomBooleanFeatureConfiguration$$Original = $RandomBooleanFeatureConfiguration;}
declare module "net.minecraft.world.level.pathfinder.PathfindingContext" {
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$PathType} from "net.minecraft.world.level.pathfinder.PathType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CollisionGetter, $CollisionGetter$$Type} from "net.minecraft.world.level.CollisionGetter"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $PathfindingContext {
constructor(arg0: $CollisionGetter$$Type, arg1: $Mob$$Type)

public "level"(): $CollisionGetter
public "currentEvalPos"(): $BlockPos
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "mobPosition"(): $BlockPos
public "getPathTypeFromState"(arg0: integer, arg1: integer, arg2: integer): $PathType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathfindingContext$$Type = ($PathfindingContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PathfindingContext$$Original = $PathfindingContext;}
declare module "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub" {
import {$Either, $Either$$Type} from "com.mojang.datafixers.util.Either"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$StructurePiecesBuilder, $StructurePiecesBuilder$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$Record} from "java.lang.Record"

export class $Structure$GenerationStub extends $Record {
constructor(arg0: $BlockPos$$Type, arg1: $Consumer$$Type<($StructurePiecesBuilder)>)
constructor(position: $BlockPos$$Type, generator: $Either$$Type<($Consumer$$Type<($StructurePiecesBuilder$$Type)>), ($StructurePiecesBuilder$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "position"(): $BlockPos
public "generator"(): $Either<($Consumer<($StructurePiecesBuilder)>), ($StructurePiecesBuilder)>
public "getPiecesBuilder"(): $StructurePiecesBuilder
get "piecesBuilder"(): $StructurePiecesBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Structure$GenerationStub$$Type = ({"position"?: $BlockPos$$Type, "generator"?: $Either$$Type<($Consumer$$Type<($StructurePiecesBuilder$$Type)>), ($StructurePiecesBuilder$$Type)>}) | ([position?: $BlockPos$$Type, generator?: $Either$$Type<($Consumer$$Type<($StructurePiecesBuilder$$Type)>), ($StructurePiecesBuilder$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Structure$GenerationStub$$Original = $Structure$GenerationStub;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.RandomSpreadFoliagePlacer" {
import {$FoliagePlacerType} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacerType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$FoliagePlacer$FoliageSetter$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageSetter"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$FoliagePlacer$FoliageAttachment$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $RandomSpreadFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($RandomSpreadFoliagePlacer)>
readonly "offset": $IntProvider
readonly "radius": $IntProvider

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: $IntProvider$$Type, arg3: integer)

public "type"(): $FoliagePlacerType<(never)>
public "createFoliage"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: integer, arg5: $FoliagePlacer$FoliageAttachment$$Type, arg6: integer, arg7: integer, arg8: integer): void
public "shouldSkipLocation"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: boolean): boolean
public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomSpreadFoliagePlacer$$Type = ($RandomSpreadFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomSpreadFoliagePlacer$$Original = $RandomSpreadFoliagePlacer;}
declare module "net.minecraft.world.level.levelgen.heightproviders.HeightProvider" {
import {$HeightProviderType} from "net.minecraft.world.level.levelgen.heightproviders.HeightProviderType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$WorldGenerationContext$$Type} from "net.minecraft.world.level.levelgen.WorldGenerationContext"

export class $HeightProvider {
static readonly "CODEC": $Codec<($HeightProvider)>

constructor()

public "getType"(): $HeightProviderType<(never)>
public "sample"(arg0: $RandomSource$$Type, arg1: $WorldGenerationContext$$Type): integer
get "type"(): $HeightProviderType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeightProvider$$Type = ($HeightProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HeightProvider$$Original = $HeightProvider;}
declare module "net.minecraft.world.level.levelgen.NoiseChunk$NoiseInterpolator" {
import {$DensityFunctions$Marker$Type} from "net.minecraft.world.level.levelgen.DensityFunctions$Marker$Type"
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$NoiseChunk, $NoiseChunk$$Type} from "net.minecraft.world.level.levelgen.NoiseChunk"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$NoiseChunk$NoiseChunkDensityFunction$$Interface} from "net.minecraft.world.level.levelgen.NoiseChunk$NoiseChunkDensityFunction"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$DensityFunctions$MarkerOrMarked$$Interface} from "net.minecraft.world.level.levelgen.DensityFunctions$MarkerOrMarked"
import {$DensityFunction, $DensityFunction$$Type} from "net.minecraft.world.level.levelgen.DensityFunction"

export class $NoiseChunk$NoiseInterpolator implements $DensityFunctions$MarkerOrMarked$$Interface, $NoiseChunk$NoiseChunkDensityFunction$$Interface {
readonly "this$0": $NoiseChunk
 "slice0": ((double)[])[]
 "slice1": ((double)[])[]

constructor(arg0: $NoiseChunk$$Type, arg1: $DensityFunction$$Type)

public "type"(): $DensityFunctions$Marker$Type
public "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
public "wrapped"(): $DensityFunction
public "updateForX"(arg0: double): void
public "updateForY"(arg0: double): void
public "updateForZ"(arg0: double): void
public "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
public "selectCellYZ"(arg0: integer, arg1: integer): void
public "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
public "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
public "abs"(): $DensityFunction
public "clamp"(arg0: double, arg1: double): $DensityFunction
public "maxValue"(): double
public "square"(): $DensityFunction
public "halfNegative"(): $DensityFunction
public "quarterNegative"(): $DensityFunction
public "minValue"(): double
public "cube"(): $DensityFunction
public "squeeze"(): $DensityFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseChunk$NoiseInterpolator$$Type = ($NoiseChunk$NoiseInterpolator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseChunk$NoiseInterpolator$$Original = $NoiseChunk$NoiseInterpolator;}
declare module "net.minecraft.world.level.block.entity.HangingSignBlockEntity" {
import {$Level} from "net.minecraft.world.level.Level"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$SignBlockEntity} from "net.minecraft.world.level.block.entity.SignBlockEntity"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $HangingSignBlockEntity extends $SignBlockEntity {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getSignInteractionFailedSoundEvent"(): $SoundEvent
public "getMaxTextLineWidth"(): integer
public "getTextLineHeight"(): integer
public "getUpdatePacket"(): $Packet
get "signInteractionFailedSoundEvent"(): $SoundEvent
get "maxTextLineWidth"(): integer
get "textLineHeight"(): integer
get "updatePacket"(): $Packet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HangingSignBlockEntity$$Type = ($HangingSignBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HangingSignBlockEntity$$Original = $HangingSignBlockEntity;}
declare module "net.minecraft.world.level.block.entity.BrushableBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BrushableBlockEntity extends $BlockEntity {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getItem"(): $ItemStack
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "unpackLootTable"(arg0: $Player$$Type): void
public "setLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
public "getHitDirection"(): $Direction
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "brush"(arg0: long, arg1: $Player$$Type, arg2: $Direction$$Type): boolean
public "checkReset"(): void
get "item"(): $ItemStack
get "hitDirection"(): $Direction
get "updatePacket"(): $ClientboundBlockEntityDataPacket
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BrushableBlockEntity$$Type = ($BrushableBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BrushableBlockEntity$$Original = $BrushableBlockEntity;}
declare module "net.minecraft.world.level.levelgen.carver.CarverDebugSettings" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CarverDebugSettings {
static readonly "CODEC": $Codec<($CarverDebugSettings)>
static readonly "DEFAULT": $CarverDebugSettings

public static "of"(arg0: boolean, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: $BlockState$$Type): $CarverDebugSettings
public static "of"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type): $CarverDebugSettings
public static "of"(arg0: boolean, arg1: $BlockState$$Type): $CarverDebugSettings
public "getWaterState"(): $BlockState
public "getLavaState"(): $BlockState
public "isDebugMode"(): boolean
public "getBarrierState"(): $BlockState
public "getAirState"(): $BlockState
get "waterState"(): $BlockState
get "lavaState"(): $BlockState
get "debugMode"(): boolean
get "barrierState"(): $BlockState
get "airState"(): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarverDebugSettings$$Type = ($CarverDebugSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarverDebugSettings$$Original = $CarverDebugSettings;}
declare module "net.minecraft.world.level.levelgen.structure.StructureSpawnOverride$BoundingBoxType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $StructureSpawnOverride$BoundingBoxType extends $Enum<($StructureSpawnOverride$BoundingBoxType)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($StructureSpawnOverride$BoundingBoxType)>
static readonly "STRUCTURE": $StructureSpawnOverride$BoundingBoxType
static readonly "PIECE": $StructureSpawnOverride$BoundingBoxType

public static "values"(): ($StructureSpawnOverride$BoundingBoxType)[]
public static "valueOf"(arg0: StringJS): $StructureSpawnOverride$BoundingBoxType
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureSpawnOverride$BoundingBoxType$$Type = (("piece") | ("full"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureSpawnOverride$BoundingBoxType$$Original = $StructureSpawnOverride$BoundingBoxType;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Record} from "java.lang.Record"

export class $SimpleBlockConfiguration extends $Record implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($SimpleBlockConfiguration)>

constructor(arg0: $BlockStateProvider$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "toPlace"(): $BlockStateProvider
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleBlockConfiguration$$Type = ({"toPlace"?: $BlockStateProvider$$Type}) | ([toPlace?: $BlockStateProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleBlockConfiguration$$Original = $SimpleBlockConfiguration;}
declare module "net.minecraft.world.level.LevelAccessor" {
import {$Iterable} from "java.lang.Iterable"
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$SoundSource$$Type} from "net.minecraft.sounds.SoundSource"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$Stream} from "java.util.stream.Stream"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BiomeManager} from "net.minecraft.world.level.biome.BiomeManager"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$Difficulty} from "net.minecraft.world.Difficulty"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$LevelData} from "net.minecraft.world.level.storage.LevelData"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$CommonLevelAccessor$$Interface} from "net.minecraft.world.level.CommonLevelAccessor"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"
import {$LevelTimeAccess$$Interface} from "net.minecraft.world.level.LevelTimeAccess"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$ChunkSource} from "net.minecraft.world.level.chunk.ChunkSource"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$TickPriority$$Type} from "net.minecraft.world.ticks.TickPriority"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Class$$Type} from "java.lang.Class"
import {$TargetingConditions$$Type} from "net.minecraft.world.entity.ai.targeting.TargetingConditions"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$HolderLookup} from "net.minecraft.core.HolderLookup"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$LevelTickAccess} from "net.minecraft.world.ticks.LevelTickAccess"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$DifficultyInstance} from "net.minecraft.world.DifficultyInstance"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$DimensionType} from "net.minecraft.world.level.dimension.DimensionType"

export interface $LevelAccessor$$Interface extends $CommonLevelAccessor$$Interface, $LevelTimeAccess$$Interface {
get "chunkSource"(): $ChunkSource
get "random"(): $RandomSource
get "levelData"(): $LevelData
get "blockTicks"(): $LevelTickAccess<($Block)>
get "fluidTicks"(): $LevelTickAccess<($Fluid)>
get "server"(): $MinecraftServer
get "difficulty"(): $Difficulty
get "moonBrightness"(): float
get "moonPhase"(): integer
get "seaLevel"(): integer
get "clientSide"(): boolean
get "skyDarken"(): integer
get "biomeManager"(): $BiomeManager
get "height"(): integer
get "minBuildHeight"(): integer
get "mcEntities"(): $Iterable<($Entity)>
get "players"(): $EntityArrayList
get "mcPlayers"(): $List<($Player)>
get "lightEngine"(): $LevelLightEngine
get "worldBorder"(): $WorldBorder
get "entities"(): $EntityArrayList
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "maxSection"(): integer
get "minSection"(): integer
get "sectionsCount"(): integer
}

export class $LevelAccessor implements $LevelAccessor$$Interface {
 "getChunkSource"(): $ChunkSource
 "neighborShapeChanged"(arg0: $Direction$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type, arg4: integer, arg5: integer): void
 "blockUpdated"(arg0: $BlockPos$$Type, arg1: $Block$$Type): void
 "addParticle"(arg0: $ParticleOptions$$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): void
 "nextSubTickCount"(): long
 "getRandom"(): $RandomSource
 "levelEvent"(arg0: $Player$$Type, arg1: integer, arg2: $BlockPos$$Type, arg3: integer): void
 "levelEvent"(arg0: integer, arg1: $BlockPos$$Type, arg2: integer): void
 "dayTime"(): long
 "getLevelData"(): $LevelData
 "getBlockTicks"(): $LevelTickAccess<($Block)>
 "getFluidTicks"(): $LevelTickAccess<($Fluid)>
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer, arg3: $TickPriority$$Type): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer, arg3: $TickPriority$$Type): void
 "getCurrentDifficultyAt"(arg0: $BlockPos$$Type): $DifficultyInstance
 "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $Vec3$$Type): void
 "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $Vec3$$Type, arg2: $GameEvent$Context$$Type): void
 "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $BlockPos$$Type): void
 "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
 "gameEvent"(arg0: $ResourceKey$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
 "getServer"(): $MinecraftServer
 "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type, arg4: float, arg5: float): void
 "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type): void
 "getDifficulty"(): $Difficulty
 "hasChunk"(arg0: integer, arg1: integer): boolean
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "getTimeOfDay"(arg0: float): float
 "getMoonBrightness"(): float
 "getMoonPhase"(): integer
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($Entity)>
 "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type, arg2: $Predicate$$Type<($Entity)>): $List<($Entity)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type): $List<(T)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "hasNearbyAlivePlayer"(arg0: double, arg1: double, arg2: double, arg3: double): boolean
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: double, arg2: double, arg3: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: double, arg3: double, arg4: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: $Predicate$$Type<($Entity)>): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): $Player
 "getNearestPlayer"(arg0: $Entity$$Type, arg1: double): $Player
 "getNearestEntity"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double, arg6: $AABB$$Type): T
 "getNearestEntity"<T extends $LivingEntity>(arg0: $List$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double): T
 "getNearbyPlayers"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: $AABB$$Type): $List<($Player)>
 "getNearbyEntities"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: $AABB$$Type): $List<(T)>
 "getPlayerByUUID"(arg0: $UUID$$Type): $Player
 "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
 "getBlockStatesIfLoaded"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "registryAccess"(): $RegistryAccess
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
 "dimensionType"(): $DimensionType
/**
 * 
 * @deprecated
 */
 "getSeaLevel"(): integer
 "isClientSide"(): boolean
 "getSkyDarken"(): integer
 "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
 "getUncachedNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "canSeeSkyFromBelowWater"(arg0: $BlockPos$$Type): boolean
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type): integer
 "isWaterAt"(arg0: $BlockPos$$Type): boolean
 "hasBiomes"(): boolean
 "enabledFeatures"(): $FeatureFlagSet
 "getPathfindingCostFromLightLevels"(arg0: $BlockPos$$Type): float
 "getBiomeManager"(): $BiomeManager
 "isEmptyBlock"(arg0: $BlockPos$$Type): boolean
 "holderLookup"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>): $HolderLookup<(T)>
 "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "getBiomeFabric"(arg0: $BlockPos$$Type): $Holder
 "getChunk"(arg0: $BlockPos$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
 "getHeight"(): integer
 "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
/**
 * 
 * @deprecated
 */
 "getLightLevelDependentMagicValue"(arg0: $BlockPos$$Type): float
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: $BlockPos$$Type): boolean
 "getMinBuildHeight"(): integer
 "containsAnyLiquid"(arg0: $AABB$$Type): boolean
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getPlayers"(): $EntityArrayList
 "getMcPlayers"(): $List<($Player)>
 "self"(): $EntityGetter
 "getLightEngine"(): $LevelLightEngine
 "canSeeSky"(arg0: $BlockPos$$Type): boolean
 "getShade"(arg0: $Direction$$Type, arg1: boolean): float
 "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
 "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
 "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
 "getWorldBorder"(): $WorldBorder
 "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
 "isUnobstructed"(arg0: $Entity$$Type): boolean
 "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "noCollision"(arg0: $Entity$$Type): boolean
 "noCollision"(arg0: $AABB$$Type): boolean
 "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
 "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
 "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
 "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
 "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
 "holder"<T>(arg0: $ResourceKey$$Type<(T)>): $Optional<($Holder$Reference<(T)>)>
 "isAreaLoaded"(arg0: $BlockPos$$Type, arg1: integer): boolean
 "holderOrThrow"<T>(arg0: $ResourceKey$$Type<(T)>): $Holder<(T)>
/**
 * 
 * @deprecated
 */
 "getBlockEntityRenderAttachment"(arg0: $BlockPos$$Type): any
 "isStateAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($BlockState)>): boolean
 "isFluidAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($FluidState)>): boolean
 "removeBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "addFreshEntity"(arg0: $Entity$$Type): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type, arg3: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type): boolean
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntities"(): $EntityArrayList
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
 "getMaxLightLevel"(): integer
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getMaxBuildHeight"(): integer
 "getSectionIndex"(arg0: integer): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionsCount"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
 "getBlockEntityRenderData"(arg0: $BlockPos$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelAccessor$$Type = ($LevelAccessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelAccessor$$Original = $LevelAccessor;}
declare module "net.minecraft.world.level.chunk.LightChunkGetter" {
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$SectionPos$$Type} from "net.minecraft.core.SectionPos"
import {$LightChunk} from "net.minecraft.world.level.chunk.LightChunk"

export interface $LightChunkGetter$$Interface {
get "level"(): $BlockGetter
}

export class $LightChunkGetter implements $LightChunkGetter$$Interface {
 "getLevel"(): $BlockGetter
 "getChunkForLighting"(arg0: integer, arg1: integer): $LightChunk
 "onLightUpdate"(arg0: $LightLayer$$Type, arg1: $SectionPos$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LightChunkGetter$$Type = ($LightChunkGetter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LightChunkGetter$$Original = $LightChunkGetter;}
declare module "net.minecraft.world.level.levelgen.structure.structures.JigsawStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$LiquidSettings, $LiquidSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings"
import {$List$$Type} from "java.util.List"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$DimensionPadding, $DimensionPadding$$Type} from "net.minecraft.world.level.levelgen.structure.pools.DimensionPadding"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$StructureTemplatePool$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool"
import {$PoolAliasBinding$$Type} from "net.minecraft.world.level.levelgen.structure.pools.alias.PoolAliasBinding"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$HeightProvider$$Type} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $JigsawStructure extends $Structure {
static readonly "CODEC": $MapCodec<($JigsawStructure)>
static readonly "DEFAULT_LIQUID_SETTINGS": $LiquidSettings
static readonly "DEFAULT_DIMENSION_PADDING": $DimensionPadding
static readonly "MAX_DEPTH": integer
static readonly "MIN_DEPTH": integer
static readonly "DIRECT_CODEC": $Codec<($Structure)>
static readonly "MAX_TOTAL_STRUCTURE_RANGE": integer

constructor(arg0: $Structure$StructureSettings$$Type, arg1: $Holder$$Type<($StructureTemplatePool)>, arg2: integer, arg3: $HeightProvider$$Type, arg4: boolean, arg5: $Heightmap$Types$$Type)
constructor(arg0: $Structure$StructureSettings$$Type, arg1: $Holder$$Type<($StructureTemplatePool)>, arg2: ($ResourceLocation$$Type)?, arg3: integer, arg4: $HeightProvider$$Type, arg5: boolean, arg6: ($Heightmap$Types$$Type)?, arg7: integer, arg8: $List$$Type<($PoolAliasBinding$$Type)>, arg9: $DimensionPadding$$Type, arg10: $LiquidSettings$$Type)
constructor(arg0: $Structure$StructureSettings$$Type, arg1: $Holder$$Type<($StructureTemplatePool)>, arg2: integer, arg3: $HeightProvider$$Type, arg4: boolean)

public "type"(): $StructureType<(never)>
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JigsawStructure$$Type = ($JigsawStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JigsawStructure$$Original = $JigsawStructure;}
declare module "net.minecraft.world.level.Spawner" {
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export interface $Spawner$$Interface {

(arg0: $EntityType<(never)>, arg1: $RandomSource): void
}

export class $Spawner implements $Spawner$$Interface {
static "appendHoverText"(arg0: $ItemStack$$Type, arg1: $List$$Type<($Component$$Type)>, arg2: StringJS): void
static "getSpawnEntityDisplayName"(arg0: $ItemStack$$Type, arg1: StringJS): $Component
 "setEntityId"(arg0: $EntityType$$Type<(never)>, arg1: $RandomSource$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Spawner$$Type = ((arg0: $EntityType<(never)>, arg1: $RandomSource) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Spawner$$Original = $Spawner;}
declare module "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer$Builder" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$LootPoolEntryContainer} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer"
import {$Function$$Type} from "java.util.function.Function"
import {$List} from "java.util.List"
import {$EntryGroup$Builder} from "net.minecraft.world.level.storage.loot.entries.EntryGroup$Builder"
import {$SequentialEntry$Builder} from "net.minecraft.world.level.storage.loot.entries.SequentialEntry$Builder"
import {$LootItemCondition} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"
import {$ConditionUserBuilder, $ConditionUserBuilder$$Interface} from "net.minecraft.world.level.storage.loot.predicates.ConditionUserBuilder"
import {$AlternativesEntry$Builder} from "net.minecraft.world.level.storage.loot.entries.AlternativesEntry$Builder"

export class $LootPoolEntryContainer$Builder<T extends $LootPoolEntryContainer$Builder<(object)>> implements $ConditionUserBuilder$$Interface<(T)> {
constructor()

public "append"(arg0: $LootPoolEntryContainer$Builder$$Type<(never)>): $EntryGroup$Builder
public "unwrap"(): T
public "build"(): $LootPoolEntryContainer
public "when"(arg0: $LootItemCondition$Builder$$Type): $ConditionUserBuilder
public "getConditions"(): $List<($LootItemCondition)>
public "then"(arg0: $LootPoolEntryContainer$Builder$$Type<(never)>): $SequentialEntry$Builder
public "getThis"(): T
public "otherwise"(arg0: $LootPoolEntryContainer$Builder$$Type<(never)>): $AlternativesEntry$Builder
public "when"<E>(arg0: $Iterable$$Type<(E)>, arg1: $Function$$Type<(E), ($LootItemCondition$Builder$$Type)>): T
get "conditions"(): $List<($LootItemCondition)>
get "this"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootPoolEntryContainer$Builder$$Type<T> = ($LootPoolEntryContainer$Builder<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootPoolEntryContainer$Builder$$Original<T> = $LootPoolEntryContainer$Builder<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DeltaFeatureConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($DeltaFeatureConfiguration)>

constructor(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $IntProvider$$Type, arg3: $IntProvider$$Type)

public "size"(): $IntProvider
public "contents"(): $BlockState
public "rim"(): $BlockState
public "rimSize"(): $IntProvider
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DeltaFeatureConfiguration$$Type = ($DeltaFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DeltaFeatureConfiguration$$Original = $DeltaFeatureConfiguration;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.RandomizedIntStateProvider" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BlockStateProviderType} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProviderType"
import {$IntegerProperty$$Type} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $RandomizedIntStateProvider extends $BlockStateProvider {
static readonly "CODEC": $MapCodec<($RandomizedIntStateProvider)>

constructor(arg0: $BlockStateProvider$$Type, arg1: $IntegerProperty$$Type, arg2: $IntProvider$$Type)
constructor(arg0: $BlockStateProvider$$Type, arg1: StringJS, arg2: $IntProvider$$Type)

public "type"(): $BlockStateProviderType<(never)>
public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomizedIntStateProvider$$Type = ($RandomizedIntStateProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomizedIntStateProvider$$Original = $RandomizedIntStateProvider;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessorList" {
import {$StructureProcessor, $StructureProcessor$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$List, $List$$Type} from "java.util.List"

export class $StructureProcessorList {
constructor(arg0: $List$$Type<($StructureProcessor$$Type)>)

public "toString"(): StringJS
public "list"(): $List<($StructureProcessor)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenProcessorList
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenProcessorListTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureProcessorList$$Type = (Special.WorldgenProcessorList);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureProcessorList$$Original = $StructureProcessorList;}
declare module "net.minecraft.world.level.levelgen.structure.structures.EndCityStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $EndCityStructure extends $Structure {
static readonly "CODEC": $MapCodec<($EndCityStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "type"(): $StructureType<(never)>
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndCityStructure$$Type = ($EndCityStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EndCityStructure$$Original = $EndCityStructure;}
declare module "net.minecraft.world.level.chunk.LevelChunk" {
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$NoiseChunk} from "net.minecraft.world.level.levelgen.NoiseChunk"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ChunkAccess$TicksToSave} from "net.minecraft.world.level.chunk.ChunkAccess$TicksToSave"
import {$LevelChunk$EntityCreationType$$Type} from "net.minecraft.world.level.chunk.LevelChunk$EntityCreationType"
import {$TickContainerAccess} from "net.minecraft.world.ticks.TickContainerAccess"
import {$BlendingData, $BlendingData$$Type} from "net.minecraft.world.level.levelgen.blending.BlendingData"
import {$AttachmentType$$Type as $AttachmentType$0$$Type} from "net.fabricmc.fabric.api.attachment.v1.AttachmentType"
import {$IAttachmentHolder$$Interface} from "net.neoforged.neoforge.attachment.IAttachmentHolder"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Heightmap} from "net.minecraft.world.level.levelgen.Heightmap"
import {$ChunkSkyLightSources} from "net.minecraft.world.level.lighting.ChunkSkyLightSources"
import {$Logger} from "org.slf4j.Logger"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$AttachmentChange$$Type} from "net.fabricmc.fabric.impl.attachment.sync.AttachmentChange"
import {$ChunkStatus} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$FullChunkStatus, $FullChunkStatus$$Type} from "net.minecraft.server.level.FullChunkStatus"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ClientboundLevelChunkPacketData$BlockEntityTagOutput$$Type} from "net.minecraft.network.protocol.game.ClientboundLevelChunkPacketData$BlockEntityTagOutput"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$GameEventListenerRegistry} from "net.minecraft.world.level.gameevent.GameEventListenerRegistry"
import {$ShortList} from "it.unimi.dsi.fastutil.shorts.ShortList"
import {$AttachmentTargetInfo} from "net.fabricmc.fabric.impl.attachment.sync.AttachmentTargetInfo"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"
import {$AttachmentTargetImpl$$Interface} from "net.fabricmc.fabric.impl.attachment.AttachmentTargetImpl"
import {$ProtoChunk$$Type} from "net.minecraft.world.level.chunk.ProtoChunk"
import {$UpgradeData, $UpgradeData$$Type} from "net.minecraft.world.level.chunk.UpgradeData"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Function$$Type} from "java.util.function.Function"
import {$LevelChunkTicks$$Type} from "net.minecraft.world.ticks.LevelChunkTicks"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AttachmentSyncPayloadS2C$$Type} from "net.fabricmc.fabric.impl.attachment.sync.s2c.AttachmentSyncPayloadS2C"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$AttachmentType$$Type} from "net.neoforged.neoforge.attachment.AttachmentType"
import {$Map} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$LevelChunkSection, $LevelChunkSection$$Type} from "net.minecraft.world.level.chunk.LevelChunkSection"
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$ExtendedChunk$$Interface} from "com.sk89q.worldedit.neoforge.internal.ExtendedChunk"
import {$Heightmap$Types} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$LevelChunk$PostLoadProcessor$$Type} from "net.minecraft.world.level.chunk.LevelChunk$PostLoadProcessor"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LevelChunkAuxiliaryLightManager} from "net.neoforged.neoforge.common.world.LevelChunkAuxiliaryLightManager"
import {$Int2ObjectMap$$Type} from "it.unimi.dsi.fastutil.ints.Int2ObjectMap"

export class $LevelChunk extends $ChunkAccess implements $IAttachmentHolder$$Interface, $ExtendedChunk$$Interface, $AttachmentTargetImpl$$Interface {
readonly "upgradeData": $UpgradeData
 "xaero_wm_chunkClean": boolean
readonly "chunkPos": $ChunkPos
readonly "level": $Level
 "xaero_chunkClean": boolean
readonly "pendingBlockEntities": $Map<($BlockPos), ($CompoundTag)>
 "noiseChunk": $NoiseChunk
readonly "sections": ($LevelChunkSection)[]
 "loaded": boolean
 "skyLightSources": $ChunkSkyLightSources
readonly "postProcessing": ($ShortList)[]
 "blendingData": $BlendingData
static readonly "LOGGER": $Logger
readonly "levelHeightAccessor": $LevelHeightAccessor
readonly "blockEntities": $Map<($BlockPos), ($BlockEntity)>
 "saveTimePoint": long
 "unsaved": boolean
readonly "heightmaps": $Map<($Heightmap$Types), ($Heightmap)>
static readonly "NO_FILLED_SECTION": integer

constructor(arg0: $ServerLevel$$Type, arg1: $ProtoChunk$$Type, arg2: $LevelChunk$PostLoadProcessor$$Type)
constructor(arg0: $Level$$Type, arg1: $ChunkPos$$Type, arg2: $UpgradeData$$Type, arg3: $LevelChunkTicks$$Type<($Block$$Type)>, arg4: $LevelChunkTicks$$Type<($Fluid$$Type)>, arg5: long, arg6: ($LevelChunkSection$$Type)[], arg7: $LevelChunk$PostLoadProcessor$$Type, arg8: $BlendingData$$Type)
constructor(arg0: $Level$$Type, arg1: $ChunkPos$$Type)

public "isEmpty"(): boolean
public "getLevel"(): $Level
public "getBlockEntityNbtForSaving"(arg0: $BlockPos$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public "getTicksForSerialization"(): $ChunkAccess$TicksToSave
public "getListenerRegistry"(arg0: integer): $GameEventListenerRegistry
public "getFluidState"(arg0: integer, arg1: integer, arg2: integer): $FluidState
public "getFluidState"(arg0: $BlockPos$$Type): $FluidState
public "fabric_shouldTryToSync"(): boolean
public "getBlockEntity"(arg0: $BlockPos$$Type, arg1: $LevelChunk$EntityCreationType$$Type): $BlockEntity
public "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
public "setLoaded"(arg0: boolean): void
public "isTicking"(arg0: $BlockPos$$Type): boolean
public "fabric_syncChange"(arg0: $AttachmentType$0$$Type, arg1: $AttachmentSyncPayloadS2C$$Type): void
public "unregisterTickContainerFromLevel"(arg0: $ServerLevel$$Type): void
public "unpackTicks"(arg0: long): void
public "addAndRegisterBlockEntity"(arg0: $BlockEntity$$Type): void
public "setBlockState"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: boolean): $BlockState
public "setBlockState"(pos: $BlockPos$$Type, state: $BlockState$$Type, moved: boolean, update: boolean): $BlockState
public "setBlockEntity"(arg0: $BlockEntity$$Type): void
public "getFullStatus"(): $FullChunkStatus
public "removeBlockEntity"(arg0: $BlockPos$$Type): void
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "getPersistedStatus"(): $ChunkStatus
public "getBlockEntities"(): $Map<($BlockPos), ($BlockEntity)>
public "clearAllBlockEntities"(): void
/**
 * 
 * @deprecated
 */
public "addEntity"(arg0: $Entity$$Type): void
public "getBlockTicks"(): $TickContainerAccess<($Block)>
public "getFluidTicks"(): $TickContainerAccess<($Fluid)>
public "getAuxLightManager"(arg0: $ChunkPos$$Type): $LevelChunkAuxiliaryLightManager
public "syncData"(arg0: $AttachmentType$$Type<(never)>): void
public "fabric_computeInitialSyncChanges"(arg0: $ServerPlayer$$Type, arg1: $Consumer$$Type): void
public "fabric_getDynamicRegistryManager"(): $RegistryAccess
public "redirect$bhf000$worldedit$setBlockStateHook"(target: $BlockState$$Type, world: $Level$$Type, pos: $BlockPos$$Type, old: $BlockState$$Type, move: boolean): void
public "registerTickContainerInLevel"(arg0: $ServerLevel$$Type): void
public "postProcessGeneration"(): void
public "replaceWithPacketData"(arg0: $FriendlyByteBuf$$Type, arg1: $CompoundTag$$Type, arg2: $Consumer$$Type<($ClientboundLevelChunkPacketData$BlockEntityTagOutput)>): void
public "setGameEventListenerRegistrySections"(arg0: $Int2ObjectMap$$Type): void
public "registerAllBlockEntitiesAfterLevelLoad"(): void
public "runPostLoad"(): void
public "replaceBiomes"(arg0: $FriendlyByteBuf$$Type): void
public "setFullStatus"(arg0: $Supplier$$Type<($FullChunkStatus$$Type)>): void
public "getData"<T>(arg0: $AttachmentType$$Type<(T)>): T
public "removeData"<T>(arg0: $AttachmentType$$Type<(T)>): T
public "getExistingDataOrNull"<T>(arg0: $AttachmentType$$Type<(T)>): T
public "hasAttachments"(): boolean
public "setData"<T>(arg0: $AttachmentType$$Type<(T)>, arg1: T): T
public "hasData"(arg0: $AttachmentType$$Type<(never)>): boolean
public "acknowledgeSyncedEntry"(arg0: $AttachmentType$0$$Type<(never)>, arg1: $AttachmentChange$$Type): void
public "fabric_getSyncTargetInfo"(): $AttachmentTargetInfo<(never)>
public static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
public static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
get "empty"(): boolean
get "ticksForSerialization"(): $ChunkAccess$TicksToSave
set "blockEntity"(value: $BlockEntity$$Type)
get "fullStatus"(): $FullChunkStatus
get "persistedStatus"(): $ChunkStatus
get "blockTicks"(): $TickContainerAccess<($Block)>
get "fluidTicks"(): $TickContainerAccess<($Fluid)>
set "gameEventListenerRegistrySections"(value: $Int2ObjectMap$$Type)
set "fullStatus"(value: $Supplier$$Type<($FullChunkStatus$$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelChunk$$Type = ($LevelChunk);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelChunk$$Original = $LevelChunk;}
declare module "net.minecraft.world.level.WorldDataConfiguration" {
import {$FeatureFlagSet, $FeatureFlagSet$$Type} from "net.minecraft.world.flag.FeatureFlagSet"
import {$Codec} from "com.mojang.serialization.Codec"
import {$DataPackConfig, $DataPackConfig$$Type} from "net.minecraft.world.level.DataPackConfig"
import {$Record} from "java.lang.Record"

export class $WorldDataConfiguration extends $Record {
static readonly "CODEC": $Codec<($WorldDataConfiguration)>
static readonly "ENABLED_FEATURES_ID": StringJS
static readonly "DEFAULT": $WorldDataConfiguration

constructor(arg0: $DataPackConfig$$Type, arg1: $FeatureFlagSet$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "enabledFeatures"(): $FeatureFlagSet
public "dataPacks"(): $DataPackConfig
public "expandFeatures"(arg0: $FeatureFlagSet$$Type): $WorldDataConfiguration
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldDataConfiguration$$Type = ({"dataPacks"?: $DataPackConfig$$Type, "enabledFeatures"?: $FeatureFlagSet$$Type}) | ([dataPacks?: $DataPackConfig$$Type, enabledFeatures?: $FeatureFlagSet$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldDataConfiguration$$Original = $WorldDataConfiguration;}
declare module "net.minecraft.world.level.biome.Biome$Precipitation" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $Biome$Precipitation extends $Enum<($Biome$Precipitation)> implements $StringRepresentable$$Interface {
static readonly "RAIN": $Biome$Precipitation
static readonly "CODEC": $Codec<($Biome$Precipitation)>
static readonly "SNOW": $Biome$Precipitation
static readonly "NONE": $Biome$Precipitation

public static "values"(): ($Biome$Precipitation)[]
public static "valueOf"(arg0: StringJS): $Biome$Precipitation
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Biome$Precipitation$$Type = (("none") | ("rain") | ("snow"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Biome$Precipitation$$Original = $Biome$Precipitation;}
declare module "net.minecraft.world.level.portal.PortalForcer" {
import {$Direction$Axis$$Type} from "net.minecraft.core.Direction$Axis"
import {$Optional} from "java.util.Optional"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockUtil$FoundRectangle} from "net.minecraft.BlockUtil$FoundRectangle"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WorldBorder$$Type} from "net.minecraft.world.level.border.WorldBorder"

export class $PortalForcer {
readonly "level": $ServerLevel
static readonly "TICKET_RADIUS": integer

constructor(arg0: $ServerLevel$$Type)

public "findClosestPortalPosition"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $WorldBorder$$Type): $Optional
public "createPortal"(arg0: $BlockPos$$Type, arg1: $Direction$Axis$$Type): $Optional<($BlockUtil$FoundRectangle)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PortalForcer$$Type = ($PortalForcer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PortalForcer$$Original = $PortalForcer;}
declare module "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement$FrequencyReductionMethod" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $StructurePlacement$FrequencyReductionMethod extends $Enum<($StructurePlacement$FrequencyReductionMethod)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($StructurePlacement$FrequencyReductionMethod)>
static readonly "LEGACY_TYPE_3": $StructurePlacement$FrequencyReductionMethod
static readonly "LEGACY_TYPE_2": $StructurePlacement$FrequencyReductionMethod
static readonly "LEGACY_TYPE_1": $StructurePlacement$FrequencyReductionMethod
static readonly "DEFAULT": $StructurePlacement$FrequencyReductionMethod

public static "values"(): ($StructurePlacement$FrequencyReductionMethod)[]
public static "valueOf"(arg0: StringJS): $StructurePlacement$FrequencyReductionMethod
public "getSerializedName"(): StringJS
public "shouldGenerate"(arg0: long, arg1: integer, arg2: integer, arg3: integer, arg4: float): boolean
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePlacement$FrequencyReductionMethod$$Type = (("default") | ("legacy_type_1") | ("legacy_type_2") | ("legacy_type_3"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePlacement$FrequencyReductionMethod$$Original = $StructurePlacement$FrequencyReductionMethod;}
declare module "net.minecraft.world.level.chunk.BlockColumn" {
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockColumn$$Interface {
}

export class $BlockColumn implements $BlockColumn$$Interface {
 "getBlock"(arg0: integer): $BlockState
 "setBlock"(arg0: integer, arg1: $BlockState$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockColumn$$Type = ($BlockColumn);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockColumn$$Original = $BlockColumn;}
declare module "net.minecraft.world.level.levelgen.NoiseChunk$NoiseChunkDensityFunction" {
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$DensityFunction, $DensityFunction$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction"

export interface $NoiseChunk$NoiseChunkDensityFunction$$Interface extends $DensityFunction$$Interface {
}

export class $NoiseChunk$NoiseChunkDensityFunction implements $NoiseChunk$NoiseChunkDensityFunction$$Interface {
 "abs"(): $DensityFunction
 "clamp"(arg0: double, arg1: double): $DensityFunction
 "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
 "maxValue"(): double
 "square"(): $DensityFunction
 "halfNegative"(): $DensityFunction
 "quarterNegative"(): $DensityFunction
 "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
 "minValue"(): double
 "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
 "cube"(): $DensityFunction
 "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
 "squeeze"(): $DensityFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseChunk$NoiseChunkDensityFunction$$Type = ($NoiseChunk$NoiseChunkDensityFunction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseChunk$NoiseChunkDensityFunction$$Original = $NoiseChunk$NoiseChunkDensityFunction;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockColumnConfiguration$Layer, $BlockColumnConfiguration$Layer$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration$Layer"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Record} from "java.lang.Record"

export class $BlockColumnConfiguration extends $Record implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($BlockColumnConfiguration)>

constructor(arg0: $List$$Type<($BlockColumnConfiguration$Layer$$Type)>, arg1: $Direction$$Type, arg2: $BlockPredicate$$Type, arg3: boolean)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "layer"(arg0: $IntProvider$$Type, arg1: $BlockStateProvider$$Type): $BlockColumnConfiguration$Layer
public "layers"(): $List<($BlockColumnConfiguration$Layer)>
public "direction"(): $Direction
public "prioritizeTip"(): boolean
public "allowedPlacement"(): $BlockPredicate
public static "simple"(arg0: $IntProvider$$Type, arg1: $BlockStateProvider$$Type): $BlockColumnConfiguration
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockColumnConfiguration$$Type = ({"layers"?: $List$$Type<($BlockColumnConfiguration$Layer$$Type)>, "direction"?: $Direction$$Type, "allowedPlacement"?: $BlockPredicate$$Type, "prioritizeTip"?: boolean}) | ([layers?: $List$$Type<($BlockColumnConfiguration$Layer$$Type)>, direction?: $Direction$$Type, allowedPlacement?: $BlockPredicate$$Type, prioritizeTip?: boolean]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockColumnConfiguration$$Original = $BlockColumnConfiguration;}
declare module "net.minecraft.world.level.block.state.properties.IntegerProperty" {
import {$Collection} from "java.util.Collection"
import {$Optional} from "java.util.Optional"
import {$Comparable$$Type} from "java.lang.Comparable"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $IntegerProperty extends $Property<(integer)> {
constructor(arg0: StringJS, arg1: integer, arg2: integer)

public "getName"(arg0: $Comparable$$Type): StringJS
public "getName"(arg0: integer): StringJS
public "equals"(arg0: any): boolean
public "getValue"(arg0: StringJS): $Optional<(integer)>
public static "create"(arg0: StringJS, arg1: integer, arg2: integer): $IntegerProperty
public "generateHashCode"(): integer
public "getPossibleValues"(): $Collection<(integer)>
get "possibleValues"(): $Collection<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntegerProperty$$Type = ($IntegerProperty);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IntegerProperty$$Original = $IntegerProperty;}
declare module "net.minecraft.world.level.CommonLevelAccessor" {
import {$Iterable} from "java.lang.Iterable"
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$Holder} from "net.minecraft.core.Holder"
import {$LevelReader$$Interface} from "net.minecraft.world.level.LevelReader"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$Stream} from "java.util.stream.Stream"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BiomeManager} from "net.minecraft.world.level.biome.BiomeManager"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Class$$Type} from "java.lang.Class"
import {$TargetingConditions$$Type} from "net.minecraft.world.entity.ai.targeting.TargetingConditions"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$HolderLookup} from "net.minecraft.core.HolderLookup"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$LevelSimulatedRW$$Interface} from "net.minecraft.world.level.LevelSimulatedRW"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$EntityGetter, $EntityGetter$$Interface} from "net.minecraft.world.level.EntityGetter"
import {$DimensionType} from "net.minecraft.world.level.dimension.DimensionType"

export interface $CommonLevelAccessor$$Interface extends $EntityGetter$$Interface, $LevelReader$$Interface, $LevelSimulatedRW$$Interface {
get "seaLevel"(): integer
get "clientSide"(): boolean
get "skyDarken"(): integer
get "biomeManager"(): $BiomeManager
get "height"(): integer
get "minBuildHeight"(): integer
get "mcEntities"(): $Iterable<($Entity)>
get "players"(): $EntityArrayList
get "mcPlayers"(): $List<($Player)>
get "lightEngine"(): $LevelLightEngine
get "worldBorder"(): $WorldBorder
get "entities"(): $EntityArrayList
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "maxSection"(): integer
get "minSection"(): integer
get "sectionsCount"(): integer
}

export class $CommonLevelAccessor implements $CommonLevelAccessor$$Interface {
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($Entity)>
 "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type, arg2: $Predicate$$Type<($Entity)>): $List<($Entity)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type): $List<(T)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "hasNearbyAlivePlayer"(arg0: double, arg1: double, arg2: double, arg3: double): boolean
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: double, arg2: double, arg3: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: double, arg3: double, arg4: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: $Predicate$$Type<($Entity)>): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): $Player
 "getNearestPlayer"(arg0: $Entity$$Type, arg1: double): $Player
 "getNearestEntity"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double, arg6: $AABB$$Type): T
 "getNearestEntity"<T extends $LivingEntity>(arg0: $List$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double): T
 "getNearbyPlayers"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: $AABB$$Type): $List<($Player)>
 "getNearbyEntities"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: $AABB$$Type): $List<(T)>
 "getPlayerByUUID"(arg0: $UUID$$Type): $Player
 "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
 "getBlockStatesIfLoaded"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "registryAccess"(): $RegistryAccess
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
 "dimensionType"(): $DimensionType
/**
 * 
 * @deprecated
 */
 "getSeaLevel"(): integer
 "isClientSide"(): boolean
 "getSkyDarken"(): integer
 "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
 "getUncachedNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "canSeeSkyFromBelowWater"(arg0: $BlockPos$$Type): boolean
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type): integer
 "isWaterAt"(arg0: $BlockPos$$Type): boolean
 "hasBiomes"(): boolean
 "enabledFeatures"(): $FeatureFlagSet
 "getPathfindingCostFromLightLevels"(arg0: $BlockPos$$Type): float
 "getBiomeManager"(): $BiomeManager
 "isEmptyBlock"(arg0: $BlockPos$$Type): boolean
 "holderLookup"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>): $HolderLookup<(T)>
 "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "getBiomeFabric"(arg0: $BlockPos$$Type): $Holder
 "getChunk"(arg0: $BlockPos$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
 "getHeight"(): integer
 "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
/**
 * 
 * @deprecated
 */
 "getLightLevelDependentMagicValue"(arg0: $BlockPos$$Type): float
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: $BlockPos$$Type): boolean
 "getMinBuildHeight"(): integer
 "containsAnyLiquid"(arg0: $AABB$$Type): boolean
/**
 * 
 * @deprecated
 */
 "hasChunk"(arg0: integer, arg1: integer): boolean
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getPlayers"(): $EntityArrayList
 "getMcPlayers"(): $List<($Player)>
 "self"(): $EntityGetter
 "getLightEngine"(): $LevelLightEngine
 "canSeeSky"(arg0: $BlockPos$$Type): boolean
 "getShade"(arg0: $Direction$$Type, arg1: boolean): float
 "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
 "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
 "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
 "getWorldBorder"(): $WorldBorder
 "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
 "isUnobstructed"(arg0: $Entity$$Type): boolean
 "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "noCollision"(arg0: $Entity$$Type): boolean
 "noCollision"(arg0: $AABB$$Type): boolean
 "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
 "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
 "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
 "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
 "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
 "holder"<T>(arg0: $ResourceKey$$Type<(T)>): $Optional<($Holder$Reference<(T)>)>
 "isAreaLoaded"(arg0: $BlockPos$$Type, arg1: integer): boolean
 "holderOrThrow"<T>(arg0: $ResourceKey$$Type<(T)>): $Holder<(T)>
/**
 * 
 * @deprecated
 */
 "getBlockEntityRenderAttachment"(arg0: $BlockPos$$Type): any
 "isStateAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($BlockState)>): boolean
 "isFluidAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($FluidState)>): boolean
 "removeBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "addFreshEntity"(arg0: $Entity$$Type): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type, arg3: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type): boolean
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntities"(): $EntityArrayList
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
 "getMaxLightLevel"(): integer
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getMaxBuildHeight"(): integer
 "getSectionIndex"(arg0: integer): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionsCount"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
 "getBlockEntityRenderData"(arg0: $BlockPos$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommonLevelAccessor$$Type = ($CommonLevelAccessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CommonLevelAccessor$$Original = $CommonLevelAccessor;}
declare module "net.minecraft.world.level.storage.LevelStorageSource" {
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$LevelDataAndDimensions} from "net.minecraft.world.level.storage.LevelDataAndDimensions"
import {$LevelStorageSource$LevelStorageAccess} from "net.minecraft.world.level.storage.LevelStorageSource$LevelStorageAccess"
import {$LevelStorageSource$LevelCandidates, $LevelStorageSource$LevelCandidates$$Type} from "net.minecraft.world.level.storage.LevelStorageSource$LevelCandidates"
import {$List} from "java.util.List"
import {$Dynamic, $Dynamic$$Type} from "com.mojang.serialization.Dynamic"
import {$PackRepository$$Type} from "net.minecraft.server.packs.repository.PackRepository"
import {$DirectoryValidator, $DirectoryValidator$$Type} from "net.minecraft.world.level.validation.DirectoryValidator"
import {$LevelStorageSource$LevelDirectory$$Type} from "net.minecraft.world.level.storage.LevelStorageSource$LevelDirectory"
import {$DataFixer, $DataFixer$$Type} from "com.mojang.datafixers.DataFixer"
import {$LevelStem$$Type} from "net.minecraft.world.level.dimension.LevelStem"
import {$RegistryAccess$Frozen$$Type} from "net.minecraft.core.RegistryAccess$Frozen"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$DateTimeFormatter} from "java.time.format.DateTimeFormatter"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$WorldLoader$PackConfig} from "net.minecraft.server.WorldLoader$PackConfig"
import {$LevelSummary} from "net.minecraft.world.level.storage.LevelSummary"
import {$WorldDataConfiguration, $WorldDataConfiguration$$Type} from "net.minecraft.world.level.WorldDataConfiguration"
import {$Logger} from "org.slf4j.Logger"
import {$Instant} from "java.time.Instant"

export class $LevelStorageSource {
readonly "fixerUpper": $DataFixer
static readonly "ALLOWED_SYMLINKS_CONFIG_NAME": StringJS
static readonly "FORMATTER": $DateTimeFormatter
static readonly "LOGGER": $Logger

constructor(arg0: $Path$$Type, arg1: $Path$$Type, arg2: $DirectoryValidator$$Type, arg3: $DataFixer$$Type)

public "getName"(): StringJS
public "getBaseDir"(): $Path
public static "parseValidator"(arg0: $Path$$Type): $DirectoryValidator
public static "createDefault"(arg0: $Path$$Type): $LevelStorageSource
public "createAccess"(arg0: StringJS): $LevelStorageSource$LevelStorageAccess
public "getLevelPath"(arg0: StringJS): $Path
public "makeLevelSummary"(arg0: $Dynamic$$Type<(never)>, arg1: $LevelStorageSource$LevelDirectory$$Type, arg2: boolean): $LevelSummary
public static "getPackConfig"(arg0: $Dynamic$$Type<(never)>, arg1: $PackRepository$$Type, arg2: boolean): $WorldLoader$PackConfig
public "getBackupPath"(): $Path
public static "readDataConfig"(arg0: $Dynamic$$Type<(never)>): $WorldDataConfiguration
public "loadLevelSummaries"(arg0: $LevelStorageSource$LevelCandidates$$Type): $CompletableFuture<($List<($LevelSummary)>)>
public "levelExists"(arg0: StringJS): boolean
public "getWorldDirValidator"(): $DirectoryValidator
public "findLevelCandidates"(): $LevelStorageSource$LevelCandidates
public static "getLevelDataAndDimensions"(arg0: $Dynamic$$Type<(never)>, arg1: $WorldDataConfiguration$$Type, arg2: $Registry$$Type<($LevelStem$$Type)>, arg3: $RegistryAccess$Frozen$$Type): $LevelDataAndDimensions
public static "getFileModificationTime"(arg0: $Path$$Type): $Instant
public "isNewLevelIdAcceptable"(arg0: StringJS): boolean
public static "readLevelDataTagRaw"(arg0: $Path$$Type): $CompoundTag
public static "readLevelDataTagFixed"(arg0: $Path$$Type, arg1: $DataFixer$$Type): $Dynamic<(never)>
public "validateAndCreateAccess"(arg0: StringJS): $LevelStorageSource$LevelStorageAccess
get "name"(): StringJS
get "baseDir"(): $Path
get "backupPath"(): $Path
get "worldDirValidator"(): $DirectoryValidator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelStorageSource$$Type = ($LevelStorageSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelStorageSource$$Original = $LevelStorageSource;}
declare module "net.minecraft.world.level.block.entity.BannerPatternLayers" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$BannerPatternLayers$Layer, $BannerPatternLayers$Layer$$Type} from "net.minecraft.world.level.block.entity.BannerPatternLayers$Layer"
import {$Logger} from "org.slf4j.Logger"
import {$Record} from "java.lang.Record"

export class $BannerPatternLayers extends $Record {
static readonly "CODEC": $Codec<($BannerPatternLayers)>
static readonly "LOGGER": $Logger
static readonly "EMPTY": $BannerPatternLayers
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($BannerPatternLayers)>

constructor(arg0: $List$$Type<($BannerPatternLayers$Layer$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "layers"(): $List<($BannerPatternLayers$Layer)>
public "removeLast"(): $BannerPatternLayers
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BannerPatternLayers$$Type = ({"layers"?: $List$$Type<($BannerPatternLayers$Layer$$Type)>}) | ([layers?: $List$$Type<($BannerPatternLayers$Layer$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BannerPatternLayers$$Original = $BannerPatternLayers;}
declare module "net.minecraft.world.level.levelgen.Aquifer$FluidPicker" {
import {$Aquifer$FluidStatus, $Aquifer$FluidStatus$$Type} from "net.minecraft.world.level.levelgen.Aquifer$FluidStatus"

export interface $Aquifer$FluidPicker$$Interface {

(arg0: integer, arg1: integer, arg2: integer): $Aquifer$FluidStatus$$Type
}

export class $Aquifer$FluidPicker implements $Aquifer$FluidPicker$$Interface {
 "computeFluid"(arg0: integer, arg1: integer, arg2: integer): $Aquifer$FluidStatus
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Aquifer$FluidPicker$$Type = ((arg0: integer, arg1: integer, arg2: integer) => $Aquifer$FluidStatus$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Aquifer$FluidPicker$$Original = $Aquifer$FluidPicker;}
declare module "net.minecraft.world.level.Explosion$BlockInteraction" {
import {$Enum} from "java.lang.Enum"

export class $Explosion$BlockInteraction extends $Enum<($Explosion$BlockInteraction)> {
static readonly "TRIGGER_BLOCK": $Explosion$BlockInteraction
static readonly "DESTROY_WITH_DECAY": $Explosion$BlockInteraction
static readonly "DESTROY": $Explosion$BlockInteraction
static readonly "KEEP": $Explosion$BlockInteraction

public static "values"(): ($Explosion$BlockInteraction)[]
public static "valueOf"(arg0: StringJS): $Explosion$BlockInteraction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Explosion$BlockInteraction$$Type = (("keep") | ("destroy") | ("destroy_with_decay") | ("trigger_block"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Explosion$BlockInteraction$$Original = $Explosion$BlockInteraction;}
declare module "net.minecraft.world.level.block.SimpleWaterloggedBlock" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$LiquidBlockContainer$$Interface} from "net.minecraft.world.level.block.LiquidBlockContainer"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BucketPickup$$Interface} from "net.minecraft.world.level.block.BucketPickup"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $SimpleWaterloggedBlock$$Interface extends $BucketPickup$$Interface, $LiquidBlockContainer$$Interface {
get "pickupSound"(): $Optional<($SoundEvent)>
}

export class $SimpleWaterloggedBlock implements $SimpleWaterloggedBlock$$Interface {
 "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
 "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
 "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
 "getPickupSound"(): $Optional<($SoundEvent)>
 "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleWaterloggedBlock$$Type = ($SimpleWaterloggedBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleWaterloggedBlock$$Original = $SimpleWaterloggedBlock;}
declare module "net.minecraft.world.level.levelgen.feature.SpikeFeature$EndSpike" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AABB} from "net.minecraft.world.phys.AABB"

export class $SpikeFeature$EndSpike {
static readonly "CODEC": $Codec<($SpikeFeature$EndSpike)>

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: boolean)

public "getCenterZ"(): integer
public "getCenterX"(): integer
public "getHeight"(): integer
public "getTopBoundingBox"(): $AABB
public "isCenterWithinChunk"(arg0: $BlockPos$$Type): boolean
public "getRadius"(): integer
public "isGuarded"(): boolean
get "centerZ"(): integer
get "centerX"(): integer
get "height"(): integer
get "topBoundingBox"(): $AABB
get "radius"(): integer
get "guarded"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpikeFeature$EndSpike$$Type = ($SpikeFeature$EndSpike);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpikeFeature$EndSpike$$Original = $SpikeFeature$EndSpike;}
declare module "net.minecraft.world.level.LevelTimeAccess" {
import {$Iterable} from "java.lang.Iterable"
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$Holder} from "net.minecraft.core.Holder"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$LevelReader$$Interface} from "net.minecraft.world.level.LevelReader"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$HolderLookup} from "net.minecraft.core.HolderLookup"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$BiomeManager} from "net.minecraft.world.level.biome.BiomeManager"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$DimensionType} from "net.minecraft.world.level.dimension.DimensionType"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export interface $LevelTimeAccess$$Interface extends $LevelReader$$Interface {
get "moonBrightness"(): float
get "moonPhase"(): integer
get "seaLevel"(): integer
get "clientSide"(): boolean
get "skyDarken"(): integer
get "biomeManager"(): $BiomeManager
get "height"(): integer
get "minBuildHeight"(): integer
get "lightEngine"(): $LevelLightEngine
get "worldBorder"(): $WorldBorder
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "maxSection"(): integer
get "minSection"(): integer
get "sectionsCount"(): integer
}

export class $LevelTimeAccess implements $LevelTimeAccess$$Interface {
 "getTimeOfDay"(arg0: float): float
 "getMoonBrightness"(): float
 "dayTime"(): long
 "getMoonPhase"(): integer
 "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
 "getBlockStatesIfLoaded"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "registryAccess"(): $RegistryAccess
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
 "dimensionType"(): $DimensionType
/**
 * 
 * @deprecated
 */
 "getSeaLevel"(): integer
 "isClientSide"(): boolean
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "getSkyDarken"(): integer
 "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
 "getUncachedNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "canSeeSkyFromBelowWater"(arg0: $BlockPos$$Type): boolean
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type): integer
 "isWaterAt"(arg0: $BlockPos$$Type): boolean
 "hasBiomes"(): boolean
 "enabledFeatures"(): $FeatureFlagSet
 "getPathfindingCostFromLightLevels"(arg0: $BlockPos$$Type): float
 "getBiomeManager"(): $BiomeManager
 "isEmptyBlock"(arg0: $BlockPos$$Type): boolean
 "holderLookup"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>): $HolderLookup<(T)>
 "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "getBiomeFabric"(arg0: $BlockPos$$Type): $Holder
 "getChunk"(arg0: $BlockPos$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
 "getHeight"(): integer
 "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
/**
 * 
 * @deprecated
 */
 "getLightLevelDependentMagicValue"(arg0: $BlockPos$$Type): float
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: $BlockPos$$Type): boolean
 "getMinBuildHeight"(): integer
 "containsAnyLiquid"(arg0: $AABB$$Type): boolean
/**
 * 
 * @deprecated
 */
 "hasChunk"(arg0: integer, arg1: integer): boolean
 "getLightEngine"(): $LevelLightEngine
 "canSeeSky"(arg0: $BlockPos$$Type): boolean
 "getShade"(arg0: $Direction$$Type, arg1: boolean): float
 "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
 "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
 "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
 "getWorldBorder"(): $WorldBorder
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
 "isUnobstructed"(arg0: $Entity$$Type): boolean
 "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "noCollision"(arg0: $Entity$$Type): boolean
 "noCollision"(arg0: $AABB$$Type): boolean
 "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
 "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
 "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
 "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
 "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
 "holder"<T>(arg0: $ResourceKey$$Type<(T)>): $Optional<($Holder$Reference<(T)>)>
 "isAreaLoaded"(arg0: $BlockPos$$Type, arg1: integer): boolean
 "holderOrThrow"<T>(arg0: $ResourceKey$$Type<(T)>): $Holder<(T)>
/**
 * 
 * @deprecated
 */
 "getBlockEntityRenderAttachment"(arg0: $BlockPos$$Type): any
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
 "getMaxLightLevel"(): integer
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getMaxBuildHeight"(): integer
 "getSectionIndex"(arg0: integer): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionsCount"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
 "getBlockEntityRenderData"(arg0: $BlockPos$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelTimeAccess$$Type = ($LevelTimeAccess);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelTimeAccess$$Original = $LevelTimeAccess;}
declare module "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElementType" {
import {$SinglePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.SinglePoolElement"
import {$FeaturePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.FeaturePoolElement"
import {$EmptyPoolElement} from "net.minecraft.world.level.levelgen.structure.pools.EmptyPoolElement"
import {$StructurePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElement"
import {$LegacySinglePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.LegacySinglePoolElement"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$ListPoolElement} from "net.minecraft.world.level.levelgen.structure.pools.ListPoolElement"

export interface $StructurePoolElementType$$Interface<P extends $StructurePoolElement> {

(): $MapCodec$$Type<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenStructurePoolElement
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenStructurePoolElementTag
}

export class $StructurePoolElementType<P extends $StructurePoolElement> implements $StructurePoolElementType$$Interface {
static readonly "SINGLE": $StructurePoolElementType<($SinglePoolElement)>
static readonly "LEGACY": $StructurePoolElementType<($LegacySinglePoolElement)>
static readonly "FEATURE": $StructurePoolElementType<($FeaturePoolElement)>
static readonly "LIST": $StructurePoolElementType<($ListPoolElement)>
static readonly "EMPTY": $StructurePoolElementType<($EmptyPoolElement)>

static "register"<P extends $StructurePoolElement>(arg0: StringJS, arg1: $MapCodec$$Type<(P)>): $StructurePoolElementType<(P)>
 "codec"(): $MapCodec<(P)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePoolElementType$$Type<P> = (Special.WorldgenStructurePoolElement) | (() => $MapCodec$$Type<(P)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePoolElementType$$Original<P> = $StructurePoolElementType<(P)>;}
declare module "net.minecraft.world.level.block.Mirror" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Rotation} from "net.minecraft.world.level.block.Rotation"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Component} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$OctahedralGroup} from "com.mojang.math.OctahedralGroup"

export class $Mirror extends $Enum<($Mirror)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($Mirror)>
static readonly "FRONT_BACK": $Mirror
static readonly "LEFT_RIGHT": $Mirror
static readonly "NONE": $Mirror

public static "values"(): ($Mirror)[]
public static "valueOf"(arg0: StringJS): $Mirror
public "symbol"(): $Component
public "mirror"(arg0: $Direction$$Type): $Direction
public "mirror"(arg0: integer, arg1: integer): integer
public "getSerializedName"(): StringJS
public "rotation"(): $OctahedralGroup
public "getRotation"(arg0: $Direction$$Type): $Rotation
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Mirror$$Type = (("none") | ("left_right") | ("front_back"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Mirror$$Original = $Mirror;}
declare module "net.minecraft.world.level.levelgen.SurfaceRules$RuleSource" {
import {$SurfaceRules$SurfaceRule, $SurfaceRules$SurfaceRule$$Type} from "net.minecraft.world.level.levelgen.SurfaceRules$SurfaceRule"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$Function, $Function$$Type, $Function$$Interface} from "java.util.function.Function"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$SurfaceRules$Context, $SurfaceRules$Context$$Type} from "net.minecraft.world.level.levelgen.SurfaceRules$Context"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export interface $SurfaceRules$RuleSource$$Interface extends $Function$$Interface<($SurfaceRules$Context), ($SurfaceRules$SurfaceRule)> {
}

export class $SurfaceRules$RuleSource implements $SurfaceRules$RuleSource$$Interface {
static readonly "CODEC": $Codec<($SurfaceRules$RuleSource)>

static "bootstrap"(arg0: $Registry$$Type<($MapCodec$$Type<($SurfaceRules$RuleSource$$Type)>)>): $MapCodec<($SurfaceRules$RuleSource)>
 "codec"(): $KeyDispatchDataCodec<($SurfaceRules$RuleSource)>
 "apply"(arg0: $SurfaceRules$Context$$Type): $SurfaceRules$SurfaceRule
static "identity"<T>(): $Function<($SurfaceRules$Context), ($SurfaceRules$Context)>
 "compose"<V>(arg0: $Function$$Type<(V), ($SurfaceRules$Context$$Type)>): $Function<(V), ($SurfaceRules$SurfaceRule)>
 "andThen"<V>(arg0: $Function$$Type<($SurfaceRules$SurfaceRule), (V)>): $Function<($SurfaceRules$Context), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SurfaceRules$RuleSource$$Type = ($SurfaceRules$RuleSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SurfaceRules$RuleSource$$Original = $SurfaceRules$RuleSource;}
declare module "net.minecraft.world.level.timers.TimerQueue" {
import {$TimerCallbacks$$Type} from "net.minecraft.world.level.timers.TimerCallbacks"
import {$Dynamic$$Type} from "com.mojang.serialization.Dynamic"
import {$Set} from "java.util.Set"
import {$Stream$$Type} from "java.util.stream.Stream"
import {$ListTag} from "net.minecraft.nbt.ListTag"
import {$TimerCallback$$Type} from "net.minecraft.world.level.timers.TimerCallback"

export class $TimerQueue<T> {
constructor(arg0: $TimerCallbacks$$Type<(T)>, arg1: $Stream$$Type<($Dynamic$$Type<(never)>)>)
constructor(arg0: $TimerCallbacks$$Type<(T)>)

public "remove"(arg0: StringJS): integer
public "store"(): $ListTag
public "schedule"(arg0: StringJS, arg1: long, arg2: $TimerCallback$$Type<(T)>): void
public "tick"(arg0: T, arg1: long): void
public "getEventsIds"(): $Set<(StringJS)>
get "eventsIds"(): $Set<(StringJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimerQueue$$Type<T> = ($TimerQueue<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TimerQueue$$Original<T> = $TimerQueue<(T)>;}
declare module "net.minecraft.world.level.pathfinder.NodeEvaluator" {
import {$Mob, $Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$PathType} from "net.minecraft.world.level.pathfinder.PathType"
import {$PathNavigationRegion$$Type} from "net.minecraft.world.level.PathNavigationRegion"
import {$PathfindingContext, $PathfindingContext$$Type} from "net.minecraft.world.level.pathfinder.PathfindingContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Node, $Node$$Type} from "net.minecraft.world.level.pathfinder.Node"
import {$Int2ObjectMap} from "it.unimi.dsi.fastutil.ints.Int2ObjectMap"
import {$Target} from "net.minecraft.world.level.pathfinder.Target"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $NodeEvaluator {
 "mob": $Mob
 "entityHeight": integer
 "entityDepth": integer
readonly "nodes": $Int2ObjectMap<($Node)>
 "currentContext": $PathfindingContext
 "entityWidth": integer

constructor()

public "done"(): void
public "prepare"(arg0: $PathNavigationRegion$$Type, arg1: $Mob$$Type): void
public "getTarget"(arg0: double, arg1: double, arg2: double): $Target
public "getNode"(arg0: integer, arg1: integer, arg2: integer): $Node
public "getNode"(arg0: $BlockPos$$Type): $Node
public "setCanPassDoors"(arg0: boolean): void
public "setCanOpenDoors"(arg0: boolean): void
public "setCanFloat"(arg0: boolean): void
public "canFloat"(): boolean
public "getStart"(): $Node
public "setCanWalkOverFences"(arg0: boolean): void
public static "isBurningBlock"(arg0: $BlockState$$Type): boolean
public "canOpenDoors"(): boolean
public "canPassDoors"(): boolean
public "getPathType"(arg0: $Mob$$Type, arg1: $BlockPos$$Type): $PathType
public "getPathType"(arg0: $PathfindingContext$$Type, arg1: integer, arg2: integer, arg3: integer): $PathType
public "getNeighbors"(arg0: ($Node$$Type)[], arg1: $Node$$Type): integer
public "canWalkOverFences"(): boolean
public "getPathTypeOfMob"(arg0: $PathfindingContext$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: $Mob$$Type): $PathType
public "getTargetNodeAt"(arg0: double, arg1: double, arg2: double): $Target
get "start"(): $Node
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NodeEvaluator$$Type = ($NodeEvaluator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NodeEvaluator$$Original = $NodeEvaluator;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.DarkOakTrunkPlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$TrunkPlacerType} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacerType"
import {$List} from "java.util.List"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $DarkOakTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($DarkOakTrunkPlacer)>
static readonly "MAX_HEIGHT": integer
readonly "baseHeight": integer
readonly "heightRandA": integer
readonly "heightRandB": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "type"(): $TrunkPlacerType<(never)>
public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DarkOakTrunkPlacer$$Type = ($DarkOakTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DarkOakTrunkPlacer$$Original = $DarkOakTrunkPlacer;}
declare module "net.minecraft.world.level.biome.BiomeManager" {
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BiomeManager$NoiseBiomeSource$$Type} from "net.minecraft.world.level.biome.BiomeManager$NoiseBiomeSource"
import {$BiomeManagerAccessor$$Interface} from "net.createmod.ponder.mixin.accessor.BiomeManagerAccessor"
import {$Holder} from "net.minecraft.core.Holder"

export class $BiomeManager implements $BiomeManagerAccessor$$Interface {
readonly "biomeZoomSeed": long
static readonly "CHUNK_CENTER_QUART": integer

constructor(arg0: $BiomeManager$NoiseBiomeSource$$Type, arg1: long)

public "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
public "withDifferentSource"(arg0: $BiomeManager$NoiseBiomeSource$$Type): $BiomeManager
public static "obfuscateSeed"(arg0: long): long
public "getNoiseBiomeAtQuart"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
public "catnip$getBiomeZoomSeed"(): long
public "getNoiseBiomeAtPosition"(arg0: $BlockPos$$Type): $Holder<($Biome)>
public "getNoiseBiomeAtPosition"(arg0: double, arg1: double, arg2: double): $Holder<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeManager$$Type = ($BiomeManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeManager$$Original = $BiomeManager;}
declare module "net.minecraft.world.level.levelgen.WorldGenerationContext" {
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"

export class $WorldGenerationContext {
constructor(arg0: $ChunkGenerator$$Type, arg1: $LevelHeightAccessor$$Type)

public "getGenDepth"(): integer
public "getMinGenY"(): integer
get "genDepth"(): integer
get "minGenY"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldGenerationContext$$Type = ($WorldGenerationContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldGenerationContext$$Original = $WorldGenerationContext;}
declare module "net.minecraft.world.level.block.entity.TheEndPortalBlockEntity" {
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TheEndPortalBlockEntity extends $BlockEntity {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)
constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "shouldRenderFace"(arg0: $Direction$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TheEndPortalBlockEntity$$Type = ($TheEndPortalBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TheEndPortalBlockEntity$$Original = $TheEndPortalBlockEntity;}
declare module "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext" {
import {$Blender} from "net.minecraft.world.level.levelgen.blending.Blender"

export interface $DensityFunction$FunctionContext$$Interface {
get "blender"(): $Blender
}

export class $DensityFunction$FunctionContext implements $DensityFunction$FunctionContext$$Interface {
 "blockX"(): integer
 "blockY"(): integer
 "blockZ"(): integer
 "getBlender"(): $Blender
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunction$FunctionContext$$Type = ($DensityFunction$FunctionContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunction$FunctionContext$$Original = $DensityFunction$FunctionContext;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$TreeDecorator$Context$$Type} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context"
import {$TreeDecoratorType} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecoratorType"

export class $TreeDecorator {
static readonly "CODEC": $Codec<($TreeDecorator)>

constructor()

public "type"(): $TreeDecoratorType<(never)>
public "place"(arg0: $TreeDecorator$Context$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TreeDecorator$$Type = ($TreeDecorator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TreeDecorator$$Original = $TreeDecorator;}
declare module "net.minecraft.world.level.entity.Visibility" {
import {$Enum} from "java.lang.Enum"
import {$FullChunkStatus$$Type} from "net.minecraft.server.level.FullChunkStatus"

export class $Visibility extends $Enum<($Visibility)> {
static readonly "TICKING": $Visibility
static readonly "TRACKED": $Visibility
static readonly "HIDDEN": $Visibility

public static "values"(): ($Visibility)[]
public static "valueOf"(arg0: StringJS): $Visibility
public "isAccessible"(): boolean
public "isTicking"(): boolean
public static "fromFullChunkStatus"(arg0: $FullChunkStatus$$Type): $Visibility
get "accessible"(): boolean
get "ticking"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Visibility$$Type = (("hidden") | ("tracked") | ("ticking"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Visibility$$Original = $Visibility;}
declare module "net.minecraft.world.level.block.entity.vault.VaultConfig" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$PlayerDetector, $PlayerDetector$$Type} from "net.minecraft.world.level.block.entity.trialspawner.PlayerDetector"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$PlayerDetector$EntitySelector, $PlayerDetector$EntitySelector$$Type} from "net.minecraft.world.level.block.entity.trialspawner.PlayerDetector$EntitySelector"
import {$Record} from "java.lang.Record"

export class $VaultConfig extends $Record {
static "CODEC": $Codec<($VaultConfig)>
static "DEFAULT": $VaultConfig
static readonly "TAG_NAME": StringJS

constructor(arg0: $ResourceKey$$Type<($LootTable)>, arg1: double, arg2: double, arg3: $ItemStack$$Type, arg4: ($ResourceKey$$Type<($LootTable$$Type)>)?, arg5: $PlayerDetector$$Type, arg6: $PlayerDetector$EntitySelector$$Type)
constructor(arg0: $ResourceKey$$Type<($LootTable)>, arg1: double, arg2: double, arg3: $ItemStack$$Type, arg4: ($ResourceKey$$Type<($LootTable$$Type)>)?)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "lootTable"(): $ResourceKey<($LootTable)>
public "entitySelector"(): $PlayerDetector$EntitySelector
public "deactivationRange"(): double
public "activationRange"(): double
public "playerDetector"(): $PlayerDetector
public "keyItem"(): $ItemStack
public "overrideLootTableToDisplay"(): $Optional<($ResourceKey<($LootTable)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VaultConfig$$Type = ({"deactivationRange"?: double, "overrideLootTableToDisplay"?: ($ResourceKey$$Type<($LootTable$$Type)>)?, "activationRange"?: double, "keyItem"?: $ItemStack$$Type, "playerDetector"?: $PlayerDetector$$Type, "lootTable"?: $ResourceKey$$Type<($LootTable)>, "entitySelector"?: $PlayerDetector$EntitySelector$$Type}) | ([deactivationRange?: double, overrideLootTableToDisplay?: ($ResourceKey$$Type<($LootTable$$Type)>)?, activationRange?: double, keyItem?: $ItemStack$$Type, playerDetector?: $PlayerDetector$$Type, lootTable?: $ResourceKey$$Type<($LootTable)>, entitySelector?: $PlayerDetector$EntitySelector$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VaultConfig$$Original = $VaultConfig;}
declare module "net.minecraft.world.level.dimension.end.EndDragonFight$Data" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Record} from "java.lang.Record"

export class $EndDragonFight$Data extends $Record {
static readonly "CODEC": $Codec<($EndDragonFight$Data)>
static readonly "DEFAULT": $EndDragonFight$Data

constructor(needsStateScanning: boolean, dragonKilled: boolean, previouslyKilled: boolean, isRespawning: boolean, dragonUUID: ($UUID$$Type)?, exitPortalLocation: ($BlockPos$$Type)?, gateways: ($List$$Type<(integer)>)?)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "dragonUUID"(): $Optional<($UUID)>
public "gateways"(): $Optional<($List<(integer)>)>
public "previouslyKilled"(): boolean
public "needsStateScanning"(): boolean
public "isRespawning"(): boolean
public "dragonKilled"(): boolean
public "exitPortalLocation"(): $Optional<($BlockPos)>
get "respawning"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EndDragonFight$Data$$Type = ({"isRespawning"?: boolean, "previouslyKilled"?: boolean, "exitPortalLocation"?: ($BlockPos$$Type)?, "gateways"?: ($List$$Type<(integer)>)?, "dragonUUID"?: ($UUID$$Type)?, "dragonKilled"?: boolean, "needsStateScanning"?: boolean}) | ([isRespawning?: boolean, previouslyKilled?: boolean, exitPortalLocation?: ($BlockPos$$Type)?, gateways?: ($List$$Type<(integer)>)?, dragonUUID?: ($UUID$$Type)?, dragonKilled?: boolean, needsStateScanning?: boolean]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EndDragonFight$Data$$Original = $EndDragonFight$Data;}
declare module "net.minecraft.world.level.timers.TimerCallback" {
import {$TimerQueue, $TimerQueue$$Type} from "net.minecraft.world.level.timers.TimerQueue"

export interface $TimerCallback$$Interface<T> {

(arg0: T, arg1: $TimerQueue<(T)>, arg2: long): void
}

export class $TimerCallback<T> implements $TimerCallback$$Interface {
 "handle"(arg0: T, arg1: $TimerQueue$$Type<(T)>, arg2: long): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimerCallback$$Type<T> = ((arg0: T, arg1: $TimerQueue<(T)>, arg2: long) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TimerCallback$$Original<T> = $TimerCallback<(T)>;}
declare module "net.minecraft.world.level.storage.loot.predicates.AllOfCondition$Builder" {
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$List$$Type} from "java.util.List"
import {$CompositeLootItemCondition$Builder} from "net.minecraft.world.level.storage.loot.predicates.CompositeLootItemCondition$Builder"
import {$LootItemCondition, $LootItemCondition$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"

export class $AllOfCondition$Builder extends $CompositeLootItemCondition$Builder {
constructor(...arg0: ($LootItemCondition$Builder$$Type)[])

public "create"(arg0: $List$$Type<($LootItemCondition$$Type)>): $LootItemCondition
public "and"(arg0: $LootItemCondition$Builder$$Type): $AllOfCondition$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllOfCondition$Builder$$Type = ($AllOfCondition$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AllOfCondition$Builder$$Original = $AllOfCondition$Builder;}
declare module "net.minecraft.world.level.levelgen.structure.StructurePiece$BlockSelector" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $StructurePiece$BlockSelector {
constructor()

public "next"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: boolean): void
public "getNext"(): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePiece$BlockSelector$$Type = ($StructurePiece$BlockSelector);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePiece$BlockSelector$$Original = $StructurePiece$BlockSelector;}
declare module "net.minecraft.world.level.levelgen.feature.featuresize.FeatureSizeType" {
import {$ThreeLayersFeatureSize} from "net.minecraft.world.level.levelgen.feature.featuresize.ThreeLayersFeatureSize"
import {$TwoLayersFeatureSize} from "net.minecraft.world.level.levelgen.feature.featuresize.TwoLayersFeatureSize"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$FeatureSize} from "net.minecraft.world.level.levelgen.feature.featuresize.FeatureSize"

export class $FeatureSizeType<P extends $FeatureSize> {
static readonly "THREE_LAYERS_FEATURE_SIZE": $FeatureSizeType<($ThreeLayersFeatureSize)>
static readonly "TWO_LAYERS_FEATURE_SIZE": $FeatureSizeType<($TwoLayersFeatureSize)>

constructor(arg0: $MapCodec$$Type<(P)>)

public "codec"(): $MapCodec<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenFeatureSizeType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenFeatureSizeTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FeatureSizeType$$Type<P> = (Special.WorldgenFeatureSizeType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FeatureSizeType$$Original<P> = $FeatureSizeType<(P)>;}
declare module "net.minecraft.world.level.block.state.BlockBehaviour$BlockStateBase$Cache" {
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BlockStateCacheAccess$$Interface} from "malte0811.ferritecore.ducks.BlockStateCacheAccess"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$SupportType$$Type} from "net.minecraft.world.level.block.SupportType"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockBehaviour$BlockStateBase$Cache implements $BlockStateCacheAccess$$Interface {
readonly "largeCollisionShape": boolean
readonly "lightBlock": integer
readonly "isCollisionShapeFullBlock": boolean
 "collisionShape": $VoxelShape
readonly "solidRender": boolean
 "occlusionShapes": ($VoxelShape)[]
readonly "propagatesSkylightDown": boolean

constructor(arg0: $BlockState$$Type)

public "getCollisionShape"(): $VoxelShape
public "isFaceSturdy"(arg0: $Direction$$Type, arg1: $SupportType$$Type): boolean
public "setCollisionShape"(arg0: $VoxelShape$$Type): void
public "getFaceSturdy"(): (boolean)[]
public "setOcclusionShapes"(arg0: ($VoxelShape$$Type)[]): void
public "setFaceSturdy"(arg0: (boolean)[]): void
public "getOcclusionShapes"(): ($VoxelShape)[]
get "faceSturdy"(): (boolean)[]
set "faceSturdy"(value: (boolean)[])
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviour$BlockStateBase$Cache$$Type = ($BlockBehaviour$BlockStateBase$Cache);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviour$BlockStateBase$Cache$$Original = $BlockBehaviour$BlockStateBase$Cache;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$Palette" {
import {$List, $List$$Type} from "java.util.List"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"

export class $StructureTemplate$Palette {
constructor(arg0: $List$$Type<($StructureTemplate$StructureBlockInfo$$Type)>)

public "blocks"(arg0: $Block$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "blocks"(): $List<($StructureTemplate$StructureBlockInfo)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureTemplate$Palette$$Type = ($StructureTemplate$Palette);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureTemplate$Palette$$Original = $StructureTemplate$Palette;}
declare module "net.minecraft.world.level.levelgen.structure.structures.StrongholdStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $StrongholdStructure extends $Structure {
static readonly "CODEC": $MapCodec<($StrongholdStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "type"(): $StructureType<(never)>
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StrongholdStructure$$Type = ($StrongholdStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StrongholdStructure$$Original = $StrongholdStructure;}
declare module "net.minecraft.world.level.block.state.BlockBehaviour$Properties" {
import {$FeatureFlagSet, $FeatureFlagSet$$Type} from "net.minecraft.world.flag.FeatureFlagSet"
import {$MapColor$$Type} from "net.minecraft.world.level.material.MapColor"
import {$FeatureFlag$$Type} from "net.minecraft.world.flag.FeatureFlag"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviour$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour"
import {$BlockBehaviour$OffsetFunction, $BlockBehaviour$OffsetFunction$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$OffsetFunction"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$NoteBlockInstrument, $NoteBlockInstrument$$Type} from "net.minecraft.world.level.block.state.properties.NoteBlockInstrument"
import {$AbstractBlockSettingsAccessor$$Interface} from "net.fabricmc.fabric.mixin.object.builder.AbstractBlockSettingsAccessor"
import {$ToIntFunction, $ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BlockPropertiesAccessor$$Interface} from "com.supermartijn642.core.mixin.BlockPropertiesAccessor"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$BlockBehaviour$OffsetType$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$OffsetType"
import {$BlockBehaviour$StateArgumentPredicate, $BlockBehaviour$StateArgumentPredicate$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$StateArgumentPredicate"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockBehaviour$StatePredicate, $BlockBehaviour$StatePredicate$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$StatePredicate"
import {$PushReaction, $PushReaction$$Type} from "net.minecraft.world.level.material.PushReaction"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockBehaviour$Properties implements $BlockPropertiesAccessor$$Interface, $AbstractBlockSettingsAccessor$$Interface {
 "offsetFunction": $BlockBehaviour$OffsetFunction
 "canOcclude": boolean
 "lightEmission": $ToIntFunction<($BlockState)>
 "drops": $ResourceKey<($LootTable)>
 "soundType": $SoundType
static readonly "CODEC": $Codec<($BlockBehaviour$Properties)>
 "isRandomlyTicking": boolean
 "spawnTerrainParticles": boolean
 "isAir": boolean
 "hasCollision": boolean

constructor()

public static "of"(): $BlockBehaviour$Properties
public "instrument"(arg0: $NoteBlockInstrument$$Type): $BlockBehaviour$Properties
public "requiresCorrectToolForDrops"(): $BlockBehaviour$Properties
public "requiredFeatures"(...arg0: ($FeatureFlag$$Type)[]): $BlockBehaviour$Properties
public "sound"(arg0: $SoundType$$Type): $BlockBehaviour$Properties
public "getIsAir"(): boolean
public "setDrops"(arg0: $ResourceKey$$Type): void
public "setLiquid"(arg0: boolean): void
public "setIsAir"(arg0: boolean): void
public "getSpeedFactor"(): float
public "getJumpFactor"(): float
public "isSuffocating"(arg0: $BlockBehaviour$StatePredicate$$Type): $BlockBehaviour$Properties
public "strength"(arg0: float): $BlockBehaviour$Properties
public "strength"(arg0: float, arg1: float): $BlockBehaviour$Properties
public "isRedstoneConductor"(arg0: $BlockBehaviour$StatePredicate$$Type): $BlockBehaviour$Properties
public "forceSolidOn"(): $BlockBehaviour$Properties
/**
 * 
 * @deprecated
 */
public "forceSolidOff"(): $BlockBehaviour$Properties
public "isValidSpawn"(arg0: $BlockBehaviour$StateArgumentPredicate$$Type<($EntityType$$Type<(never)>)>): $BlockBehaviour$Properties
public "pushReaction"(arg0: $PushReaction$$Type): $BlockBehaviour$Properties
public "isViewBlocking"(arg0: $BlockBehaviour$StatePredicate$$Type): $BlockBehaviour$Properties
public "replaceable"(): $BlockBehaviour$Properties
public "hasPostProcess"(arg0: $BlockBehaviour$StatePredicate$$Type): $BlockBehaviour$Properties
public "emissiveRendering"(arg0: $BlockBehaviour$StatePredicate$$Type): $BlockBehaviour$Properties
public "liquid"(): $BlockBehaviour$Properties
public "air"(): $BlockBehaviour$Properties
public "dynamicShape"(): $BlockBehaviour$Properties
public "speedFactor"(arg0: float): $BlockBehaviour$Properties
public "ignitedByLava"(): $BlockBehaviour$Properties
public "noLootTable"(): $BlockBehaviour$Properties
public "instabreak"(): $BlockBehaviour$Properties
public "offsetType"(arg0: $BlockBehaviour$OffsetType$$Type): $BlockBehaviour$Properties
/**
 * 
 * @deprecated
 */
public "dropsLike"(arg0: $Block$$Type): $BlockBehaviour$Properties
public "lootFrom"(arg0: $Supplier$$Type<($Block$$Type)>): $BlockBehaviour$Properties
public "setLootTableSupplier"(arg0: $Supplier$$Type): void
public "getIsRandomlyTicking"(): boolean
public "getIsRedstoneConductor"(): $BlockBehaviour$StatePredicate
public "getLootTableSupplier"(): $Supplier
public "setIsRandomlyTicking"(arg0: boolean): void
public "setRequiredFeatures"(arg0: $FeatureFlagSet$$Type): void
public "getEmissiveRendering"(): $BlockBehaviour$StatePredicate
public "setSpawnTerrainParticles"(arg0: boolean): void
public "getSpawnTerrainParticles"(): boolean
public "getRequiredFeatures"(): $FeatureFlagSet
public "lightLevel"(arg0: $ToIntFunction$$Type<($BlockState)>): $BlockBehaviour$Properties
public static "ofFullCopy"(arg0: $BlockBehaviour$$Type): $BlockBehaviour$Properties
public "isRequiresCorrectToolForDrops"(): boolean
public "setRequiresCorrectToolForDrops"(arg0: boolean): void
public "getDrops"(): $ResourceKey
public "friction"(arg0: float): $BlockBehaviour$Properties
public "jumpFactor"(arg0: float): $BlockBehaviour$Properties
public "mapColor"(arg0: $Function$$Type<($BlockState), ($MapColor$$Type)>): $BlockBehaviour$Properties
public "mapColor"(arg0: $DyeColor$$Type): $BlockBehaviour$Properties
public "mapColor"(arg0: $MapColor$$Type): $BlockBehaviour$Properties
public "destroyTime"(arg0: float): $BlockBehaviour$Properties
public "getMapColor"(): $Function
public "explosionResistance"(arg0: float): $BlockBehaviour$Properties
public "getExplosionResistance"(): float
public "getSoundType"(): $SoundType
public "getFriction"(): float
public "setHasCollision"(arg0: boolean): void
public "setReplaceable"(arg0: boolean): void
public "getOffsetFunction"(): $BlockBehaviour$OffsetFunction
public "setIgnitedByLava"(arg0: boolean): void
public "setForceSolidOn"(arg0: boolean): void
public "getForceSolidOff"(): boolean
public "getForceSolidOn"(): boolean
public "getReplaceable"(): boolean
public "getDynamicShape"(): boolean
public "setDynamicShape"(arg0: boolean): void
public "setCanOcclude"(arg0: boolean): void
public "getIsViewBlocking"(): $BlockBehaviour$StatePredicate
public "noOcclusion"(): $BlockBehaviour$Properties
public "getHasCollision"(): boolean
public "getLuminance"(): $ToIntFunction
public "getCanOcclude"(): boolean
public "noCollission"(): $BlockBehaviour$Properties
public "getPushReaction"(): $PushReaction
public "getInstrument"(): $NoteBlockInstrument
public "setMapColor"(arg0: $Function$$Type): void
public "getIgnitedByLava"(): boolean
public "setForceSolidOff"(arg0: boolean): void
/**
 * 
 * @deprecated
 */
public static "ofLegacyCopy"(arg0: $BlockBehaviour$$Type): $BlockBehaviour$Properties
public "getIsSuffocating"(): $BlockBehaviour$StatePredicate
public "getHasPostProcess"(): $BlockBehaviour$StatePredicate
public "getDestroyTime"(): float
public "noTerrainParticles"(): $BlockBehaviour$Properties
public "getIsValidSpawn"(): $BlockBehaviour$StateArgumentPredicate
public "randomTicks"(): $BlockBehaviour$Properties
public "setOffsetFunction"(arg0: $BlockBehaviour$OffsetFunction$$Type): void
public "getLiquid"(): boolean
set "lootTableSupplier"(value: $Supplier$$Type)
get "lootTableSupplier"(): $Supplier
get "luminance"(): $ToIntFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviour$Properties$$Type = ($BlockBehaviour$Properties);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviour$Properties$$Original = $BlockBehaviour$Properties;}
declare module "net.minecraft.world.level.levelgen.DensityFunction$NoiseHolder" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$NormalNoise, $NormalNoise$$Type} from "net.minecraft.world.level.levelgen.synth.NormalNoise"
import {$NormalNoise$NoiseParameters, $NormalNoise$NoiseParameters$$Type} from "net.minecraft.world.level.levelgen.synth.NormalNoise$NoiseParameters"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $DensityFunction$NoiseHolder extends $Record {
static readonly "CODEC": $Codec<($DensityFunction$NoiseHolder)>

constructor(arg0: $Holder$$Type<($NormalNoise$NoiseParameters)>)
constructor(arg0: $Holder$$Type<($NormalNoise$NoiseParameters)>, arg1: $NormalNoise$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getValue"(arg0: double, arg1: double, arg2: double): double
public "maxValue"(): double
public "noiseData"(): $Holder<($NormalNoise$NoiseParameters)>
public "noise"(): $NormalNoise
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunction$NoiseHolder$$Type = ({"noiseData"?: $Holder$$Type<($NormalNoise$NoiseParameters)>, "noise"?: $NormalNoise$$Type}) | ([noiseData?: $Holder$$Type<($NormalNoise$NoiseParameters)>, noise?: $NormalNoise$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunction$NoiseHolder$$Original = $DensityFunction$NoiseHolder;}
declare module "net.minecraft.world.level.levelgen.carver.WorldCarver$CarveSkipChecker" {
import {$CarvingContext, $CarvingContext$$Type} from "net.minecraft.world.level.levelgen.carver.CarvingContext"

export interface $WorldCarver$CarveSkipChecker$$Interface {

(arg0: $CarvingContext, arg1: double, arg2: double, arg3: double, arg4: integer): boolean
}

export class $WorldCarver$CarveSkipChecker implements $WorldCarver$CarveSkipChecker$$Interface {
 "shouldSkip"(arg0: $CarvingContext$$Type, arg1: double, arg2: double, arg3: double, arg4: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldCarver$CarveSkipChecker$$Type = ((arg0: $CarvingContext, arg1: double, arg2: double, arg3: double, arg4: integer) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldCarver$CarveSkipChecker$$Original = $WorldCarver$CarveSkipChecker;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.ForkingTrunkPlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$TrunkPlacerType} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacerType"
import {$List} from "java.util.List"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $ForkingTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($ForkingTrunkPlacer)>
static readonly "MAX_HEIGHT": integer
readonly "baseHeight": integer
readonly "heightRandA": integer
readonly "heightRandB": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "type"(): $TrunkPlacerType<(never)>
public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForkingTrunkPlacer$$Type = ($ForkingTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ForkingTrunkPlacer$$Original = $ForkingTrunkPlacer;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer" {
import {$FoliagePlacer$FoliageSetter$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageSetter"
import {$RecordCodecBuilder$Instance$$Type} from "com.mojang.serialization.codecs.RecordCodecBuilder$Instance"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$FoliagePlacerType} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacerType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Products$P2} from "com.mojang.datafixers.Products$P2"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RecordCodecBuilder$Mu} from "com.mojang.serialization.codecs.RecordCodecBuilder$Mu"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FoliagePlacer$FoliageAttachment$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $FoliagePlacer {
static readonly "CODEC": $Codec<($FoliagePlacer)>
readonly "offset": $IntProvider
readonly "radius": $IntProvider

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type)

public "type"(): $FoliagePlacerType<(never)>
public "placeLeavesRowWithHangingLeavesBelow"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: $BlockPos$$Type, arg5: integer, arg6: integer, arg7: boolean, arg8: float, arg9: float): void
public "placeLeavesRow"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: $BlockPos$$Type, arg5: integer, arg6: integer, arg7: boolean): void
public "createFoliage"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: integer, arg5: $FoliagePlacer$FoliageAttachment$$Type, arg6: integer, arg7: integer, arg8: integer): void
public "createFoliage"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: integer, arg5: $FoliagePlacer$FoliageAttachment$$Type, arg6: integer, arg7: integer): void
public "shouldSkipLocation"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: boolean): boolean
public static "foliagePlacerParts"<P extends $FoliagePlacer>(arg0: $RecordCodecBuilder$Instance$$Type<(P)>): $Products$P2<($RecordCodecBuilder$Mu<(P)>), ($IntProvider), ($IntProvider)>
public "foliageRadius"(arg0: $RandomSource$$Type, arg1: integer): integer
public static "tryPlaceLeaf"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: $BlockPos$$Type): boolean
public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
public "shouldSkipLocationSigned"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoliagePlacer$$Type = ($FoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FoliagePlacer$$Original = $FoliagePlacer;}
declare module "net.minecraft.world.level.block.state.properties.RedstoneSide" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $RedstoneSide extends $Enum<($RedstoneSide)> implements $StringRepresentable$$Interface {
static readonly "SIDE": $RedstoneSide
static readonly "UP": $RedstoneSide
static readonly "NONE": $RedstoneSide

public "isConnected"(): boolean
public "toString"(): StringJS
public static "values"(): ($RedstoneSide)[]
public static "valueOf"(arg0: StringJS): $RedstoneSide
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "connected"(): boolean
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RedstoneSide$$Type = (("up") | ("side") | ("none"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RedstoneSide$$Original = $RedstoneSide;}
declare module "net.minecraft.world.level.block.Portal$Transition" {
import {$Enum} from "java.lang.Enum"

export class $Portal$Transition extends $Enum<($Portal$Transition)> {
static readonly "CONFUSION": $Portal$Transition
static readonly "NONE": $Portal$Transition

public static "values"(): ($Portal$Transition)[]
public static "valueOf"(arg0: StringJS): $Portal$Transition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Portal$Transition$$Type = (("confusion") | ("none"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Portal$Transition$$Original = $Portal$Transition;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Record} from "java.lang.Record"

export class $TwistingVinesConfig extends $Record implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($TwistingVinesConfig)>

constructor(arg0: integer, arg1: integer, arg2: integer)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "maxHeight"(): integer
public "spreadHeight"(): integer
public "spreadWidth"(): integer
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TwistingVinesConfig$$Type = ({"maxHeight"?: integer, "spreadHeight"?: integer, "spreadWidth"?: integer}) | ([maxHeight?: integer, spreadHeight?: integer, spreadWidth?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TwistingVinesConfig$$Original = $TwistingVinesConfig;}
declare module "net.minecraft.world.level.saveddata.maps.MapItemSavedData" {
import {$Iterable} from "java.lang.Iterable"
import {$MapId$$Type} from "net.minecraft.world.level.saveddata.maps.MapId"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$List$$Type} from "java.util.List"
import {$MapDecoration, $MapDecoration$$Type} from "net.minecraft.world.level.saveddata.maps.MapDecoration"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$SavedData} from "net.minecraft.world.level.saveddata.SavedData"
import {$MapItemSavedData$HoldingPlayer} from "net.minecraft.world.level.saveddata.maps.MapItemSavedData$HoldingPlayer"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$MapDecorationType$$Type} from "net.minecraft.world.level.saveddata.maps.MapDecorationType"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$StationBlockEntity$$Type} from "com.simibubi.create.content.trains.station.StationBlockEntity"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$StationMarker$$Type} from "com.simibubi.create.content.trains.station.StationMarker"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection} from "java.util.Collection"
import {$Map} from "java.util.Map"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$MapBanner} from "net.minecraft.world.level.saveddata.maps.MapBanner"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$StationMapData$$Interface} from "com.simibubi.create.content.trains.station.StationMapData"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$SavedData$Factory} from "net.minecraft.world.level.saveddata.SavedData$Factory"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"

export class $MapItemSavedData extends $SavedData implements $StationMapData$$Interface {
readonly "centerZ": integer
static readonly "TRACKED_DECORATION_LIMIT": integer
readonly "centerX": integer
readonly "scale": byte
readonly "decorations": $Map<(StringJS), ($MapDecoration)>
static readonly "MAX_SCALE": integer
readonly "dimension": $ResourceKey<($Level)>
 "colors": (byte)[]

public static "load"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): $MapItemSavedData
public static "factory"(): $SavedData$Factory<($MapItemSavedData)>
public "save"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public "setColor"(arg0: integer, arg1: integer, arg2: byte): void
public static "addTargetDecoration"(arg0: $ItemStack$$Type, arg1: $BlockPos$$Type, arg2: StringJS, arg3: $Holder$$Type<($MapDecorationType)>): void
public static "createFresh"(arg0: double, arg1: double, arg2: byte, arg3: boolean, arg4: boolean, arg5: $ResourceKey$$Type<($Level)>): $MapItemSavedData
public "checkBanners"(arg0: $BlockGetter$$Type, arg1: integer, arg2: integer): void
public "updateColor"(arg0: integer, arg1: integer, arg2: byte): boolean
public "tickCarriedBy"(arg0: $Player$$Type, arg1: $ItemStack$$Type): void
public "getHoldingPlayer"(arg0: $Player$$Type): $MapItemSavedData$HoldingPlayer
public "toggleBanner"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type): boolean
public "removedFromFrame"(arg0: $BlockPos$$Type, arg1: integer): void
public "toggleStation"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $StationBlockEntity$$Type): boolean
public "isTrackedCountOverLimit"(arg0: integer): boolean
public "isExplorationMap"(): boolean
public "getDecorations"(): $Iterable<($MapDecoration)>
public "getUpdatePacket"(arg0: $MapId$$Type, arg1: $Player$$Type): $Packet<(never)>
public "locked"(): $MapItemSavedData
public "scaled"(): $MapItemSavedData
public "getBanners"(): $Collection<($MapBanner)>
public static "createForClient"(arg0: byte, arg1: boolean, arg2: $ResourceKey$$Type<($Level)>): $MapItemSavedData
public "removeDecoration"(arg0: StringJS): void
public "addDecoration"(arg0: $Holder$$Type<($MapDecorationType)>, arg1: $LevelAccessor$$Type, arg2: StringJS, arg3: double, arg4: double, arg5: double, arg6: $Component$$Type): void
public "addStationMarker"(arg0: $StationMarker$$Type): void
public "addClientSideDecorations"(arg0: $List$$Type<($MapDecoration$$Type)>): void
public "handler$gej000$create$onCheckBanners"(arg0: $BlockGetter$$Type, arg1: integer, arg2: integer, arg3: $CallbackInfo$$Type): void
get "explorationMap"(): boolean
get "banners"(): $Collection<($MapBanner)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapItemSavedData$$Type = ($MapItemSavedData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapItemSavedData$$Original = $MapItemSavedData;}
declare module "net.minecraft.world.level.levelgen.placement.PlacedFeature" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$ConfiguredFeature, $ConfiguredFeature$$Type} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$HolderSet} from "net.minecraft.core.HolderSet"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$PlacementModifier, $PlacementModifier$$Type} from "net.minecraft.world.level.levelgen.placement.PlacementModifier"
import {$Record} from "java.lang.Record"

export class $PlacedFeature extends $Record {
static readonly "CODEC": $Codec<($Holder<($PlacedFeature)>)>
static readonly "DIRECT_CODEC": $Codec<($PlacedFeature)>
static readonly "LIST_CODEC": $Codec<($HolderSet<($PlacedFeature)>)>
static readonly "LIST_OF_LISTS_CODEC": $Codec<($List<($HolderSet<($PlacedFeature)>)>)>

constructor(arg0: $Holder$$Type<($ConfiguredFeature<(never), (never)>)>, arg1: $List$$Type<($PlacementModifier$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "feature"(): $Holder<($ConfiguredFeature<(never), (never)>)>
public "placement"(): $List<($PlacementModifier)>
public "place"(arg0: $WorldGenLevel$$Type, arg1: $ChunkGenerator$$Type, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type): boolean
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
public "placeWithBiomeCheck"(arg0: $WorldGenLevel$$Type, arg1: $ChunkGenerator$$Type, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type): boolean
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenPlacedFeature
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenPlacedFeatureTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlacedFeature$$Type = (Special.WorldgenPlacedFeature) | ({"placement"?: $List$$Type<($PlacementModifier$$Type)>, "feature"?: $Holder$$Type<($ConfiguredFeature<(never), (never)>)>}) | ([placement?: $List$$Type<($PlacementModifier$$Type)>, feature?: $Holder$$Type<($ConfiguredFeature<(never), (never)>)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlacedFeature$$Original = $PlacedFeature;}
declare module "net.minecraft.world.level.chunk.PalettedContainer$Strategy" {
import {$PalettedContainer$Configuration} from "net.minecraft.world.level.chunk.PalettedContainer$Configuration"
import {$Palette$Factory} from "net.minecraft.world.level.chunk.Palette$Factory"
import {$IdMap$$Type} from "net.minecraft.core.IdMap"

export class $PalettedContainer$Strategy {
static "SECTION_STATES": $PalettedContainer$Strategy
static readonly "SINGLE_VALUE_PALETTE_FACTORY": $Palette$Factory
static readonly "GLOBAL_PALETTE_FACTORY": $Palette$Factory
static readonly "LINEAR_PALETTE_FACTORY": $Palette$Factory
static "SECTION_BIOMES": $PalettedContainer$Strategy
static readonly "HASHMAP_PALETTE_FACTORY": $Palette$Factory

constructor(arg0: integer)

public "size"(): integer
public "getIndex"(arg0: integer, arg1: integer, arg2: integer): integer
public "getConfiguration"<A>(arg0: $IdMap$$Type<(A)>, arg1: integer): $PalettedContainer$Configuration<(A)>
public "calculateBitsForSerialization"<A>(arg0: $IdMap$$Type<(A)>, arg1: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PalettedContainer$Strategy$$Type = ($PalettedContainer$Strategy);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PalettedContainer$Strategy$$Original = $PalettedContainer$Strategy;}
declare module "net.minecraft.world.level.block.entity.DropperBlockEntity" {
import {$DispenserBlockEntity} from "net.minecraft.world.level.block.entity.DispenserBlockEntity"
import {$ReferenceArraySet} from "it.unimi.dsi.fastutil.objects.ReferenceArraySet"
import {$Level} from "net.minecraft.world.level.Level"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$Component} from "net.minecraft.network.chat.Component"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DropperBlockEntity extends $DispenserBlockEntity {
 "inventoryChangeListeners": $ReferenceArraySet
 "worldPosition": $BlockPos
 "lootTable": $ResourceKey<($LootTable)>
 "level": $Level
static readonly "CONTAINER_SIZE": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventoryHandlingTypeListeners": $ReferenceArraySet
 "lockKey": $LockCode
 "hasComparators": byte
 "lootTableSeed": long
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getDefaultName"(): $Component
public "stillValid"(arg0: $Player$$Type): boolean
public "setChanged"(): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitContentModified"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$emitRemoved"(): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public static "tryClear"(arg0: any): void
get "defaultName"(): $Component
get "changed"(): void
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DropperBlockEntity$$Type = ($DropperBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DropperBlockEntity$$Original = $DropperBlockEntity;}
declare module "net.minecraft.world.level.pathfinder.Path" {
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$Set$$Type} from "java.util.Set"
import {$Path$DebugData} from "net.minecraft.world.level.pathfinder.Path$DebugData"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Node, $Node$$Type} from "net.minecraft.world.level.pathfinder.Node"
import {$Target$$Type} from "net.minecraft.world.level.pathfinder.Target"

export class $Path {
constructor(arg0: $List$$Type<($Node$$Type)>, arg1: $BlockPos$$Type, arg2: boolean)

public "toString"(): StringJS
public "isDone"(): boolean
public "copy"(): $Path
public "getTarget"(): $BlockPos
public "advance"(): void
public "replaceNode"(arg0: integer, arg1: $Node$$Type): void
public "getNode"(arg0: integer): $Node
public "getNodePos"(arg0: integer): $BlockPos
public "sameAs"(arg0: $Path$$Type): boolean
public "getEndNode"(): $Node
public "canReach"(): boolean
public "setDebug"(arg0: ($Node$$Type)[], arg1: ($Node$$Type)[], arg2: $Set$$Type<($Target$$Type)>): void
public "writeToStream"(arg0: $FriendlyByteBuf$$Type): void
public static "createFromStream"(arg0: $FriendlyByteBuf$$Type): $Path
public "getNextEntityPos"(arg0: $Entity$$Type): $Vec3
public "getNextNode"(): $Node
public "getNextNodeIndex"(): integer
public "getNodeCount"(): integer
public "getNextNodePos"(): $BlockPos
public "truncateNodes"(arg0: integer): void
public "notStarted"(): boolean
public "debugData"(): $Path$DebugData
public "setNextNodeIndex"(arg0: integer): void
public "getEntityPosAtNode"(arg0: $Entity$$Type, arg1: integer): $Vec3
public static "readNodeArray"(arg0: $FriendlyByteBuf$$Type): ($Node)[]
public static "writeNodeArray"(arg0: $FriendlyByteBuf$$Type, arg1: ($Node$$Type)[]): void
public "getDistToTarget"(): float
public "getPreviousNode"(): $Node
get "done"(): boolean
get "target"(): $BlockPos
get "endNode"(): $Node
get "nextNode"(): $Node
get "nextNodeIndex"(): integer
get "nodeCount"(): integer
get "nextNodePos"(): $BlockPos
set "nextNodeIndex"(value: integer)
get "distToTarget"(): float
get "previousNode"(): $Node
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Path$$Type = ($Path);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Path$$Original = $Path;}
declare module "net.minecraft.world.level.block.state.properties.StructureMode" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Component} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $StructureMode extends $Enum<($StructureMode)> implements $StringRepresentable$$Interface {
static readonly "CORNER": $StructureMode
static readonly "LOAD": $StructureMode
static readonly "DATA": $StructureMode
static readonly "SAVE": $StructureMode

public static "values"(): ($StructureMode)[]
public static "valueOf"(arg0: StringJS): $StructureMode
public "getDisplayName"(): $Component
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "displayName"(): $Component
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureMode$$Type = (("save") | ("load") | ("corner") | ("data"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureMode$$Original = $StructureMode;}
declare module "net.minecraft.world.level.block.state.properties.PistonType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $PistonType extends $Enum<($PistonType)> implements $StringRepresentable$$Interface {
static readonly "STICKY": $PistonType
static readonly "DEFAULT": $PistonType

public "toString"(): StringJS
public static "values"(): ($PistonType)[]
public static "valueOf"(arg0: StringJS): $PistonType
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PistonType$$Type = (("normal") | ("sticky"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PistonType$$Original = $PistonType;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.DualNoiseProvider" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$InclusiveRange$$Type} from "net.minecraft.util.InclusiveRange"
import {$List, $List$$Type} from "java.util.List"
import {$BlockStateProviderType} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProviderType"
import {$NormalNoise} from "net.minecraft.world.level.levelgen.synth.NormalNoise"
import {$NoiseProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.NoiseProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$NormalNoise$NoiseParameters, $NormalNoise$NoiseParameters$$Type} from "net.minecraft.world.level.levelgen.synth.NormalNoise$NoiseParameters"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $DualNoiseProvider extends $NoiseProvider {
static readonly "CODEC": $MapCodec<($DualNoiseProvider)>
readonly "seed": long
readonly "noise": $NormalNoise
readonly "scale": float
readonly "parameters": $NormalNoise$NoiseParameters
readonly "states": $List<($BlockState)>

constructor(arg0: $InclusiveRange$$Type<(integer)>, arg1: $NormalNoise$NoiseParameters$$Type, arg2: float, arg3: long, arg4: $NormalNoise$NoiseParameters$$Type, arg5: float, arg6: $List$$Type<($BlockState$$Type)>)

public "type"(): $BlockStateProviderType<(never)>
public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
public "getSlowNoiseValue"(arg0: $BlockPos$$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DualNoiseProvider$$Type = ($DualNoiseProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DualNoiseProvider$$Original = $DualNoiseProvider;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $LiquidSettings extends $Enum<($LiquidSettings)> implements $StringRepresentable$$Interface {
static "CODEC": $Codec<($LiquidSettings)>
static readonly "IGNORE_WATERLOGGING": $LiquidSettings
static readonly "APPLY_WATERLOGGING": $LiquidSettings

public static "values"(): ($LiquidSettings)[]
public static "valueOf"(arg0: StringJS): $LiquidSettings
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LiquidSettings$$Type = (("ignore_waterlogging") | ("apply_waterlogging"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LiquidSettings$$Original = $LiquidSettings;}
declare module "net.minecraft.world.level.levelgen.structure.structures.JungleTempleStructure" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$SinglePieceStructure} from "net.minecraft.world.level.levelgen.structure.SinglePieceStructure"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $JungleTempleStructure extends $SinglePieceStructure {
static readonly "CODEC": $MapCodec<($JungleTempleStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "type"(): $StructureType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JungleTempleStructure$$Type = ($JungleTempleStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JungleTempleStructure$$Original = $JungleTempleStructure;}
declare module "net.minecraft.world.level.levelgen.structure.structures.RuinedPortalStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$List$$Type} from "java.util.List"
import {$RuinedPortalStructure$Setup$$Type} from "net.minecraft.world.level.levelgen.structure.structures.RuinedPortalStructure$Setup"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $RuinedPortalStructure extends $Structure {
static readonly "CODEC": $MapCodec<($RuinedPortalStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type, arg1: $List$$Type<($RuinedPortalStructure$Setup$$Type)>)
constructor(arg0: $Structure$StructureSettings$$Type, arg1: $RuinedPortalStructure$Setup$$Type)

public "type"(): $StructureType<(never)>
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuinedPortalStructure$$Type = ($RuinedPortalStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuinedPortalStructure$$Original = $RuinedPortalStructure;}
declare module "net.minecraft.world.level.block.entity.SignBlockEntity" {
import {$UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$FilteredText$$Type} from "net.minecraft.server.network.FilteredText"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List$$Type} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$SignText, $SignText$$Type} from "net.minecraft.world.level.block.entity.SignText"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SignBlockEntity extends $BlockEntity {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)
constructor(arg0: $BlockEntityType$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public static "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $SignBlockEntity$$Type): void
public "getText"(arg0: boolean): $SignText
public "setText"(arg0: $SignText$$Type, arg1: boolean): boolean
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "updateText"(arg0: $UnaryOperator$$Type<($SignText)>, arg1: boolean): boolean
public "onlyOpCanSetNbt"(): boolean
public "executeClickCommandsIfPresent"(arg0: $Player$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: boolean): boolean
public "getSignInteractionFailedSoundEvent"(): $SoundEvent
public "setAllowedPlayerEditor"(arg0: $UUID$$Type): void
public "getPlayerWhoMayEdit"(): $UUID
public "canExecuteClickCommands"(arg0: boolean, arg1: $Player$$Type): boolean
public "setWaxed"(arg0: boolean): boolean
public "getMaxTextLineWidth"(): integer
public "createDefaultSignText"(): $SignText
public "playerIsTooFarAwayToEdit"(arg0: $UUID$$Type): boolean
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdatePacket"(): $Packet
public "isWaxed"(): boolean
public "isFacingFrontText"(arg0: $Player$$Type): boolean
public "getFrontText"(): $SignText
public "updateSignText"(arg0: $Player$$Type, arg1: boolean, arg2: $List$$Type<($FilteredText$$Type)>): void
public "getBackText"(): $SignText
public "getTextLineHeight"(): integer
get "signInteractionFailedSoundEvent"(): $SoundEvent
set "allowedPlayerEditor"(value: $UUID$$Type)
get "playerWhoMayEdit"(): $UUID
set "waxed"(value: boolean)
get "maxTextLineWidth"(): integer
get "updatePacket"(): $Packet
get "waxed"(): boolean
get "frontText"(): $SignText
get "backText"(): $SignText
get "textLineHeight"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignBlockEntity$$Type = ($SignBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SignBlockEntity$$Original = $SignBlockEntity;}
declare module "net.minecraft.world.level.chunk.LevelChunk$EntityCreationType" {
import {$Enum} from "java.lang.Enum"

export class $LevelChunk$EntityCreationType extends $Enum<($LevelChunk$EntityCreationType)> {
static readonly "QUEUED": $LevelChunk$EntityCreationType
static readonly "CHECK": $LevelChunk$EntityCreationType
static readonly "IMMEDIATE": $LevelChunk$EntityCreationType

public static "values"(): ($LevelChunk$EntityCreationType)[]
public static "valueOf"(arg0: StringJS): $LevelChunk$EntityCreationType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelChunk$EntityCreationType$$Type = (("immediate") | ("queued") | ("check"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelChunk$EntityCreationType$$Original = $LevelChunk$EntityCreationType;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration$TargetBlockState" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$RuleTest, $RuleTest$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $OreConfiguration$TargetBlockState {
static readonly "CODEC": $Codec<($OreConfiguration$TargetBlockState)>
readonly "state": $BlockState
readonly "target": $RuleTest

constructor(arg0: $RuleTest$$Type, arg1: $BlockState$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OreConfiguration$TargetBlockState$$Type = ($OreConfiguration$TargetBlockState);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OreConfiguration$TargetBlockState$$Original = $OreConfiguration$TargetBlockState;}
declare module "net.minecraft.world.level.chunk.ImposterProtoChunk" {
import {$ProtoChunk} from "net.minecraft.world.level.chunk.ProtoChunk"
import {$BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$UpgradeData} from "net.minecraft.world.level.chunk.UpgradeData"
import {$NoiseChunk} from "net.minecraft.world.level.levelgen.NoiseChunk"
import {$LongSet, $LongSet$$Type} from "it.unimi.dsi.fastutil.longs.LongSet"
import {$ChunkAccess$TicksToSave} from "net.minecraft.world.level.chunk.ChunkAccess$TicksToSave"
import {$Holder} from "net.minecraft.core.Holder"
import {$TickContainerAccess} from "net.minecraft.world.ticks.TickContainerAccess"
import {$Climate$Sampler$$Type} from "net.minecraft.world.level.biome.Climate$Sampler"
import {$BlendingData, $BlendingData$$Type} from "net.minecraft.world.level.levelgen.blending.BlendingData"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$AttachmentType$$Type} from "net.fabricmc.fabric.api.attachment.v1.AttachmentType"
import {$Structure, $Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Function$$Type} from "java.util.function.Function"
import {$CarvingMask} from "net.minecraft.world.level.chunk.CarvingMask"
import {$Heightmap} from "net.minecraft.world.level.levelgen.Heightmap"
import {$AttachmentHolder$AsField} from "net.neoforged.neoforge.attachment.AttachmentHolder$AsField"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ChunkSkyLightSources} from "net.minecraft.world.level.lighting.ChunkSkyLightSources"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$AttachmentSyncPayloadS2C$$Type} from "net.fabricmc.fabric.impl.attachment.sync.s2c.AttachmentSyncPayloadS2C"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$LevelChunkSection} from "net.minecraft.world.level.chunk.LevelChunkSection"
import {$ChunkPos} from "net.minecraft.world.level.ChunkPos"
import {$ChunkStatus, $ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$GenerationStep$Carving$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Carving"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$Heightmap$Types, $Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$BiomeResolver$$Type} from "net.minecraft.world.level.biome.BiomeResolver"
import {$StructureStart, $StructureStart$$Type} from "net.minecraft.world.level.levelgen.structure.StructureStart"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$LevelChunk, $LevelChunk$$Type} from "net.minecraft.world.level.chunk.LevelChunk"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$ShortList} from "it.unimi.dsi.fastutil.shorts.ShortList"
import {$AttachmentTargetInfo} from "net.fabricmc.fabric.impl.attachment.sync.AttachmentTargetInfo"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $ImposterProtoChunk extends $ProtoChunk {
readonly "upgradeData": $UpgradeData
readonly "chunkPos": $ChunkPos
readonly "pendingBlockEntities": $Map<($BlockPos), ($CompoundTag)>
 "noiseChunk": $NoiseChunk
readonly "sections": ($LevelChunkSection)[]
 "skyLightSources": $ChunkSkyLightSources
readonly "postProcessing": ($ShortList)[]
 "blendingData": $BlendingData
readonly "levelHeightAccessor": $LevelHeightAccessor
readonly "blockEntities": $Map<($BlockPos), ($BlockEntity)>
 "saveTimePoint": long
 "unsaved": boolean
readonly "heightmaps": $Map<($Heightmap$Types), ($Heightmap)>
static readonly "NO_FILLED_SECTION": integer

constructor(arg0: $LevelChunk$$Type, arg1: boolean)

public "isUnsaved"(): boolean
public "findBlocks"(arg0: $BiPredicate$$Type<($BlockState), ($BlockPos)>, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
public "findBlocks"(arg0: $Predicate$$Type<($BlockState)>, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
public "findBlocks"(arg0: $Predicate$$Type<($BlockState)>, arg1: $BiPredicate$$Type<($BlockState), ($BlockPos)>, arg2: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
public "getBlockEntityNbtForSaving"(arg0: $BlockPos$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public "getTicksForSerialization"(): $ChunkAccess$TicksToSave
public "fillBiomesFromNoise"(arg0: $BiomeResolver$$Type, arg1: $Climate$Sampler$$Type): void
public "getReferencesForStructure"(arg0: $Structure$$Type): $LongSet
public "initializeLightSources"(): void
public "getAttachmentHolder"(): $AttachmentHolder$AsField
public "addReferenceForStructure"(arg0: $Structure$$Type, arg1: long): void
public "setStartForStructure"(arg0: $Structure$$Type, arg1: $StructureStart$$Type): void
public "getStartForStructure"(arg0: $Structure$$Type): $StructureStart
public "getFluidState"(arg0: $BlockPos$$Type): $FluidState
public "markPosForPostprocessing"(arg0: $BlockPos$$Type): void
public "getPos"(): $ChunkPos
public "fabric_getSyncTargetInfo"(): $AttachmentTargetInfo
public "fabric_shouldTryToSync"(): boolean
public "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
public "getOrCreateCarvingMask"(arg0: $GenerationStep$Carving$$Type): $CarvingMask
public "fabric_syncChange"(arg0: $AttachmentType$$Type, arg1: $AttachmentSyncPayloadS2C$$Type): void
public "getAllStarts"(): $Map<($Structure), ($StructureStart)>
public "setBlockState"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: boolean): $BlockState
public "setBlockEntity"(arg0: $BlockEntity$$Type): void
public "removeBlockEntity"(arg0: $BlockPos$$Type): void
public "setUnsaved"(arg0: boolean): void
public "getWrapped"(): $LevelChunk
public "getSection"(arg0: integer): $LevelChunkSection
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "isLightCorrect"(): boolean
public "setAllStarts"(arg0: $Map$$Type<($Structure$$Type), ($StructureStart$$Type)>): void
public "getAllReferences"(): $Map<($Structure), ($LongSet)>
public "getBlockEntityNbt"(arg0: $BlockPos$$Type): $CompoundTag
public "setLightCorrect"(arg0: boolean): void
public "getSkyLightSources"(): $ChunkSkyLightSources
public "setHeightmap"(arg0: $Heightmap$Types$$Type, arg1: (long)[]): void
public "setBlockEntityNbt"(arg0: $CompoundTag$$Type): void
public "getBlendingData"(): $BlendingData
public "setBlendingData"(arg0: $BlendingData$$Type): void
public "getPersistedStatus"(): $ChunkStatus
public "setAllReferences"(arg0: $Map$$Type<($Structure$$Type), ($LongSet$$Type)>): void
public "addEntity"(arg0: $Entity$$Type): void
public "getSections"(): ($LevelChunkSection)[]
public "getBlockTicks"(): $TickContainerAccess<($Block)>
public "getFluidTicks"(): $TickContainerAccess<($Fluid)>
public "getMaxLightLevel"(): integer
public "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
public "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
public "fabric_computeInitialSyncChanges"(arg0: $ServerPlayer$$Type, arg1: $Consumer$$Type): void
public "fabric_getDynamicRegistryManager"(): $RegistryAccess
public "getOrCreateHeightmapUnprimed"(arg0: $Heightmap$Types$$Type): $Heightmap
public "getCarvingMask"(arg0: $GenerationStep$Carving$$Type): $CarvingMask
public "setPersistedStatus"(arg0: $ChunkStatus$$Type): void
public static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
public static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
get "ticksForSerialization"(): $ChunkAccess$TicksToSave
get "attachmentHolder"(): $AttachmentHolder$AsField
get "pos"(): $ChunkPos
get "allStarts"(): $Map<($Structure), ($StructureStart)>
set "blockEntity"(value: $BlockEntity$$Type)
get "wrapped"(): $LevelChunk
get "lightCorrect"(): boolean
set "allStarts"(value: $Map$$Type<($Structure$$Type), ($StructureStart$$Type)>)
get "allReferences"(): $Map<($Structure), ($LongSet)>
set "lightCorrect"(value: boolean)
set "blockEntityNbt"(value: $CompoundTag$$Type)
get "persistedStatus"(): $ChunkStatus
set "allReferences"(value: $Map$$Type<($Structure$$Type), ($LongSet$$Type)>)
get "blockTicks"(): $TickContainerAccess<($Block)>
get "fluidTicks"(): $TickContainerAccess<($Fluid)>
get "maxLightLevel"(): integer
set "persistedStatus"(value: $ChunkStatus$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ImposterProtoChunk$$Type = ($ImposterProtoChunk);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ImposterProtoChunk$$Original = $ImposterProtoChunk;}
declare module "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerState" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$TrialSpawner$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawner"

export class $TrialSpawnerState extends $Enum<($TrialSpawnerState)> implements $StringRepresentable$$Interface {
static readonly "COOLDOWN": $TrialSpawnerState
static readonly "ACTIVE": $TrialSpawnerState
static readonly "INACTIVE": $TrialSpawnerState
static readonly "EJECTING_REWARD": $TrialSpawnerState
static readonly "WAITING_FOR_REWARD_EJECTION": $TrialSpawnerState
static readonly "WAITING_FOR_PLAYERS": $TrialSpawnerState

public static "values"(): ($TrialSpawnerState)[]
public static "valueOf"(arg0: StringJS): $TrialSpawnerState
public "getSerializedName"(): StringJS
public "isCapableOfSpawning"(): boolean
public "lightLevel"(): integer
public "tickAndGetNext"(arg0: $BlockPos$$Type, arg1: $TrialSpawner$$Type, arg2: $ServerLevel$$Type): $TrialSpawnerState
public "spinningMobSpeed"(): double
public "hasSpinningMob"(): boolean
public "emitParticles"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: boolean): void
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "capableOfSpawning"(): boolean
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrialSpawnerState$$Type = (("inactive") | ("waiting_for_players") | ("active") | ("waiting_for_reward_ejection") | ("ejecting_reward") | ("cooldown"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrialSpawnerState$$Original = $TrialSpawnerState;}
declare module "net.minecraft.world.level.chunk.ChunkGeneratorStructureState" {
import {$HolderLookup$$Type} from "net.minecraft.core.HolderLookup"
import {$StructureSet, $StructureSet$$Type} from "net.minecraft.world.level.levelgen.structure.StructureSet"
import {$List} from "java.util.List"
import {$RandomState, $RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$StructurePlacement} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement"
import {$ChunkPos} from "net.minecraft.world.level.ChunkPos"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$BiomeSource$$Type} from "net.minecraft.world.level.biome.BiomeSource"
import {$ConcentricRingsStructurePlacement$$Type} from "net.minecraft.world.level.levelgen.structure.placement.ConcentricRingsStructurePlacement"
import {$Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$IChunkGenerator$$Interface} from "org.embeddedt.modernfix.duck.IChunkGenerator"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Stream$$Type} from "java.util.stream.Stream"

export class $ChunkGeneratorStructureState implements $IChunkGenerator$$Interface {
public "getPlacementsForStructure"(arg0: $Holder$$Type<($Structure)>): $List<($StructurePlacement)>
public "possibleStructureSets"(): $List<($Holder<($StructureSet)>)>
public "getRingPositionsFor"(arg0: $ConcentricRingsStructurePlacement$$Type): $List<($ChunkPos)>
public "randomState"(): $RandomState
public "ensureStructuresGenerated"(): void
public "mfix$setAssociatedServerLevel"(level: $ServerLevel$$Type): void
public "getLevelSeed"(): long
public static "createForNormal"(arg0: $RandomState$$Type, arg1: long, arg2: $BiomeSource$$Type, arg3: $HolderLookup$$Type<($StructureSet$$Type)>): $ChunkGeneratorStructureState
public static "createForFlat"(arg0: $RandomState$$Type, arg1: long, arg2: $BiomeSource$$Type, arg3: $Stream$$Type<($Holder$$Type<($StructureSet$$Type)>)>): $ChunkGeneratorStructureState
public "hasStructureChunkInRange"(arg0: $Holder$$Type<($StructureSet)>, arg1: integer, arg2: integer, arg3: integer): boolean
get "levelSeed"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkGeneratorStructureState$$Type = ($ChunkGeneratorStructureState);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkGeneratorStructureState$$Original = $ChunkGeneratorStructureState;}
declare module "net.minecraft.world.level.block.LiquidBlockContainer" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $LiquidBlockContainer$$Interface {
}

export class $LiquidBlockContainer implements $LiquidBlockContainer$$Interface {
 "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
 "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LiquidBlockContainer$$Type = ($LiquidBlockContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LiquidBlockContainer$$Original = $LiquidBlockContainer;}
declare module "net.minecraft.world.level.levelgen.feature.ConfiguredFeature" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Feature, $Feature$$Type} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$HolderSet} from "net.minecraft.core.HolderSet"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration, $FeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Holder} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $ConfiguredFeature<FC extends $FeatureConfiguration, F extends $Feature<(object)>> extends $Record {
static readonly "CODEC": $Codec<($Holder<($ConfiguredFeature<(never), (never)>)>)>
static readonly "DIRECT_CODEC": $Codec<($ConfiguredFeature<(never), (never)>)>
static readonly "LIST_CODEC": $Codec<($HolderSet<($ConfiguredFeature<(never), (never)>)>)>

constructor(arg0: F, arg1: FC)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "feature"(): F
public "config"(): FC
public "place"(arg0: $WorldGenLevel$$Type, arg1: $ChunkGenerator$$Type, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type): boolean
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenConfiguredFeature
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenConfiguredFeatureTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfiguredFeature$$Type<FC, F> = (Special.WorldgenConfiguredFeature) | ({"config"?: FC, "feature"?: F}) | ([config?: FC, feature?: F]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConfiguredFeature$$Original<FC, F> = $ConfiguredFeature<(FC), (F)>;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.TrunkVineDecorator" {
import {$TreeDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$TreeDecorator$Context$$Type} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context"
import {$TreeDecoratorType} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecoratorType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $TrunkVineDecorator extends $TreeDecorator {
static readonly "CODEC": $MapCodec<($TrunkVineDecorator)>
static readonly "INSTANCE": $TrunkVineDecorator

constructor()

public "type"(): $TreeDecoratorType<(never)>
public "place"(arg0: $TreeDecorator$Context$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrunkVineDecorator$$Type = ($TrunkVineDecorator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrunkVineDecorator$$Original = $TrunkVineDecorator;}
declare module "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockPredicate, $BlockPredicate$$Type} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $HugeFungusConfiguration implements $FeatureConfiguration$$Interface {
readonly "validBaseState": $BlockState
readonly "replaceableBlocks": $BlockPredicate
static readonly "CODEC": $Codec<($HugeFungusConfiguration)>
readonly "decorState": $BlockState
readonly "planted": boolean
readonly "hatState": $BlockState
readonly "stemState": $BlockState

constructor(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: $BlockPredicate$$Type, arg5: boolean)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HugeFungusConfiguration$$Type = ($HugeFungusConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HugeFungusConfiguration$$Original = $HugeFungusConfiguration;}
declare module "net.minecraft.world.level.block.entity.DecoratedPotBlockEntity" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$RandomizableContainer$$Interface} from "net.minecraft.world.RandomizableContainer"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$Set$$Type} from "java.util.Set"
import {$ContainerSingleItem$BlockContainerSingleItem$$Interface} from "net.minecraft.world.ticks.ContainerSingleItem$BlockContainerSingleItem"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$Container, $Container$$Type} from "net.minecraft.world.Container"
import {$PotDecorations, $PotDecorations$$Type} from "net.minecraft.world.level.block.entity.PotDecorations"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$DecoratedPotBlockEntity$WobbleStyle, $DecoratedPotBlockEntity$WobbleStyle$$Type} from "net.minecraft.world.level.block.entity.DecoratedPotBlockEntity$WobbleStyle"

export class $DecoratedPotBlockEntity extends $BlockEntity implements $RandomizableContainer$$Interface, $ContainerSingleItem$BlockContainerSingleItem$$Interface {
static readonly "TAG_SHERDS": StringJS
 "worldPosition": $BlockPos
 "lootTable": $ResourceKey<($LootTable)>
 "lastWobbleStyle": $DecoratedPotBlockEntity$WobbleStyle
static readonly "TAG_ITEM": StringJS
 "level": $Level
 "wobbleStartedAtTick": long
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
static readonly "EVENT_POT_WOBBLES": integer
 "lootTableSeed": long
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "wobble"(arg0: $DecoratedPotBlockEntity$WobbleStyle$$Type): void
public "setFromItem"(arg0: $ItemStack$$Type): void
public "triggerEvent"(arg0: integer, arg1: integer): boolean
public "getContainerBlockEntity"(): $BlockEntity
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getPotAsItem"(): $ItemStack
public "setLootTable"(arg0: $ResourceKey$$Type<($LootTable)>): void
public "getDecorations"(): $PotDecorations
public "getUpdatePacket"(): $Packet
public "setLootTableSeed"(arg0: long): void
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "getDirection"(): $Direction
public "getTheItem"(): $ItemStack
public "setTheItem"(arg0: $ItemStack$$Type): void
public "getLootTable"(): $ResourceKey<($LootTable)>
public "getLootTableSeed"(): long
public static "createDecoratedPotItem"(arg0: $PotDecorations$$Type): $ItemStack
public "collectImplicitComponents"(arg0: $DataComponentMap$Builder$$Type): void
public "applyImplicitComponents"(arg0: $BlockEntity$DataComponentInput$$Type): void
public "splitTheItem"(arg0: integer): $ItemStack
public "getLevel"(): $Level
public "tryLoadLootTable"(arg0: $CompoundTag$$Type): boolean
public "trySaveLootTable"(arg0: $CompoundTag$$Type): boolean
public "unpackLootTable"(arg0: $Player$$Type): void
public "setLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
public "getBlockPos"(): $BlockPos
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public "stillValid"(arg0: $Player$$Type): boolean
public "isEmpty"(): boolean
public "getItem"(arg0: integer): $ItemStack
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "removeItemNoUpdate"(arg0: integer): $ItemStack
public "getContainerSize"(): integer
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "getMaxStackSize"(): integer
public "getMaxStackSize"(arg0: $ItemStack$$Type): integer
public "hasAnyMatching"(arg0: $Predicate$$Type<($ItemStack)>): boolean
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public "stopOpen"(arg0: $Player$$Type): void
public "hasAnyOf"(arg0: $Set$$Type<($Item$$Type)>): boolean
public "countItem"(arg0: $Item$$Type): integer
public "startOpen"(arg0: $Player$$Type): void
public "canTakeItem"(arg0: $Container$$Type, arg1: integer, arg2: $ItemStack$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "clearContent"(): void
public "removeTheItem"(): $ItemStack
public static "tryClear"(arg0: any): void
public "canReceiveTransferCooldown"(): boolean
public "setTransferCooldown"(arg0: long): void
public "lithium$itemInsertionTestRequiresStackSize1"(): boolean
public "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "getWidth"(): integer
public "getHeight"(): integer
public "isMutable"(): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
public "getSlots"(): integer
public "getSlotLimit"(slot: integer): integer
public "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
public "setChanged"(): void
public "getStackInSlot"(slot: integer): $ItemStack
public "asContainer"(): $Container
public "clear"(): void
public "self"(): $Container
public "getBlock"(level: $Level$$Type): $LevelBlock
public "isEmpty"(): boolean
public "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(): integer
public "countNonEmpty"(match: $ItemPredicate$$Type): integer
public "getAllItems"(): $List<($ItemStack)>
public "clear"(match: $ItemPredicate$$Type): void
public "find"(): integer
public "find"(match: $ItemPredicate$$Type): integer
public "count"(): integer
public "count"(match: $ItemPredicate$$Type): integer
set "fromItem"(value: $ItemStack$$Type)
get "containerBlockEntity"(): $BlockEntity
get "potAsItem"(): $ItemStack
get "decorations"(): $PotDecorations
get "updatePacket"(): $Packet
get "direction"(): $Direction
get "theItem"(): $ItemStack
set "theItem"(value: $ItemStack$$Type)
get "blockPos"(): $BlockPos
get "empty"(): boolean
get "containerSize"(): integer
get "maxStackSize"(): integer
set "transferCooldown"(value: long)
get "width"(): integer
get "height"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "changed"(): void
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DecoratedPotBlockEntity$$Type = ($DecoratedPotBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DecoratedPotBlockEntity$$Original = $DecoratedPotBlockEntity;}
declare module "net.minecraft.world.level.block.entity.BlockEntityType" {
import {$ChestBlockEntity} from "net.minecraft.world.level.block.entity.ChestBlockEntity"
import {$ChiseledBookShelfBlockEntity} from "net.minecraft.world.level.block.entity.ChiseledBookShelfBlockEntity"
import {$BlockEntityType$BlockEntitySupplier$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType$BlockEntitySupplier"
import {$DispenserBlockEntity} from "net.minecraft.world.level.block.entity.DispenserBlockEntity"
import {$HopperBlockEntity} from "net.minecraft.world.level.block.entity.HopperBlockEntity"
import {$SignBlockEntity} from "net.minecraft.world.level.block.entity.SignBlockEntity"
import {$BarrelBlockEntity} from "net.minecraft.world.level.block.entity.BarrelBlockEntity"
import {$SmokerBlockEntity} from "net.minecraft.world.level.block.entity.SmokerBlockEntity"
import {$JigsawBlockEntity} from "net.minecraft.world.level.block.entity.JigsawBlockEntity"
import {$SculkSensorBlockEntity} from "net.minecraft.world.level.block.entity.SculkSensorBlockEntity"
import {$BrushableBlockEntity} from "net.minecraft.world.level.block.entity.BrushableBlockEntity"
import {$CommandBlockEntity} from "net.minecraft.world.level.block.entity.CommandBlockEntity"
import {$JukeboxBlockEntity} from "net.minecraft.world.level.block.entity.JukeboxBlockEntity"
import {$BrewingStandBlockEntity} from "net.minecraft.world.level.block.entity.BrewingStandBlockEntity"
import {$BannerBlockEntity} from "net.minecraft.world.level.block.entity.BannerBlockEntity"
import {$DaylightDetectorBlockEntity} from "net.minecraft.world.level.block.entity.DaylightDetectorBlockEntity"
import {$TrappedChestBlockEntity} from "net.minecraft.world.level.block.entity.TrappedChestBlockEntity"
import {$Set, $Set$$Type} from "java.util.Set"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$BeaconBlockEntity} from "net.minecraft.world.level.block.entity.BeaconBlockEntity"
import {$BlockEntityRenderPredicate, $BlockEntityRenderPredicate$$Type} from "net.caffeinemc.mods.sodium.api.blockentity.BlockEntityRenderPredicate"
import {$TheEndGatewayBlockEntity} from "net.minecraft.world.level.block.entity.TheEndGatewayBlockEntity"
import {$CalibratedSculkSensorBlockEntity} from "net.minecraft.world.level.block.entity.CalibratedSculkSensorBlockEntity"
import {$TrialSpawnerBlockEntity} from "net.minecraft.world.level.block.entity.TrialSpawnerBlockEntity"
import {$PistonMovingBlockEntity} from "net.minecraft.world.level.block.piston.PistonMovingBlockEntity"
import {$BlockEntityVisualizer, $BlockEntityVisualizer$$Type} from "dev.engine_room.flywheel.api.visualization.BlockEntityVisualizer"
import {$DecoratedPotBlockEntity} from "net.minecraft.world.level.block.entity.DecoratedPotBlockEntity"
import {$CrafterBlockEntity} from "net.minecraft.world.level.block.entity.CrafterBlockEntity"
import {$VaultBlockEntity} from "net.minecraft.world.level.block.entity.vault.VaultBlockEntity"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$DynamicLightHandlerHolder, $DynamicLightHandlerHolder$$Interface} from "toni.sodiumdynamiclights.accessor.DynamicLightHandlerHolder"
import {$AccessorBlockEntityType$$Interface} from "com.railwayteam.railways.mixin.AccessorBlockEntityType"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockEntityTypeAccessor$$Interface} from "net.neoforged.neoforge.mixins.BlockEntityTypeAccessor"
import {$ConduitBlockEntity} from "net.minecraft.world.level.block.entity.ConduitBlockEntity"
import {$Type$$Type} from "com.mojang.datafixers.types.Type"
import {$ExtendedBlockEntityType$$Interface} from "net.caffeinemc.mods.sodium.client.render.chunk.ExtendedBlockEntityType"
import {$SculkShriekerBlockEntity} from "net.minecraft.world.level.block.entity.SculkShriekerBlockEntity"
import {$DropperBlockEntity} from "net.minecraft.world.level.block.entity.DropperBlockEntity"
import {$Component} from "net.minecraft.network.chat.Component"
import {$BlockEntityTypeExtension$$Interface} from "dev.engine_room.flywheel.impl.extension.BlockEntityTypeExtension"
import {$TheEndPortalBlockEntity} from "net.minecraft.world.level.block.entity.TheEndPortalBlockEntity"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$DynamicLightHandler, $DynamicLightHandler$$Type} from "dev.lambdaurora.lambdynlights.api.DynamicLightHandler"
import {$FabricBlockEntityType$$Interface} from "net.fabricmc.fabric.api.object.builder.v1.block.entity.FabricBlockEntityType"
import {$EnchantingTableBlockEntity} from "net.minecraft.world.level.block.entity.EnchantingTableBlockEntity"
import {$SculkCatalystBlockEntity} from "net.minecraft.world.level.block.entity.SculkCatalystBlockEntity"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CampfireBlockEntity} from "net.minecraft.world.level.block.entity.CampfireBlockEntity"
import {$BellBlockEntity} from "net.minecraft.world.level.block.entity.BellBlockEntity"
import {$EnderChestBlockEntity} from "net.minecraft.world.level.block.entity.EnderChestBlockEntity"
import {$LecternBlockEntity} from "net.minecraft.world.level.block.entity.LecternBlockEntity"
import {$FurnaceBlockEntity} from "net.minecraft.world.level.block.entity.FurnaceBlockEntity"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$SpawnerBlockEntity} from "net.minecraft.world.level.block.entity.SpawnerBlockEntity"
import {$ShulkerBoxBlockEntity} from "net.minecraft.world.level.block.entity.ShulkerBoxBlockEntity"
import {$BeehiveBlockEntity} from "net.minecraft.world.level.block.entity.BeehiveBlockEntity"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$HangingSignBlockEntity} from "net.minecraft.world.level.block.entity.HangingSignBlockEntity"
import {$StructureBlockEntity} from "net.minecraft.world.level.block.entity.StructureBlockEntity"
import {$BedBlockEntity} from "net.minecraft.world.level.block.entity.BedBlockEntity"
import {$SkullBlockEntity} from "net.minecraft.world.level.block.entity.SkullBlockEntity"
import {$BlastFurnaceBlockEntity} from "net.minecraft.world.level.block.entity.BlastFurnaceBlockEntity"
import {$ComparatorBlockEntity} from "net.minecraft.world.level.block.entity.ComparatorBlockEntity"

export class $BlockEntityType<T extends $BlockEntity> implements $BlockEntityTypeAccessor$$Interface, $ExtendedBlockEntityType$$Interface, $FabricBlockEntityType$$Interface, $AccessorBlockEntityType$$Interface, $DynamicLightHandlerHolder$$Interface, $BlockEntityTypeExtension$$Interface {
static readonly "BLAST_FURNACE": $BlockEntityType<($BlastFurnaceBlockEntity)>
static readonly "HANGING_SIGN": $BlockEntityType<($HangingSignBlockEntity)>
static readonly "COMPARATOR": $BlockEntityType<($ComparatorBlockEntity)>
static readonly "VAULT": $BlockEntityType<($VaultBlockEntity)>
static readonly "SKULL": $BlockEntityType<($SkullBlockEntity)>
static readonly "CHISELED_BOOKSHELF": $BlockEntityType<($ChiseledBookShelfBlockEntity)>
static readonly "JIGSAW": $BlockEntityType<($JigsawBlockEntity)>
static readonly "DECORATED_POT": $BlockEntityType<($DecoratedPotBlockEntity)>
static readonly "BEACON": $BlockEntityType<($BeaconBlockEntity)>
static readonly "CRAFTER": $BlockEntityType<($CrafterBlockEntity)>
static readonly "FURNACE": $BlockEntityType<($FurnaceBlockEntity)>
static readonly "BEEHIVE": $BlockEntityType<($BeehiveBlockEntity)>
static readonly "PISTON": $BlockEntityType<($PistonMovingBlockEntity)>
static readonly "TRAPPED_CHEST": $BlockEntityType<($TrappedChestBlockEntity)>
static readonly "END_PORTAL": $BlockEntityType<($TheEndPortalBlockEntity)>
static readonly "ENDER_CHEST": $BlockEntityType<($EnderChestBlockEntity)>
static readonly "COMMAND_BLOCK": $BlockEntityType<($CommandBlockEntity)>
static readonly "SIGN": $BlockEntityType<($SignBlockEntity)>
static readonly "STRUCTURE_BLOCK": $BlockEntityType<($StructureBlockEntity)>
static readonly "BELL": $BlockEntityType<($BellBlockEntity)>
static readonly "ENCHANTING_TABLE": $BlockEntityType<($EnchantingTableBlockEntity)>
static readonly "BREWING_STAND": $BlockEntityType<($BrewingStandBlockEntity)>
static readonly "BED": $BlockEntityType<($BedBlockEntity)>
static readonly "MOB_SPAWNER": $BlockEntityType<($SpawnerBlockEntity)>
static readonly "CALIBRATED_SCULK_SENSOR": $BlockEntityType<($CalibratedSculkSensorBlockEntity)>
static readonly "SCULK_CATALYST": $BlockEntityType<($SculkCatalystBlockEntity)>
static readonly "CONDUIT": $BlockEntityType<($ConduitBlockEntity)>
static readonly "CAMPFIRE": $BlockEntityType<($CampfireBlockEntity)>
static readonly "END_GATEWAY": $BlockEntityType<($TheEndGatewayBlockEntity)>
static readonly "SMOKER": $BlockEntityType<($SmokerBlockEntity)>
static readonly "DISPENSER": $BlockEntityType<($DispenserBlockEntity)>
static readonly "SCULK_SHRIEKER": $BlockEntityType<($SculkShriekerBlockEntity)>
static readonly "HOPPER": $BlockEntityType<($HopperBlockEntity)>
static readonly "CHEST": $BlockEntityType<($ChestBlockEntity)>
static readonly "DAYLIGHT_DETECTOR": $BlockEntityType<($DaylightDetectorBlockEntity)>
static readonly "BANNER": $BlockEntityType<($BannerBlockEntity)>
static readonly "SCULK_SENSOR": $BlockEntityType<($SculkSensorBlockEntity)>
static readonly "TRIAL_SPAWNER": $BlockEntityType<($TrialSpawnerBlockEntity)>
static readonly "LECTERN": $BlockEntityType<($LecternBlockEntity)>
static readonly "SHULKER_BOX": $BlockEntityType<($ShulkerBoxBlockEntity)>
static readonly "BRUSHABLE_BLOCK": $BlockEntityType<($BrushableBlockEntity)>
static readonly "JUKEBOX": $BlockEntityType<($JukeboxBlockEntity)>
static readonly "BARREL": $BlockEntityType<($BarrelBlockEntity)>
static readonly "DROPPER": $BlockEntityType<($DropperBlockEntity)>

constructor(arg0: $BlockEntityType$BlockEntitySupplier$$Type<(T)>, arg1: $Set$$Type<($Block$$Type)>, arg2: $Type$$Type<(never)>)

public static "getKey"(arg0: $BlockEntityType$$Type<(never)>): $ResourceLocation
public "create"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): T
public "isValid"(arg0: $BlockState$$Type): boolean
public "sodium$removeRenderPredicate"(arg0: $BlockEntityRenderPredicate$$Type): boolean
public "getBlockEntity"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): T
public "sodiumdynamiclights$getSetting"(): boolean
public "sodiumdynamiclights$getName"(): $Component
public "sodiumdynamiclights$getDynamicLightHandler"(): $DynamicLightHandler
public "sodiumdynamiclights$setDynamicLightHandler"(handler: $DynamicLightHandler$$Type): void
public "getValidBlocks"(): $Set
public "flywheel$setVisualizer"(visualizer: $BlockEntityVisualizer$$Type): void
public "flywheel$getVisualizer"(): $BlockEntityVisualizer
public "builtInRegistryHolder"(): $Holder$Reference<($BlockEntityType<(never)>)>
public "sodium$getRenderPredicates"(): ($BlockEntityRenderPredicate)[]
public "sodium$addRenderPredicate"(arg0: $BlockEntityRenderPredicate$$Type): void
public "neoforge$setValidBlocks"(arg0: $Set$$Type): void
public "addSupportedBlock"(arg0: $Block$$Type): void
public "setValidBlocks"(arg0: $Set$$Type): void
public static "shouldRender"<T extends $BlockEntity>(arg0: $BlockEntityType$$Type<(any)>, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: any): boolean
public static "removeRenderPredicate"<T extends $BlockEntity>(arg0: $BlockEntityType$$Type<(any)>, arg1: $BlockEntityRenderPredicate$$Type<(any)>): boolean
public static "addRenderPredicate"<T extends $BlockEntity>(arg0: $BlockEntityType$$Type<(any)>, arg1: $BlockEntityRenderPredicate$$Type<(any)>): void
public static "cast"<T extends $BlockEntity>(entityType: $BlockEntityType$$Type<(any)>): $DynamicLightHandlerHolder<(any)>
public static "cast"<T extends $Entity>(entityType: $EntityType$$Type<(any)>): $DynamicLightHandlerHolder<(any)>
get "validBlocks"(): $Set
set "validBlocks"(value: $Set$$Type)
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.BlockEntityType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.BlockEntityTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityType$$Type<T> = (Special.BlockEntityType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityType$$Original<T> = $BlockEntityType<(T)>;}
declare module "net.minecraft.world.level.dimension.DimensionType$MonsterSettings" {
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $DimensionType$MonsterSettings extends $Record {
static readonly "CODEC": $MapCodec<($DimensionType$MonsterSettings)>

constructor(arg0: boolean, arg1: boolean, arg2: $IntProvider$$Type, arg3: integer)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "monsterSpawnBlockLightLimit"(): integer
public "piglinSafe"(): boolean
public "monsterSpawnLightTest"(): $IntProvider
public "hasRaids"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionType$MonsterSettings$$Type = ({"piglinSafe"?: boolean, "monsterSpawnBlockLightLimit"?: integer, "hasRaids"?: boolean, "monsterSpawnLightTest"?: $IntProvider$$Type}) | ([piglinSafe?: boolean, monsterSpawnBlockLightLimit?: integer, hasRaids?: boolean, monsterSpawnLightTest?: $IntProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DimensionType$MonsterSettings$$Original = $DimensionType$MonsterSettings;}
declare module "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement$ExclusionZone" {
import {$ChunkGeneratorStructureState$$Type} from "net.minecraft.world.level.chunk.ChunkGeneratorStructureState"
import {$StructureSet, $StructureSet$$Type} from "net.minecraft.world.level.levelgen.structure.StructureSet"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

/**
 * 
 * @deprecated
 */
export class $StructurePlacement$ExclusionZone extends $Record {
static readonly "CODEC": $Codec<($StructurePlacement$ExclusionZone)>

constructor(arg0: $Holder$$Type<($StructureSet)>, arg1: integer)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "otherSet"(): $Holder<($StructureSet)>
public "chunkCount"(): integer
public "isPlacementForbidden"(arg0: $ChunkGeneratorStructureState$$Type, arg1: integer, arg2: integer): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePlacement$ExclusionZone$$Type = ({"chunkCount"?: integer, "otherSet"?: $Holder$$Type<($StructureSet)>}) | ([chunkCount?: integer, otherSet?: $Holder$$Type<($StructureSet)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePlacement$ExclusionZone$$Original = $StructurePlacement$ExclusionZone;}
declare module "net.minecraft.world.level.levelgen.NoiseChunk" {
import {$NoiseGeneratorSettings$$Type} from "net.minecraft.world.level.levelgen.NoiseGeneratorSettings"
import {$DensityFunction$ContextProvider$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$List, $List$$Type} from "java.util.List"
import {$RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$Blender, $Blender$$Type} from "net.minecraft.world.level.levelgen.blending.Blender"
import {$NoiseSettings$$Type} from "net.minecraft.world.level.levelgen.NoiseSettings"
import {$NoiseRouter$$Type} from "net.minecraft.world.level.levelgen.NoiseRouter"
import {$DensityFunction$FunctionContext, $DensityFunction$FunctionContext$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$Aquifer} from "net.minecraft.world.level.levelgen.Aquifer"
import {$DensityFunction, $DensityFunction$$Type} from "net.minecraft.world.level.levelgen.DensityFunction"
import {$Blender$BlendingOutput} from "net.minecraft.world.level.levelgen.blending.Blender$BlendingOutput"
import {$Climate$Sampler} from "net.minecraft.world.level.biome.Climate$Sampler"
import {$DensityFunctions$BeardifierOrMarker$$Type} from "net.minecraft.world.level.levelgen.DensityFunctions$BeardifierOrMarker"
import {$NoiseChunk$CacheAllInCell} from "net.minecraft.world.level.levelgen.NoiseChunk$CacheAllInCell"
import {$NoiseChunk$NoiseInterpolator} from "net.minecraft.world.level.levelgen.NoiseChunk$NoiseInterpolator"
import {$Aquifer$FluidPicker$$Type} from "net.minecraft.world.level.levelgen.Aquifer$FluidPicker"
import {$Climate$ParameterPoint$$Type} from "net.minecraft.world.level.biome.Climate$ParameterPoint"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $NoiseChunk implements $DensityFunction$ContextProvider$$Interface, $DensityFunction$FunctionContext$$Interface {
 "cellStartBlockY": integer
readonly "cellCountY": integer
 "interpolating": boolean
 "arrayInterpolationCounter": long
readonly "firstNoiseZ": integer
 "fillingCell": boolean
readonly "cellNoiseMinY": integer
readonly "noiseSizeXZ": integer
 "inCellZ": integer
 "inCellY": integer
 "inCellX": integer
readonly "cellCaches": $List<($NoiseChunk$CacheAllInCell)>
readonly "cellCountXZ": integer
readonly "firstNoiseX": integer
readonly "interpolators": $List<($NoiseChunk$NoiseInterpolator)>
 "arrayIndex": integer
 "interpolationCounter": long

constructor(arg0: integer, arg1: $RandomState$$Type, arg2: integer, arg3: integer, arg4: $NoiseSettings$$Type, arg5: $DensityFunctions$BeardifierOrMarker$$Type, arg6: $NoiseGeneratorSettings$$Type, arg7: $Aquifer$FluidPicker$$Type, arg8: $Blender$$Type)

public "wrap"(arg0: $DensityFunction$$Type): $DensityFunction
public "cachedClimateSampler"(arg0: $NoiseRouter$$Type, arg1: $List$$Type<($Climate$ParameterPoint$$Type)>): $Climate$Sampler
public "getInterpolatedState"(): $BlockState
public "initializeForFirstCellX"(): void
public "cellHeight"(): integer
public "swapSlices"(): void
public "updateForX"(arg0: integer, arg1: double): void
public "updateForY"(arg0: integer, arg1: double): void
public "cellWidth"(): integer
public "aquifer"(): $Aquifer
public static "forChunk"(arg0: $ChunkAccess$$Type, arg1: $RandomState$$Type, arg2: $DensityFunctions$BeardifierOrMarker$$Type, arg3: $NoiseGeneratorSettings$$Type, arg4: $Aquifer$FluidPicker$$Type, arg5: $Blender$$Type): $NoiseChunk
public "updateForZ"(arg0: integer, arg1: double): void
public "forIndex"(arg0: integer): $DensityFunction$FunctionContext
public "blockX"(): integer
public "blockY"(): integer
public "blockZ"(): integer
public "advanceCellX"(arg0: integer): void
public "stopInterpolation"(): void
public "selectCellYZ"(arg0: integer, arg1: integer): void
public "fillAllDirectly"(arg0: (double)[], arg1: $DensityFunction$$Type): void
public "getBlender"(): $Blender
public "preliminarySurfaceLevel"(arg0: integer, arg1: integer): integer
public "getOrComputeBlendingOutput"(arg0: integer, arg1: integer): $Blender$BlendingOutput
get "interpolatedState"(): $BlockState
get "blender"(): $Blender
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseChunk$$Type = ($NoiseChunk);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseChunk$$Original = $NoiseChunk;}
declare module "net.minecraft.world.level.block.entity.SculkSensorBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$VibrationSystem$Data} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$Data"
import {$GameEventListener$Provider$$Interface} from "net.minecraft.world.level.gameevent.GameEventListener$Provider"
import {$VibrationSystem$Listener} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$Listener"
import {$Level} from "net.minecraft.world.level.Level"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$VibrationSystem$User} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$User"
import {$GameEvent, $GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$VibrationSystem$$Interface} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem"
import {$GameEventListener} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SculkSensorBlockEntity extends $BlockEntity implements $GameEventListener$Provider$$Interface<($VibrationSystem$Listener)>, $VibrationSystem$$Interface {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)
constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getVibrationUser"(): $VibrationSystem$User
public "getVibrationData"(): $VibrationSystem$Data
public "getListener"(): $GameEventListener
public "getLastVibrationFrequency"(): integer
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "createVibrationUser"(): $VibrationSystem$User
public "setLastVibrationFrequency"(arg0: integer): void
public static "getResonanceEventByFrequency"(arg0: integer): $ResourceKey<($GameEvent)>
public static "getRedstoneStrengthForDistance"(arg0: float, arg1: integer): integer
public static "getGameEventFrequency"(arg0: $ResourceKey$$Type<($GameEvent)>): integer
public static "getGameEventFrequency"(arg0: $Holder$$Type<($GameEvent)>): integer
get "vibrationUser"(): $VibrationSystem$User
get "vibrationData"(): $VibrationSystem$Data
get "listener"(): $GameEventListener
get "lastVibrationFrequency"(): integer
set "lastVibrationFrequency"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkSensorBlockEntity$$Type = ($SculkSensorBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkSensorBlockEntity$$Original = $SculkSensorBlockEntity;}
declare module "net.minecraft.world.level.gameevent.GameEvent" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$Holder} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $GameEvent extends $Record {
static readonly "EXPLODE": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_DESTROY": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_OPEN": $Holder$Reference<($GameEvent)>
static readonly "ENTITY_MOUNT": $Holder$Reference<($GameEvent)>
static readonly "FLUID_PLACE": $Holder$Reference<($GameEvent)>
static readonly "DEFAULT_NOTIFICATION_RADIUS": integer
static readonly "BLOCK_ATTACH": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_DETACH": $Holder$Reference<($GameEvent)>
static readonly "ENTITY_DAMAGE": $Holder$Reference<($GameEvent)>
static readonly "PROJECTILE_SHOOT": $Holder$Reference<($GameEvent)>
static readonly "DRINK": $Holder$Reference<($GameEvent)>
static readonly "ENTITY_DIE": $Holder$Reference<($GameEvent)>
static readonly "HIT_GROUND": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_ACTIVATE": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_10": $Holder$Reference<($GameEvent)>
static readonly "CODEC": $Codec<($Holder<($GameEvent)>)>
static readonly "RESONATE_14": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_13": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_12": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_11": $Holder$Reference<($GameEvent)>
static readonly "CONTAINER_CLOSE": $Holder$Reference<($GameEvent)>
static readonly "LIGHTNING_STRIKE": $Holder$Reference<($GameEvent)>
static readonly "CONTAINER_OPEN": $Holder$Reference<($GameEvent)>
static readonly "PRIME_FUSE": $Holder$Reference<($GameEvent)>
static readonly "SWIM": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_CLOSE": $Holder$Reference<($GameEvent)>
static readonly "EAT": $Holder$Reference<($GameEvent)>
static readonly "TELEPORT": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_15": $Holder$Reference<($GameEvent)>
static readonly "INSTRUMENT_PLAY": $Holder$Reference<($GameEvent)>
static readonly "SCULK_SENSOR_TENDRILS_CLICKING": $Holder$Reference<($GameEvent)>
static readonly "ENTITY_PLACE": $Holder$Reference<($GameEvent)>
static readonly "SPLASH": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_DEACTIVATE": $Holder$Reference<($GameEvent)>
static readonly "ITEM_INTERACT_FINISH": $Holder$Reference<($GameEvent)>
static readonly "SHRIEK": $Holder$Reference<($GameEvent)>
static readonly "ENTITY_ACTION": $Holder$Reference<($GameEvent)>
static readonly "JUKEBOX_PLAY": $Holder$Reference<($GameEvent)>
static readonly "NOTE_BLOCK_PLAY": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_CHANGE": $Holder$Reference<($GameEvent)>
static readonly "FLAP": $Holder$Reference<($GameEvent)>
static readonly "PROJECTILE_LAND": $Holder$Reference<($GameEvent)>
static readonly "EQUIP": $Holder$Reference<($GameEvent)>
static readonly "ENTITY_INTERACT": $Holder$Reference<($GameEvent)>
static readonly "UNEQUIP": $Holder$Reference<($GameEvent)>
static readonly "STEP": $Holder$Reference<($GameEvent)>
static readonly "JUKEBOX_STOP_PLAY": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_7": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_6": $Holder$Reference<($GameEvent)>
static readonly "ITEM_INTERACT_START": $Holder$Reference<($GameEvent)>
static readonly "SHEAR": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_5": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_4": $Holder$Reference<($GameEvent)>
static readonly "ELYTRA_GLIDE": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_9": $Holder$Reference<($GameEvent)>
static readonly "ENTITY_DISMOUNT": $Holder$Reference<($GameEvent)>
static readonly "FLUID_PICKUP": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_8": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_3": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_2": $Holder$Reference<($GameEvent)>
static readonly "BLOCK_PLACE": $Holder$Reference<($GameEvent)>
static readonly "RESONATE_1": $Holder$Reference<($GameEvent)>

constructor(arg0: integer)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "bootstrap"(arg0: $Registry$$Type<($GameEvent$$Type)>): $Holder<($GameEvent)>
public "notificationRadius"(): integer
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.GameEvent
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.GameEventTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameEvent$$Type = (Special.GameEvent) | ({"notificationRadius"?: integer}) | ([notificationRadius?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameEvent$$Original = $GameEvent;}
declare module "net.minecraft.world.level.block.entity.ShulkerBoxBlockEntity$AnimationStatus" {
import {$Enum} from "java.lang.Enum"

export class $ShulkerBoxBlockEntity$AnimationStatus extends $Enum<($ShulkerBoxBlockEntity$AnimationStatus)> {
static readonly "CLOSED": $ShulkerBoxBlockEntity$AnimationStatus
static readonly "CLOSING": $ShulkerBoxBlockEntity$AnimationStatus
static readonly "OPENING": $ShulkerBoxBlockEntity$AnimationStatus
static readonly "OPENED": $ShulkerBoxBlockEntity$AnimationStatus

public static "values"(): ($ShulkerBoxBlockEntity$AnimationStatus)[]
public static "valueOf"(arg0: StringJS): $ShulkerBoxBlockEntity$AnimationStatus
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShulkerBoxBlockEntity$AnimationStatus$$Type = (("closed") | ("opening") | ("opened") | ("closing"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShulkerBoxBlockEntity$AnimationStatus$$Original = $ShulkerBoxBlockEntity$AnimationStatus;}
declare module "net.minecraft.world.level.levelgen.LegacyRandomSource" {
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$PositionalRandomFactory} from "net.minecraft.world.level.levelgen.PositionalRandomFactory"
import {$BitRandomSource$$Interface} from "net.minecraft.world.level.levelgen.BitRandomSource"

export class $LegacyRandomSource implements $BitRandomSource$$Interface {
constructor(arg0: long)

public "next"(arg0: integer): integer
public "setSeed"(arg0: long): void
public "nextGaussian"(): double
public "fork"(): $RandomSource
public "forkPositional"(): $PositionalRandomFactory
public "nextDouble"(): double
public "nextInt"(arg0: integer): integer
public "nextInt"(): integer
public "nextLong"(): long
public "nextBoolean"(): boolean
public "nextFloat"(): float
public static "create"(arg0: long): $RandomSource
public static "create"(): $RandomSource
public "nextInt"(arg0: integer, arg1: integer): integer
public "triangle"(arg0: double, arg1: double): double
public static "createNewThreadLocalInstance"(): $RandomSource
public "nextIntBetweenInclusive"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public static "createThreadSafe"(): $RandomSource
public "consumeCount"(arg0: integer): void
set "seed"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LegacyRandomSource$$Type = ($LegacyRandomSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LegacyRandomSource$$Original = $LegacyRandomSource;}
declare module "net.minecraft.world.level.levelgen.structure.structures.OceanMonumentStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$PiecesContainer, $PiecesContainer$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $OceanMonumentStructure extends $Structure {
static readonly "CODEC": $MapCodec<($OceanMonumentStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "type"(): $StructureType<(never)>
public static "regeneratePiecesAfterLoad"(arg0: $ChunkPos$$Type, arg1: long, arg2: $PiecesContainer$$Type): $PiecesContainer
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OceanMonumentStructure$$Type = ($OceanMonumentStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OceanMonumentStructure$$Original = $OceanMonumentStructure;}
declare module "net.minecraft.world.level.levelgen.NoiseChunk$CacheAllInCell" {
import {$DensityFunctions$Marker$Type} from "net.minecraft.world.level.levelgen.DensityFunctions$Marker$Type"
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$NoiseChunk$NoiseChunkDensityFunction$$Interface} from "net.minecraft.world.level.levelgen.NoiseChunk$NoiseChunkDensityFunction"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$DensityFunctions$MarkerOrMarked$$Interface} from "net.minecraft.world.level.levelgen.DensityFunctions$MarkerOrMarked"
import {$DensityFunction} from "net.minecraft.world.level.levelgen.DensityFunction"

export class $NoiseChunk$CacheAllInCell implements $DensityFunctions$MarkerOrMarked$$Interface, $NoiseChunk$NoiseChunkDensityFunction$$Interface {
public "type"(): $DensityFunctions$Marker$Type
public "wrapped"(): $DensityFunction
public "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
public "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
public "abs"(): $DensityFunction
public "clamp"(arg0: double, arg1: double): $DensityFunction
public "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
public "maxValue"(): double
public "square"(): $DensityFunction
public "halfNegative"(): $DensityFunction
public "quarterNegative"(): $DensityFunction
public "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
public "minValue"(): double
public "cube"(): $DensityFunction
public "squeeze"(): $DensityFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseChunk$CacheAllInCell$$Type = ($NoiseChunk$CacheAllInCell);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseChunk$CacheAllInCell$$Original = $NoiseChunk$CacheAllInCell;}
declare module "net.minecraft.world.level.levelgen.placement.PlacementContext" {
import {$GenerationStep$Carving$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Carving"
import {$WorldGenLevel, $WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$ChunkGenerator, $ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$CarvingMask} from "net.minecraft.world.level.chunk.CarvingMask"
import {$WorldGenerationContext} from "net.minecraft.world.level.levelgen.WorldGenerationContext"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $PlacementContext extends $WorldGenerationContext {
constructor(arg0: $WorldGenLevel$$Type, arg1: $ChunkGenerator$$Type, arg2: ($PlacedFeature$$Type)?)

public "generator"(): $ChunkGenerator
public "getLevel"(): $WorldGenLevel
public "topFeature"(): $Optional<($PlacedFeature)>
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
public "getCarvingMask"(arg0: $ChunkPos$$Type, arg1: $GenerationStep$Carving$$Type): $CarvingMask
public "getMinBuildHeight"(): integer
get "level"(): $WorldGenLevel
get "minBuildHeight"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlacementContext$$Type = ($PlacementContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlacementContext$$Original = $PlacementContext;}
declare module "net.minecraft.world.level.storage.PrimaryLevelData$SpecialWorldProperty" {
import {$Enum} from "java.lang.Enum"

/**
 * 
 * @deprecated
 */
export class $PrimaryLevelData$SpecialWorldProperty extends $Enum<($PrimaryLevelData$SpecialWorldProperty)> {
static readonly "FLAT": $PrimaryLevelData$SpecialWorldProperty
static readonly "NONE": $PrimaryLevelData$SpecialWorldProperty
static readonly "DEBUG": $PrimaryLevelData$SpecialWorldProperty

public static "values"(): ($PrimaryLevelData$SpecialWorldProperty)[]
public static "valueOf"(arg0: StringJS): $PrimaryLevelData$SpecialWorldProperty
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PrimaryLevelData$SpecialWorldProperty$$Type = (("none") | ("flat") | ("debug"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PrimaryLevelData$SpecialWorldProperty$$Original = $PrimaryLevelData$SpecialWorldProperty;}
declare module "net.minecraft.world.level.block.entity.vault.VaultBlockEntity" {
import {$VaultServerData} from "net.minecraft.world.level.block.entity.vault.VaultServerData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ClientGamePacketListener} from "net.minecraft.network.protocol.game.ClientGamePacketListener"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$VaultSharedData} from "net.minecraft.world.level.block.entity.vault.VaultSharedData"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$VaultConfig, $VaultConfig$$Type} from "net.minecraft.world.level.block.entity.vault.VaultConfig"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$VaultClientData} from "net.minecraft.world.level.block.entity.vault.VaultClientData"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $VaultBlockEntity extends $BlockEntity {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "getServerData"(): $VaultServerData
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getClientData"(): $VaultClientData
public "getSharedData"(): $VaultSharedData
public static "access$000"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "getConfig"(): $VaultConfig
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "setConfig"(arg0: $VaultConfig$$Type): void
get "serverData"(): $VaultServerData
get "clientData"(): $VaultClientData
get "sharedData"(): $VaultSharedData
get "config"(): $VaultConfig
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
set "config"(value: $VaultConfig$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VaultBlockEntity$$Type = ($VaultBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VaultBlockEntity$$Original = $VaultBlockEntity;}
declare module "net.minecraft.world.level.block.entity.BannerPatternLayers$Layer" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$BannerPattern, $BannerPattern$$Type} from "net.minecraft.world.level.block.entity.BannerPattern"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $BannerPatternLayers$Layer extends $Record {
static readonly "CODEC": $Codec<($BannerPatternLayers$Layer)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($BannerPatternLayers$Layer)>

constructor(arg0: $Holder$$Type<($BannerPattern)>, arg1: $DyeColor$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "pattern"(): $Holder<($BannerPattern)>
public "color"(): $DyeColor
public "description"(): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BannerPatternLayers$Layer$$Type = ({"pattern"?: $Holder$$Type<($BannerPattern)>, "color"?: $DyeColor$$Type}) | ([pattern?: $Holder$$Type<($BannerPattern)>, color?: $DyeColor$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BannerPatternLayers$Layer$$Original = $BannerPatternLayers$Layer;}
declare module "net.minecraft.world.level.WorldGenLevel" {
import {$Iterable} from "java.lang.Iterable"
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$SoundSource$$Type} from "net.minecraft.sounds.SoundSource"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$Stream} from "java.util.stream.Stream"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BiomeManager} from "net.minecraft.world.level.biome.BiomeManager"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$Difficulty} from "net.minecraft.world.Difficulty"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$LevelData} from "net.minecraft.world.level.storage.LevelData"
import {$ServerLevelAccessor$$Interface} from "net.minecraft.world.level.ServerLevelAccessor"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$ChunkSource} from "net.minecraft.world.level.chunk.ChunkSource"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$TickPriority$$Type} from "net.minecraft.world.ticks.TickPriority"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Class$$Type} from "java.lang.Class"
import {$TargetingConditions$$Type} from "net.minecraft.world.entity.ai.targeting.TargetingConditions"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$HolderLookup} from "net.minecraft.core.HolderLookup"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$LevelTickAccess} from "net.minecraft.world.ticks.LevelTickAccess"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$DifficultyInstance} from "net.minecraft.world.DifficultyInstance"
import {$ServerLevel} from "net.minecraft.server.level.ServerLevel"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$DimensionType} from "net.minecraft.world.level.dimension.DimensionType"

export interface $WorldGenLevel$$Interface extends $ServerLevelAccessor$$Interface {
get "seed"(): long
set "currentlyGenerating"(value: $Supplier$$Type<(StringJS)>)
get "level"(): $ServerLevel
get "chunkSource"(): $ChunkSource
get "random"(): $RandomSource
get "levelData"(): $LevelData
get "blockTicks"(): $LevelTickAccess<($Block)>
get "fluidTicks"(): $LevelTickAccess<($Fluid)>
get "server"(): $MinecraftServer
get "difficulty"(): $Difficulty
get "moonBrightness"(): float
get "moonPhase"(): integer
get "seaLevel"(): integer
get "clientSide"(): boolean
get "skyDarken"(): integer
get "biomeManager"(): $BiomeManager
get "height"(): integer
get "minBuildHeight"(): integer
get "mcEntities"(): $Iterable<($Entity)>
get "players"(): $EntityArrayList
get "mcPlayers"(): $List<($Player)>
get "lightEngine"(): $LevelLightEngine
get "worldBorder"(): $WorldBorder
get "entities"(): $EntityArrayList
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "maxSection"(): integer
get "minSection"(): integer
get "sectionsCount"(): integer
}

export class $WorldGenLevel implements $WorldGenLevel$$Interface {
 "getSeed"(): long
 "ensureCanWrite"(arg0: $BlockPos$$Type): boolean
 "setCurrentlyGenerating"(arg0: $Supplier$$Type<(StringJS)>): void
 "getLevel"(): $ServerLevel
 "addFreshEntityWithPassengers"(arg0: $Entity$$Type): void
 "getChunkSource"(): $ChunkSource
 "neighborShapeChanged"(arg0: $Direction$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type, arg4: integer, arg5: integer): void
 "blockUpdated"(arg0: $BlockPos$$Type, arg1: $Block$$Type): void
 "addParticle"(arg0: $ParticleOptions$$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): void
 "nextSubTickCount"(): long
 "getRandom"(): $RandomSource
 "levelEvent"(arg0: $Player$$Type, arg1: integer, arg2: $BlockPos$$Type, arg3: integer): void
 "levelEvent"(arg0: integer, arg1: $BlockPos$$Type, arg2: integer): void
 "dayTime"(): long
 "getLevelData"(): $LevelData
 "getBlockTicks"(): $LevelTickAccess<($Block)>
 "getFluidTicks"(): $LevelTickAccess<($Fluid)>
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer, arg3: $TickPriority$$Type): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer, arg3: $TickPriority$$Type): void
 "getCurrentDifficultyAt"(arg0: $BlockPos$$Type): $DifficultyInstance
 "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $Vec3$$Type): void
 "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $Vec3$$Type, arg2: $GameEvent$Context$$Type): void
 "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $BlockPos$$Type): void
 "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
 "gameEvent"(arg0: $ResourceKey$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
 "getServer"(): $MinecraftServer
 "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type, arg4: float, arg5: float): void
 "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type): void
 "getDifficulty"(): $Difficulty
 "hasChunk"(arg0: integer, arg1: integer): boolean
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "getTimeOfDay"(arg0: float): float
 "getMoonBrightness"(): float
 "getMoonPhase"(): integer
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($Entity)>
 "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type, arg2: $Predicate$$Type<($Entity)>): $List<($Entity)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type): $List<(T)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "hasNearbyAlivePlayer"(arg0: double, arg1: double, arg2: double, arg3: double): boolean
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: double, arg2: double, arg3: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: double, arg3: double, arg4: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: $Predicate$$Type<($Entity)>): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): $Player
 "getNearestPlayer"(arg0: $Entity$$Type, arg1: double): $Player
 "getNearestEntity"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double, arg6: $AABB$$Type): T
 "getNearestEntity"<T extends $LivingEntity>(arg0: $List$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double): T
 "getNearbyPlayers"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: $AABB$$Type): $List<($Player)>
 "getNearbyEntities"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: $AABB$$Type): $List<(T)>
 "getPlayerByUUID"(arg0: $UUID$$Type): $Player
 "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
 "getBlockStatesIfLoaded"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "registryAccess"(): $RegistryAccess
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
 "dimensionType"(): $DimensionType
/**
 * 
 * @deprecated
 */
 "getSeaLevel"(): integer
 "isClientSide"(): boolean
 "getSkyDarken"(): integer
 "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
 "getUncachedNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "canSeeSkyFromBelowWater"(arg0: $BlockPos$$Type): boolean
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type): integer
 "isWaterAt"(arg0: $BlockPos$$Type): boolean
 "hasBiomes"(): boolean
 "enabledFeatures"(): $FeatureFlagSet
 "getPathfindingCostFromLightLevels"(arg0: $BlockPos$$Type): float
 "getBiomeManager"(): $BiomeManager
 "isEmptyBlock"(arg0: $BlockPos$$Type): boolean
 "holderLookup"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>): $HolderLookup<(T)>
 "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "getBiomeFabric"(arg0: $BlockPos$$Type): $Holder
 "getChunk"(arg0: $BlockPos$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
 "getHeight"(): integer
 "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
/**
 * 
 * @deprecated
 */
 "getLightLevelDependentMagicValue"(arg0: $BlockPos$$Type): float
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: $BlockPos$$Type): boolean
 "getMinBuildHeight"(): integer
 "containsAnyLiquid"(arg0: $AABB$$Type): boolean
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getPlayers"(): $EntityArrayList
 "getMcPlayers"(): $List<($Player)>
 "self"(): $EntityGetter
 "getLightEngine"(): $LevelLightEngine
 "canSeeSky"(arg0: $BlockPos$$Type): boolean
 "getShade"(arg0: $Direction$$Type, arg1: boolean): float
 "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
 "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
 "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
 "getWorldBorder"(): $WorldBorder
 "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
 "isUnobstructed"(arg0: $Entity$$Type): boolean
 "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "noCollision"(arg0: $Entity$$Type): boolean
 "noCollision"(arg0: $AABB$$Type): boolean
 "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
 "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
 "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
 "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
 "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
 "holder"<T>(arg0: $ResourceKey$$Type<(T)>): $Optional<($Holder$Reference<(T)>)>
 "isAreaLoaded"(arg0: $BlockPos$$Type, arg1: integer): boolean
 "holderOrThrow"<T>(arg0: $ResourceKey$$Type<(T)>): $Holder<(T)>
/**
 * 
 * @deprecated
 */
 "getBlockEntityRenderAttachment"(arg0: $BlockPos$$Type): any
 "isStateAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($BlockState)>): boolean
 "isFluidAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($FluidState)>): boolean
 "removeBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "addFreshEntity"(arg0: $Entity$$Type): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type, arg3: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type): boolean
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntities"(): $EntityArrayList
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
 "getMaxLightLevel"(): integer
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getMaxBuildHeight"(): integer
 "getSectionIndex"(arg0: integer): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionsCount"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
 "getBlockEntityRenderData"(arg0: $BlockPos$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldGenLevel$$Type = ($WorldGenLevel);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldGenLevel$$Original = $WorldGenLevel;}
declare module "net.minecraft.world.level.levelgen.synth.ImprovedNoise" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$StringBuilder$$Type} from "java.lang.StringBuilder"

export class $ImprovedNoise {
readonly "zo": double
readonly "yo": double
readonly "xo": double

constructor(arg0: $RandomSource$$Type)

public "parityConfigString"(arg0: $StringBuilder$$Type): void
public "noise"(arg0: double, arg1: double, arg2: double): double
/**
 * 
 * @deprecated
 */
public "noise"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double): double
public "noiseWithDerivative"(arg0: double, arg1: double, arg2: double, arg3: (double)[]): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ImprovedNoise$$Type = ($ImprovedNoise);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ImprovedNoise$$Original = $ImprovedNoise;}
declare module "net.minecraft.world.level.levelgen.structure.structures.IglooStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $IglooStructure extends $Structure {
static readonly "CODEC": $MapCodec<($IglooStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "type"(): $StructureType<(never)>
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IglooStructure$$Type = ($IglooStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IglooStructure$$Original = $IglooStructure;}
declare module "net.minecraft.world.level.chunk.storage.ChunkScanAccess" {
import {$CompletableFuture, $CompletableFuture$$Type} from "java.util.concurrent.CompletableFuture"
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$StreamTagVisitor, $StreamTagVisitor$$Type} from "net.minecraft.nbt.StreamTagVisitor"

export interface $ChunkScanAccess$$Interface {

(arg0: $ChunkPos, arg1: $StreamTagVisitor): $CompletableFuture$$Type<(void)>
}

export class $ChunkScanAccess implements $ChunkScanAccess$$Interface {
 "scanChunk"(arg0: $ChunkPos$$Type, arg1: $StreamTagVisitor$$Type): $CompletableFuture<(void)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkScanAccess$$Type = ((arg0: $ChunkPos, arg1: $StreamTagVisitor) => $CompletableFuture$$Type<(void)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkScanAccess$$Original = $ChunkScanAccess;}
declare module "net.minecraft.world.level.GameRules$GameRuleTypeVisitor" {
import {$GameRules$Value} from "net.minecraft.world.level.GameRules$Value"
import {$GameRules$Type$$Type} from "net.minecraft.world.level.GameRules$Type"
import {$GameRules$BooleanValue$$Type} from "net.minecraft.world.level.GameRules$BooleanValue"
import {$GameRules$Key$$Type} from "net.minecraft.world.level.GameRules$Key"
import {$GameRules$IntegerValue$$Type} from "net.minecraft.world.level.GameRules$IntegerValue"

export interface $GameRules$GameRuleTypeVisitor$$Interface {
}

export class $GameRules$GameRuleTypeVisitor implements $GameRules$GameRuleTypeVisitor$$Interface {
 "visit"<T extends $GameRules$Value<(object)>>(arg0: $GameRules$Key$$Type<(T)>, arg1: $GameRules$Type$$Type<(T)>): void
 "visitInteger"(arg0: $GameRules$Key$$Type<($GameRules$IntegerValue$$Type)>, arg1: $GameRules$Type$$Type<($GameRules$IntegerValue$$Type)>): void
 "visitBoolean"(arg0: $GameRules$Key$$Type<($GameRules$BooleanValue$$Type)>, arg1: $GameRules$Type$$Type<($GameRules$BooleanValue$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$GameRuleTypeVisitor$$Type = ($GameRules$GameRuleTypeVisitor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$GameRuleTypeVisitor$$Original = $GameRules$GameRuleTypeVisitor;}
declare module "net.minecraft.world.level.storage.loot.LootTable" {
import {$LootContext$$Type} from "net.minecraft.world.level.storage.loot.LootContext"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$LootTableAccessor$$Interface} from "com.blackgear.platform.core.mixin.neoforge.access.LootTableAccessor"
import {$LootItemFunction$$Type} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction"
import {$List, $List$$Type} from "java.util.List"
import {$LootPool, $LootPool$$Type} from "net.minecraft.world.level.storage.loot.LootPool"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$LootParams$$Type} from "net.minecraft.world.level.storage.loot.LootParams"
import {$LootContextParamSet, $LootContextParamSet$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$Holder} from "net.minecraft.core.Holder"
import {$ObjectArrayList} from "it.unimi.dsi.fastutil.objects.ObjectArrayList"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LootTable$Builder} from "net.minecraft.world.level.storage.loot.LootTable$Builder"
import {$LootTableAccessor$$Interface as $LootTableAccessor$1$$Interface} from "fzzyhmstrs.emi_loot.mixins.LootTableAccessor"
import {$LootTableAccessor$$Interface as $LootTableAccessor$0$$Interface} from "com.jesz.createdieselgenerators.mixins.LootTableAccessor"
import {$Container$$Type} from "net.minecraft.world.Container"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$LootTableAccessor$$Interface as $LootTableAccessor$2$$Interface} from "net.fabricmc.fabric.mixin.loot.LootTableAccessor"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"

export class $LootTable implements $LootTableAccessor$1$$Interface, $LootTableAccessor$2$$Interface, $LootTableAccessor$$Interface, $LootTableAccessor$0$$Interface {
static readonly "CODEC": $Codec<($Holder<($LootTable)>)>
static readonly "DEFAULT_PARAM_SET": $LootContextParamSet
readonly "pools": $List<($LootPool)>
static readonly "DIRECT_CODEC": $Codec<($LootTable)>
static readonly "RANDOMIZE_SEED": long
static readonly "EMPTY": $LootTable

constructor(arg0: $LootContextParamSet$$Type, arg1: ($ResourceLocation$$Type)?, arg2: $List$$Type<($LootPool$$Type)>, arg3: $List$$Type<($LootItemFunction$$Type)>)

public "fill"(arg0: $Container$$Type, arg1: $LootParams$$Type, arg2: long): void
public "validate"(arg0: $ValidationContext$$Type): void
public "getPool"(arg0: StringJS): $LootPool
public "isFrozen"(): boolean
public "freeze"(): void
public "setLootTableId"(arg0: $ResourceLocation$$Type): void
/**
 * 
 * @deprecated
 */
public "getRandomItemsRaw"(arg0: $LootParams$$Type, arg1: $Consumer$$Type<($ItemStack)>): void
/**
 * 
 * @deprecated
 */
public "getRandomItemsRaw"(arg0: $LootContext$$Type, arg1: $Consumer$$Type<($ItemStack)>): void
public "getLootTableId"(): $ResourceLocation
public "fabric_getPools"(): $List
public static "lootTable"(): $LootTable$Builder
public static "createStackSplitter"(arg0: $ServerLevel$$Type, arg1: $Consumer$$Type<($ItemStack)>): $Consumer<($ItemStack)>
public "fabric_getFunctions"(): $List
public "fabric_getRandomSequenceId"(): $Optional
public "getParamSet"(): $LootContextParamSet
public "handler$bae000$balm$getRandomItems"(arg0: $LootContext$$Type, arg1: $CallbackInfoReturnable$$Type): void
public "removePool"(arg0: StringJS): $LootPool
public "addPool"(arg0: $LootPool$$Type): void
public "getPools"(): $List
public "getRandomItems"(arg0: $LootContext$$Type, arg1: $Consumer$$Type<($ItemStack)>): void
public "getRandomItems"(arg0: $LootParams$$Type): $ObjectArrayList<($ItemStack)>
public "getRandomItems"(arg0: $LootParams$$Type, arg1: $RandomSource$$Type): $ObjectArrayList<($ItemStack)>
public "getRandomItems"(arg0: $LootParams$$Type, arg1: long): $ObjectArrayList<($ItemStack)>
public "getRandomItems"(arg0: $LootParams$$Type, arg1: long, arg2: $Consumer$$Type<($ItemStack)>): void
public "getRandomItems"(arg0: $LootParams$$Type, arg1: $Consumer$$Type<($ItemStack)>): void
get "frozen"(): boolean
set "lootTableId"(value: $ResourceLocation$$Type)
get "lootTableId"(): $ResourceLocation
get "paramSet"(): $LootContextParamSet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootTable$$Type = ($LootTable);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootTable$$Original = $LootTable;}
declare module "net.minecraft.world.level.ClipContext" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$ClipContext$Block$$Type} from "net.minecraft.world.level.ClipContext$Block"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ClipContext$Fluid, $ClipContext$Fluid$$Type} from "net.minecraft.world.level.ClipContext$Fluid"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$ClipContextAccessor$$Interface} from "net.caffeinemc.mods.lithium.mixin.world.raycast.ClipContextAccessor"

export class $ClipContext implements $ClipContextAccessor$$Interface {
constructor(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $ClipContext$Block$$Type, arg3: $ClipContext$Fluid$$Type, arg4: $Entity$$Type)
constructor(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $ClipContext$Block$$Type, arg3: $ClipContext$Fluid$$Type, arg4: $CollisionContext$$Type)

public "getFrom"(): $Vec3
public "getTo"(): $Vec3
public "getFluidShape"(arg0: $FluidState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getBlockShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getFluidHandling"(): $ClipContext$Fluid
get "from"(): $Vec3
get "to"(): $Vec3
get "fluidHandling"(): $ClipContext$Fluid
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClipContext$$Type = ($ClipContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClipContext$$Original = $ClipContext;}
declare module "net.minecraft.world.level.block.entity.ConduitBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ConduitBlockEntity extends $BlockEntity {
 "worldPosition": $BlockPos
 "tickCount": integer
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "isActive"(): boolean
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public static "clientTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $ConduitBlockEntity$$Type): void
public "getActiveRotation"(arg0: float): float
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "isHunting"(): boolean
public "getUpdatePacket"(): $Packet
public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $ConduitBlockEntity$$Type): void
get "active"(): boolean
get "hunting"(): boolean
get "updatePacket"(): $Packet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConduitBlockEntity$$Type = ($ConduitBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConduitBlockEntity$$Original = $ConduitBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $ProbabilityFeatureConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($ProbabilityFeatureConfiguration)>
readonly "probability": float

constructor(arg0: float)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProbabilityFeatureConfiguration$$Type = ($ProbabilityFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ProbabilityFeatureConfiguration$$Original = $ProbabilityFeatureConfiguration;}
declare module "net.minecraft.world.level.block.entity.BarrelBlockEntity" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$ContainerOpenersCounter} from "net.minecraft.world.level.block.entity.ContainerOpenersCounter"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LithiumInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumInventory"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$RandomizableContainerBlockEntity} from "net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity"
import {$ReferenceArraySet} from "it.unimi.dsi.fastutil.objects.ReferenceArraySet"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Type, $InventoryChangeTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"

export class $BarrelBlockEntity extends $RandomizableContainerBlockEntity implements $LithiumInventory$$Interface, $InventoryChangeTracker$$Interface {
 "inventoryChangeListeners": $ReferenceArraySet
 "worldPosition": $BlockPos
readonly "openersCounter": $ContainerOpenersCounter
 "lootTable": $ResourceKey<($LootTable)>
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventoryHandlingTypeListeners": $ReferenceArraySet
 "lockKey": $LockCode
 "hasComparators": byte
 "lootTableSeed": long
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "updateBlockState"(arg0: $BlockState$$Type, arg1: boolean): void
public "getDefaultName"(): $Component
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "handler$bpi000$lithium$setInventoryStackListReplacement"(arg0: $NonNullList$$Type, arg1: $CallbackInfo$$Type): void
public "getContainerSize"(): integer
public "getItems"(): $NonNullList<($ItemStack)>
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "setItems"(arg0: $NonNullList$$Type<($ItemStack$$Type)>): void
public "stopOpen"(arg0: $Player$$Type): void
public "startOpen"(arg0: $Player$$Type): void
public "recheckOpen"(): void
public "playSound"(arg0: $BlockState$$Type, arg1: $SoundEvent$$Type): void
public "getInventoryLithium"(): $NonNullList
public "setInventoryLithium"(arg0: $NonNullList$$Type): void
public "createMenu"(arg0: integer, arg1: $Inventory$$Type): $AbstractContainerMenu
public "generateLootLithium"(): void
public "stopListenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "listenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "listenForContentChangesOnce"(arg0: $LithiumStackList$$Type, arg1: $InventoryChangeListener$$Type): void
public "stillValid"(arg0: $Player$$Type): boolean
public "setChanged"(): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitContentModified"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$emitRemoved"(): void
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public static "tryClear"(arg0: any): void
get "defaultName"(): $Component
get "containerSize"(): integer
get "items"(): $NonNullList<($ItemStack)>
set "items"(value: $NonNullList$$Type<($ItemStack$$Type)>)
get "inventoryLithium"(): $NonNullList
set "inventoryLithium"(value: $NonNullList$$Type)
get "changed"(): void
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BarrelBlockEntity$$Type = ($BarrelBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BarrelBlockEntity$$Original = $BarrelBlockEntity;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureEntityInfo" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $StructureTemplate$StructureEntityInfo {
readonly "nbt": $CompoundTag
readonly "blockPos": $BlockPos
readonly "pos": $Vec3

constructor(arg0: $Vec3$$Type, arg1: $BlockPos$$Type, arg2: $CompoundTag$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureTemplate$StructureEntityInfo$$Type = ($StructureTemplate$StructureEntityInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureTemplate$StructureEntityInfo$$Original = $StructureTemplate$StructureEntityInfo;}
declare module "net.minecraft.world.level.chunk.PalettedContainer$CountConsumer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $PalettedContainer$CountConsumer$$Interface<T> {

(arg0: T, arg1: integer): void
}

export class $PalettedContainer$CountConsumer<T> implements $PalettedContainer$CountConsumer$$Interface {
 "accept"(arg0: T, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PalettedContainer$CountConsumer$$Type<T> = ((arg0: T, arg1: integer) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PalettedContainer$CountConsumer$$Original<T> = $PalettedContainer$CountConsumer<(T)>;}
declare module "net.minecraft.world.level.block.state.properties.BambooLeaves" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $BambooLeaves extends $Enum<($BambooLeaves)> implements $StringRepresentable$$Interface {
static readonly "SMALL": $BambooLeaves
static readonly "LARGE": $BambooLeaves
static readonly "NONE": $BambooLeaves

public "toString"(): StringJS
public static "values"(): ($BambooLeaves)[]
public static "valueOf"(arg0: StringJS): $BambooLeaves
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BambooLeaves$$Type = (("none") | ("small") | ("large"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BambooLeaves$$Original = $BambooLeaves;}
declare module "net.minecraft.world.level.chunk.ChunkAccess" {
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor, $LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$NoiseChunk, $NoiseChunk$$Type} from "net.minecraft.world.level.levelgen.NoiseChunk"
import {$BelowZeroRetrogen} from "net.minecraft.world.level.levelgen.BelowZeroRetrogen"
import {$ChunkAccess$TicksToSave} from "net.minecraft.world.level.chunk.ChunkAccess$TicksToSave"
import {$Map$Entry} from "java.util.Map$Entry"
import {$Holder} from "net.minecraft.core.Holder"
import {$TickContainerAccess} from "net.minecraft.world.ticks.TickContainerAccess"
import {$BlendingData, $BlendingData$$Type} from "net.minecraft.world.level.levelgen.blending.BlendingData"
import {$AttachmentType$$Type as $AttachmentType$0$$Type} from "net.fabricmc.fabric.api.attachment.v1.AttachmentType"
import {$IAttachmentHolder$$Interface} from "net.neoforged.neoforge.attachment.IAttachmentHolder"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$BiomeGenerationSettings, $BiomeGenerationSettings$$Type} from "net.minecraft.world.level.biome.BiomeGenerationSettings"
import {$Set} from "java.util.Set"
import {$Heightmap} from "net.minecraft.world.level.levelgen.Heightmap"
import {$BiomeManager$NoiseBiomeSource$$Interface} from "net.minecraft.world.level.biome.BiomeManager$NoiseBiomeSource"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$Stream} from "java.util.stream.Stream"
import {$ChunkSkyLightSources} from "net.minecraft.world.level.lighting.ChunkSkyLightSources"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$AttachmentChange$$Type} from "net.fabricmc.fabric.impl.attachment.sync.AttachmentChange"
import {$ChunkStatus} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$StructureAccess$$Interface} from "net.minecraft.world.level.chunk.StructureAccess"
import {$LightChunk$$Interface} from "net.minecraft.world.level.chunk.LightChunk"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$StructureStart, $StructureStart$$Type} from "net.minecraft.world.level.levelgen.structure.StructureStart"
import {$VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$ChunkAccessAccessor$$Interface} from "com.copycatsplus.copycats.mixin.foundation.copycat.ChunkAccessAccessor"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$GameEventListenerRegistry} from "net.minecraft.world.level.gameevent.GameEventListenerRegistry"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$ShortList, $ShortList$$Type} from "it.unimi.dsi.fastutil.shorts.ShortList"
import {$AttachmentTargetInfo} from "net.fabricmc.fabric.impl.attachment.sync.AttachmentTargetInfo"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"
import {$IChunkTimeSave$$Interface} from "com.smoothchunk.world.IChunkTimeSave"
import {$AttachmentTargetImpl$$Interface} from "net.fabricmc.fabric.impl.attachment.AttachmentTargetImpl"
import {$BiPredicate$$Type} from "java.util.function.BiPredicate"
import {$UpgradeData, $UpgradeData$$Type} from "net.minecraft.world.level.chunk.UpgradeData"
import {$LongSet, $LongSet$$Type} from "it.unimi.dsi.fastutil.longs.LongSet"
import {$Level} from "net.minecraft.world.level.Level"
import {$Climate$Sampler$$Type} from "net.minecraft.world.level.biome.Climate$Sampler"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Structure, $Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$AttachmentHolder$AsField} from "net.neoforged.neoforge.attachment.AttachmentHolder$AsField"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$AttachmentSyncPayloadS2C$$Type} from "net.fabricmc.fabric.impl.attachment.sync.s2c.AttachmentSyncPayloadS2C"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$AttachmentType$$Type} from "net.neoforged.neoforge.attachment.AttachmentType"
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$LevelChunkSection, $LevelChunkSection$$Type} from "net.minecraft.world.level.chunk.LevelChunkSection"
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter$$Interface} from "net.minecraft.world.level.BlockGetter"
import {$Heightmap$Types, $Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$BiomeResolver$$Type} from "net.minecraft.world.level.biome.BiomeResolver"
import {$Registry$$Type} from "net.minecraft.core.Registry"

export class $ChunkAccess implements $BlockGetter$$Interface, $BiomeManager$NoiseBiomeSource$$Interface, $LightChunk$$Interface, $StructureAccess$$Interface, $IAttachmentHolder$$Interface, $IChunkTimeSave$$Interface, $AttachmentTargetImpl$$Interface, $ChunkAccessAccessor$$Interface {
readonly "upgradeData": $UpgradeData
readonly "chunkPos": $ChunkPos
readonly "pendingBlockEntities": $Map<($BlockPos), ($CompoundTag)>
 "noiseChunk": $NoiseChunk
readonly "sections": ($LevelChunkSection)[]
 "skyLightSources": $ChunkSkyLightSources
readonly "postProcessing": ($ShortList)[]
 "blendingData": $BlendingData
readonly "levelHeightAccessor": $LevelHeightAccessor
readonly "blockEntities": $Map<($BlockPos), ($BlockEntity)>
 "saveTimePoint": long
 "unsaved": boolean
readonly "heightmaps": $Map<($Heightmap$Types), ($Heightmap)>
static readonly "NO_FILLED_SECTION": integer

constructor(arg0: $ChunkPos$$Type, arg1: $UpgradeData$$Type, arg2: $LevelHeightAccessor$$Type, arg3: $Registry$$Type<($Biome$$Type)>, arg4: long, arg5: ($LevelChunkSection$$Type)[], arg6: $BlendingData$$Type)

public "isUnsaved"(): boolean
/**
 * 
 * @deprecated
 */
public "findBlocks"(arg0: $BiPredicate$$Type<($BlockState), ($BlockPos)>, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
public "findBlocks"(arg0: $Predicate$$Type<($BlockState)>, arg1: $BiPredicate$$Type<($BlockState), ($BlockPos)>, arg2: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
public "findBlocks"(arg0: $Predicate$$Type<($BlockState)>, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
public "getLevel"(): $Level
public "getData"<T>(arg0: $AttachmentType$$Type<(T)>): T
public "getBlockEntityNbtForSaving"(arg0: $BlockPos$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public "getOrCreateNoiseChunk"(arg0: $Function$$Type<($ChunkAccess), ($NoiseChunk$$Type)>): $NoiseChunk
public "writeAttachmentsToNBT"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "getBelowZeroRetrogen"(): $BelowZeroRetrogen
public "getTicksForSerialization"(): $ChunkAccess$TicksToSave
public "fillBiomesFromNoise"(arg0: $BiomeResolver$$Type, arg1: $Climate$Sampler$$Type): void
public "getReferencesForStructure"(arg0: $Structure$$Type): $LongSet
public "hasAnyStructureReferences"(): boolean
public "initializeLightSources"(): void
public "incrementInhabitedTime"(arg0: long): void
public "getAttachmentHolder"(): $AttachmentHolder$AsField
public "readAttachmentsFromNBT"(arg0: $HolderLookup$Provider$$Type, arg1: $CompoundTag$$Type): void
public "getListenerRegistry"(arg0: integer): $GameEventListenerRegistry
public "addReferenceForStructure"(arg0: $Structure$$Type, arg1: long): void
public static "getOrCreateOffsetList"(arg0: ($ShortList$$Type)[], arg1: integer): $ShortList
public "getHighestGeneratedStatus"(): $ChunkStatus
public "findBlockLightSources"(arg0: $BiConsumer$$Type<($BlockPos), ($BlockState)>): void
public "isOldNoiseGeneration"(): boolean
public "setStartForStructure"(arg0: $Structure$$Type, arg1: $StructureStart$$Type): void
public "getBlockEntitiesPos"(): $Set<($BlockPos)>
public "addPackedPostProcess"(arg0: short, arg1: integer): void
public "getStartForStructure"(arg0: $Structure$$Type): $StructureStart
public "markPosForPostprocessing"(arg0: $BlockPos$$Type): void
public "getPos"(): $ChunkPos
public "removeData"<T>(arg0: $AttachmentType$$Type<(T)>): T
public "acknowledgeSyncedEntry"(arg0: $AttachmentType$0$$Type, arg1: $AttachmentChange$$Type): void
public "fabric_getSyncTargetInfo"(): $AttachmentTargetInfo
public "fabric_shouldTryToSync"(): boolean
public "getExistingDataOrNull"<T>(arg0: $AttachmentType$$Type<(T)>): T
public "hasAttachments"(): boolean
public "getAllStarts"(): $Map<($Structure), ($StructureStart)>
public "setBlockState"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: boolean): $BlockState
public "setBlockEntity"(arg0: $BlockEntity$$Type): void
public "removeBlockEntity"(arg0: $BlockPos$$Type): void
public "getInhabitedTime"(): long
public "setUnsaved"(arg0: boolean): void
public "getSection"(arg0: integer): $LevelChunkSection
public "isLightCorrect"(): boolean
public "getHeightmaps"(): $Collection<($Map$Entry<($Heightmap$Types), ($Heightmap)>)>
public "getPostProcessing"(): ($ShortList)[]
public "setAllStarts"(arg0: $Map$$Type<($Structure$$Type), ($StructureStart$$Type)>): void
public "getAllReferences"(): $Map
public "getBlockEntityNbt"(arg0: $BlockPos$$Type): $CompoundTag
public "setLightCorrect"(arg0: boolean): void
public "isSectionEmpty"(arg0: integer): boolean
public "getSkyLightSources"(): $ChunkSkyLightSources
public "setHeightmap"(arg0: $Heightmap$Types$$Type, arg1: (long)[]): void
public "setBlockEntityNbt"(arg0: $CompoundTag$$Type): void
public "getBlendingData"(): $BlendingData
public "setBlendingData"(arg0: $BlendingData$$Type): void
/**
 * 
 * @deprecated
 */
public "carverBiome"(arg0: $Supplier$$Type<($BiomeGenerationSettings$$Type)>): $BiomeGenerationSettings
public "hasPrimedHeightmap"(arg0: $Heightmap$Types$$Type): boolean
public "getPersistedStatus"(): $ChunkStatus
public "getUpgradeData"(): $UpgradeData
public "setInhabitedTime"(arg0: long): void
public "setAllReferences"(arg0: $Map$$Type<($Structure$$Type), ($LongSet$$Type)>): void
public "getBlockEntities"(): $Map
public "isUpgrading"(): boolean
public "isYSpaceEmpty"(arg0: integer, arg1: integer): boolean
public "addEntity"(arg0: $Entity$$Type): void
public "getSections"(): ($LevelChunkSection)[]
public "setData"<T>(arg0: $AttachmentType$$Type<(T)>, arg1: T): T
public "getBlockTicks"(): $TickContainerAccess<($Block)>
public "getFluidTicks"(): $TickContainerAccess<($Fluid)>
public "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
public "hasData"(arg0: $AttachmentType$$Type<(never)>): boolean
public "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
public "getHeight"(): integer
public "fabric_computeInitialSyncChanges"(arg0: $ServerPlayer$$Type, arg1: $Consumer$$Type): void
public "fabric_getDynamicRegistryManager"(): $RegistryAccess
public "smoothchunk$setSaveTimePoint"(arg0: long): void
public "smoothchunk$getNextSaveTime"(): long
public "getOrCreateHeightmapUnprimed"(arg0: $Heightmap$Types$$Type): $Heightmap
public "getHeightAccessorForGeneration"(): $LevelHeightAccessor
public "getHighestFilledSectionIndex"(): integer
public "getMinBuildHeight"(): integer
/**
 * 
 * @deprecated
 */
public "getHighestSectionPosition"(): integer
public "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
public "getFluidState"(arg0: $BlockPos$$Type): $FluidState
public "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
public "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
public "getLightEmission"(arg0: $BlockPos$$Type): integer
public "clip"(arg0: $ClipContext$$Type): $BlockHitResult
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
public "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
public "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
public "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
public "getMaxLightLevel"(): integer
public static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
public "getData"<T>(arg0: $Supplier$$Type<($AttachmentType$$Type<(T)>)>): T
public "removeData"<T>(arg0: $Supplier$$Type<($AttachmentType$$Type<(T)>)>): T
public "getExistingDataOrNull"<T>(arg0: $Supplier$$Type<($AttachmentType$$Type<(T)>)>): T
public "getExistingData"<T>(arg0: $Supplier$$Type<($AttachmentType$$Type<(T)>)>): $Optional<(T)>
public "getExistingData"<T>(arg0: $AttachmentType$$Type<(T)>): $Optional<(T)>
public "setData"<T>(arg0: $Supplier$$Type<($AttachmentType$$Type<(T)>)>, arg1: T): T
public "syncData"(arg0: $AttachmentType$$Type<(never)>): void
public "syncData"(arg0: $Supplier$$Type<($AttachmentType$$Type<(never)>)>): void
public "hasData"<T>(arg0: $Supplier$$Type<($AttachmentType$$Type<(T)>)>): boolean
public "fabric_syncChange"(arg0: $AttachmentType$0$$Type<(never)>, arg1: $AttachmentSyncPayloadS2C$$Type): void
public "setAttached"<A>(arg0: $AttachmentType$0$$Type<(A)>, arg1: A): A
public static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
public "getSectionYFromSectionIndex"(arg0: integer): integer
public "getSectionIndexFromSectionY"(arg0: integer): integer
public "getMaxBuildHeight"(): integer
public "getSectionIndex"(arg0: integer): integer
public "getMaxSection"(): integer
public "getMinSection"(): integer
public "getSectionsCount"(): integer
public "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
public "isOutsideBuildHeight"(arg0: integer): boolean
public "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
public "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
public "getModelData"(arg0: $BlockPos$$Type): $ModelData
public "getBlockEntityRenderData"(arg0: $BlockPos$$Type): any
public "hasBiomes"(): boolean
public "getBiomeFabric"(arg0: $BlockPos$$Type): $Holder<($Biome)>
public "getAttachedOrCreate"<A>(arg0: $AttachmentType$0$$Type<(A)>, arg1: $Supplier$$Type<(A)>): A
public "getAttachedOrCreate"<A>(arg0: $AttachmentType$0$$Type<(A)>): A
public "hasAttached"(arg0: $AttachmentType$0$$Type<(never)>): boolean
public "getAttached"<A>(arg0: $AttachmentType$0$$Type<(A)>): A
public "removeAttached"<A>(arg0: $AttachmentType$0$$Type<(A)>): A
public "getAttachedOrElse"<A>(arg0: $AttachmentType$0$$Type<(A)>, arg1: A): A
public "getAttachedOrSet"<A>(arg0: $AttachmentType$0$$Type<(A)>, arg1: A): A
public "modifyAttached"<A>(arg0: $AttachmentType$0$$Type<(A)>, arg1: $UnaryOperator$$Type<(A)>): A
public "getAttachedOrThrow"<A>(arg0: $AttachmentType$0$$Type<(A)>): A
public "getAttachedOrGet"<A>(arg0: $AttachmentType$0$$Type<(A)>, arg1: $Supplier$$Type<(A)>): A
get "level"(): $Level
get "belowZeroRetrogen"(): $BelowZeroRetrogen
get "ticksForSerialization"(): $ChunkAccess$TicksToSave
get "attachmentHolder"(): $AttachmentHolder$AsField
get "highestGeneratedStatus"(): $ChunkStatus
get "oldNoiseGeneration"(): boolean
get "blockEntitiesPos"(): $Set<($BlockPos)>
get "pos"(): $ChunkPos
get "allStarts"(): $Map<($Structure), ($StructureStart)>
set "blockEntity"(value: $BlockEntity$$Type)
get "inhabitedTime"(): long
get "lightCorrect"(): boolean
set "allStarts"(value: $Map$$Type<($Structure$$Type), ($StructureStart$$Type)>)
get "allReferences"(): $Map
set "lightCorrect"(value: boolean)
set "blockEntityNbt"(value: $CompoundTag$$Type)
get "persistedStatus"(): $ChunkStatus
set "inhabitedTime"(value: long)
set "allReferences"(value: $Map$$Type<($Structure$$Type), ($LongSet$$Type)>)
get "upgrading"(): boolean
get "blockTicks"(): $TickContainerAccess<($Block)>
get "fluidTicks"(): $TickContainerAccess<($Fluid)>
get "height"(): integer
get "heightAccessorForGeneration"(): $LevelHeightAccessor
get "highestFilledSectionIndex"(): integer
get "minBuildHeight"(): integer
get "highestSectionPosition"(): integer
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "maxSection"(): integer
get "minSection"(): integer
get "sectionsCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkAccess$$Type = ($ChunkAccess);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkAccess$$Original = $ChunkAccess;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.TagMatchTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$RuleTestType} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTestType"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TagMatchTest extends $RuleTest {
static readonly "CODEC": $MapCodec<($TagMatchTest)>

constructor(arg0: $TagKey$$Type<($Block)>)

public "test"(arg0: $BlockState$$Type, arg1: $RandomSource$$Type): boolean
public "getType"(): $RuleTestType<(never)>
get "type"(): $RuleTestType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagMatchTest$$Type = ($TagMatchTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TagMatchTest$$Original = $TagMatchTest;}
declare module "net.minecraft.world.level.GameType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Abilities$$Type} from "net.minecraft.world.entity.player.Abilities"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Component} from "net.minecraft.network.chat.Component"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $GameType extends $Enum<($GameType)> implements $StringRepresentable$$Interface {
static readonly "SURVIVAL": $GameType
static readonly "SPECTATOR": $GameType
static readonly "CODEC": $StringRepresentable$EnumCodec<($GameType)>
static readonly "CREATIVE": $GameType
static readonly "ADVENTURE": $GameType
static readonly "DEFAULT_MODE": $GameType

public "getName"(): StringJS
public static "values"(): ($GameType)[]
public static "valueOf"(arg0: StringJS): $GameType
public "getId"(): integer
public "isCreative"(): boolean
public "isBlockPlacingRestricted"(): boolean
public "getShortDisplayName"(): $Component
public "updatePlayerAbilities"(arg0: $Abilities$$Type): void
public "getSerializedName"(): StringJS
public static "byName"(arg0: StringJS, arg1: $GameType$$Type): $GameType
public static "byName"(arg0: StringJS): $GameType
public "isSurvival"(): boolean
public static "byId"(arg0: integer): $GameType
public "getLongDisplayName"(): $Component
public static "byNullableId"(arg0: integer): $GameType
public static "getNullableId"(arg0: $GameType$$Type): integer
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "name"(): StringJS
get "id"(): integer
get "creative"(): boolean
get "blockPlacingRestricted"(): boolean
get "shortDisplayName"(): $Component
get "serializedName"(): StringJS
get "survival"(): boolean
get "longDisplayName"(): $Component
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameType$$Type = (("survival") | ("creative") | ("adventure") | ("spectator"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameType$$Original = $GameType;}
declare module "net.minecraft.world.level.gameevent.DynamicGameEventListener" {
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$GameEventListener, $GameEventListener$$Type} from "net.minecraft.world.level.gameevent.GameEventListener"

export class $DynamicGameEventListener<T extends $GameEventListener> {
constructor(arg0: T)

public "remove"(arg0: $ServerLevel$$Type): void
public "add"(arg0: $ServerLevel$$Type): void
public "move"(arg0: $ServerLevel$$Type): void
public "getListener"(): T
get "listener"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicGameEventListener$$Type<T> = ($DynamicGameEventListener<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DynamicGameEventListener$$Original<T> = $DynamicGameEventListener<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.rootplacers.RootPlacerType" {
import {$RootPlacer} from "net.minecraft.world.level.levelgen.feature.rootplacers.RootPlacer"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$MangroveRootPlacer} from "net.minecraft.world.level.levelgen.feature.rootplacers.MangroveRootPlacer"

export class $RootPlacerType<P extends $RootPlacer> {
static readonly "MANGROVE_ROOT_PLACER": $RootPlacerType<($MangroveRootPlacer)>

constructor(arg0: $MapCodec$$Type<(P)>)

public "codec"(): $MapCodec<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenRootPlacerType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenRootPlacerTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RootPlacerType$$Type<P> = (Special.WorldgenRootPlacerType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RootPlacerType$$Original<P> = $RootPlacerType<(P)>;}
declare module "net.minecraft.world.level.storage.loot.predicates.ConditionUserBuilder" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$Function$$Type} from "java.util.function.Function"

export interface $ConditionUserBuilder$$Interface<T extends $ConditionUserBuilder<(object)>> {
}

export class $ConditionUserBuilder<T extends $ConditionUserBuilder<(object)>> implements $ConditionUserBuilder$$Interface {
 "unwrap"(): T
 "when"<E>(arg0: $Iterable$$Type<(E)>, arg1: $Function$$Type<(E), ($LootItemCondition$Builder$$Type)>): T
 "when"(arg0: $LootItemCondition$Builder$$Type): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConditionUserBuilder$$Type<T> = ($ConditionUserBuilder<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConditionUserBuilder$$Original<T> = $ConditionUserBuilder<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration" {
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$CaveSurface, $CaveSurface$$Type} from "net.minecraft.world.level.levelgen.placement.CaveSurface"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $VegetationPatchConfiguration implements $FeatureConfiguration$$Interface {
readonly "vegetationFeature": $Holder<($PlacedFeature)>
readonly "extraEdgeColumnChance": float
static readonly "CODEC": $Codec<($VegetationPatchConfiguration)>
readonly "depth": $IntProvider
readonly "surface": $CaveSurface
readonly "vegetationChance": float
readonly "extraBottomBlockChance": float
readonly "replaceable": $TagKey<($Block)>
readonly "xzRadius": $IntProvider
readonly "groundState": $BlockStateProvider
readonly "verticalRange": integer

constructor(arg0: $TagKey$$Type<($Block)>, arg1: $BlockStateProvider$$Type, arg2: $Holder$$Type<($PlacedFeature)>, arg3: $CaveSurface$$Type, arg4: $IntProvider$$Type, arg5: float, arg6: integer, arg7: float, arg8: $IntProvider$$Type, arg9: float)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VegetationPatchConfiguration$$Type = ($VegetationPatchConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VegetationPatchConfiguration$$Original = $VegetationPatchConfiguration;}
declare module "net.minecraft.world.level.portal.DimensionTransition" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$DimensionTransition$PostDimensionTransition, $DimensionTransition$PostDimensionTransition$$Type} from "net.minecraft.world.level.portal.DimensionTransition$PostDimensionTransition"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$Record} from "java.lang.Record"

export class $DimensionTransition extends $Record {
static readonly "PLACE_PORTAL_TICKET": $DimensionTransition$PostDimensionTransition
static readonly "PLAY_PORTAL_SOUND": $DimensionTransition$PostDimensionTransition
static readonly "DO_NOTHING": $DimensionTransition$PostDimensionTransition

constructor(arg0: $ServerLevel$$Type, arg1: $Vec3$$Type, arg2: $Vec3$$Type, arg3: float, arg4: float, arg5: boolean, arg6: $DimensionTransition$PostDimensionTransition$$Type)
constructor(arg0: $ServerLevel$$Type, arg1: $Entity$$Type, arg2: $DimensionTransition$PostDimensionTransition$$Type)
constructor(arg0: $ServerLevel$$Type, arg1: $Vec3$$Type, arg2: $Vec3$$Type, arg3: float, arg4: float, arg5: $DimensionTransition$PostDimensionTransition$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "pos"(): $Vec3
public "newLevel"(): $ServerLevel
public "postDimensionTransition"(): $DimensionTransition$PostDimensionTransition
public "xRot"(): float
public "yRot"(): float
public static "missingRespawnBlock"(arg0: $ServerLevel$$Type, arg1: $Entity$$Type, arg2: $DimensionTransition$PostDimensionTransition$$Type): $DimensionTransition
public "missingRespawnBlock"(): boolean
public "speed"(): $Vec3
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionTransition$$Type = ({"xRot"?: float, "yRot"?: float, "speed"?: $Vec3$$Type, "pos"?: $Vec3$$Type, "postDimensionTransition"?: $DimensionTransition$PostDimensionTransition$$Type, "newLevel"?: $ServerLevel$$Type, "missingRespawnBlock"?: boolean}) | ([xRot?: float, yRot?: float, speed?: $Vec3$$Type, pos?: $Vec3$$Type, postDimensionTransition?: $DimensionTransition$PostDimensionTransition$$Type, newLevel?: $ServerLevel$$Type, missingRespawnBlock?: boolean]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DimensionTransition$$Original = $DimensionTransition;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$MultifaceBlock, $MultifaceBlock$$Type} from "net.minecraft.world.level.block.MultifaceBlock"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $MultifaceGrowthConfiguration implements $FeatureConfiguration$$Interface {
readonly "canPlaceOnWall": boolean
readonly "chanceOfSpreading": float
static readonly "CODEC": $Codec<($MultifaceGrowthConfiguration)>
readonly "canPlaceOnCeiling": boolean
readonly "searchRange": integer
readonly "canPlaceOnFloor": boolean
readonly "canBePlacedOn": $HolderSet<($Block)>
readonly "placeBlock": $MultifaceBlock

constructor(arg0: $MultifaceBlock$$Type, arg1: integer, arg2: boolean, arg3: boolean, arg4: boolean, arg5: float, arg6: $HolderSet$$Type<($Block)>)

public "getShuffledDirectionsExcept"(arg0: $RandomSource$$Type, arg1: $Direction$$Type): $List<($Direction)>
public "getShuffledDirections"(arg0: $RandomSource$$Type): $List<($Direction)>
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultifaceGrowthConfiguration$$Type = ($MultifaceGrowthConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultifaceGrowthConfiguration$$Original = $MultifaceGrowthConfiguration;}
declare module "net.minecraft.world.level.storage.loot.LootDataType" {
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$LootItemFunction} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$LootDataType$Validator, $LootDataType$Validator$$Type} from "net.minecraft.world.level.storage.loot.LootDataType$Validator"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$BiConsumer, $BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Stream} from "java.util.stream.Stream"
import {$LootItemCondition} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"
import {$Record} from "java.lang.Record"

export class $LootDataType<T> extends $Record {
static readonly "TABLE": $LootDataType<($LootTable)>
static readonly "MODIFIER": $LootDataType<($LootItemFunction)>
static readonly "PREDICATE": $LootDataType<($LootItemCondition)>

constructor(registryKey: $ResourceKey$$Type<($Registry<(T)>)>, codec: $Codec$$Type<(T)>, validator: $LootDataType$Validator$$Type<(T)>, defaultValue: T, conditionalCodec: $Codec$$Type<((T)?)>, idSetter: $BiConsumer$$Type<(T), ($ResourceLocation)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public static "values"(): $Stream<($LootDataType<(never)>)>
public "hashCode"(): integer
public "defaultValue"(): T
public "deserialize"<V>(arg0: $ResourceLocation$$Type, arg1: $DynamicOps$$Type<(V)>, arg2: V): $Optional<(T)>
public "validator"(): $LootDataType$Validator<(T)>
public "codec"(): $Codec<(T)>
public "registryKey"(): $ResourceKey<($Registry<(T)>)>
public "conditionalCodec"(): $Codec<($Optional<(T)>)>
public "handler$elj000$probejs$apply"(resourceLocation: $ResourceLocation$$Type, ops: $DynamicOps$$Type, value: any, cir: $CallbackInfoReturnable$$Type): void
public "idSetter"(): $BiConsumer<(T), ($ResourceLocation)>
public "runValidation"(arg0: $ValidationContext$$Type, arg1: $ResourceKey$$Type<(T)>, arg2: T): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootDataType$$Type<T> = ({"defaultValue"?: T, "conditionalCodec"?: $Codec$$Type<((T)?)>, "idSetter"?: $BiConsumer$$Type<(T), ($ResourceLocation$$Type)>, "validator"?: $LootDataType$Validator$$Type<(T)>, "registryKey"?: $ResourceKey$$Type<($Registry<(T)>)>, "codec"?: $Codec$$Type<(T)>}) | ([defaultValue?: T, conditionalCodec?: $Codec$$Type<((T)?)>, idSetter?: $BiConsumer$$Type<(T), ($ResourceLocation$$Type)>, validator?: $LootDataType$Validator$$Type<(T)>, registryKey?: $ResourceKey$$Type<($Registry<(T)>)>, codec?: $Codec$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootDataType$$Original<T> = $LootDataType<(T)>;}
declare module "net.minecraft.world.level.pathfinder.Path$DebugData" {
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$Set, $Set$$Type} from "java.util.Set"
import {$Node, $Node$$Type} from "net.minecraft.world.level.pathfinder.Node"
import {$Target, $Target$$Type} from "net.minecraft.world.level.pathfinder.Target"
import {$Record} from "java.lang.Record"

export class $Path$DebugData extends $Record {
constructor(arg0: ($Node$$Type)[], arg1: ($Node$$Type)[], arg2: $Set$$Type<($Target$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "write"(arg0: $FriendlyByteBuf$$Type): void
public static "read"(arg0: $FriendlyByteBuf$$Type): $Path$DebugData
public "targetNodes"(): $Set<($Target)>
public "closedSet"(): ($Node)[]
public "openSet"(): ($Node)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Path$DebugData$$Type = ({"closedSet"?: ($Node$$Type)[], "targetNodes"?: $Set$$Type<($Target$$Type)>, "openSet"?: ($Node$$Type)[]}) | ([closedSet?: ($Node$$Type)[], targetNodes?: $Set$$Type<($Target$$Type)>, openSet?: ($Node$$Type)[]]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Path$DebugData$$Original = $Path$DebugData;}
declare module "net.minecraft.world.level.levelgen.blending.Blender" {
import {$Blender$DistanceGetter} from "net.minecraft.world.level.levelgen.blending.Blender$DistanceGetter"
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$ProtoChunk$$Type} from "net.minecraft.world.level.chunk.ProtoChunk"
import {$Map$$Type} from "java.util.Map"
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$Long2ObjectOpenHashMap$$Type} from "it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$Blender$BlendingOutput} from "net.minecraft.world.level.levelgen.blending.Blender$BlendingOutput"
import {$BlendingData$$Type} from "net.minecraft.world.level.levelgen.blending.BlendingData"
import {$BiomeResolver, $BiomeResolver$$Type} from "net.minecraft.world.level.biome.BiomeResolver"
import {$WorldGenRegion$$Type} from "net.minecraft.server.level.WorldGenRegion"
import {$Direction8$$Type} from "net.minecraft.core.Direction8"

export class $Blender {
constructor(arg0: $Long2ObjectOpenHashMap$$Type<($BlendingData$$Type)>, arg1: $Long2ObjectOpenHashMap$$Type<($BlendingData$$Type)>)

public static "of"(arg0: $WorldGenRegion$$Type): $Blender
public static "empty"(): $Blender
public "blendDensity"(arg0: $DensityFunction$FunctionContext$$Type, arg1: double): double
public "getBiomeResolver"(arg0: $BiomeResolver$$Type): $BiomeResolver
public "blendOffsetAndFactor"(arg0: integer, arg1: integer): $Blender$BlendingOutput
public static "makeOldChunkDistanceGetter"(arg0: $BlendingData$$Type, arg1: $Map$$Type<($Direction8$$Type), ($BlendingData$$Type)>): $Blender$DistanceGetter
public static "generateBorderTicks"(arg0: $WorldGenRegion$$Type, arg1: $ChunkAccess$$Type): void
public static "addAroundOldChunksCarvingMaskFilter"(arg0: $WorldGenLevel$$Type, arg1: $ProtoChunk$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Blender$$Type = ($Blender);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Blender$$Original = $Blender;}
declare module "net.minecraft.world.level.material.FogType" {
import {$Enum} from "java.lang.Enum"

export class $FogType extends $Enum<($FogType)> {
static readonly "LAVA": $FogType
static readonly "POWDER_SNOW": $FogType
static readonly "NONE": $FogType
static readonly "WATER": $FogType

public static "values"(): ($FogType)[]
public static "valueOf"(arg0: StringJS): $FogType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FogType$$Type = (("lava") | ("water") | ("powder_snow") | ("none"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FogType$$Original = $FogType;}
declare module "net.minecraft.world.level.block.entity.trialspawner.PlayerDetector$EntitySelector" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$List, $List$$Type} from "java.util.List"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"

export interface $PlayerDetector$EntitySelector$$Interface {
}

export class $PlayerDetector$EntitySelector implements $PlayerDetector$EntitySelector$$Interface {
static readonly "SELECT_FROM_LEVEL": $PlayerDetector$EntitySelector

 "getPlayers"(arg0: $ServerLevel$$Type, arg1: $Predicate$$Type<($Player)>): $List<($Player)>
 "getEntities"<T extends $Entity>(arg0: $ServerLevel$$Type, arg1: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg2: $AABB$$Type, arg3: $Predicate$$Type<(T)>): $List<(T)>
static "onlySelectPlayers"(arg0: $List$$Type<($Player$$Type)>): $PlayerDetector$EntitySelector
static "onlySelectPlayer"(arg0: $Player$$Type): $PlayerDetector$EntitySelector
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerDetector$EntitySelector$$Type = ($PlayerDetector$EntitySelector);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerDetector$EntitySelector$$Original = $PlayerDetector$EntitySelector;}
declare module "net.minecraft.world.level.levelgen.structure.StructureCheck" {
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Map$$Type} from "java.util.Map"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$StructurePlacement$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$DataFixer$$Type} from "com.mojang.datafixers.DataFixer"
import {$StructureCheckResult} from "net.minecraft.world.level.levelgen.structure.StructureCheckResult"
import {$BiomeSource$$Type} from "net.minecraft.world.level.biome.BiomeSource"
import {$Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$StructureStart$$Type} from "net.minecraft.world.level.levelgen.structure.StructureStart"
import {$ChunkScanAccess$$Type} from "net.minecraft.world.level.chunk.storage.ChunkScanAccess"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $StructureCheck {
constructor(arg0: $ChunkScanAccess$$Type, arg1: $RegistryAccess$$Type, arg2: $StructureTemplateManager$$Type, arg3: $ResourceKey$$Type<($Level)>, arg4: $ChunkGenerator$$Type, arg5: $RandomState$$Type, arg6: $LevelHeightAccessor$$Type, arg7: $BiomeSource$$Type, arg8: long, arg9: $DataFixer$$Type)

public "incrementReference"(arg0: $ChunkPos$$Type, arg1: $Structure$$Type): void
public "onStructureLoad"(arg0: $ChunkPos$$Type, arg1: $Map$$Type<($Structure$$Type), ($StructureStart$$Type)>): void
public "checkStart"(arg0: $ChunkPos$$Type, arg1: $Structure$$Type, arg2: $StructurePlacement$$Type, arg3: boolean): $StructureCheckResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureCheck$$Type = ($StructureCheck);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureCheck$$Original = $StructureCheck;}
declare module "net.minecraft.world.level.levelgen.DensityFunctions$BeardifierOrMarker" {
import {$DensityFunction$SimpleFunction$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction$SimpleFunction"
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$DensityFunction} from "net.minecraft.world.level.levelgen.DensityFunction"

export interface $DensityFunctions$BeardifierOrMarker$$Interface extends $DensityFunction$SimpleFunction$$Interface {
}

export class $DensityFunctions$BeardifierOrMarker implements $DensityFunctions$BeardifierOrMarker$$Interface {
static readonly "CODEC": $KeyDispatchDataCodec<($DensityFunction)>

 "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
 "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
 "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
 "abs"(): $DensityFunction
 "clamp"(arg0: double, arg1: double): $DensityFunction
 "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
 "maxValue"(): double
 "square"(): $DensityFunction
 "halfNegative"(): $DensityFunction
 "quarterNegative"(): $DensityFunction
 "minValue"(): double
 "cube"(): $DensityFunction
 "squeeze"(): $DensityFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunctions$BeardifierOrMarker$$Type = ($DensityFunctions$BeardifierOrMarker);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunctions$BeardifierOrMarker$$Original = $DensityFunctions$BeardifierOrMarker;}
declare module "net.minecraft.world.level.biome.AmbientAdditionsSettings" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $AmbientAdditionsSettings {
static readonly "CODEC": $Codec<($AmbientAdditionsSettings)>

constructor(arg0: $Holder$$Type<($SoundEvent)>, arg1: double)

public "getSoundEvent"(): $Holder<($SoundEvent)>
public "getTickChance"(): double
get "soundEvent"(): $Holder<($SoundEvent)>
get "tickChance"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AmbientAdditionsSettings$$Type = ($AmbientAdditionsSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AmbientAdditionsSettings$$Original = $AmbientAdditionsSettings;}
declare module "net.minecraft.world.level.storage.WritableLevelData" {
import {$GameRules} from "net.minecraft.world.level.GameRules"
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Difficulty} from "net.minecraft.world.Difficulty"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CrashReportCategory$$Type} from "net.minecraft.CrashReportCategory"
import {$LevelData$$Interface} from "net.minecraft.world.level.storage.LevelData"

export interface $WritableLevelData$$Interface extends $LevelData$$Interface {
set "raining"(value: boolean)
get "difficultyLocked"(): boolean
get "raining"(): boolean
get "hardcore"(): boolean
get "gameTime"(): long
get "spawnPos"(): $BlockPos
get "spawnAngle"(): float
get "thundering"(): boolean
get "dayTime"(): long
get "difficulty"(): $Difficulty
get "gameRules"(): $GameRules
}

export class $WritableLevelData implements $WritableLevelData$$Interface {
 "setSpawn"(arg0: $BlockPos$$Type, arg1: float): void
 "setRaining"(arg0: boolean): void
 "isDifficultyLocked"(): boolean
 "isRaining"(): boolean
 "isHardcore"(): boolean
 "fillCrashReportCategory"(arg0: $CrashReportCategory$$Type, arg1: $LevelHeightAccessor$$Type): void
 "getGameTime"(): long
 "getSpawnPos"(): $BlockPos
 "getSpawnAngle"(): float
 "isThundering"(): boolean
 "getDayTime"(): long
 "getDifficulty"(): $Difficulty
 "getGameRules"(): $GameRules
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WritableLevelData$$Type = ($WritableLevelData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WritableLevelData$$Original = $WritableLevelData;}
declare module "net.minecraft.world.level.storage.LevelSummary" {
import {$LevelSettings, $LevelSettings$$Type} from "net.minecraft.world.level.LevelSettings"
import {$Comparable$$Interface} from "java.lang.Comparable"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$LevelVersion, $LevelVersion$$Type} from "net.minecraft.world.level.storage.LevelVersion"
import {$GameType} from "net.minecraft.world.level.GameType"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$LevelSummary$BackupStatus} from "net.minecraft.world.level.storage.LevelSummary$BackupStatus"

export class $LevelSummary implements $Comparable$$Interface<($LevelSummary)> {
static readonly "PLAY_WORLD": $Component

constructor(arg0: $LevelSettings$$Type, arg1: $LevelVersion$$Type, arg2: StringJS, arg3: boolean, arg4: boolean, arg5: boolean, arg6: $Path$$Type)

public "compareTo"(arg0: any): integer
public "compareTo"(arg0: $LevelSummary$$Type): integer
public "isLocked"(): boolean
public "getLevelName"(): StringJS
public "getInfo"(): $Component
public "canEdit"(): boolean
public "canUpload"(): boolean
public "getLevelId"(): StringJS
public "isHardcore"(): boolean
public "getIcon"(): $Path
public "getSettings"(): $LevelSettings
public "isExperimental"(): boolean
public "isDisabled"(): boolean
public "canDelete"(): boolean
public "canRecreate"(): boolean
public "isCompatible"(): boolean
public "getGameMode"(): $GameType
public "getLastPlayed"(): long
public "hasCommands"(): boolean
public "shouldBackup"(): boolean
public "isDowngrade"(): boolean
public "backupStatus"(): $LevelSummary$BackupStatus
public "levelVersion"(): $LevelVersion
public "requiresManualConversion"(): boolean
public "primaryActionActive"(): boolean
public "primaryActionMessage"(): $Component
public "getWorldVersionName"(): $MutableComponent
get "locked"(): boolean
get "levelName"(): StringJS
get "info"(): $Component
get "levelId"(): StringJS
get "hardcore"(): boolean
get "icon"(): $Path
get "settings"(): $LevelSettings
get "experimental"(): boolean
get "disabled"(): boolean
get "compatible"(): boolean
get "gameMode"(): $GameType
get "lastPlayed"(): long
get "downgrade"(): boolean
get "worldVersionName"(): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelSummary$$Type = ($LevelSummary);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelSummary$$Original = $LevelSummary;}
declare module "net.minecraft.world.level.GameRules$Value" {
import {$CommandContext$$Type} from "com.mojang.brigadier.context.CommandContext"
import {$GameRules$Type, $GameRules$Type$$Type} from "net.minecraft.world.level.GameRules$Type"
import {$CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"
import {$MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export class $GameRules$Value<T extends $GameRules$Value<(object)>> {
readonly "type": $GameRules$Type<(T)>

constructor(arg0: $GameRules$Type$$Type<(T)>)

public "toString"(): StringJS
public "copy"(): T
public "setFrom"(arg0: T, arg1: $MinecraftServer$$Type): void
public "serialize"(): StringJS
public "deserialize"(arg0: StringJS): void
public "getSelf"(): T
public "updateFromArgument"(arg0: $CommandContext$$Type<($CommandSourceStack$$Type)>, arg1: StringJS): void
public "getCommandResult"(): integer
public "onChanged"(arg0: $MinecraftServer$$Type): void
public "setFromArgument"(arg0: $CommandContext$$Type<($CommandSourceStack$$Type)>, arg1: StringJS): void
get "self"(): T
get "commandResult"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$Value$$Type<T> = ($GameRules$Value<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$Value$$Original<T> = $GameRules$Value<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStateConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($BlockStateConfiguration)>
readonly "state": $BlockState

constructor(arg0: $BlockState$$Type)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateConfiguration$$Type = ($BlockStateConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateConfiguration$$Original = $BlockStateConfiguration;}
declare module "net.minecraft.world.level.levelgen.structure.StructureCheckResult" {
import {$Enum} from "java.lang.Enum"

export class $StructureCheckResult extends $Enum<($StructureCheckResult)> {
static readonly "CHUNK_LOAD_NEEDED": $StructureCheckResult
static readonly "START_NOT_PRESENT": $StructureCheckResult
static readonly "START_PRESENT": $StructureCheckResult

public static "values"(): ($StructureCheckResult)[]
public static "valueOf"(arg0: StringJS): $StructureCheckResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureCheckResult$$Type = (("start_present") | ("start_not_present") | ("chunk_load_needed"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureCheckResult$$Original = $StructureCheckResult;}
declare module "net.minecraft.world.level.block.state.BlockBehaviour$OffsetType" {
import {$Enum} from "java.lang.Enum"

export class $BlockBehaviour$OffsetType extends $Enum<($BlockBehaviour$OffsetType)> {
static readonly "XZ": $BlockBehaviour$OffsetType
static readonly "XYZ": $BlockBehaviour$OffsetType
static readonly "NONE": $BlockBehaviour$OffsetType

public static "values"(): ($BlockBehaviour$OffsetType)[]
public static "valueOf"(arg0: StringJS): $BlockBehaviour$OffsetType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviour$OffsetType$$Type = (("none") | ("xz") | ("xyz"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviour$OffsetType$$Original = $BlockBehaviour$OffsetType;}
declare module "net.minecraft.world.level.block.state.properties.Half" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $Half extends $Enum<($Half)> implements $StringRepresentable$$Interface {
static readonly "TOP": $Half
static readonly "BOTTOM": $Half

public "toString"(): StringJS
public static "values"(): ($Half)[]
public static "valueOf"(arg0: StringJS): $Half
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Half$$Type = (("top") | ("bottom"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Half$$Original = $Half;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration" {
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$RootPlacer, $RootPlacer$$Type} from "net.minecraft.world.level.levelgen.feature.rootplacers.RootPlacer"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$FeatureSize, $FeatureSize$$Type} from "net.minecraft.world.level.levelgen.feature.featuresize.FeatureSize"
import {$TreeDecorator, $TreeDecorator$$Type} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$FoliagePlacer, $FoliagePlacer$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$TrunkPlacer, $TrunkPlacer$$Type} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$Stream} from "java.util.stream.Stream"

export class $TreeConfiguration implements $FeatureConfiguration$$Interface {
readonly "foliagePlacer": $FoliagePlacer
readonly "trunkProvider": $BlockStateProvider
static readonly "CODEC": $Codec<($TreeConfiguration)>
readonly "trunkPlacer": $TrunkPlacer
readonly "rootPlacer": $Optional<($RootPlacer)>
readonly "decorators": $List<($TreeDecorator)>
readonly "foliageProvider": $BlockStateProvider
readonly "ignoreVines": boolean
readonly "minimumSize": $FeatureSize
readonly "forceDirt": boolean
readonly "dirtProvider": $BlockStateProvider

constructor(arg0: $BlockStateProvider$$Type, arg1: $TrunkPlacer$$Type, arg2: $BlockStateProvider$$Type, arg3: $FoliagePlacer$$Type, arg4: ($RootPlacer$$Type)?, arg5: $BlockStateProvider$$Type, arg6: $FeatureSize$$Type, arg7: $List$$Type<($TreeDecorator$$Type)>, arg8: boolean, arg9: boolean)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TreeConfiguration$$Type = ($TreeConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TreeConfiguration$$Original = $TreeConfiguration;}
declare module "net.minecraft.world.level.biome.Biome" {
import {$Biome$ClimateSettings, $Biome$ClimateSettings$$Type} from "net.minecraft.world.level.biome.Biome$ClimateSettings"
import {$Optional} from "java.util.Optional"
import {$ExtendedBiome$$Interface} from "net.irisshaders.iris.mixinterface.ExtendedBiome"
import {$BiomeAccessor$$Interface} from "com.blackgear.vanillabackport.core.mixin.access.BiomeAccessor"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$Holder} from "net.minecraft.core.Holder"
import {$PerlinSimplexNoise} from "net.minecraft.world.level.levelgen.synth.PerlinSimplexNoise"
import {$AmbientMoodSettings} from "net.minecraft.world.level.biome.AmbientMoodSettings"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$MobSpawnSettings, $MobSpawnSettings$$Type} from "net.minecraft.world.level.biome.MobSpawnSettings"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ModifiableBiomeInfo} from "net.neoforged.neoforge.common.world.ModifiableBiomeInfo"
import {$BiomeGenerationSettings, $BiomeGenerationSettings$$Type} from "net.minecraft.world.level.biome.BiomeGenerationSettings"
import {$HolderSet} from "net.minecraft.core.HolderSet"
import {$AmbientParticleSettings} from "net.minecraft.world.level.biome.AmbientParticleSettings"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AmbientAdditionsSettings} from "net.minecraft.world.level.biome.AmbientAdditionsSettings"
import {$Music} from "net.minecraft.sounds.Music"
import {$Biome$Precipitation} from "net.minecraft.world.level.biome.Biome$Precipitation"
import {$BiomeSpecialEffects, $BiomeSpecialEffects$$Type} from "net.minecraft.world.level.biome.BiomeSpecialEffects"

export class $Biome implements $ExtendedBiome$$Interface, $BiomeAccessor$$Interface {
static readonly "CODEC": $Codec<($Holder<($Biome)>)>
static readonly "NETWORK_CODEC": $Codec<($Biome)>
/**
 * 
 * @deprecated
 */
static readonly "BIOME_INFO_NOISE": $PerlinSimplexNoise
readonly "mobSettings": $MobSpawnSettings
static readonly "FROZEN_TEMPERATURE_NOISE": $PerlinSimplexNoise
static readonly "DIRECT_CODEC": $Codec<($Biome)>
static readonly "LIST_CODEC": $Codec<($HolderSet<($Biome)>)>
readonly "generationSettings": $BiomeGenerationSettings

constructor(arg0: $Biome$ClimateSettings$$Type, arg1: $BiomeSpecialEffects$$Type, arg2: $BiomeGenerationSettings$$Type, arg3: $MobSpawnSettings$$Type)

public "shouldSnow"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): boolean
public "getBackgroundMusic"(): $Optional<($Music)>
public "shouldFreeze"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: boolean): boolean
public "shouldFreeze"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): boolean
public "getGenerationSettings"(): $BiomeGenerationSettings
public "getPrecipitationAt"(arg0: $BlockPos$$Type): $Biome$Precipitation
public "getSpecialEffects"(): $BiomeSpecialEffects
public "getDownfall"(): float
public "coldEnoughToSnow"(arg0: $BlockPos$$Type): boolean
public "hasPrecipitation"(): boolean
public "getBaseTemperature"(): float
public "getFogColor"(): integer
public "getAmbientLoop"(): $Optional<($Holder<($SoundEvent)>)>
public "getFoliageColor"(): integer
public "getMobSettings"(): $MobSpawnSettings
public "getWaterColor"(): integer
public "getWaterFogColor"(): integer
public "getBiomeCategory"(): integer
public "warmEnoughToRain"(arg0: $BlockPos$$Type): boolean
public "getAmbientMood"(): $Optional<($AmbientMoodSettings)>
public "getClimateSettings"(): $Biome$ClimateSettings
public "setBiomeCategory"(arg0: integer): void
public "getGrassColor"(arg0: double, arg1: double): integer
public "getModifiedSpecialEffects"(): $BiomeSpecialEffects
public "getModifiedClimateSettings"(): $Biome$ClimateSettings
public "getAmbientParticle"(): $Optional<($AmbientParticleSettings)>
public "getSkyColor"(): integer
public "getTemperature"(pos: $BlockPos$$Type): float
public "shouldMeltFrozenOceanIcebergSlightly"(arg0: $BlockPos$$Type): boolean
public "getHeightAdjustedTemperature"(arg0: $BlockPos$$Type): float
public "modifiableBiomeInfo"(): $ModifiableBiomeInfo
public "getAmbientAdditions"(): $Optional<($AmbientAdditionsSettings)>
get "backgroundMusic"(): $Optional<($Music)>
get "specialEffects"(): $BiomeSpecialEffects
get "downfall"(): float
get "baseTemperature"(): float
get "fogColor"(): integer
get "ambientLoop"(): $Optional<($Holder<($SoundEvent)>)>
get "foliageColor"(): integer
get "waterColor"(): integer
get "waterFogColor"(): integer
get "biomeCategory"(): integer
get "ambientMood"(): $Optional<($AmbientMoodSettings)>
get "climateSettings"(): $Biome$ClimateSettings
set "biomeCategory"(value: integer)
get "modifiedSpecialEffects"(): $BiomeSpecialEffects
get "modifiedClimateSettings"(): $Biome$ClimateSettings
get "ambientParticle"(): $Optional<($AmbientParticleSettings)>
get "skyColor"(): integer
get "ambientAdditions"(): $Optional<($AmbientAdditionsSettings)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenBiome
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenBiomeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Biome$$Type = (Special.WorldgenBiome);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Biome$$Original = $Biome;}
declare module "net.minecraft.world.level.chunk.status.ChunkStep" {
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$ChunkDependencies, $ChunkDependencies$$Type} from "net.minecraft.world.level.chunk.status.ChunkDependencies"
import {$ChunkAccess, $ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$WorldGenContext$$Type} from "net.minecraft.world.level.chunk.status.WorldGenContext"
import {$StaticCache2D$$Type} from "net.minecraft.util.StaticCache2D"
import {$ChunkStatus, $ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$GenerationChunkHolder$$Type} from "net.minecraft.server.level.GenerationChunkHolder"
import {$ChunkStatusTask, $ChunkStatusTask$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatusTask"
import {$Record} from "java.lang.Record"

export class $ChunkStep extends $Record {
constructor(arg0: $ChunkStatus$$Type, arg1: $ChunkDependencies$$Type, arg2: $ChunkDependencies$$Type, arg3: integer, arg4: $ChunkStatusTask$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "apply"(arg0: $WorldGenContext$$Type, arg1: $StaticCache2D$$Type<($GenerationChunkHolder$$Type)>, arg2: $ChunkAccess$$Type): $CompletableFuture<($ChunkAccess)>
public "task"(): $ChunkStatusTask
public "targetStatus"(): $ChunkStatus
public "directDependencies"(): $ChunkDependencies
public "accumulatedDependencies"(): $ChunkDependencies
public "blockStateWriteRadius"(): integer
public "getAccumulatedRadiusOf"(arg0: $ChunkStatus$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkStep$$Type = ({"blockStateWriteRadius"?: integer, "accumulatedDependencies"?: $ChunkDependencies$$Type, "directDependencies"?: $ChunkDependencies$$Type, "targetStatus"?: $ChunkStatus$$Type, "task"?: $ChunkStatusTask$$Type}) | ([blockStateWriteRadius?: integer, accumulatedDependencies?: $ChunkDependencies$$Type, directDependencies?: $ChunkDependencies$$Type, targetStatus?: $ChunkStatus$$Type, task?: $ChunkStatusTask$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkStep$$Original = $ChunkStep;}
declare module "net.minecraft.world.level.block.entity.BellBlockEntity" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BellBlockEntity extends $BlockEntity {
 "worldPosition": $BlockPos
 "ticks": integer
 "level": $Level
 "clickDirection": $Direction
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "shaking": boolean
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "clientTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BellBlockEntity$$Type): void
public "onHit"(arg0: $Direction$$Type): void
public "triggerEvent"(arg0: integer, arg1: integer): boolean
public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BellBlockEntity$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BellBlockEntity$$Type = ($BellBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BellBlockEntity$$Original = $BellBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$FloatProvider, $FloatProvider$$Type} from "net.minecraft.util.valueproviders.FloatProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $LargeDripstoneConfiguration implements $FeatureConfiguration$$Interface {
readonly "minRadiusForWind": integer
static readonly "CODEC": $Codec<($LargeDripstoneConfiguration)>
readonly "maxColumnRadiusToCaveHeightRatio": float
readonly "heightScale": $FloatProvider
readonly "stalactiteBluntness": $FloatProvider
readonly "columnRadius": $IntProvider
readonly "floorToCeilingSearchRange": integer
readonly "stalagmiteBluntness": $FloatProvider
readonly "windSpeed": $FloatProvider
readonly "minBluntnessForWind": float

constructor(arg0: integer, arg1: $IntProvider$$Type, arg2: $FloatProvider$$Type, arg3: float, arg4: $FloatProvider$$Type, arg5: $FloatProvider$$Type, arg6: $FloatProvider$$Type, arg7: integer, arg8: float)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LargeDripstoneConfiguration$$Type = ($LargeDripstoneConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LargeDripstoneConfiguration$$Original = $LargeDripstoneConfiguration;}
declare module "net.minecraft.world.level.levelgen.GenerationStep$Carving" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $GenerationStep$Carving extends $Enum<($GenerationStep$Carving)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($GenerationStep$Carving)>
static readonly "LIQUID": $GenerationStep$Carving
static readonly "AIR": $GenerationStep$Carving

public "getName"(): StringJS
public static "values"(): ($GenerationStep$Carving)[]
public static "valueOf"(arg0: StringJS): $GenerationStep$Carving
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "name"(): StringJS
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenerationStep$Carving$$Type = (("air") | ("liquid"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GenerationStep$Carving$$Original = $GenerationStep$Carving;}
declare module "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate" {
import {$WorldGenLevel, $WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BiPredicate, $BiPredicate$$Type, $BiPredicate$$Interface} from "java.util.function.BiPredicate"
import {$List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Codec} from "com.mojang.serialization.Codec"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$BlockPredicateType} from "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicateType"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockPredicate$$Interface extends $BiPredicate$$Interface<($WorldGenLevel), ($BlockPos)> {
}

export class $BlockPredicate implements $BlockPredicate$$Interface {
static readonly "ONLY_IN_AIR_OR_WATER_PREDICATE": $BlockPredicate
static readonly "CODEC": $Codec<($BlockPredicate)>
static readonly "ONLY_IN_AIR_PREDICATE": $BlockPredicate

 "type"(): $BlockPredicateType<(never)>
static "not"(arg0: $BlockPredicate$$Type): $BlockPredicate
static "allOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
static "allOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
static "allOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
static "unobstructed"(arg0: $Vec3i$$Type): $BlockPredicate
static "unobstructed"(): $BlockPredicate
static "hasSturdyFace"(arg0: $Vec3i$$Type, arg1: $Direction$$Type): $BlockPredicate
static "hasSturdyFace"(arg0: $Direction$$Type): $BlockPredicate
static "insideWorld"(arg0: $Vec3i$$Type): $BlockPredicate
static "wouldSurvive"(arg0: $BlockState$$Type, arg1: $Vec3i$$Type): $BlockPredicate
static "matchesFluids"(arg0: $Vec3i$$Type, ...arg1: ($Fluid$$Type)[]): $BlockPredicate
static "matchesFluids"(...arg0: ($Fluid$$Type)[]): $BlockPredicate
static "matchesFluids"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Fluid$$Type)>): $BlockPredicate
static "anyOf"(...arg0: ($BlockPredicate$$Type)[]): $BlockPredicate
static "anyOf"(arg0: $List$$Type<($BlockPredicate$$Type)>): $BlockPredicate
static "anyOf"(arg0: $BlockPredicate$$Type, arg1: $BlockPredicate$$Type): $BlockPredicate
static "replaceable"(): $BlockPredicate
static "replaceable"(arg0: $Vec3i$$Type): $BlockPredicate
static "matchesBlocks"(arg0: $Vec3i$$Type, arg1: $List$$Type<($Block$$Type)>): $BlockPredicate
static "matchesBlocks"(arg0: $Vec3i$$Type, ...arg1: ($Block$$Type)[]): $BlockPredicate
static "matchesBlocks"(...arg0: ($Block$$Type)[]): $BlockPredicate
static "matchesBlocks"(arg0: $List$$Type<($Block$$Type)>): $BlockPredicate
static "solid"(): $BlockPredicate
static "solid"(arg0: $Vec3i$$Type): $BlockPredicate
static "matchesTag"(arg0: $TagKey$$Type<($Block)>): $BlockPredicate
static "matchesTag"(arg0: $Vec3i$$Type, arg1: $TagKey$$Type<($Block)>): $BlockPredicate
static "alwaysTrue"(): $BlockPredicate
static "noFluid"(arg0: $Vec3i$$Type): $BlockPredicate
static "noFluid"(): $BlockPredicate
 "test"(arg0: $WorldGenLevel$$Type, arg1: $BlockPos$$Type): boolean
 "or"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
 "negate"(): $BiPredicate<($WorldGenLevel), ($BlockPos)>
 "and"(arg0: $BiPredicate$$Type<($WorldGenLevel), ($BlockPos)>): $BiPredicate<($WorldGenLevel), ($BlockPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPredicate$$Type = ($BlockPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPredicate$$Original = $BlockPredicate;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $CountConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($CountConfiguration)>

constructor(arg0: integer)
constructor(arg0: $IntProvider$$Type)

public "count"(): $IntProvider
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CountConfiguration$$Type = ($CountConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CountConfiguration$$Original = $CountConfiguration;}
declare module "net.minecraft.world.level.biome.Biome$ClimateSettings" {
import {$Biome$TemperatureModifier, $Biome$TemperatureModifier$$Type} from "net.minecraft.world.level.biome.Biome$TemperatureModifier"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $Biome$ClimateSettings extends $Record {
static readonly "CODEC": $MapCodec<($Biome$ClimateSettings)>

constructor(hasPrecipitation: boolean, temperature: float, temperatureModifier: $Biome$TemperatureModifier$$Type, downfall: float)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "temperature"(): float
public "downfall"(): float
public "hasPrecipitation"(): boolean
public "temperatureModifier"(): $Biome$TemperatureModifier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Biome$ClimateSettings$$Type = ({"temperatureModifier"?: $Biome$TemperatureModifier$$Type, "hasPrecipitation"?: boolean, "downfall"?: float, "temperature"?: float}) | ([temperatureModifier?: $Biome$TemperatureModifier$$Type, hasPrecipitation?: boolean, downfall?: float, temperature?: float]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Biome$ClimateSettings$$Original = $Biome$ClimateSettings;}
declare module "net.minecraft.world.level.storage.loot.predicates.CompositeLootItemCondition$Builder" {
import {$AnyOfCondition$Builder} from "net.minecraft.world.level.storage.loot.predicates.AnyOfCondition$Builder"
import {$LootItemCondition$Builder, $LootItemCondition$Builder$$Type, $LootItemCondition$Builder$$Interface} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$List$$Type} from "java.util.List"
import {$AllOfCondition$Builder} from "net.minecraft.world.level.storage.loot.predicates.AllOfCondition$Builder"
import {$LootItemCondition, $LootItemCondition$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"

export class $CompositeLootItemCondition$Builder implements $LootItemCondition$Builder$$Interface {
constructor(...arg0: ($LootItemCondition$Builder$$Type)[])

public "create"(arg0: $List$$Type<($LootItemCondition$$Type)>): $LootItemCondition
public "build"(): $LootItemCondition
public "addTerm"(arg0: $LootItemCondition$Builder$$Type): void
public "or"(arg0: $LootItemCondition$Builder$$Type): $AnyOfCondition$Builder
public "and"(arg0: $LootItemCondition$Builder$$Type): $AllOfCondition$Builder
public "invert"(): $LootItemCondition$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompositeLootItemCondition$Builder$$Type = ($CompositeLootItemCondition$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CompositeLootItemCondition$Builder$$Original = $CompositeLootItemCondition$Builder;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.PineFoliagePlacer" {
import {$FoliagePlacerType} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacerType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$FoliagePlacer$FoliageSetter$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageSetter"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$FoliagePlacer$FoliageAttachment$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $PineFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($PineFoliagePlacer)>
readonly "offset": $IntProvider
readonly "radius": $IntProvider

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: $IntProvider$$Type)

public "type"(): $FoliagePlacerType<(never)>
public "createFoliage"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: integer, arg5: $FoliagePlacer$FoliageAttachment$$Type, arg6: integer, arg7: integer, arg8: integer): void
public "shouldSkipLocation"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: boolean): boolean
public "foliageRadius"(arg0: $RandomSource$$Type, arg1: integer): integer
public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PineFoliagePlacer$$Type = ($PineFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PineFoliagePlacer$$Original = $PineFoliagePlacer;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.UpwardsBranchingTrunkPlacer" {
import {$List} from "java.util.List"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$TrunkPlacerType} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacerType"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $UpwardsBranchingTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($UpwardsBranchingTrunkPlacer)>
static readonly "MAX_HEIGHT": integer
readonly "baseHeight": integer
readonly "heightRandA": integer
readonly "heightRandB": integer

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $IntProvider$$Type, arg4: float, arg5: $IntProvider$$Type, arg6: $HolderSet$$Type<($Block)>)

public "type"(): $TrunkPlacerType<(never)>
public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
public "validTreePos"(arg0: $LevelSimulatedReader$$Type, arg1: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpwardsBranchingTrunkPlacer$$Type = ($UpwardsBranchingTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UpwardsBranchingTrunkPlacer$$Original = $UpwardsBranchingTrunkPlacer;}
declare module "net.minecraft.world.level.block.state.properties.BellAttachType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $BellAttachType extends $Enum<($BellAttachType)> implements $StringRepresentable$$Interface {
static readonly "FLOOR": $BellAttachType
static readonly "DOUBLE_WALL": $BellAttachType
static readonly "CEILING": $BellAttachType
static readonly "SINGLE_WALL": $BellAttachType

public static "values"(): ($BellAttachType)[]
public static "valueOf"(arg0: StringJS): $BellAttachType
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BellAttachType$$Type = (("floor") | ("ceiling") | ("single_wall") | ("double_wall"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BellAttachType$$Original = $BellAttachType;}
declare module "net.minecraft.world.level.levelgen.placement.CaveSurface" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Direction} from "net.minecraft.core.Direction"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $CaveSurface extends $Enum<($CaveSurface)> implements $StringRepresentable$$Interface {
static readonly "FLOOR": $CaveSurface
static readonly "CODEC": $Codec<($CaveSurface)>
static readonly "CEILING": $CaveSurface

public static "values"(): ($CaveSurface)[]
public static "valueOf"(arg0: StringJS): $CaveSurface
public "getSerializedName"(): StringJS
public "getY"(): integer
public "getDirection"(): $Direction
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "y"(): integer
get "direction"(): $Direction
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CaveSurface$$Type = (("ceiling") | ("floor"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CaveSurface$$Original = $CaveSurface;}
declare module "net.minecraft.world.level.levelgen.structure.StructureSet" {
import {$StructureSet$StructureSelectionEntry, $StructureSet$StructureSelectionEntry$$Type} from "net.minecraft.world.level.levelgen.structure.StructureSet$StructureSelectionEntry"
import {$Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Codec} from "com.mojang.serialization.Codec"
import {$List, $List$$Type} from "java.util.List"
import {$StructurePlacement, $StructurePlacement$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $StructureSet extends $Record {
static readonly "CODEC": $Codec<($Holder<($StructureSet)>)>
static readonly "DIRECT_CODEC": $Codec<($StructureSet)>

constructor(arg0: $Holder$$Type<($Structure)>, arg1: $StructurePlacement$$Type)
constructor(arg0: $List$$Type<($StructureSet$StructureSelectionEntry$$Type)>, arg1: $StructurePlacement$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "entry"(arg0: $Holder$$Type<($Structure)>): $StructureSet$StructureSelectionEntry
public static "entry"(arg0: $Holder$$Type<($Structure)>, arg1: integer): $StructureSet$StructureSelectionEntry
public "placement"(): $StructurePlacement
public "structures"(): $List<($StructureSet$StructureSelectionEntry)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenStructureSet
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenStructureSetTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureSet$$Type = (Special.WorldgenStructureSet) | ({"placement"?: $StructurePlacement$$Type, "structures"?: $List$$Type<($StructureSet$StructureSelectionEntry$$Type)>}) | ([placement?: $StructurePlacement$$Type, structures?: $List$$Type<($StructureSet$StructureSelectionEntry$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureSet$$Original = $StructureSet;}
declare module "net.minecraft.world.level.biome.BiomeResolver" {
import {$Climate$Sampler, $Climate$Sampler$$Type} from "net.minecraft.world.level.biome.Climate$Sampler"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export interface $BiomeResolver$$Interface {

(arg0: integer, arg1: integer, arg2: integer, arg3: $Climate$Sampler): $Holder$$Type<($Biome$$Type)>
}

export class $BiomeResolver implements $BiomeResolver$$Interface {
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer, arg3: $Climate$Sampler$$Type): $Holder<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeResolver$$Type = ((arg0: integer, arg1: integer, arg2: integer, arg3: $Climate$Sampler) => $Holder$$Type<($Biome$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeResolver$$Original = $BiomeResolver;}
declare module "net.minecraft.world.level.chunk.ChunkAccess$TicksToSave" {
import {$SerializableTickContainer, $SerializableTickContainer$$Type} from "net.minecraft.world.ticks.SerializableTickContainer"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Record} from "java.lang.Record"

export class $ChunkAccess$TicksToSave extends $Record {
constructor(blocks: $SerializableTickContainer$$Type<($Block$$Type)>, fluids: $SerializableTickContainer$$Type<($Fluid$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "fluids"(): $SerializableTickContainer<($Fluid)>
public "blocks"(): $SerializableTickContainer<($Block)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkAccess$TicksToSave$$Type = ({"fluids"?: $SerializableTickContainer$$Type<($Fluid$$Type)>, "blocks"?: $SerializableTickContainer$$Type<($Block$$Type)>}) | ([fluids?: $SerializableTickContainer$$Type<($Fluid$$Type)>, blocks?: $SerializableTickContainer$$Type<($Block$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkAccess$TicksToSave$$Original = $ChunkAccess$TicksToSave;}
declare module "net.minecraft.world.level.levelgen.blending.BlendingData$DensityConsumer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $BlendingData$DensityConsumer$$Interface {
}

export class $BlendingData$DensityConsumer implements $BlendingData$DensityConsumer$$Interface {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlendingData$DensityConsumer$$Type = ($BlendingData$DensityConsumer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlendingData$DensityConsumer$$Original = $BlendingData$DensityConsumer;}
declare module "net.minecraft.world.level.chunk.UpgradeData" {
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$LevelChunk$$Type} from "net.minecraft.world.level.chunk.LevelChunk"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$UpgradeData$BlockFixer} from "net.minecraft.world.level.chunk.UpgradeData$BlockFixer"
import {$Set} from "java.util.Set"

export class $UpgradeData {
static readonly "CHUNKY_FIXERS": $Set<($UpgradeData$BlockFixer)>
static readonly "EMPTY": $UpgradeData
static readonly "MAP": $Map<($Block), ($UpgradeData$BlockFixer)>

constructor(arg0: $CompoundTag$$Type, arg1: $LevelHeightAccessor$$Type)

public "isEmpty"(): boolean
public "write"(): $CompoundTag
public "upgrade"(arg0: $LevelChunk$$Type): void
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeData$$Type = ($UpgradeData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UpgradeData$$Original = $UpgradeData;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.CocoaDecorator" {
import {$TreeDecorator} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator"
import {$TreeDecorator$Context$$Type} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context"
import {$TreeDecoratorType} from "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecoratorType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $CocoaDecorator extends $TreeDecorator {
static readonly "CODEC": $MapCodec<($CocoaDecorator)>

constructor(arg0: float)

public "type"(): $TreeDecoratorType<(never)>
public "place"(arg0: $TreeDecorator$Context$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CocoaDecorator$$Type = ($CocoaDecorator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CocoaDecorator$$Original = $CocoaDecorator;}
declare module "net.minecraft.world.level.GameRules$BooleanValue" {
import {$CommandContext$$Type} from "com.mojang.brigadier.context.CommandContext"
import {$GameRules$Type, $GameRules$Type$$Type} from "net.minecraft.world.level.GameRules$Type"
import {$GameRules$Value, $GameRules$Value$$Type} from "net.minecraft.world.level.GameRules$Value"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"
import {$MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export class $GameRules$BooleanValue extends $GameRules$Value<($GameRules$BooleanValue)> {
readonly "type": $GameRules$Type<(T)>

constructor(arg0: $GameRules$Type$$Type<($GameRules$BooleanValue$$Type)>, arg1: boolean)

public "get"(): boolean
public "set"(arg0: boolean, arg1: $MinecraftServer$$Type): void
public "copy"(): $GameRules$Value
public static "create"(arg0: boolean, arg1: $BiConsumer$$Type<($MinecraftServer), ($GameRules$BooleanValue)>): $GameRules$Type<($GameRules$BooleanValue)>
public static "create"(arg0: boolean): $GameRules$Type<($GameRules$BooleanValue)>
public "setFrom"(arg0: $GameRules$BooleanValue$$Type, arg1: $MinecraftServer$$Type): void
public "setFrom"(arg0: $GameRules$Value$$Type, arg1: $MinecraftServer$$Type): void
public "serialize"(): StringJS
public "deserialize"(arg0: StringJS): void
public "getSelf"(): $GameRules$Value
public "updateFromArgument"(arg0: $CommandContext$$Type<($CommandSourceStack$$Type)>, arg1: StringJS): void
public "getCommandResult"(): integer
get "self"(): $GameRules$Value
get "commandResult"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$BooleanValue$$Type = ($GameRules$BooleanValue);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$BooleanValue$$Original = $GameRules$BooleanValue;}
declare module "net.minecraft.world.level.chunk.LevelChunk$PostLoadProcessor" {
import {$LevelChunk, $LevelChunk$$Type} from "net.minecraft.world.level.chunk.LevelChunk"

export interface $LevelChunk$PostLoadProcessor$$Interface {

(arg0: $LevelChunk): void
}

export class $LevelChunk$PostLoadProcessor implements $LevelChunk$PostLoadProcessor$$Interface {
 "run"(arg0: $LevelChunk$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelChunk$PostLoadProcessor$$Type = ((arg0: $LevelChunk) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelChunk$PostLoadProcessor$$Original = $LevelChunk$PostLoadProcessor;}
declare module "net.minecraft.world.level.levelgen.structure.structures.NetherFossilStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$HeightProvider, $HeightProvider$$Type} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $NetherFossilStructure extends $Structure {
static readonly "CODEC": $MapCodec<($NetherFossilStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>
readonly "height": $HeightProvider

constructor(arg0: $Structure$StructureSettings$$Type, arg1: $HeightProvider$$Type)

public "type"(): $StructureType<(never)>
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetherFossilStructure$$Type = ($NetherFossilStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NetherFossilStructure$$Original = $NetherFossilStructure;}
declare module "net.minecraft.world.level.ExplosionDamageCalculator" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$Optional} from "java.util.Optional"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ExplosionDamageCalculator {
constructor()

public "shouldDamageEntity"(arg0: $Explosion$$Type, arg1: $Entity$$Type): boolean
public "shouldBlockExplode"(arg0: $Explosion$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: float): boolean
public "getBlockExplosionResistance"(arg0: $Explosion$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $FluidState$$Type): $Optional<(float)>
public "getKnockbackMultiplier"(arg0: $Entity$$Type): float
public "getEntityDamageAmount"(arg0: $Explosion$$Type, arg1: $Entity$$Type): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionDamageCalculator$$Type = ($ExplosionDamageCalculator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExplosionDamageCalculator$$Original = $ExplosionDamageCalculator;}
declare module "net.minecraft.world.level.levelgen.structure.placement.ConcentricRingsStructurePlacement" {
import {$ChunkGeneratorStructureState$$Type} from "net.minecraft.world.level.chunk.ChunkGeneratorStructureState"
import {$Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$Optional$$Type} from "java.util.Optional"
import {$StructurePlacement$ExclusionZone$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement$ExclusionZone"
import {$StructurePlacementType} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacementType"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$StructurePlacement} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructurePlacement$FrequencyReductionMethod$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement$FrequencyReductionMethod"

export class $ConcentricRingsStructurePlacement extends $StructurePlacement {
static readonly "CODEC": $MapCodec<($ConcentricRingsStructurePlacement)>

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $HolderSet$$Type<($Biome)>)
constructor(arg0: $Vec3i$$Type, arg1: $StructurePlacement$FrequencyReductionMethod$$Type, arg2: float, arg3: integer, arg4: ($StructurePlacement$ExclusionZone$$Type)?, arg5: integer, arg6: integer, arg7: integer, arg8: $HolderSet$$Type<($Biome)>)

public "type"(): $StructurePlacementType<(never)>
public "count"(): integer
public "spread"(): integer
public "distance"(): integer
public "isPlacementChunk"(arg0: $ChunkGeneratorStructureState$$Type, arg1: integer, arg2: integer): boolean
public "preferredBiomes"(): $HolderSet<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConcentricRingsStructurePlacement$$Type = ($ConcentricRingsStructurePlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConcentricRingsStructurePlacement$$Original = $ConcentricRingsStructurePlacement;}
declare module "net.minecraft.world.level.LevelReader" {
import {$Iterable} from "java.lang.Iterable"
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ILevelReaderExtension$$Interface} from "net.neoforged.neoforge.common.extensions.ILevelReaderExtension"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$Holder} from "net.minecraft.core.Holder"
import {$WorldViewMixin$$Interface} from "net.fabricmc.fabric.mixin.rendering.data.WorldViewMixin"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$BiomeManager$NoiseBiomeSource$$Interface} from "net.minecraft.world.level.biome.BiomeManager$NoiseBiomeSource"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$Stream} from "java.util.stream.Stream"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$ChunkView$$Interface} from "net.caffeinemc.mods.lithium.common.world.ChunkView"
import {$BiomeManager} from "net.minecraft.world.level.biome.BiomeManager"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$CollisionGetter$$Interface} from "net.minecraft.world.level.CollisionGetter"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockAndTintGetter$$Interface} from "net.minecraft.world.level.BlockAndTintGetter"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$HolderLookup} from "net.minecraft.core.HolderLookup"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$RenderAttachedBlockView$$Interface} from "net.fabricmc.fabric.api.rendering.data.v1.RenderAttachedBlockView"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$SignalGetter$$Interface} from "net.minecraft.world.level.SignalGetter"
import {$DimensionType} from "net.minecraft.world.level.dimension.DimensionType"

export interface $LevelReader$$Interface extends $BlockAndTintGetter$$Interface, $CollisionGetter$$Interface, $SignalGetter$$Interface, $BiomeManager$NoiseBiomeSource$$Interface, $ILevelReaderExtension$$Interface, $WorldViewMixin$$Interface, $RenderAttachedBlockView$$Interface, $ChunkView$$Interface {
get "seaLevel"(): integer
get "clientSide"(): boolean
get "skyDarken"(): integer
get "biomeManager"(): $BiomeManager
get "height"(): integer
get "minBuildHeight"(): integer
get "lightEngine"(): $LevelLightEngine
get "worldBorder"(): $WorldBorder
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "maxSection"(): integer
get "minSection"(): integer
get "sectionsCount"(): integer
}

export class $LevelReader implements $LevelReader$$Interface {
 "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
 "getBlockStatesIfLoaded"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "registryAccess"(): $RegistryAccess
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
 "dimensionType"(): $DimensionType
/**
 * 
 * @deprecated
 */
 "getSeaLevel"(): integer
 "isClientSide"(): boolean
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "getSkyDarken"(): integer
 "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
 "getUncachedNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "canSeeSkyFromBelowWater"(arg0: $BlockPos$$Type): boolean
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type): integer
 "isWaterAt"(arg0: $BlockPos$$Type): boolean
 "hasBiomes"(): boolean
 "enabledFeatures"(): $FeatureFlagSet
 "getPathfindingCostFromLightLevels"(arg0: $BlockPos$$Type): float
 "getBiomeManager"(): $BiomeManager
 "isEmptyBlock"(arg0: $BlockPos$$Type): boolean
 "holderLookup"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>): $HolderLookup<(T)>
 "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "getBiomeFabric"(arg0: $BlockPos$$Type): $Holder
 "getChunk"(arg0: $BlockPos$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
 "getHeight"(): integer
 "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
/**
 * 
 * @deprecated
 */
 "getLightLevelDependentMagicValue"(arg0: $BlockPos$$Type): float
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: $BlockPos$$Type): boolean
 "getMinBuildHeight"(): integer
 "containsAnyLiquid"(arg0: $AABB$$Type): boolean
/**
 * 
 * @deprecated
 */
 "hasChunk"(arg0: integer, arg1: integer): boolean
 "getLightEngine"(): $LevelLightEngine
 "canSeeSky"(arg0: $BlockPos$$Type): boolean
 "getShade"(arg0: $Direction$$Type, arg1: boolean): float
 "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
 "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
 "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
 "getWorldBorder"(): $WorldBorder
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
 "isUnobstructed"(arg0: $Entity$$Type): boolean
 "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "noCollision"(arg0: $Entity$$Type): boolean
 "noCollision"(arg0: $AABB$$Type): boolean
 "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
 "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
 "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
 "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
 "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
 "holder"<T>(arg0: $ResourceKey$$Type<(T)>): $Optional<($Holder$Reference<(T)>)>
 "isAreaLoaded"(arg0: $BlockPos$$Type, arg1: integer): boolean
 "holderOrThrow"<T>(arg0: $ResourceKey$$Type<(T)>): $Holder<(T)>
/**
 * 
 * @deprecated
 */
 "getBlockEntityRenderAttachment"(arg0: $BlockPos$$Type): any
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
 "getMaxLightLevel"(): integer
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getMaxBuildHeight"(): integer
 "getSectionIndex"(arg0: integer): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionsCount"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
 "getBlockEntityRenderData"(arg0: $BlockPos$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelReader$$Type = ($LevelReader);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelReader$$Original = $LevelReader;}
declare module "net.minecraft.world.level.levelgen.Aquifer$FluidStatus" {
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $Aquifer$FluidStatus {
readonly "fluidLevel": integer
readonly "fluidType": $BlockState

constructor(arg0: integer, arg1: $BlockState$$Type)

public "at"(arg0: integer): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Aquifer$FluidStatus$$Type = ($Aquifer$FluidStatus);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Aquifer$FluidStatus$$Original = $Aquifer$FluidStatus;}
declare module "net.minecraft.world.level.block.state.BlockBehaviour$StateArgumentPredicate" {
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockBehaviour$StateArgumentPredicate$$Interface<A> {

(arg0: $BlockState, arg1: $BlockGetter, arg2: $BlockPos, arg3: A): boolean
}

export class $BlockBehaviour$StateArgumentPredicate<A> implements $BlockBehaviour$StateArgumentPredicate$$Interface {
 "test"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: A): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviour$StateArgumentPredicate$$Type<A> = ((arg0: $BlockState, arg1: $BlockGetter, arg2: $BlockPos, arg3: A) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviour$StateArgumentPredicate$$Original<A> = $BlockBehaviour$StateArgumentPredicate<(A)>;}
declare module "net.minecraft.world.level.levelgen.DensityFunction$Visitor" {
import {$DensityFunction$NoiseHolder, $DensityFunction$NoiseHolder$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$NoiseHolder"
import {$DensityFunction, $DensityFunction$$Type} from "net.minecraft.world.level.levelgen.DensityFunction"

export interface $DensityFunction$Visitor$$Interface {

(arg0: $DensityFunction): $DensityFunction$$Type
}

export class $DensityFunction$Visitor implements $DensityFunction$Visitor$$Interface {
 "apply"(arg0: $DensityFunction$$Type): $DensityFunction
 "visitNoise"(arg0: $DensityFunction$NoiseHolder$$Type): $DensityFunction$NoiseHolder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunction$Visitor$$Type = ((arg0: $DensityFunction) => $DensityFunction$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunction$Visitor$$Original = $DensityFunction$Visitor;}
declare module "net.minecraft.world.level.block.entity.TrialSpawnerBlockEntity" {
import {$TrialSpawnerState, $TrialSpawnerState$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerState"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List$$Type} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$TrialSpawner$StateAccessor$$Interface} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawner$StateAccessor"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$TrialSpawner} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawner"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Spawner$$Interface} from "net.minecraft.world.level.Spawner"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $TrialSpawnerBlockEntity extends $BlockEntity implements $Spawner$$Interface, $TrialSpawner$StateAccessor$$Interface {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getState"(): $TrialSpawnerState
public "setState"(arg0: $Level$$Type, arg1: $TrialSpawnerState$$Type): void
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "markUpdated"(): void
public "onlyOpCanSetNbt"(): boolean
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getTrialSpawner"(): $TrialSpawner
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "setEntityId"(arg0: $EntityType$$Type<(never)>, arg1: $RandomSource$$Type): void
public static "appendHoverText"(arg0: $ItemStack$$Type, arg1: $List$$Type<($Component$$Type)>, arg2: StringJS): void
public static "getSpawnEntityDisplayName"(arg0: $ItemStack$$Type, arg1: StringJS): $Component
get "state"(): $TrialSpawnerState
get "trialSpawner"(): $TrialSpawner
get "updatePacket"(): $ClientboundBlockEntityDataPacket
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrialSpawnerBlockEntity$$Type = ($TrialSpawnerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrialSpawnerBlockEntity$$Original = $TrialSpawnerBlockEntity;}
declare module "net.minecraft.world.level.levelgen.synth.PerlinSimplexNoise" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$List$$Type} from "java.util.List"

export class $PerlinSimplexNoise {
constructor(arg0: $RandomSource$$Type, arg1: $List$$Type<(integer)>)

public "getValue"(arg0: double, arg1: double, arg2: boolean): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PerlinSimplexNoise$$Type = ($PerlinSimplexNoise);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PerlinSimplexNoise$$Original = $PerlinSimplexNoise;}
declare module "net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer" {
import {$BoundingBox} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$StructurePiece, $StructurePiece$$Type} from "net.minecraft.world.level.levelgen.structure.StructurePiece"
import {$List, $List$$Type} from "java.util.List"
import {$StructurePieceSerializationContext$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ListTag$$Type} from "net.minecraft.nbt.ListTag"
import {$Record} from "java.lang.Record"

export class $PiecesContainer extends $Record {
constructor(arg0: $List$$Type<($StructurePiece$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "load"(arg0: $ListTag$$Type, arg1: $StructurePieceSerializationContext$$Type): $PiecesContainer
public "isEmpty"(): boolean
public "save"(arg0: $StructurePieceSerializationContext$$Type): $Tag
public "pieces"(): $List<($StructurePiece)>
public "calculateBoundingBox"(): $BoundingBox
public "isInsidePiece"(arg0: $BlockPos$$Type): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PiecesContainer$$Type = ({"pieces"?: $List$$Type<($StructurePiece$$Type)>}) | ([pieces?: $List$$Type<($StructurePiece$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PiecesContainer$$Original = $PiecesContainer;}
declare module "net.minecraft.world.level.block.state.properties.Property" {
import {$Collection} from "java.util.Collection"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Optional} from "java.util.Optional"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$DataResult} from "com.mojang.serialization.DataResult"
import {$Property$Value} from "net.minecraft.world.level.block.state.properties.Property$Value"
import {$StateHolder, $StateHolder$$Type} from "net.minecraft.world.level.block.state.StateHolder"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Stream} from "java.util.stream.Stream"

export class $Property<T extends $Comparable<(object)>> {
constructor(arg0: StringJS, arg1: $Class$$Type<(T)>)

public "getName"(): StringJS
public "getName"(arg0: T): StringJS
public "value"(arg0: $StateHolder$$Type<(never), (never)>): $Property$Value<(T)>
public "value"(arg0: T): $Property$Value<(T)>
public "equals"(p_equals_1_: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getValue"(arg0: StringJS): $Optional<(T)>
public "generateHashCode"(): integer
public "getPossibleValues"(): $Collection<(T)>
public "getAllValues"(): $Stream<($Property$Value<(T)>)>
public "getValueClass"(): $Class<(T)>
public "parseValue"<U, S extends $StateHolder<(object), (object)>>(arg0: $DynamicOps$$Type<(U)>, arg1: S, arg2: U): $DataResult<(S)>
public "codec"(): $Codec<(T)>
public "valueCodec"(): $Codec<($Property$Value<(T)>)>
get "name"(): StringJS
get "possibleValues"(): $Collection<(T)>
get "allValues"(): $Stream<($Property$Value<(T)>)>
get "valueClass"(): $Class<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Property$$Type<T> = ($Property<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Property$$Original<T> = $Property<(T)>;}
declare module "net.minecraft.world.level.levelgen.Aquifer" {
import {$NoiseChunk$$Type} from "net.minecraft.world.level.levelgen.NoiseChunk"
import {$Aquifer$FluidPicker$$Type} from "net.minecraft.world.level.levelgen.Aquifer$FluidPicker"
import {$PositionalRandomFactory$$Type} from "net.minecraft.world.level.levelgen.PositionalRandomFactory"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$NoiseRouter$$Type} from "net.minecraft.world.level.levelgen.NoiseRouter"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export interface $Aquifer$$Interface {
}

export class $Aquifer implements $Aquifer$$Interface {
static "create"(arg0: $NoiseChunk$$Type, arg1: $ChunkPos$$Type, arg2: $NoiseRouter$$Type, arg3: $PositionalRandomFactory$$Type, arg4: integer, arg5: integer, arg6: $Aquifer$FluidPicker$$Type): $Aquifer
 "computeSubstance"(arg0: $DensityFunction$FunctionContext$$Type, arg1: double): $BlockState
 "shouldScheduleFluidUpdate"(): boolean
static "createDisabled"(arg0: $Aquifer$FluidPicker$$Type): $Aquifer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Aquifer$$Type = ($Aquifer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Aquifer$$Original = $Aquifer;}
declare module "net.minecraft.world.level.storage.loot.LootContext" {
import {$HolderGetter$Provider, $HolderGetter$Provider$$Type} from "net.minecraft.core.HolderGetter$Provider"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$LootItemFunction, $LootItemFunction$$Type} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction"
import {$LootParams$$Type} from "net.minecraft.world.level.storage.loot.LootParams"
import {$LootContext$VisitedEntry, $LootContext$VisitedEntry$$Type} from "net.minecraft.world.level.storage.loot.LootContext$VisitedEntry"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LootContextParam$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ServerLevel} from "net.minecraft.server.level.ServerLevel"
import {$LootItemCondition, $LootItemCondition$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"

export class $LootContext {
constructor(arg0: $LootParams$$Type, arg1: $RandomSource$$Type, arg2: $HolderGetter$Provider$$Type)

public "getLevel"(): $ServerLevel
public "hasVisitedElement"(arg0: $LootContext$VisitedEntry$$Type<(never)>): boolean
public "addDynamicDrops"(arg0: $ResourceLocation$$Type, arg1: $Consumer$$Type<($ItemStack)>): void
public "popVisitedElement"(arg0: $LootContext$VisitedEntry$$Type<(never)>): void
public "getQueriedLootTableId"(): $ResourceLocation
public "getParamOrNull"<T>(arg0: $LootContextParam$$Type<(T)>): T
public "getRandom"(): $RandomSource
public "pushVisitedElement"(arg0: $LootContext$VisitedEntry$$Type<(never)>): boolean
public static "createVisitedEntry"(arg0: $LootTable$$Type): $LootContext$VisitedEntry<($LootTable)>
public static "createVisitedEntry"(arg0: $LootItemCondition$$Type): $LootContext$VisitedEntry<($LootItemCondition)>
public static "createVisitedEntry"(arg0: $LootItemFunction$$Type): $LootContext$VisitedEntry<($LootItemFunction)>
public "getResolver"(): $HolderGetter$Provider
public "hasParam"(arg0: $LootContextParam$$Type<(never)>): boolean
public "getParam"<T>(arg0: $LootContextParam$$Type<(T)>): T
public "getLuck"(): float
public "setQueriedLootTableId"(arg0: $ResourceLocation$$Type): void
get "level"(): $ServerLevel
get "queriedLootTableId"(): $ResourceLocation
get "random"(): $RandomSource
get "resolver"(): $HolderGetter$Provider
get "luck"(): float
set "queriedLootTableId"(value: $ResourceLocation$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootContext$$Type = ($LootContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootContext$$Original = $LootContext;}
declare module "net.minecraft.world.level.ClipContext$Fluid" {
import {$Enum} from "java.lang.Enum"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"

export class $ClipContext$Fluid extends $Enum<($ClipContext$Fluid)> {
static readonly "SOURCE_ONLY": $ClipContext$Fluid
static readonly "NONE": $ClipContext$Fluid
static readonly "ANY": $ClipContext$Fluid
static readonly "WATER": $ClipContext$Fluid

public static "values"(): ($ClipContext$Fluid)[]
public static "valueOf"(arg0: StringJS): $ClipContext$Fluid
public "canPick"(arg0: $FluidState$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClipContext$Fluid$$Type = (("none") | ("source_only") | ("any") | ("water"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClipContext$Fluid$$Original = $ClipContext$Fluid;}
declare module "net.minecraft.world.level.block.state.properties.AttachFace" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $AttachFace extends $Enum<($AttachFace)> implements $StringRepresentable$$Interface {
static readonly "FLOOR": $AttachFace
static readonly "WALL": $AttachFace
static readonly "CEILING": $AttachFace

public static "values"(): ($AttachFace)[]
public static "valueOf"(arg0: StringJS): $AttachFace
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachFace$$Type = (("floor") | ("wall") | ("ceiling"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttachFace$$Original = $AttachFace;}
declare module "net.minecraft.world.level.biome.Climate$Sampler" {
import {$Climate$TargetPoint} from "net.minecraft.world.level.biome.Climate$TargetPoint"
import {$List, $List$$Type} from "java.util.List"
import {$Climate$ParameterPoint, $Climate$ParameterPoint$$Type} from "net.minecraft.world.level.biome.Climate$ParameterPoint"
import {$ImprovedNoise} from "net.minecraft.world.level.levelgen.synth.ImprovedNoise"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$MultiNoiseSamplerHooks$$Interface} from "net.fabricmc.fabric.impl.biome.MultiNoiseSamplerHooks"
import {$DensityFunction, $DensityFunction$$Type} from "net.minecraft.world.level.levelgen.DensityFunction"
import {$Record} from "java.lang.Record"

export class $Climate$Sampler extends $Record implements $MultiNoiseSamplerHooks$$Interface {
constructor(arg0: $DensityFunction$$Type, arg1: $DensityFunction$$Type, arg2: $DensityFunction$$Type, arg3: $DensityFunction$$Type, arg4: $DensityFunction$$Type, arg5: $DensityFunction$$Type, arg6: $List$$Type<($Climate$ParameterPoint$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "depth"(): $DensityFunction
public "temperature"(): $DensityFunction
public "weirdness"(): $DensityFunction
public "erosion"(): $DensityFunction
public "humidity"(): $DensityFunction
public "sample"(arg0: integer, arg1: integer, arg2: integer): $Climate$TargetPoint
public "spawnTarget"(): $List<($Climate$ParameterPoint)>
public "continentalness"(): $DensityFunction
public "findSpawnPosition"(): $BlockPos
public "fabric_setSeed"(arg0: long): void
public "fabric_getSeed"(): long
public "fabric_getEndBiomesSampler"(): $ImprovedNoise
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Climate$Sampler$$Type = ({"continentalness"?: $DensityFunction$$Type, "weirdness"?: $DensityFunction$$Type, "erosion"?: $DensityFunction$$Type, "temperature"?: $DensityFunction$$Type, "depth"?: $DensityFunction$$Type, "spawnTarget"?: $List$$Type<($Climate$ParameterPoint$$Type)>, "humidity"?: $DensityFunction$$Type}) | ([continentalness?: $DensityFunction$$Type, weirdness?: $DensityFunction$$Type, erosion?: $DensityFunction$$Type, temperature?: $DensityFunction$$Type, depth?: $DensityFunction$$Type, spawnTarget?: $List$$Type<($Climate$ParameterPoint$$Type)>, humidity?: $DensityFunction$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Climate$Sampler$$Original = $Climate$Sampler;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration" {
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$WeightedPlacedFeature, $WeightedPlacedFeature$$Type} from "net.minecraft.world.level.levelgen.feature.WeightedPlacedFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $RandomFeatureConfiguration implements $FeatureConfiguration$$Interface {
readonly "features": $List<($WeightedPlacedFeature)>
static readonly "CODEC": $Codec<($RandomFeatureConfiguration)>
readonly "defaultFeature": $Holder<($PlacedFeature)>

constructor(arg0: $List$$Type<($WeightedPlacedFeature$$Type)>, arg1: $Holder$$Type<($PlacedFeature)>)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomFeatureConfiguration$$Type = ($RandomFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomFeatureConfiguration$$Original = $RandomFeatureConfiguration;}
declare module "net.minecraft.world.level.biome.MobSpawnSettings$SpawnerData" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$WeightedEntry$Wrapper} from "net.minecraft.util.random.WeightedEntry$Wrapper"
import {$WeightedEntry$IntrusiveBase} from "net.minecraft.util.random.WeightedEntry$IntrusiveBase"
import {$Weight$$Type} from "net.minecraft.util.random.Weight"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $MobSpawnSettings$SpawnerData extends $WeightedEntry$IntrusiveBase {
static readonly "CODEC": $Codec<($MobSpawnSettings$SpawnerData)>
readonly "minCount": integer
readonly "type": $EntityType<(never)>
readonly "maxCount": integer

constructor(arg0: $EntityType$$Type<(never)>, arg1: integer, arg2: integer, arg3: integer)
constructor(arg0: $EntityType$$Type<(never)>, arg1: $Weight$$Type, arg2: integer, arg3: integer)

public "toString"(): StringJS
public static "wrap"<T>(arg0: T, arg1: integer): $WeightedEntry$Wrapper<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobSpawnSettings$SpawnerData$$Type = ($MobSpawnSettings$SpawnerData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobSpawnSettings$SpawnerData$$Original = $MobSpawnSettings$SpawnerData;}
declare module "net.minecraft.world.level.storage.loot.LootParams" {
import {$LootContextParam$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Map$$Type} from "java.util.Map"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$LootParams$DynamicDrop$$Type} from "net.minecraft.world.level.storage.loot.LootParams$DynamicDrop"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $LootParams {
constructor(arg0: $ServerLevel$$Type, arg1: $Map$$Type<($LootContextParam$$Type<(never)>), (any)>, arg2: $Map$$Type<($ResourceLocation$$Type), ($LootParams$DynamicDrop$$Type)>, arg3: float)

public "getLevel"(): $ServerLevel
public "addDynamicDrops"(arg0: $ResourceLocation$$Type, arg1: $Consumer$$Type<($ItemStack)>): void
public "getParamOrNull"<T>(arg0: $LootContextParam$$Type<(T)>): T
public "getParameter"<T>(arg0: $LootContextParam$$Type<(T)>): T
public "hasParam"(arg0: $LootContextParam$$Type<(never)>): boolean
public "getOptionalParameter"<T>(arg0: $LootContextParam$$Type<(T)>): T
public "getLuck"(): float
get "level"(): $ServerLevel
get "luck"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootParams$$Type = ($LootParams);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootParams$$Original = $LootParams;}
declare module "net.minecraft.world.level.gameevent.GameEventListenerRegistry" {
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$GameEventListenerRegistry$ListenerVisitor$$Type} from "net.minecraft.world.level.gameevent.GameEventListenerRegistry$ListenerVisitor"
import {$GameEventListener$$Type} from "net.minecraft.world.level.gameevent.GameEventListener"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export interface $GameEventListenerRegistry$$Interface {
get "empty"(): boolean
}

export class $GameEventListenerRegistry implements $GameEventListenerRegistry$$Interface {
static readonly "NOOP": $GameEventListenerRegistry

 "isEmpty"(): boolean
 "register"(arg0: $GameEventListener$$Type): void
 "unregister"(arg0: $GameEventListener$$Type): void
 "visitInRangeListeners"(arg0: $Holder$$Type<($GameEvent)>, arg1: $Vec3$$Type, arg2: $GameEvent$Context$$Type, arg3: $GameEventListenerRegistry$ListenerVisitor$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameEventListenerRegistry$$Type = ($GameEventListenerRegistry);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameEventListenerRegistry$$Original = $GameEventListenerRegistry;}
declare module "net.minecraft.world.level.gameevent.GameEventListener$Provider" {
import {$GameEventListener, $GameEventListener$$Type} from "net.minecraft.world.level.gameevent.GameEventListener"

export interface $GameEventListener$Provider$$Interface<T extends $GameEventListener> {

(): T
get "listener"(): T
}

export class $GameEventListener$Provider<T extends $GameEventListener> implements $GameEventListener$Provider$$Interface {
 "getListener"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameEventListener$Provider$$Type<T> = (() => T);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameEventListener$Provider$$Original<T> = $GameEventListener$Provider<(T)>;}
declare module "net.minecraft.world.level.levelgen.structure.pools.EmptyPoolElement" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$StructurePoolElementType} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElementType"
import {$LiquidSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings"
import {$List} from "java.util.List"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructurePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElement"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Vec3i} from "net.minecraft.core.Vec3i"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$StructureTemplate$StructureBlockInfo} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $EmptyPoolElement extends $StructurePoolElement {
static readonly "CODEC": $MapCodec<($EmptyPoolElement)>
static readonly "INSTANCE": $EmptyPoolElement

public "toString"(): StringJS
public "getType"(): $StructurePoolElementType<(never)>
public "getSize"(arg0: $StructureTemplateManager$$Type, arg1: $Rotation$$Type): $Vec3i
public "getShuffledJigsawBlocks"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type, arg3: $RandomSource$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "place"(arg0: $StructureTemplateManager$$Type, arg1: $WorldGenLevel$$Type, arg2: $StructureManager$$Type, arg3: $ChunkGenerator$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type, arg6: $Rotation$$Type, arg7: $BoundingBox$$Type, arg8: $RandomSource$$Type, arg9: $LiquidSettings$$Type, arg10: boolean): boolean
public "getBoundingBox"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type): $BoundingBox
get "type"(): $StructurePoolElementType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyPoolElement$$Type = ($EmptyPoolElement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EmptyPoolElement$$Original = $EmptyPoolElement;}
declare module "net.minecraft.world.level.block.state.properties.SlabType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $SlabType extends $Enum<($SlabType)> implements $StringRepresentable$$Interface {
static readonly "TOP": $SlabType
static readonly "BOTTOM": $SlabType
static readonly "DOUBLE": $SlabType

public "toString"(): StringJS
public static "values"(): ($SlabType)[]
public static "valueOf"(arg0: StringJS): $SlabType
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlabType$$Type = (("top") | ("bottom") | ("double"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SlabType$$Original = $SlabType;}
declare module "net.minecraft.world.level.storage.loot.entries.SequentialEntry$Builder" {
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$LootPoolEntryContainer} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer"
import {$LootPoolEntryContainer$Builder, $LootPoolEntryContainer$Builder$$Type} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer$Builder"
import {$ConditionUserBuilder} from "net.minecraft.world.level.storage.loot.predicates.ConditionUserBuilder"

export class $SequentialEntry$Builder extends $LootPoolEntryContainer$Builder<($SequentialEntry$Builder)> {
constructor(...arg0: ($LootPoolEntryContainer$Builder$$Type<(never)>)[])

public "build"(): $LootPoolEntryContainer
public "then"(arg0: $LootPoolEntryContainer$Builder$$Type<(never)>): $SequentialEntry$Builder
public "getThis"(): $SequentialEntry$Builder
public "when"(arg0: $LootItemCondition$Builder$$Type): $ConditionUserBuilder
get "this"(): $SequentialEntry$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequentialEntry$Builder$$Type = ($SequentialEntry$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SequentialEntry$Builder$$Original = $SequentialEntry$Builder;}
declare module "net.minecraft.world.level.chunk.Palette$Factory" {
import {$List, $List$$Type} from "java.util.List"
import {$Palette, $Palette$$Type} from "net.minecraft.world.level.chunk.Palette"
import {$IdMap, $IdMap$$Type} from "net.minecraft.core.IdMap"
import {$PaletteResize, $PaletteResize$$Type} from "net.minecraft.world.level.chunk.PaletteResize"

export interface $Palette$Factory$$Interface {

(arg0: integer, arg1: $IdMap<(A)>, arg2: $PaletteResize<(A)>, arg3: $List<(A)>): $Palette$$Type<(A)>
}

export class $Palette$Factory implements $Palette$Factory$$Interface {
 "create"<A>(arg0: integer, arg1: $IdMap$$Type<(A)>, arg2: $PaletteResize$$Type<(A)>, arg3: $List$$Type<(A)>): $Palette<(A)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Palette$Factory$$Type = ((arg0: integer, arg1: $IdMap<(A)>, arg2: $PaletteResize<(A)>, arg3: $List<(A)>) => $Palette$$Type<(A)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Palette$Factory$$Original = $Palette$Factory;}
declare module "net.minecraft.world.level.chunk.status.ChunkDependencies" {
import {$ImmutableList, $ImmutableList$$Type} from "com.google.common.collect.ImmutableList"
import {$ChunkStatus, $ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"

export class $ChunkDependencies {
constructor(arg0: $ImmutableList$$Type<($ChunkStatus$$Type)>)

public "size"(): integer
public "get"(arg0: integer): $ChunkStatus
public "toString"(): StringJS
public "asList"(): $ImmutableList<($ChunkStatus)>
public "getRadius"(): integer
public "getRadiusOf"(arg0: $ChunkStatus$$Type): integer
get "radius"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkDependencies$$Type = ($ChunkDependencies);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkDependencies$$Original = $ChunkDependencies;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.FancyFoliagePlacer" {
import {$FoliagePlacerType} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacerType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$FoliagePlacer$FoliageSetter$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageSetter"
import {$BlobFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.BlobFoliagePlacer"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$FoliagePlacer$FoliageAttachment$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $FancyFoliagePlacer extends $BlobFoliagePlacer {
static readonly "CODEC": $MapCodec<($FancyFoliagePlacer)>
readonly "offset": $IntProvider
readonly "radius": $IntProvider
readonly "height": integer

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: integer)

public "type"(): $FoliagePlacerType<(never)>
public "createFoliage"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: integer, arg5: $FoliagePlacer$FoliageAttachment$$Type, arg6: integer, arg7: integer, arg8: integer): void
public "shouldSkipLocation"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FancyFoliagePlacer$$Type = ($FancyFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FancyFoliagePlacer$$Original = $FancyFoliagePlacer;}
declare module "net.minecraft.world.level.saveddata.maps.MapBanner" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$List} from "java.util.List"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapDecorationType} from "net.minecraft.world.level.saveddata.maps.MapDecorationType"
import {$Holder} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $MapBanner extends $Record {
static readonly "CODEC": $Codec<($MapBanner)>
static readonly "LIST_CODEC": $Codec<($List<($MapBanner)>)>

constructor(arg0: $BlockPos$$Type, arg1: $DyeColor$$Type, arg2: ($Component$$Type)?)

public "name"(): $Optional<($Component)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getId"(): StringJS
public "pos"(): $BlockPos
public "color"(): $DyeColor
public "getDecoration"(): $Holder<($MapDecorationType)>
public static "fromWorld"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $MapBanner
get "id"(): StringJS
get "decoration"(): $Holder<($MapDecorationType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapBanner$$Type = ({"pos"?: $BlockPos$$Type, "name"?: ($Component$$Type)?, "color"?: $DyeColor$$Type}) | ([pos?: $BlockPos$$Type, name?: ($Component$$Type)?, color?: $DyeColor$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapBanner$$Original = $MapBanner;}
declare module "net.minecraft.world.level.levelgen.structure.pools.alias.PoolAliasBinding" {
import {$RandomGroup} from "net.minecraft.world.level.levelgen.structure.pools.alias.RandomGroup"
import {$List$$Type} from "java.util.List"
import {$Direct} from "net.minecraft.world.level.levelgen.structure.pools.alias.Direct"
import {$SimpleWeightedRandomList$$Type} from "net.minecraft.util.random.SimpleWeightedRandomList"
import {$Random} from "net.minecraft.world.level.levelgen.structure.pools.alias.Random"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$StructureTemplatePool, $StructureTemplatePool$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Stream} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export interface $PoolAliasBinding$$Interface {
}

export class $PoolAliasBinding implements $PoolAliasBinding$$Interface {
static readonly "CODEC": $Codec<($PoolAliasBinding)>

 "allTargets"(): $Stream<($ResourceKey<($StructureTemplatePool)>)>
static "random"(arg0: StringJS, arg1: $SimpleWeightedRandomList$$Type<(StringJS)>): $Random
static "random"(arg0: $ResourceKey$$Type<($StructureTemplatePool)>, arg1: $SimpleWeightedRandomList$$Type<($ResourceKey$$Type<($StructureTemplatePool$$Type)>)>): $Random
static "direct"(arg0: $ResourceKey$$Type<($StructureTemplatePool)>, arg1: $ResourceKey$$Type<($StructureTemplatePool)>): $Direct
static "direct"(arg0: StringJS, arg1: StringJS): $Direct
 "codec"(): $MapCodec<($PoolAliasBinding)>
 "forEachResolved"(arg0: $RandomSource$$Type, arg1: $BiConsumer$$Type<($ResourceKey<($StructureTemplatePool)>), ($ResourceKey<($StructureTemplatePool)>)>): void
static "randomGroup"(arg0: $SimpleWeightedRandomList$$Type<($List$$Type<($PoolAliasBinding$$Type)>)>): $RandomGroup
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PoolAliasBinding$$Type = ($PoolAliasBinding);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PoolAliasBinding$$Original = $PoolAliasBinding;}
declare module "net.minecraft.world.level.material.MapColor" {
import {$MapColor$Brightness$$Type} from "net.minecraft.world.level.material.MapColor$Brightness"

export class $MapColor {
readonly "col": integer
static readonly "WOOD": $MapColor
static readonly "CRIMSON_STEM": $MapColor
static readonly "TERRACOTTA_LIGHT_BLUE": $MapColor
static readonly "PODZOL": $MapColor
static readonly "WARPED_WART_BLOCK": $MapColor
static readonly "COLOR_LIGHT_GREEN": $MapColor
static readonly "COLOR_BLACK": $MapColor
static readonly "TERRACOTTA_GREEN": $MapColor
static readonly "WARPED_NYLIUM": $MapColor
static readonly "FIRE": $MapColor
static readonly "GRASS": $MapColor
static readonly "TERRACOTTA_ORANGE": $MapColor
static readonly "GLOW_LICHEN": $MapColor
static readonly "COLOR_CYAN": $MapColor
readonly "id": integer
static readonly "NONE": $MapColor
static readonly "WOOL": $MapColor
static readonly "QUARTZ": $MapColor
static readonly "WATER": $MapColor
static readonly "TERRACOTTA_YELLOW": $MapColor
static readonly "SAND": $MapColor
static readonly "SNOW": $MapColor
static readonly "DIRT": $MapColor
static readonly "LAPIS": $MapColor
static readonly "DEEPSLATE": $MapColor
static readonly "COLOR_YELLOW": $MapColor
static readonly "COLOR_LIGHT_GRAY": $MapColor
static readonly "TERRACOTTA_LIGHT_GRAY": $MapColor
static readonly "CRIMSON_NYLIUM": $MapColor
static readonly "TERRACOTTA_BLUE": $MapColor
static readonly "WARPED_HYPHAE": $MapColor
static readonly "METAL": $MapColor
static readonly "TERRACOTTA_GRAY": $MapColor
static readonly "WARPED_STEM": $MapColor
static readonly "PLANT": $MapColor
static readonly "GOLD": $MapColor
static readonly "DIAMOND": $MapColor
static readonly "COLOR_RED": $MapColor
static readonly "COLOR_ORANGE": $MapColor
static readonly "COLOR_BLUE": $MapColor
static readonly "NETHER": $MapColor
static readonly "TERRACOTTA_BLACK": $MapColor
static readonly "TERRACOTTA_PINK": $MapColor
static readonly "COLOR_MAGENTA": $MapColor
static readonly "TERRACOTTA_WHITE": $MapColor
static readonly "COLOR_GRAY": $MapColor
static readonly "COLOR_LIGHT_BLUE": $MapColor
static readonly "TERRACOTTA_LIGHT_GREEN": $MapColor
static readonly "COLOR_GREEN": $MapColor
static readonly "COLOR_PURPLE": $MapColor
static readonly "EMERALD": $MapColor
static readonly "ICE": $MapColor
static readonly "COLOR_BROWN": $MapColor
static readonly "TERRACOTTA_PURPLE": $MapColor
static readonly "TERRACOTTA_BROWN": $MapColor
static readonly "TERRACOTTA_MAGENTA": $MapColor
static readonly "RAW_IRON": $MapColor
static readonly "COLOR_PINK": $MapColor
static readonly "TERRACOTTA_RED": $MapColor
static readonly "CRIMSON_HYPHAE": $MapColor
static readonly "STONE": $MapColor
static readonly "TERRACOTTA_CYAN": $MapColor
static readonly "CLAY": $MapColor

public static "getColorFromPackedId"(arg0: integer): integer
public "getPackedId"(arg0: $MapColor$Brightness$$Type): byte
public "calculateRGBColor"(arg0: $MapColor$Brightness$$Type): integer
public static "byId"(arg0: integer): $MapColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapColor$$Type = ($MapColor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapColor$$Original = $MapColor;}
declare module "net.minecraft.world.level.levelgen.SurfaceRules$SurfaceRule" {
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $SurfaceRules$SurfaceRule$$Interface {

(arg0: integer, arg1: integer, arg2: integer): $BlockState$$Type
}

export class $SurfaceRules$SurfaceRule implements $SurfaceRules$SurfaceRule$$Interface {
 "tryApply"(arg0: integer, arg1: integer, arg2: integer): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SurfaceRules$SurfaceRule$$Type = ((arg0: integer, arg1: integer, arg2: integer) => $BlockState$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SurfaceRules$SurfaceRule$$Original = $SurfaceRules$SurfaceRule;}
declare module "net.minecraft.world.level.levelgen.presets.WorldPreset" {
import {$LevelStem, $LevelStem$$Type} from "net.minecraft.world.level.dimension.LevelStem"
import {$Map$$Type} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Optional} from "java.util.Optional"
import {$WorldDimensions} from "net.minecraft.world.level.levelgen.WorldDimensions"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Holder} from "net.minecraft.core.Holder"

export class $WorldPreset {
static readonly "CODEC": $Codec<($Holder<($WorldPreset)>)>
static readonly "DIRECT_CODEC": $Codec<($WorldPreset)>

constructor(arg0: $Map$$Type<($ResourceKey$$Type<($LevelStem$$Type)>), ($LevelStem$$Type)>)

public "overworld"(): $Optional<($LevelStem)>
public "createWorldDimensions"(): $WorldDimensions
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenWorldPreset
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenWorldPresetTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldPreset$$Type = (Special.WorldgenWorldPreset);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldPreset$$Original = $WorldPreset;}
declare module "net.minecraft.world.level.chunk.storage.IOWorker" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$Optional} from "java.util.Optional"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$ChunkScanAccess$$Interface} from "net.minecraft.world.level.chunk.storage.ChunkScanAccess"
import {$RegionStorageInfo, $RegionStorageInfo$$Type} from "net.minecraft.world.level.chunk.storage.RegionStorageInfo"
import {$RegionFileStorage} from "net.minecraft.world.level.chunk.storage.RegionFileStorage"
import {$Path$$Type} from "java.nio.file.Path"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$StreamTagVisitor$$Type} from "net.minecraft.nbt.StreamTagVisitor"

export class $IOWorker implements $ChunkScanAccess$$Interface, $AutoCloseable$$Interface {
readonly "storage": $RegionFileStorage

constructor(arg0: $RegionStorageInfo$$Type, arg1: $Path$$Type, arg2: boolean)

public "store"(arg0: $ChunkPos$$Type, arg1: $CompoundTag$$Type): $CompletableFuture<(void)>
public "close"(): void
public "storageInfo"(): $RegionStorageInfo
public "isOldChunkAround"(arg0: $ChunkPos$$Type, arg1: integer): boolean
public "loadAsync"(arg0: $ChunkPos$$Type): $CompletableFuture<($Optional<($CompoundTag)>)>
public "synchronize"(arg0: boolean): $CompletableFuture<(void)>
public "scanChunk"(arg0: $ChunkPos$$Type, arg1: $StreamTagVisitor$$Type): $CompletableFuture<(void)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IOWorker$$Type = ($IOWorker);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IOWorker$$Original = $IOWorker;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.SimpleStateProvider" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BlockStateProviderType} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProviderType"
import {$BlockStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SimpleStateProvider extends $BlockStateProvider {
static readonly "CODEC": $MapCodec<($SimpleStateProvider)>

constructor(arg0: $BlockState$$Type)

public "type"(): $BlockStateProviderType<(never)>
public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleStateProvider$$Type = ($SimpleStateProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleStateProvider$$Original = $SimpleStateProvider;}
declare module "net.minecraft.world.level.storage.loot.predicates.AnyOfCondition$Builder" {
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$List$$Type} from "java.util.List"
import {$CompositeLootItemCondition$Builder} from "net.minecraft.world.level.storage.loot.predicates.CompositeLootItemCondition$Builder"
import {$LootItemCondition, $LootItemCondition$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"

export class $AnyOfCondition$Builder extends $CompositeLootItemCondition$Builder {
constructor(...arg0: ($LootItemCondition$Builder$$Type)[])

public "create"(arg0: $List$$Type<($LootItemCondition$$Type)>): $LootItemCondition
public "or"(arg0: $LootItemCondition$Builder$$Type): $AnyOfCondition$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnyOfCondition$Builder$$Type = ($AnyOfCondition$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AnyOfCondition$Builder$$Original = $AnyOfCondition$Builder;}
declare module "net.minecraft.world.level.chunk.CarvingMask" {
import {$CarvingMask$Mask$$Type} from "net.minecraft.world.level.chunk.CarvingMask$Mask"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"

export class $CarvingMask {
constructor(arg0: integer, arg1: integer)
constructor(arg0: (long)[], arg1: integer)

public "get"(arg0: integer, arg1: integer, arg2: integer): boolean
public "toArray"(): (long)[]
public "stream"(arg0: $ChunkPos$$Type): $Stream<($BlockPos)>
public "set"(arg0: integer, arg1: integer, arg2: integer): void
public "setAdditionalMask"(arg0: $CarvingMask$Mask$$Type): void
set "additionalMask"(value: $CarvingMask$Mask$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarvingMask$$Type = ($CarvingMask);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarvingMask$$Original = $CarvingMask;}
declare module "net.minecraft.world.level.biome.MobSpawnSettings$MobSpawnCost" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Record} from "java.lang.Record"

export class $MobSpawnSettings$MobSpawnCost extends $Record {
static readonly "CODEC": $Codec<($MobSpawnSettings$MobSpawnCost)>

constructor(energyBudget: double, charge: double)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "charge"(): double
public "energyBudget"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobSpawnSettings$MobSpawnCost$$Type = ({"energyBudget"?: double, "charge"?: double}) | ([energyBudget?: double, charge?: double]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobSpawnSettings$MobSpawnCost$$Original = $MobSpawnSettings$MobSpawnCost;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration" {
import {$PlacedFeature, $PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $SimpleRandomFeatureConfiguration implements $FeatureConfiguration$$Interface {
readonly "features": $HolderSet<($PlacedFeature)>
static readonly "CODEC": $Codec<($SimpleRandomFeatureConfiguration)>

constructor(arg0: $HolderSet$$Type<($PlacedFeature)>)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleRandomFeatureConfiguration$$Type = ($SimpleRandomFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleRandomFeatureConfiguration$$Original = $SimpleRandomFeatureConfiguration;}
declare module "net.minecraft.world.level.levelgen.structure.structures.MineshaftStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"
import {$MineshaftStructure$Type$$Type} from "net.minecraft.world.level.levelgen.structure.structures.MineshaftStructure$Type"

export class $MineshaftStructure extends $Structure {
static readonly "CODEC": $MapCodec<($MineshaftStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type, arg1: $MineshaftStructure$Type$$Type)

public "type"(): $StructureType<(never)>
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MineshaftStructure$$Type = ($MineshaftStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MineshaftStructure$$Original = $MineshaftStructure;}
declare module "net.minecraft.world.level.pathfinder.PathComputationType" {
import {$Enum} from "java.lang.Enum"

export class $PathComputationType extends $Enum<($PathComputationType)> {
static readonly "LAND": $PathComputationType
static readonly "AIR": $PathComputationType
static readonly "WATER": $PathComputationType

public static "values"(): ($PathComputationType)[]
public static "valueOf"(arg0: StringJS): $PathComputationType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathComputationType$$Type = (("land") | ("water") | ("air"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PathComputationType$$Original = $PathComputationType;}
declare module "net.minecraft.world.level.levelgen.blending.Blender$BlendingOutput" {
import {$Record} from "java.lang.Record"

export class $Blender$BlendingOutput extends $Record {
constructor(arg0: double, arg1: double)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "blendingOffset"(): double
public "alpha"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Blender$BlendingOutput$$Type = ({"blendingOffset"?: double, "alpha"?: double}) | ([blendingOffset?: double, alpha?: double]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Blender$BlendingOutput$$Original = $Blender$BlendingOutput;}
declare module "net.minecraft.world.level.levelgen.feature.rootplacers.AboveRootPlacement" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$Record} from "java.lang.Record"

export class $AboveRootPlacement extends $Record {
static readonly "CODEC": $Codec<($AboveRootPlacement)>

constructor(arg0: $BlockStateProvider$$Type, arg1: float)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "aboveRootProvider"(): $BlockStateProvider
public "aboveRootPlacementChance"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AboveRootPlacement$$Type = ({"aboveRootProvider"?: $BlockStateProvider$$Type, "aboveRootPlacementChance"?: float}) | ([aboveRootProvider?: $BlockStateProvider$$Type, aboveRootPlacementChance?: float]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AboveRootPlacement$$Original = $AboveRootPlacement;}
declare module "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement" {
import {$ChunkGeneratorStructureState$$Type} from "net.minecraft.world.level.chunk.ChunkGeneratorStructureState"
import {$RecordCodecBuilder$Instance$$Type} from "com.mojang.serialization.codecs.RecordCodecBuilder$Instance"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$StructurePlacement$ExclusionZone, $StructurePlacement$ExclusionZone$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement$ExclusionZone"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Vec3i, $Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RecordCodecBuilder$Mu} from "com.mojang.serialization.codecs.RecordCodecBuilder$Mu"
import {$Products$P5} from "com.mojang.datafixers.Products$P5"
import {$StructurePlacementType} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacementType"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$StructurePlacement$FrequencyReductionMethod, $StructurePlacement$FrequencyReductionMethod$$Type} from "net.minecraft.world.level.levelgen.structure.placement.StructurePlacement$FrequencyReductionMethod"

export class $StructurePlacement {
static readonly "CODEC": $Codec<($StructurePlacement)>

constructor(arg0: $Vec3i$$Type, arg1: $StructurePlacement$FrequencyReductionMethod$$Type, arg2: float, arg3: integer, arg4: ($StructurePlacement$ExclusionZone$$Type)?)

public "salt"(): integer
public "type"(): $StructurePlacementType<(never)>
public "frequency"(): float
public "applyAdditionalChunkRestrictions"(arg0: integer, arg1: integer, arg2: long): boolean
public "applyInteractionsWithOtherStructures"(arg0: $ChunkGeneratorStructureState$$Type, arg1: integer, arg2: integer): boolean
public "isPlacementChunk"(arg0: $ChunkGeneratorStructureState$$Type, arg1: integer, arg2: integer): boolean
public "isStructureChunk"(arg0: $ChunkGeneratorStructureState$$Type, arg1: integer, arg2: integer): boolean
public "locateOffset"(): $Vec3i
public "getLocatePos"(arg0: $ChunkPos$$Type): $BlockPos
public "exclusionZone"(): $Optional<($StructurePlacement$ExclusionZone)>
public static "placementCodec"<S extends $StructurePlacement>(arg0: $RecordCodecBuilder$Instance$$Type<(S)>): $Products$P5<($RecordCodecBuilder$Mu<(S)>), ($Vec3i), ($StructurePlacement$FrequencyReductionMethod), (float), (integer), ($Optional<($StructurePlacement$ExclusionZone)>)>
public "frequencyReductionMethod"(): $StructurePlacement$FrequencyReductionMethod
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePlacement$$Type = ($StructurePlacement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePlacement$$Original = $StructurePlacement;}
declare module "net.minecraft.world.level.block.Block" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$ItemAbility$$Type} from "net.neoforged.neoforge.common.ItemAbility"
import {$ImmutableMap} from "com.google.common.collect.ImmutableMap"
import {$StateDefinition$Builder$$Type} from "net.minecraft.world.level.block.state.StateDefinition$Builder"
import {$Holder} from "net.minecraft.core.Holder"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$IBlockExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IBlockExtension"
import {$PathType, $PathType$$Type} from "net.minecraft.world.level.pathfinder.PathType"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$StateDefinition} from "net.minecraft.world.level.block.state.StateDefinition"
import {$BubbleColumnDirection} from "net.neoforged.neoforge.common.enums.BubbleColumnDirection"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$TriState} from "net.neoforged.neoforge.common.util.TriState"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$SoundType} from "net.minecraft.world.level.block.SoundType"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"
import {$IClientBlockExtensions$$Type} from "net.neoforged.neoforge.client.extensions.common.IClientBlockExtensions"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$ItemLike$$Interface} from "net.minecraft.world.level.ItemLike"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapColor, $MapColor$$Type} from "net.minecraft.world.level.material.MapColor"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$List, $List$$Type} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$ServerPlayer$RespawnPosAngle} from "net.minecraft.server.level.ServerPlayer$RespawnPosAngle"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$BlockBehaviour} from "net.minecraft.world.level.block.state.BlockBehaviour"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$Function$$Type} from "java.util.function.Function"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Map} from "java.util.Map"
import {$Item$TooltipContext$$Type} from "net.minecraft.world.item.Item$TooltipContext"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$BlockKJS$$Interface} from "dev.latvian.mods.kubejs.core.BlockKJS"
import {$SignalGetter$$Type} from "net.minecraft.world.level.SignalGetter"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$InjectedBlockExtension$$Interface} from "dev.architectury.extensions.injected.InjectedBlockExtension"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PushReaction} from "net.minecraft.world.level.material.PushReaction"
import {$Biome$Precipitation$$Type} from "net.minecraft.world.level.biome.Biome$Precipitation"

export class $Block extends $BlockBehaviour implements $ItemLike$$Interface, $IBlockExtension$$Interface, $InjectedBlockExtension$$Interface, $BlockKJS$$Interface {
 "explosionResistance": float
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "UPDATE_ALL": integer
 "drops": $ResourceKey<($LootTable)>
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
readonly "dynamicShape": boolean
 "soundType": $SoundType
 "jumpFactor": float
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($Block)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
 "speedFactor": float
 "friction": float
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
 "hasCollision": boolean

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getName"(): $MutableComponent
public "toString"(): StringJS
public static "getId"(arg0: $BlockState$$Type): Special.Block
public "destroy"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public static "box"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): $VoxelShape
public "updateEntityAfterFallOn"(arg0: $BlockGetter$$Type, arg1: $Entity$$Type): void
public "animateTick"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
/**
 * 
 * @deprecated
 */
public "getCloneItemStack"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): $ItemStack
public "getSpeedFactor"(): float
public "getJumpFactor"(): float
public "getId"(): Special.Block
public "stepOn"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Entity$$Type): void
public "fallOn"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type, arg4: float): void
public "asItem"(): $Item
public "getStateDefinition"(): $StateDefinition<($Block), ($BlockState)>
public "getDescriptionId"(): StringJS
/**
 * 
 * @deprecated
 */
public "initializeClient"(arg0: $Consumer$$Type<($IClientBlockExtensions)>): void
public "codec"(): $MapCodec<($Block)>
public static "dropResources"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): void
public static "dropResources"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): void
public static "dropResources"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type, arg4: $Entity$$Type, arg5: $ItemStack$$Type): void
public static "isShapeFullBlock"(arg0: $VoxelShape$$Type): boolean
public static "pushEntitiesUp"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $LevelAccessor$$Type, arg3: $BlockPos$$Type): $BlockState
public static "updateOrDestroy"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $LevelAccessor$$Type, arg3: $BlockPos$$Type, arg4: integer, arg5: integer): void
public static "updateOrDestroy"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $LevelAccessor$$Type, arg3: $BlockPos$$Type, arg4: integer): void
public static "shouldRenderFace"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $BlockPos$$Type): boolean
public static "canSupportCenter"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "hasDynamicShape"(): boolean
public "appendHoverText"(arg0: $ItemStack$$Type, arg1: $Item$TooltipContext$$Type, arg2: $List$$Type<($Component$$Type)>, arg3: $TooltipFlag$$Type): void
public "setPlacedBy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: $ItemStack$$Type): void
public "getTypeData"(): $Map
public "wasExploded"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Explosion$$Type): void
public "playerDestroy"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $BlockEntity$$Type, arg5: $ItemStack$$Type): void
public "popExperience"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: integer): void
public "tryDropExperience"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type, arg3: $IntProvider$$Type): void
public "setNameKey"(arg0: StringJS): void
public "withPropertiesOf"(arg0: $BlockState$$Type): $BlockState
public "playerWillDestroy"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Player$$Type): $BlockState
/**
 * 
 * @deprecated
 */
public "dropFromExplosion"(arg0: $Explosion$$Type): boolean
public static "popResource"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $ItemStack$$Type): void
public static "byItem"(arg0: $Item$$Type): $Block
public static "isFaceFull"(arg0: $VoxelShape$$Type, arg1: $Direction$$Type): boolean
public static "stateById"(arg0: integer): $BlockState
public static "getDrops"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type): $List<($ItemStack)>
public static "getDrops"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type, arg4: $Entity$$Type, arg5: $ItemStack$$Type): $List<($ItemStack)>
public "asBlock"(): $Block
public static "updateFromNeighbourShapes"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type): $BlockState
public "createBlockStateDefinition"(arg0: $StateDefinition$Builder$$Type<($Block$$Type), ($BlockState$$Type)>): void
public static "popResourceFromFace"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: $ItemStack$$Type): void
public "registerDefaultState"(arg0: $BlockState$$Type): void
public static "isExceptionForConnection"(arg0: $BlockState$$Type): boolean
public static "canSupportRigidBlock"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "getBlockBuilder"(): $BlockBuilder
public "isPossibleToRespawnInThis"(arg0: $BlockState$$Type): boolean
public "setBlockBuilder"(b: $BlockBuilder$$Type): void
public "spawnDestroyParticles"(arg0: $Level$$Type, arg1: $Player$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): void
/**
 * 
 * @deprecated
 */
public "getExplosionResistance"(): float
public "getShapeForEachState"(arg0: $Function$$Type<($BlockState), ($VoxelShape$$Type)>): $ImmutableMap<($BlockState), ($VoxelShape)>
public "handlePrecipitation"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Biome$Precipitation$$Type): void
public "defaultBlockState"(): $BlockState
public "getFriction"(): float
public "handler$bda000$vanillabackport$vb$onAnimateTick"(state: $BlockState$$Type, level: $Level$$Type, pos: $BlockPos$$Type, random: $RandomSource$$Type, ci: $CallbackInfo$$Type): void
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
/**
 * 
 * @deprecated
 */
public "builtInRegistryHolder"(): $Holder$Reference<($Block)>
public "isEmpty"(arg0: $BlockState$$Type): boolean
public "rotate"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $Rotation$$Type): $BlockState
public "collisionExtendsVertically"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): boolean
public "getPistonPushReaction"(arg0: $BlockState$$Type): $PushReaction
public "getCloneItemStack"(arg0: $BlockState$$Type, arg1: $HitResult$$Type, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type): $ItemStack
public "addRunningEffects"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): boolean
public "onBlockStateChange"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type): void
public "getLightEmission"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): integer
public "addLandingEffects"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $LivingEntity$$Type, arg5: integer): boolean
public "onNeighborChange"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type): void
public "getWeakChanges"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "makesOpenTrapdoorAboveClimbable"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): boolean
public "shouldHideAdjacentFluidFace"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $FluidState$$Type): boolean
public "isBed"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $LivingEntity$$Type): boolean
public "shouldCheckWeakPower"(arg0: $BlockState$$Type, arg1: $SignalGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "hidesNeighborFace"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: $Direction$$Type): boolean
public "getFireSpreadSpeed"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "canSustainPlant"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $BlockState$$Type): $TriState
public "isSlimeBlock"(arg0: $BlockState$$Type): boolean
public "getRespawnPosition"(arg0: $BlockState$$Type, arg1: $EntityType$$Type<(never)>, arg2: $LevelReader$$Type, arg3: $BlockPos$$Type, arg4: float): $Optional<($ServerPlayer$RespawnPosAngle)>
public "isFireSource"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "onBlockExploded"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Explosion$$Type): void
public "canEntityDestroy"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): boolean
public "isFlammable"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "isConduitFrame"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type): boolean
public "ignitedByLava"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "isPortalFrame"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "getFlammability"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "canHarvestBlock"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): boolean
public "isStickyBlock"(arg0: $BlockState$$Type): boolean
public "onCaughtFire"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $LivingEntity$$Type): void
public "getBlockPathType"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Mob$$Type): $PathType
public "canStickTo"(arg0: $BlockState$$Type, arg1: $BlockState$$Type): boolean
public "isLadder"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $LivingEntity$$Type): boolean
public "getExpDrop"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockEntity$$Type, arg4: $Entity$$Type, arg5: $ItemStack$$Type): integer
public "isBurning"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "isFertile"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "onTreeGrow"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg3: $RandomSource$$Type, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): boolean
public "canConnectRedstone"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "canBeHydrated"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $FluidState$$Type, arg4: $BlockPos$$Type): boolean
public "getMapColor"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $MapColor$$Type): $MapColor
public "getAppearance"(arg0: $BlockState$$Type, arg1: $BlockAndTintGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $BlockState$$Type, arg5: $BlockPos$$Type): $BlockState
public "getToolModifiedState"(arg0: $BlockState$$Type, arg1: $UseOnContext$$Type, arg2: $ItemAbility$$Type, arg3: boolean): $BlockState
public "getStateAtViewpoint"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Vec3$$Type): $BlockState
public "onDestroyedByPushReaction"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $FluidState$$Type): void
public "getEnchantPowerBonus"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): float
public "getBeaconColorMultiplier"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type): integer
public "hasDynamicLightEmission"(arg0: $BlockState$$Type): boolean
public "onDestroyedByPlayer"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type, arg4: boolean, arg5: $FluidState$$Type): boolean
public "shouldDisplayFluidOverlay"(arg0: $BlockState$$Type, arg1: $BlockAndTintGetter$$Type, arg2: $BlockPos$$Type, arg3: $FluidState$$Type): boolean
public "getBubbleColumnDirection"(arg0: $BlockState$$Type): $BubbleColumnDirection
public "canDropFromExplosion"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Explosion$$Type): boolean
public "supportsExternalFaceHiding"(arg0: $BlockState$$Type): boolean
public "getExplosionResistance"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Explosion$$Type): float
public "getSoundType"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): $SoundType
public "getFriction"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): float
public "isScaffolding"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $LivingEntity$$Type): boolean
public "setBedOccupied"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $LivingEntity$$Type, arg4: boolean): void
public "getBedDirection"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): $Direction
public "getAdjacentBlockPathType"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Mob$$Type, arg4: $PathType$$Type): $PathType
public "arch$holder"(): $Holder<($Block)>
public "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
public "getBlockStates"(): $List<($BlockState)>
public "setLightEmission"(v: integer): void
public "setRequiresTool"(v: boolean): void
public "setDestroySpeed"(v: float): void
public "getBlock"(): $Block
public "arch$registryName"(): $ResourceLocation
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "name"(): $MutableComponent
get "id"(): Special.Block
get "descriptionId"(): StringJS
get "typeData"(): $Map
set "nameKey"(value: StringJS)
get "blockBuilder"(): $BlockBuilder
set "blockBuilder"(value: $BlockBuilder$$Type)
get "blockStates"(): $List<($BlockState)>
set "lightEmission"(value: integer)
set "requiresTool"(value: boolean)
set "destroySpeed"(value: float)
get "block"(): $Block
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.Block
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.BlockTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Block$$Type = (Special.Block);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Block$$Original = $Block;}
declare module "net.minecraft.world.level.ChunkPos" {
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"

export class $ChunkPos {
static readonly "ZERO": $ChunkPos
static readonly "REGION_MAX_INDEX": integer
static readonly "INVALID_CHUNK_POS": long
readonly "x": integer
static readonly "REGION_SIZE": integer
readonly "z": integer

constructor(arg0: long)
constructor(arg0: $BlockPos$$Type)
constructor(arg0: integer, arg1: integer)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "hash"(arg0: integer, arg1: integer): integer
public static "rangeClosed"(arg0: $ChunkPos$$Type, arg1: integer): $Stream<($ChunkPos)>
public static "rangeClosed"(arg0: $ChunkPos$$Type, arg1: $ChunkPos$$Type): $Stream<($ChunkPos)>
public static "minFromRegion"(arg0: integer, arg1: integer): $ChunkPos
public static "maxFromRegion"(arg0: integer, arg1: integer): $ChunkPos
public "getRegionLocalZ"(): integer
public "getMinBlockZ"(): integer
public "getMinBlockX"(): integer
public "getMiddleBlockX"(): integer
public "getMiddleBlockZ"(): integer
public "getMaxBlockZ"(): integer
public "getMaxBlockX"(): integer
public "getWorldPosition"(): $BlockPos
public "distanceSquared"(arg0: $ChunkPos$$Type): integer
public "distanceSquared"(arg0: long): integer
public "getRegionLocalX"(): integer
public "getBlockX"(arg0: integer): integer
public "getBlockZ"(arg0: integer): integer
public static "getX"(arg0: long): integer
public static "getZ"(arg0: long): integer
public "getBlockAt"(arg0: integer, arg1: integer, arg2: integer): $BlockPos
public "getRegionZ"(): integer
public "getRegionX"(): integer
public "getMiddleBlockPosition"(arg0: integer): $BlockPos
public "getChessboardDistance"(arg0: $ChunkPos$$Type): integer
public "getChessboardDistance"(arg0: integer, arg1: integer): integer
public "toLong"(): long
public static "asLong"(arg0: integer, arg1: integer): long
public static "asLong"(arg0: $BlockPos$$Type): long
get "regionLocalZ"(): integer
get "minBlockZ"(): integer
get "minBlockX"(): integer
get "middleBlockX"(): integer
get "middleBlockZ"(): integer
get "maxBlockZ"(): integer
get "maxBlockX"(): integer
get "worldPosition"(): $BlockPos
get "regionLocalX"(): integer
get "regionZ"(): integer
get "regionX"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkPos$$Type = ($ChunkPos);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkPos$$Original = $ChunkPos;}
declare module "net.minecraft.world.level.storage.WorldData" {
import {$EndDragonFight$Data, $EndDragonFight$Data$$Type} from "net.minecraft.world.level.dimension.end.EndDragonFight$Data"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$LevelSettings} from "net.minecraft.world.level.LevelSettings"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Difficulty, $Difficulty$$Type} from "net.minecraft.world.Difficulty"
import {$WorldOptions} from "net.minecraft.world.level.levelgen.WorldOptions"
import {$GameRules} from "net.minecraft.world.level.GameRules"
import {$ServerLevelData} from "net.minecraft.world.level.storage.ServerLevelData"
import {$Lifecycle} from "com.mojang.serialization.Lifecycle"
import {$Set} from "java.util.Set"
import {$GameType, $GameType$$Type} from "net.minecraft.world.level.GameType"
import {$WorldDataConfiguration, $WorldDataConfiguration$$Type} from "net.minecraft.world.level.WorldDataConfiguration"
import {$CrashReportCategory$$Type} from "net.minecraft.CrashReportCategory"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export interface $WorldData$$Interface {
get "version"(): integer
get "levelName"(): StringJS
get "difficultyLocked"(): boolean
get "hardcore"(): boolean
set "gameType"(value: $GameType$$Type)
get "flatWorld"(): boolean
get "gameType"(): $GameType
get "loadedPlayerTag"(): $CompoundTag
set "difficulty"(value: $Difficulty$$Type)
get "allowCommands"(): boolean
get "debugWorld"(): boolean
get "levelSettings"(): $LevelSettings
get "difficulty"(): $Difficulty
get "gameRules"(): $GameRules
get "knownServerBrands"(): $Set<(StringJS)>
get "removedFeatureFlags"(): $Set<(StringJS)>
get "dataConfiguration"(): $WorldDataConfiguration
get "customBossEvents"(): $CompoundTag
set "customBossEvents"(value: $CompoundTag$$Type)
set "dataConfiguration"(value: $WorldDataConfiguration$$Type)
set "difficultyLocked"(value: boolean)
}

export class $WorldData implements $WorldData$$Interface {
static readonly "ANVIL_VERSION_ID": integer
static readonly "MCREGION_VERSION_ID": integer

 "getVersion"(): integer
 "getLevelName"(): StringJS
 "wasModded"(): boolean
 "isDifficultyLocked"(): boolean
 "isHardcore"(): boolean
 "fillCrashReportCategory"(arg0: $CrashReportCategory$$Type): void
 "setEndDragonFightData"(arg0: $EndDragonFight$Data$$Type): void
 "endDragonFightData"(): $EndDragonFight$Data
 "worldGenOptions"(): $WorldOptions
 "setGameType"(arg0: $GameType$$Type): void
 "isFlatWorld"(): boolean
 "getGameType"(): $GameType
 "enabledFeatures"(): $FeatureFlagSet
 "createTag"(arg0: $RegistryAccess$$Type, arg1: $CompoundTag$$Type): $CompoundTag
 "overworldData"(): $ServerLevelData
 "getLoadedPlayerTag"(): $CompoundTag
 "setDifficulty"(arg0: $Difficulty$$Type): void
 "isAllowCommands"(): boolean
 "setModdedInfo"(arg0: StringJS, arg1: boolean): void
 "isDebugWorld"(): boolean
 "getLevelSettings"(): $LevelSettings
 "getDifficulty"(): $Difficulty
 "getGameRules"(): $GameRules
 "getKnownServerBrands"(): $Set<(StringJS)>
 "getRemovedFeatureFlags"(): $Set<(StringJS)>
 "worldGenSettingsLifecycle"(): $Lifecycle
 "getDataConfiguration"(): $WorldDataConfiguration
 "getStorageVersionName"(arg0: integer): StringJS
 "getCustomBossEvents"(): $CompoundTag
 "setCustomBossEvents"(arg0: $CompoundTag$$Type): void
 "setDataConfiguration"(arg0: $WorldDataConfiguration$$Type): void
 "setDifficultyLocked"(arg0: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldData$$Type = ($WorldData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldData$$Original = $WorldData;}
declare module "net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$StructurePiece, $StructurePiece$$Type} from "net.minecraft.world.level.levelgen.structure.StructurePiece"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$List} from "java.util.List"
import {$StructurePiecesBuilderAccessor$$Interface} from "com.furiusmax.bjornlib.neo.mixin.structures.StructurePiecesBuilderAccessor"
import {$PiecesContainer} from "net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer"
import {$StructurePieceAccessor$$Interface} from "net.minecraft.world.level.levelgen.structure.StructurePieceAccessor"

export class $StructurePiecesBuilder implements $StructurePieceAccessor$$Interface, $StructurePiecesBuilderAccessor$$Interface {
constructor()

public "clear"(): void
public "isEmpty"(): boolean
public "build"(): $PiecesContainer
/**
 * 
 * @deprecated
 */
public "offsetPiecesVertically"(arg0: integer): void
public "addPiece"(arg0: $StructurePiece$$Type): void
public "getPieces"(): $List
public "findCollisionPiece"(arg0: $BoundingBox$$Type): $StructurePiece
/**
 * 
 * @deprecated
 */
public "moveBelowSeaLevel"(arg0: integer, arg1: integer, arg2: $RandomSource$$Type, arg3: integer): integer
public "moveInsideHeights"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer): void
public "getBoundingBox"(): $BoundingBox
get "empty"(): boolean
get "pieces"(): $List
get "boundingBox"(): $BoundingBox
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePiecesBuilder$$Type = ($StructurePiecesBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePiecesBuilder$$Original = $StructurePiecesBuilder;}
declare module "net.minecraft.world.level.gameevent.PositionSource" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Optional} from "java.util.Optional"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$PositionSourceType} from "net.minecraft.world.level.gameevent.PositionSourceType"

export interface $PositionSource$$Interface {
get "type"(): $PositionSourceType<($PositionSource)>
}

export class $PositionSource implements $PositionSource$$Interface {
static readonly "CODEC": $Codec<($PositionSource)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($PositionSource)>

 "getPosition"(arg0: $Level$$Type): $Optional<($Vec3)>
 "getType"(): $PositionSourceType<($PositionSource)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PositionSource$$Type = ($PositionSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PositionSource$$Original = $PositionSource;}
declare module "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet" {
import {$LootContextParamSet$Builder} from "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet$Builder"
import {$LootContextParam, $LootContextParam$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$ProblemReporter$$Type} from "net.minecraft.util.ProblemReporter"
import {$Set, $Set$$Type} from "java.util.Set"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$LootContextUser$$Type} from "net.minecraft.world.level.storage.loot.LootContextUser"

export class $LootContextParamSet {
constructor(arg0: $Set$$Type<($LootContextParam$$Type<(never)>)>, arg1: $Set$$Type<($LootContextParam$$Type<(never)>)>)

public "toString"(): StringJS
public static "builder"(): $LootContextParamSet$Builder
public "validateUser"(arg0: $ValidationContext$$Type, arg1: $LootContextUser$$Type): void
public "validateUser"(arg0: $ProblemReporter$$Type, arg1: $LootContextUser$$Type): void
public "getRequired"(): $Set<($LootContextParam<(never)>)>
public "isAllowed"(arg0: $LootContextParam$$Type<(never)>): boolean
public "getAllowed"(): $Set<($LootContextParam<(never)>)>
get "required"(): $Set<($LootContextParam<(never)>)>
get "allowed"(): $Set<($LootContextParam<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootContextParamSet$$Type = ($LootContextParamSet);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootContextParamSet$$Original = $LootContextParamSet;}
declare module "net.minecraft.world.level.storage.loot.LootTable$Builder" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$Collection$$Type} from "java.util.Collection"
import {$LootItemFunction$$Type} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction"
import {$LootPool$$Type} from "net.minecraft.world.level.storage.loot.LootPool"
import {$FabricLootTableBuilder$$Interface as $FabricLootTableBuilder$0$$Interface} from "net.fabricmc.fabric.api.loot.v3.FabricLootTableBuilder"
import {$LootItemFunction$Builder$$Type} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction$Builder"
import {$FabricLootTableBuilder$$Interface} from "net.fabricmc.fabric.api.loot.v2.FabricLootTableBuilder"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$LootContextParamSet$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet"
import {$FunctionUserBuilder, $FunctionUserBuilder$$Interface} from "net.minecraft.world.level.storage.loot.functions.FunctionUserBuilder"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LootPool$Builder$$Type} from "net.minecraft.world.level.storage.loot.LootPool$Builder"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Function$$Type} from "java.util.function.Function"

export class $LootTable$Builder implements $FunctionUserBuilder$$Interface<($LootTable$Builder)>, $FabricLootTableBuilder$$Interface, $FabricLootTableBuilder$0$$Interface {
constructor()

public "pools"(arg0: $Collection$$Type): $LootTable$Builder
public "apply"(arg0: $LootItemFunction$Builder$$Type): $FunctionUserBuilder
public "apply"(arg0: $Collection$$Type): $LootTable$Builder
public "apply"(arg0: $LootItemFunction$$Type): $LootTable$Builder
public "pool"(arg0: $LootPool$$Type): $LootTable$Builder
public "unwrap"(): $FunctionUserBuilder
public "build"(): $LootTable
public "modifyPools"(arg0: $Consumer$$Type): $LootTable$Builder
public "withPool"(arg0: $LootPool$Builder$$Type): $LootTable$Builder
public "setParamSet"(arg0: $LootContextParamSet$$Type): $LootTable$Builder
public "setRandomSequence"(arg0: $ResourceLocation$$Type): $LootTable$Builder
public "apply"<E>(arg0: (E)[], arg1: $Function$$Type<(E), ($LootItemFunction$Builder$$Type)>): $LootTable$Builder
public "apply"<E>(arg0: $Iterable$$Type<(E)>, arg1: $Function$$Type<(E), ($LootItemFunction$Builder$$Type)>): $LootTable$Builder
/**
 * 
 * @deprecated
 */
public static "copyOf"(arg0: $LootTable$$Type): $LootTable$Builder
set "paramSet"(value: $LootContextParamSet$$Type)
set "randomSequence"(value: $ResourceLocation$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootTable$Builder$$Type = ($LootTable$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootTable$Builder$$Original = $LootTable$Builder;}
declare module "net.minecraft.world.level.levelgen.structure.structures.OceanRuinStructure$Type" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $OceanRuinStructure$Type extends $Enum<($OceanRuinStructure$Type)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($OceanRuinStructure$Type)>
static readonly "COLD": $OceanRuinStructure$Type
static readonly "WARM": $OceanRuinStructure$Type

public "getName"(): StringJS
public static "values"(): ($OceanRuinStructure$Type)[]
public static "valueOf"(arg0: StringJS): $OceanRuinStructure$Type
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "name"(): StringJS
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OceanRuinStructure$Type$$Type = (("warm") | ("cold"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OceanRuinStructure$Type$$Original = $OceanRuinStructure$Type;}
declare module "net.minecraft.world.level.levelgen.blending.Blender$DistanceGetter" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Blender$DistanceGetter$$Interface {

(arg0: double, arg1: double, arg2: double): double
}

export class $Blender$DistanceGetter implements $Blender$DistanceGetter$$Interface {
 "getDistance"(arg0: double, arg1: double, arg2: double): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Blender$DistanceGetter$$Type = ((arg0: double, arg1: double, arg2: double) => double);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Blender$DistanceGetter$$Original = $Blender$DistanceGetter;}
declare module "net.minecraft.world.level.levelgen.feature.featuresize.TwoLayersFeatureSize" {
import {$FeatureSizeType} from "net.minecraft.world.level.levelgen.feature.featuresize.FeatureSizeType"
import {$OptionalInt$$Type} from "java.util.OptionalInt"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$FeatureSize} from "net.minecraft.world.level.levelgen.feature.featuresize.FeatureSize"

export class $TwoLayersFeatureSize extends $FeatureSize {
static readonly "CODEC": $MapCodec<($TwoLayersFeatureSize)>
static readonly "MAX_WIDTH": integer

constructor(arg0: integer, arg1: integer, arg2: integer)
constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $OptionalInt$$Type)

public "type"(): $FeatureSizeType<(never)>
public "getSizeAtHeight"(arg0: integer, arg1: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TwoLayersFeatureSize$$Type = ($TwoLayersFeatureSize);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TwoLayersFeatureSize$$Original = $TwoLayersFeatureSize;}
declare module "net.minecraft.world.level.block.entity.BlastFurnaceBlockEntity" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ReferenceArraySet} from "it.unimi.dsi.fastutil.objects.ReferenceArraySet"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$NonNullList} from "net.minecraft.core.NonNullList"
import {$ContainerData} from "net.minecraft.world.inventory.ContainerData"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AbstractFurnaceBlockEntity} from "net.minecraft.world.level.block.entity.AbstractFurnaceBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlastFurnaceBlockEntity extends $AbstractFurnaceBlockEntity {
 "inventoryChangeListeners": $ReferenceArraySet
readonly "dataAccess": $ContainerData
static readonly "DATA_LIT_DURATION": integer
 "level": $Level
 "cookingTotalTime": integer
static readonly "SLOT_INPUT": integer
static readonly "DATA_COOKING_PROGRESS": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventoryHandlingTypeListeners": $ReferenceArraySet
static readonly "BURN_COOL_SPEED": integer
 "remove": boolean
 "cookingProgress": integer
 "litDuration": integer
 "worldPosition": $BlockPos
static readonly "DATA_COOKING_TOTAL_TIME": integer
static readonly "BURN_TIME_STANDARD": integer
static readonly "SLOT_RESULT": integer
 "lockKey": $LockCode
 "hasComparators": byte
static readonly "NUM_DATA_VALUES": integer
 "litTime": integer
static readonly "DATA_LIT_TIME": integer
 "items": $NonNullList<($ItemStack)>
static readonly "SLOT_FUEL": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getDefaultName"(): $Component
public "getBurnDuration"(arg0: $ItemStack$$Type): integer
public "createMenu"(arg0: integer, arg1: $Inventory$$Type): $AbstractContainerMenu
public "setChanged"(): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public static "tryClear"(arg0: any): void
get "defaultName"(): $Component
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlastFurnaceBlockEntity$$Type = ($BlastFurnaceBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlastFurnaceBlockEntity$$Original = $BlastFurnaceBlockEntity;}
declare module "net.minecraft.world.level.block.state.properties.BooleanProperty" {
import {$Collection} from "java.util.Collection"
import {$Optional} from "java.util.Optional"
import {$Comparable$$Type} from "java.lang.Comparable"
import {$Property} from "net.minecraft.world.level.block.state.properties.Property"

export class $BooleanProperty extends $Property<(boolean)> {
constructor(arg0: StringJS)

public "getName"(arg0: boolean): StringJS
public "getName"(arg0: $Comparable$$Type): StringJS
public "equals"(arg0: any): boolean
public "getValue"(arg0: StringJS): $Optional<(boolean)>
public static "create"(arg0: StringJS): $BooleanProperty
public "generateHashCode"(): integer
public "getPossibleValues"(): $Collection<(boolean)>
get "possibleValues"(): $Collection<(boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanProperty$$Type = ($BooleanProperty);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BooleanProperty$$Original = $BooleanProperty;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$SpikeFeature$EndSpike, $SpikeFeature$EndSpike$$Type} from "net.minecraft.world.level.levelgen.feature.SpikeFeature$EndSpike"

export class $SpikeConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($SpikeConfiguration)>

constructor(arg0: boolean, arg1: $List$$Type<($SpikeFeature$EndSpike$$Type)>, arg2: $BlockPos$$Type)

public "getCrystalBeamTarget"(): $BlockPos
public "isCrystalInvulnerable"(): boolean
public "getSpikes"(): $List<($SpikeFeature$EndSpike)>
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "crystalBeamTarget"(): $BlockPos
get "crystalInvulnerable"(): boolean
get "spikes"(): $List<($SpikeFeature$EndSpike)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpikeConfiguration$$Type = ($SpikeConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpikeConfiguration$$Original = $SpikeConfiguration;}
declare module "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElement" {
import {$StructurePoolElementType} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElementType"
import {$SinglePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.SinglePoolElement"
import {$List, $List$$Type} from "java.util.List"
import {$EmptyPoolElement} from "net.minecraft.world.level.levelgen.structure.pools.EmptyPoolElement"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$ListPoolElement} from "net.minecraft.world.level.levelgen.structure.pools.ListPoolElement"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$StructureProcessorList$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessorList"
import {$Vec3i} from "net.minecraft.core.Vec3i"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StructureTemplate$StructureBlockInfo, $StructureTemplate$StructureBlockInfo$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate$StructureBlockInfo"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$LiquidSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings"
import {$PlacedFeature$$Type} from "net.minecraft.world.level.levelgen.placement.PlacedFeature"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$RecordCodecBuilder} from "com.mojang.serialization.codecs.RecordCodecBuilder"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$FeaturePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.FeaturePoolElement"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$StructureTemplatePool$Projection, $StructureTemplatePool$Projection$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool$Projection"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$LegacySinglePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.LegacySinglePoolElement"

export class $StructurePoolElement {
static readonly "CODEC": $Codec<($StructurePoolElement)>

constructor(arg0: $StructureTemplatePool$Projection$$Type)

public static "legacy"(arg0: StringJS, arg1: $Holder$$Type<($StructureProcessorList)>): $Function<($StructureTemplatePool$Projection), ($LegacySinglePoolElement)>
public static "legacy"(arg0: StringJS): $Function<($StructureTemplatePool$Projection), ($LegacySinglePoolElement)>
public static "list"(arg0: $List$$Type<($Function$$Type<($StructureTemplatePool$Projection$$Type), ($StructurePoolElement$$Type)>)>): $Function<($StructureTemplatePool$Projection), ($ListPoolElement)>
public static "single"(arg0: StringJS, arg1: $LiquidSettings$$Type): $Function<($StructureTemplatePool$Projection), ($SinglePoolElement)>
public static "single"(arg0: StringJS): $Function<($StructureTemplatePool$Projection), ($SinglePoolElement)>
public static "single"(arg0: StringJS, arg1: $Holder$$Type<($StructureProcessorList)>): $Function<($StructureTemplatePool$Projection), ($SinglePoolElement)>
public static "single"(arg0: StringJS, arg1: $Holder$$Type<($StructureProcessorList)>, arg2: $LiquidSettings$$Type): $Function<($StructureTemplatePool$Projection), ($SinglePoolElement)>
public static "empty"(): $Function<($StructureTemplatePool$Projection), ($EmptyPoolElement)>
public static "feature"(arg0: $Holder$$Type<($PlacedFeature)>): $Function<($StructureTemplatePool$Projection), ($FeaturePoolElement)>
public "getType"(): $StructurePoolElementType<(never)>
public "getSize"(arg0: $StructureTemplateManager$$Type, arg1: $Rotation$$Type): $Vec3i
public "getGroundLevelDelta"(): integer
public "getShuffledJigsawBlocks"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type, arg3: $RandomSource$$Type): $List<($StructureTemplate$StructureBlockInfo)>
public "place"(arg0: $StructureTemplateManager$$Type, arg1: $WorldGenLevel$$Type, arg2: $StructureManager$$Type, arg3: $ChunkGenerator$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type, arg6: $Rotation$$Type, arg7: $BoundingBox$$Type, arg8: $RandomSource$$Type, arg9: $LiquidSettings$$Type, arg10: boolean): boolean
public "handleDataMarker"(arg0: $LevelAccessor$$Type, arg1: $StructureTemplate$StructureBlockInfo$$Type, arg2: $BlockPos$$Type, arg3: $Rotation$$Type, arg4: $RandomSource$$Type, arg5: $BoundingBox$$Type): void
public static "projectionCodec"<E extends $StructurePoolElement>(): $RecordCodecBuilder<(E), ($StructureTemplatePool$Projection)>
public "setProjection"(arg0: $StructureTemplatePool$Projection$$Type): $StructurePoolElement
public "getProjection"(): $StructureTemplatePool$Projection
public "getBoundingBox"(arg0: $StructureTemplateManager$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type): $BoundingBox
get "type"(): $StructurePoolElementType<(never)>
get "groundLevelDelta"(): integer
set "projection"(value: $StructureTemplatePool$Projection$$Type)
get "projection"(): $StructureTemplatePool$Projection
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePoolElement$$Type = ($StructurePoolElement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePoolElement$$Original = $StructurePoolElement;}
declare module "net.minecraft.world.level.levelgen.structure.structures.MineshaftStructure$Type" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $MineshaftStructure$Type extends $Enum<($MineshaftStructure$Type)> implements $StringRepresentable$$Interface {
static readonly "MESA": $MineshaftStructure$Type
static readonly "CODEC": $Codec<($MineshaftStructure$Type)>
static readonly "NORMAL": $MineshaftStructure$Type

public "getName"(): StringJS
public static "values"(): ($MineshaftStructure$Type)[]
public static "valueOf"(arg0: StringJS): $MineshaftStructure$Type
public "getSerializedName"(): StringJS
public static "byId"(arg0: integer): $MineshaftStructure$Type
public "getPlanksState"(): $BlockState
public "getWoodState"(): $BlockState
public "getFenceState"(): $BlockState
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "name"(): StringJS
get "serializedName"(): StringJS
get "planksState"(): $BlockState
get "woodState"(): $BlockState
get "fenceState"(): $BlockState
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MineshaftStructure$Type$$Type = (("normal") | ("mesa"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MineshaftStructure$Type$$Original = $MineshaftStructure$Type;}
declare module "net.minecraft.world.level.block.state.BlockBehaviour$OffsetFunction" {
import {$BlockGetter, $BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockBehaviour$OffsetFunction$$Interface {

(arg0: $BlockState, arg1: $BlockGetter, arg2: $BlockPos): $Vec3$$Type
}

export class $BlockBehaviour$OffsetFunction implements $BlockBehaviour$OffsetFunction$$Interface {
 "evaluate"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $Vec3
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviour$OffsetFunction$$Type = ((arg0: $BlockState, arg1: $BlockGetter, arg2: $BlockPos) => $Vec3$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviour$OffsetFunction$$Original = $BlockBehaviour$OffsetFunction;}
declare module "net.minecraft.world.level.levelgen.structure.StructureType" {
import {$NetherFossilStructure} from "net.minecraft.world.level.levelgen.structure.structures.NetherFossilStructure"
import {$MineshaftStructure} from "net.minecraft.world.level.levelgen.structure.structures.MineshaftStructure"
import {$NetherFortressStructure} from "net.minecraft.world.level.levelgen.structure.structures.NetherFortressStructure"
import {$StrongholdStructure} from "net.minecraft.world.level.levelgen.structure.structures.StrongholdStructure"
import {$ShipwreckStructure} from "net.minecraft.world.level.levelgen.structure.structures.ShipwreckStructure"
import {$EndCityStructure} from "net.minecraft.world.level.levelgen.structure.structures.EndCityStructure"
import {$DesertPyramidStructure} from "net.minecraft.world.level.levelgen.structure.structures.DesertPyramidStructure"
import {$JungleTempleStructure} from "net.minecraft.world.level.levelgen.structure.structures.JungleTempleStructure"
import {$IglooStructure} from "net.minecraft.world.level.levelgen.structure.structures.IglooStructure"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$SwampHutStructure} from "net.minecraft.world.level.levelgen.structure.structures.SwampHutStructure"
import {$JigsawStructure} from "net.minecraft.world.level.levelgen.structure.structures.JigsawStructure"
import {$RuinedPortalStructure} from "net.minecraft.world.level.levelgen.structure.structures.RuinedPortalStructure"
import {$OceanMonumentStructure} from "net.minecraft.world.level.levelgen.structure.structures.OceanMonumentStructure"
import {$OceanRuinStructure} from "net.minecraft.world.level.levelgen.structure.structures.OceanRuinStructure"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$WoodlandMansionStructure} from "net.minecraft.world.level.levelgen.structure.structures.WoodlandMansionStructure"
import {$BuriedTreasureStructure} from "net.minecraft.world.level.levelgen.structure.structures.BuriedTreasureStructure"

export interface $StructureType$$Interface<S extends $Structure> {

(): $MapCodec$$Type<(S)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenStructureType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenStructureTypeTag
}

export class $StructureType<S extends $Structure> implements $StructureType$$Interface {
static readonly "STRONGHOLD": $StructureType<($StrongholdStructure)>
static readonly "RUINED_PORTAL": $StructureType<($RuinedPortalStructure)>
static readonly "MINESHAFT": $StructureType<($MineshaftStructure)>
static readonly "NETHER_FOSSIL": $StructureType<($NetherFossilStructure)>
static readonly "IGLOO": $StructureType<($IglooStructure)>
static readonly "SHIPWRECK": $StructureType<($ShipwreckStructure)>
static readonly "SWAMP_HUT": $StructureType<($SwampHutStructure)>
static readonly "JIGSAW": $StructureType<($JigsawStructure)>
static readonly "JUNGLE_TEMPLE": $StructureType<($JungleTempleStructure)>
static readonly "FORTRESS": $StructureType<($NetherFortressStructure)>
static readonly "OCEAN_MONUMENT": $StructureType<($OceanMonumentStructure)>
static readonly "DESERT_PYRAMID": $StructureType<($DesertPyramidStructure)>
static readonly "END_CITY": $StructureType<($EndCityStructure)>
static readonly "WOODLAND_MANSION": $StructureType<($WoodlandMansionStructure)>
static readonly "BURIED_TREASURE": $StructureType<($BuriedTreasureStructure)>
static readonly "OCEAN_RUIN": $StructureType<($OceanRuinStructure)>

 "codec"(): $MapCodec<(S)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureType$$Type<S> = (Special.WorldgenStructureType) | (() => $MapCodec$$Type<(S)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureType$$Original<S> = $StructureType<(S)>;}
declare module "net.minecraft.world.level.levelgen.GenerationStep$Decoration" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $GenerationStep$Decoration extends $Enum<($GenerationStep$Decoration)> implements $StringRepresentable$$Interface {
static readonly "RAW_GENERATION": $GenerationStep$Decoration
static readonly "UNDERGROUND_STRUCTURES": $GenerationStep$Decoration
static readonly "LOCAL_MODIFICATIONS": $GenerationStep$Decoration
static readonly "TOP_LAYER_MODIFICATION": $GenerationStep$Decoration
static readonly "CODEC": $Codec<($GenerationStep$Decoration)>
static readonly "UNDERGROUND_DECORATION": $GenerationStep$Decoration
static readonly "LAKES": $GenerationStep$Decoration
static readonly "SURFACE_STRUCTURES": $GenerationStep$Decoration
static readonly "STRONGHOLDS": $GenerationStep$Decoration
static readonly "FLUID_SPRINGS": $GenerationStep$Decoration
static readonly "VEGETAL_DECORATION": $GenerationStep$Decoration
static readonly "UNDERGROUND_ORES": $GenerationStep$Decoration

public "getName"(): StringJS
public static "values"(): ($GenerationStep$Decoration)[]
public static "valueOf"(arg0: StringJS): $GenerationStep$Decoration
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "name"(): StringJS
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenerationStep$Decoration$$Type = (("raw_generation") | ("lakes") | ("local_modifications") | ("underground_structures") | ("surface_structures") | ("strongholds") | ("underground_ores") | ("underground_decoration") | ("fluid_springs") | ("vegetal_decoration") | ("top_layer_modification"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GenerationStep$Decoration$$Original = $GenerationStep$Decoration;}
declare module "net.minecraft.world.level.levelgen.structure.Structure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$StructureSpawnOverride} from "net.minecraft.world.level.levelgen.structure.StructureSpawnOverride"
import {$BiomeSource$$Type} from "net.minecraft.world.level.biome.BiomeSource"
import {$GenerationStep$Decoration} from "net.minecraft.world.level.levelgen.GenerationStep$Decoration"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function$$Type} from "java.util.function.Function"
import {$HolderSet} from "net.minecraft.core.HolderSet"
import {$TerrainAdjustment} from "net.minecraft.world.level.levelgen.structure.TerrainAdjustment"
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$RecordCodecBuilder$Instance$$Type} from "com.mojang.serialization.codecs.RecordCodecBuilder$Instance"
import {$BoundingBox, $BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$Map} from "java.util.Map"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$RecordCodecBuilder} from "com.mojang.serialization.codecs.RecordCodecBuilder"
import {$StructureStart} from "net.minecraft.world.level.levelgen.structure.StructureStart"
import {$MobCategory} from "net.minecraft.world.entity.MobCategory"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$PiecesContainer$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$StructurePiecesBuilder$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder"
import {$Structure$StructureSettings, $Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"
import {$ModifiableStructureInfo} from "net.neoforged.neoforge.common.world.ModifiableStructureInfo"

export class $Structure {
static readonly "CODEC": $Codec<($Holder<($Structure)>)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "type"(): $StructureType<(never)>
public "step"(): $GenerationStep$Decoration
public "generate"(arg0: $RegistryAccess$$Type, arg1: $ChunkGenerator$$Type, arg2: $BiomeSource$$Type, arg3: $RandomState$$Type, arg4: $StructureTemplateManager$$Type, arg5: long, arg6: $ChunkPos$$Type, arg7: integer, arg8: $LevelHeightAccessor$$Type, arg9: $Predicate$$Type<($Holder<($Biome)>)>): $StructureStart
public "afterPlace"(arg0: $WorldGenLevel$$Type, arg1: $StructureManager$$Type, arg2: $ChunkGenerator$$Type, arg3: $RandomSource$$Type, arg4: $BoundingBox$$Type, arg5: $ChunkPos$$Type, arg6: $PiecesContainer$$Type): void
public static "getLowestY"(arg0: $Structure$GenerationContext$$Type, arg1: integer, arg2: integer): integer
public static "getLowestY"(arg0: $Structure$GenerationContext$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer): integer
/**
 * 
 * @deprecated
 */
public "getLowestYIn5by5BoxOffset7Blocks"(arg0: $Structure$GenerationContext$$Type, arg1: $Rotation$$Type): $BlockPos
public "getModifiedStructureSettings"(): $Structure$StructureSettings
public static "simpleCodec"<S extends $Structure>(arg0: $Function$$Type<($Structure$StructureSettings), (S)>): $MapCodec<(S)>
public static "settingsCodec"<S extends $Structure>(arg0: $RecordCodecBuilder$Instance$$Type<(S)>): $RecordCodecBuilder<(S), ($Structure$StructureSettings)>
public "spawnOverrides"(): $Map<($MobCategory), ($StructureSpawnOverride)>
public static "onTopOfChunkCenter"(arg0: $Structure$GenerationContext$$Type, arg1: $Heightmap$Types$$Type, arg2: $Consumer$$Type<($StructurePiecesBuilder)>): $Optional<($Structure$GenerationStub)>
public "terrainAdaptation"(): $TerrainAdjustment
public "adjustBoundingBox"(arg0: $BoundingBox$$Type): $BoundingBox
public "modifiableStructureInfo"(): $ModifiableStructureInfo
public "findValidGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public static "getMeanFirstOccupiedHeight"(arg0: $Structure$GenerationContext$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer): integer
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
public "biomes"(): $HolderSet<($Biome)>
get "modifiedStructureSettings"(): $Structure$StructureSettings
set "tingsCodec"(value: $RecordCodecBuilder$Instance$$Type<(S)>)
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenStructure
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenStructureTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Structure$$Type = (Special.WorldgenStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Structure$$Original = $Structure;}
declare module "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext" {
import {$WorldGenLevel, $WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$ConfiguredFeature, $ConfiguredFeature$$Type} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$ChunkGenerator, $ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$FeatureConfiguration, $FeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $FeaturePlaceContext<FC extends $FeatureConfiguration> {
constructor(arg0: ($ConfiguredFeature$$Type<(never), (never)>)?, arg1: $WorldGenLevel$$Type, arg2: $ChunkGenerator$$Type, arg3: $RandomSource$$Type, arg4: $BlockPos$$Type, arg5: FC)

public "random"(): $RandomSource
public "config"(): FC
public "level"(): $WorldGenLevel
public "origin"(): $BlockPos
public "chunkGenerator"(): $ChunkGenerator
public "topFeature"(): $Optional<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FeaturePlaceContext$$Type<FC> = ($FeaturePlaceContext<(FC)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FeaturePlaceContext$$Original<FC> = $FeaturePlaceContext<(FC)>;}
declare module "net.minecraft.world.level.block.state.properties.WallSide" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $WallSide extends $Enum<($WallSide)> implements $StringRepresentable$$Interface {
static readonly "LOW": $WallSide
static readonly "TALL": $WallSide
static readonly "NONE": $WallSide

public "toString"(): StringJS
public static "values"(): ($WallSide)[]
public static "valueOf"(arg0: StringJS): $WallSide
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WallSide$$Type = (("none") | ("low") | ("tall"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WallSide$$Original = $WallSide;}
declare module "net.minecraft.world.level.pathfinder.PathTypeCache" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$PathType} from "net.minecraft.world.level.pathfinder.PathType"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $PathTypeCache {
constructor()

public "invalidate"(arg0: $BlockPos$$Type): void
public "getOrCompute"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): $PathType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathTypeCache$$Type = ($PathTypeCache);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PathTypeCache$$Original = $PathTypeCache;}
declare module "net.minecraft.world.level.levelgen.structure.structures.RuinedPortalStructure$Setup" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$RuinedPortalPiece$VerticalPlacement, $RuinedPortalPiece$VerticalPlacement$$Type} from "net.minecraft.world.level.levelgen.structure.structures.RuinedPortalPiece$VerticalPlacement"
import {$Record} from "java.lang.Record"

export class $RuinedPortalStructure$Setup extends $Record {
static readonly "CODEC": $Codec<($RuinedPortalStructure$Setup)>

constructor(arg0: $RuinedPortalPiece$VerticalPlacement$$Type, arg1: float, arg2: float, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean, arg7: float)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "placement"(): $RuinedPortalPiece$VerticalPlacement
public "mossiness"(): float
public "weight"(): float
public "replaceWithBlackstone"(): boolean
public "airPocketProbability"(): float
public "canBeCold"(): boolean
public "overgrown"(): boolean
public "vines"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuinedPortalStructure$Setup$$Type = ({"canBeCold"?: boolean, "overgrown"?: boolean, "airPocketProbability"?: float, "placement"?: $RuinedPortalPiece$VerticalPlacement$$Type, "replaceWithBlackstone"?: boolean, "mossiness"?: float, "weight"?: float, "vines"?: boolean}) | ([canBeCold?: boolean, overgrown?: boolean, airPocketProbability?: float, placement?: $RuinedPortalPiece$VerticalPlacement$$Type, replaceWithBlackstone?: boolean, mossiness?: float, weight?: float, vines?: boolean]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuinedPortalStructure$Setup$$Original = $RuinedPortalStructure$Setup;}
declare module "net.minecraft.world.level.gameevent.GameEvent$Context" {
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Record} from "java.lang.Record"

export class $GameEvent$Context extends $Record {
constructor(arg0: $Entity$$Type, arg1: $BlockState$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "of"(arg0: $Entity$$Type): $GameEvent$Context
public static "of"(arg0: $BlockState$$Type): $GameEvent$Context
public static "of"(arg0: $Entity$$Type, arg1: $BlockState$$Type): $GameEvent$Context
public "sourceEntity"(): $Entity
public "affectedState"(): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameEvent$Context$$Type = ({"affectedState"?: $BlockState$$Type, "sourceEntity"?: $Entity$$Type}) | ([affectedState?: $BlockState$$Type, sourceEntity?: $Entity$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameEvent$Context$$Original = $GameEvent$Context;}
declare module "net.minecraft.world.level.block.RenderShape" {
import {$Enum} from "java.lang.Enum"

export class $RenderShape extends $Enum<($RenderShape)> {
static readonly "INVISIBLE": $RenderShape
static readonly "MODEL": $RenderShape
static readonly "ENTITYBLOCK_ANIMATED": $RenderShape

public static "values"(): ($RenderShape)[]
public static "valueOf"(arg0: StringJS): $RenderShape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RenderShape$$Type = (("invisible") | ("entityblock_animated") | ("model"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RenderShape$$Original = $RenderShape;}
declare module "net.minecraft.world.level.block.entity.StructureBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Mirror, $Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Level} from "net.minecraft.world.level.Level"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$StructureMode, $StructureMode$$Type} from "net.minecraft.world.level.block.state.properties.StructureMode"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$Vec3i, $Vec3i$$Type} from "net.minecraft.core.Vec3i"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Rotation, $Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $StructureBlockEntity extends $BlockEntity {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "AUTHOR_TAG": StringJS
static readonly "MAX_OFFSET_PER_AXIS": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean
static readonly "MAX_SIZE_PER_AXIS": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "setSeed"(arg0: long): void
public "getSeed"(): long
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "placeStructure"(arg0: $ServerLevel$$Type): void
public "unloadStructure"(): void
public "saveStructure"(arg0: boolean): boolean
public "saveStructure"(): boolean
public "setStructureSize"(arg0: $Vec3i$$Type): void
public "getStructureName"(): StringJS
public "setRotation"(arg0: $Rotation$$Type): void
public "loadStructureInfo"(arg0: $ServerLevel$$Type): boolean
public static "createRandom"(arg0: long): $RandomSource
public "getIntegrity"(): float
public "setStructureName"(arg0: StringJS): void
public "setStructureName"(arg0: $ResourceLocation$$Type): void
public "hasStructureName"(): boolean
public "setStructurePos"(arg0: $BlockPos$$Type): void
public "setMetaData"(arg0: StringJS): void
public "setIgnoreEntities"(arg0: boolean): void
public "getStructurePos"(): $BlockPos
public "getMetaData"(): StringJS
public "setIntegrity"(arg0: float): void
public "getShowBoundingBox"(): boolean
public "getStructureSize"(): $Vec3i
public "isIgnoreEntities"(): boolean
public "setShowBoundingBox"(arg0: boolean): void
public "setMode"(arg0: $StructureMode$$Type): void
public "getMode"(): $StructureMode
public "createdBy"(arg0: $LivingEntity$$Type): void
public "usedBy"(arg0: $Player$$Type): boolean
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "setMirror"(arg0: $Mirror$$Type): void
public "detectSize"(): boolean
public "setShowAir"(arg0: boolean): void
public "getShowAir"(): boolean
public "getMirror"(): $Mirror
public "getUpdatePacket"(): $Packet
public "isPowered"(): boolean
public "setPowered"(arg0: boolean): void
public "getRotation"(): $Rotation
public "placeStructureIfSameSize"(arg0: $ServerLevel$$Type): boolean
public "isStructureLoadable"(): boolean
set "seed"(value: long)
get "seed"(): long
set "structureSize"(value: $Vec3i$$Type)
get "structureName"(): StringJS
set "rotation"(value: $Rotation$$Type)
get "integrity"(): float
set "structureName"(value: StringJS)
set "structureName"(value: $ResourceLocation$$Type)
set "structurePos"(value: $BlockPos$$Type)
set "metaData"(value: StringJS)
set "ignoreEntities"(value: boolean)
get "structurePos"(): $BlockPos
get "metaData"(): StringJS
set "integrity"(value: float)
get "showBoundingBox"(): boolean
get "structureSize"(): $Vec3i
get "ignoreEntities"(): boolean
set "showBoundingBox"(value: boolean)
set "mode"(value: $StructureMode$$Type)
get "mode"(): $StructureMode
set "mirror"(value: $Mirror$$Type)
set "showAir"(value: boolean)
get "showAir"(): boolean
get "mirror"(): $Mirror
get "updatePacket"(): $Packet
get "powered"(): boolean
set "powered"(value: boolean)
get "rotation"(): $Rotation
get "structureLoadable"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureBlockEntity$$Type = ($StructureBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureBlockEntity$$Original = $StructureBlockEntity;}
declare module "net.minecraft.world.level.block.state.properties.ChestType" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $ChestType extends $Enum<($ChestType)> implements $StringRepresentable$$Interface {
static readonly "SINGLE": $ChestType
static readonly "LEFT": $ChestType
static readonly "RIGHT": $ChestType

public static "values"(): ($ChestType)[]
public static "valueOf"(arg0: StringJS): $ChestType
public "getOpposite"(): $ChestType
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "opposite"(): $ChestType
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestType$$Type = (("single") | ("left") | ("right"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestType$$Original = $ChestType;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Stream} from "java.util.stream.Stream"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $SpringConfiguration implements $FeatureConfiguration$$Interface {
readonly "holeCount": integer
static readonly "CODEC": $Codec<($SpringConfiguration)>
readonly "rockCount": integer
readonly "requiresBlockBelow": boolean
readonly "state": $FluidState
readonly "validBlocks": $HolderSet<($Block)>

constructor(arg0: $FluidState$$Type, arg1: boolean, arg2: integer, arg3: integer, arg4: $HolderSet$$Type<($Block)>)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpringConfiguration$$Type = ($SpringConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpringConfiguration$$Original = $SpringConfiguration;}
declare module "net.minecraft.world.level.levelgen.structure.StructureSpawnOverride" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$StructureSpawnOverride$BoundingBoxType, $StructureSpawnOverride$BoundingBoxType$$Type} from "net.minecraft.world.level.levelgen.structure.StructureSpawnOverride$BoundingBoxType"
import {$WeightedRandomList, $WeightedRandomList$$Type} from "net.minecraft.util.random.WeightedRandomList"
import {$MobSpawnSettings$SpawnerData, $MobSpawnSettings$SpawnerData$$Type} from "net.minecraft.world.level.biome.MobSpawnSettings$SpawnerData"
import {$Record} from "java.lang.Record"

export class $StructureSpawnOverride extends $Record {
static readonly "CODEC": $Codec<($StructureSpawnOverride)>

constructor(arg0: $StructureSpawnOverride$BoundingBoxType$$Type, arg1: $WeightedRandomList$$Type<($MobSpawnSettings$SpawnerData$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "spawns"(): $WeightedRandomList<($MobSpawnSettings$SpawnerData)>
public "boundingBox"(): $StructureSpawnOverride$BoundingBoxType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureSpawnOverride$$Type = ({"spawns"?: $WeightedRandomList$$Type<($MobSpawnSettings$SpawnerData$$Type)>, "boundingBox"?: $StructureSpawnOverride$BoundingBoxType$$Type}) | ([spawns?: $WeightedRandomList$$Type<($MobSpawnSettings$SpawnerData$$Type)>, boundingBox?: $StructureSpawnOverride$BoundingBoxType$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureSpawnOverride$$Original = $StructureSpawnOverride;}
declare module "net.minecraft.world.level.block.state.StateHolder" {
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Optional} from "java.util.Optional"
import {$FastMapStateHolder$$Interface} from "malte0811.ferritecore.ducks.FastMapStateHolder"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Reference2ObjectArrayMap$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectArrayMap"
import {$Reference2ObjectMap, $Reference2ObjectMap$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectMap"
import {$FastMap, $FastMap$$Type} from "malte0811.ferritecore.fastmap.FastMap"
import {$Map$Entry} from "java.util.Map$Entry"
import {$Table, $Table$$Type} from "com.google.common.collect.Table"
import {$StateHolderAccessor$$Interface} from "com.simibubi.create.foundation.mixin.accessor.StateHolderAccessor"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $StateHolder<O, S> implements $FastMapStateHolder$$Interface, $StateHolderAccessor$$Interface {
static readonly "PROPERTIES_TAG": StringJS
readonly "owner": O
static readonly "PROPERTY_ENTRY_TO_STRING_FUNCTION": $Function<($Map$Entry<($Property<(never)>), ($Comparable<(never)>)>), (StringJS)>
static readonly "NAME_TAG": StringJS
readonly "propertiesCodec": $MapCodec<(S)>

constructor(arg0: O, arg1: $Reference2ObjectArrayMap$$Type<($Property$$Type<(never)>), ($Comparable$$Type<(never)>)>, arg2: $MapCodec$$Type<(S)>)

public "toString"(): StringJS
public "getValue"<T extends $Comparable<(object)>>(arg0: $Property$$Type<(T)>): T
public "getProperties"(): $Collection<($Property<(never)>)>
public "setValue"<T extends $Comparable<(object)>, V extends $Comparable<(object)>>(arg0: $Property$$Type<(T)>, arg1: V): S
public "getOwner"(): any
public "getValues"(): $Map<($Property<(never)>), ($Comparable<(never)>)>
public static "findNextInCollection"<T>(arg0: $Collection$$Type<(T)>, arg1: T): T
public "getVanillaPropertyMap"(): $Reference2ObjectMap
public "getOptionalValue"<T extends $Comparable<(object)>>(arg0: $Property$$Type<(T)>): $Optional<(T)>
public "setStateMap"(arg0: $FastMap$$Type): void
public "getStateMap"(): $FastMap
public "setStateIndex"(arg0: integer): void
public "trySetValue"<T extends $Comparable<(object)>, V extends $Comparable<(object)>>(arg0: $Property$$Type<(T)>, arg1: V): S
public "setNeighborTable"(arg0: $Table$$Type): void
public "populateNeighbours"(arg0: $Map$$Type): void
public "getNeighborTable"(): $Table
public "getStateIndex"(): integer
public "hasProperty"<T extends $Comparable<(object)>>(arg0: $Property$$Type<(T)>): boolean
public "cycle"<T extends $Comparable<(object)>>(arg0: $Property$$Type<(T)>): S
public static "codec"<O, S extends $StateHolder<(object), (object)>>(arg0: $Codec$$Type<(O)>, arg1: $Function$$Type<(O), (S)>): $Codec<(S)>
public "replacePropertyMap"(arg0: $Reference2ObjectMap$$Type): void
public "redirect$fkf000$ferritecore$getNeighborFromFastMap"(arg0: $Table$$Type, arg1: any, arg2: any): any
get "properties"(): $Collection<($Property<(never)>)>
get "values"(): $Map<($Property<(never)>), ($Comparable<(never)>)>
get "vanillaPropertyMap"(): $Reference2ObjectMap
set "stateMap"(value: $FastMap$$Type)
get "stateMap"(): $FastMap
set "stateIndex"(value: integer)
set "neighborTable"(value: $Table$$Type)
get "neighborTable"(): $Table
get "stateIndex"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StateHolder$$Type<O, S> = ($StateHolder<(O), (S)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StateHolder$$Original<O, S> = $StateHolder<(O), (S)>;}
declare module "net.minecraft.world.level.block.entity.CampfireBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$TickingBlockEntity, $TickingBlockEntity$$Type} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$Optional} from "java.util.Optional"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$NonNullList} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Clearable$$Interface} from "net.minecraft.world.Clearable"
import {$BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$RecipeHolder} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$SleepingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SleepingBlockEntity"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$WrappedBlockEntityTickInvokerAccessor, $WrappedBlockEntityTickInvokerAccessor$$Type} from "net.caffeinemc.mods.lithium.mixin.world.block_entity_ticking.sleeping.WrappedBlockEntityTickInvokerAccessor"
import {$CampfireCookingRecipe} from "net.minecraft.world.item.crafting.CampfireCookingRecipe"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CampfireBlockEntity extends $BlockEntity implements $Clearable$$Interface, $SleepingBlockEntity$$Interface {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
readonly "cookingTime": (integer)[]
 "remove": boolean
readonly "cookingProgress": (integer)[]

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "getCookableRecipe"(arg0: $ItemStack$$Type): $Optional<($RecipeHolder<($CampfireCookingRecipe)>)>
public static "particleTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $CampfireBlockEntity$$Type): void
public static "cooldownTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $CampfireBlockEntity$$Type): void
public "getItems"(): $NonNullList<($ItemStack)>
public "placeFood"(arg0: $LivingEntity$$Type, arg1: $ItemStack$$Type, arg2: integer): boolean
public static "cookTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $CampfireBlockEntity$$Type): void
public "lithium$setTickWrapper"(arg0: $WrappedBlockEntityTickInvokerAccessor$$Type): void
public "lithium$getSleepingTicker"(): $TickingBlockEntity
public "lithium$getTickWrapper"(): $WrappedBlockEntityTickInvokerAccessor
public "lithium$setSleepingTicker"(arg0: $TickingBlockEntity$$Type): void
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdatePacket"(): $Packet
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "clearContent"(): void
public "dowse"(): void
public "collectImplicitComponents"(arg0: $DataComponentMap$Builder$$Type): void
public "applyImplicitComponents"(arg0: $BlockEntity$DataComponentInput$$Type): void
public static "tryClear"(arg0: any): void
public "isSleeping"(): boolean
public "setTicker"(arg0: $TickingBlockEntity$$Type): void
public "wakeUpNow"(): void
public "sleepOnlyCurrentTick"(): void
public "lithium$startSleeping"(): boolean
get "items"(): $NonNullList<($ItemStack)>
get "updatePacket"(): $Packet
get "sleeping"(): boolean
set "ticker"(value: $TickingBlockEntity$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CampfireBlockEntity$$Type = ($CampfireBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CampfireBlockEntity$$Original = $CampfireBlockEntity;}
declare module "net.minecraft.world.level.BlockGetter" {
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor, $LevelHeightAccessor$$Interface} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$BlockViewMixin$$Interface} from "net.fabricmc.fabric.mixin.blockview.BlockViewMixin"
import {$Holder} from "net.minecraft.core.Holder"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$FabricBlockView$$Interface} from "net.fabricmc.fabric.api.blockview.v2.FabricBlockView"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$IBlockGetterExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IBlockGetterExtension"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"

export interface $BlockGetter$$Interface extends $LevelHeightAccessor$$Interface, $IBlockGetterExtension$$Interface, $FabricBlockView$$Interface, $BlockViewMixin$$Interface {
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "maxSection"(): integer
get "minSection"(): integer
get "sectionsCount"(): integer
get "height"(): integer
get "minBuildHeight"(): integer
}

export class $BlockGetter implements $BlockGetter$$Interface {
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
 "getMaxLightLevel"(): integer
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getMaxBuildHeight"(): integer
 "getSectionIndex"(arg0: integer): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionsCount"(): integer
 "getHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getMinBuildHeight"(): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
 "getBlockEntityRenderData"(arg0: $BlockPos$$Type): any
 "hasBiomes"(): boolean
 "getBiomeFabric"(arg0: $BlockPos$$Type): $Holder<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockGetter$$Type = ($BlockGetter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockGetter$$Original = $BlockGetter;}
declare module "net.minecraft.world.level.block.entity.AbstractFurnaceBlockEntity" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$List, $List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BaseContainerBlockEntity} from "net.minecraft.world.level.block.entity.BaseContainerBlockEntity"
import {$AbstractFurnaceBlockEntityAccess$$Interface} from "snownee.jade.mixin.AbstractFurnaceBlockEntityAccess"
import {$ContainerData} from "net.minecraft.world.inventory.ContainerData"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$LithiumInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumInventory"
import {$AccessorAbstractFurnaceBlockEntity$$Interface} from "com.illusivesoulworks.polymorph.mixin.core.AccessorAbstractFurnaceBlockEntity"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Either$$Type} from "com.mojang.datafixers.util.Either"
import {$ObjIntConsumer$$Type} from "java.util.function.ObjIntConsumer"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$SealReactiveBlock$$Interface} from "com.lightning.northstar.world.sealer.SealReactiveBlock"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WrappedBlockEntityTickInvokerAccessor, $WrappedBlockEntityTickInvokerAccessor$$Type} from "net.caffeinemc.mods.lithium.mixin.world.block_entity_ticking.sleeping.WrappedBlockEntityTickInvokerAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TickingBlockEntity, $TickingBlockEntity$$Type} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$Map, $Map$$Type} from "java.util.Map"
import {$ReferenceArraySet} from "it.unimi.dsi.fastutil.objects.ReferenceArraySet"
import {$SpecialLogicInventory$$Interface} from "net.fabricmc.fabric.impl.transfer.item.SpecialLogicInventory"
import {$RecipeType$$Type} from "net.minecraft.world.item.crafting.RecipeType"
import {$StackedContentsCompatible$$Interface} from "net.minecraft.world.inventory.StackedContentsCompatible"
import {$WorldlyContainer$$Interface} from "net.minecraft.world.WorldlyContainer"
import {$SetChangedHandlingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SetChangedHandlingBlockEntity"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$AbstractCookingRecipe$$Type} from "net.minecraft.world.item.crafting.AbstractCookingRecipe"
import {$InventoryChangeTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$SealingMode$$Type} from "com.lightning.northstar.world.sealer.SealingMode"
import {$NonNullList, $NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$RecipeCraftingHolder$$Interface} from "net.minecraft.world.inventory.RecipeCraftingHolder"
import {$FurnaceBEAccessor$$Interface} from "dev.lopyluna.dndesires.mixins.FurnaceBEAccessor"
import {$RecipeHolder, $RecipeHolder$$Type} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$SleepingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SleepingBlockEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$StackedContents$$Type} from "net.minecraft.world.entity.player.StackedContents"

export class $AbstractFurnaceBlockEntity extends $BaseContainerBlockEntity implements $WorldlyContainer$$Interface, $RecipeCraftingHolder$$Interface, $StackedContentsCompatible$$Interface, $LithiumInventory$$Interface, $InventoryChangeTracker$$Interface, $SleepingBlockEntity$$Interface, $SetChangedHandlingBlockEntity$$Interface, $AccessorAbstractFurnaceBlockEntity$$Interface, $SpecialLogicInventory$$Interface, $AbstractFurnaceBlockEntityAccess$$Interface, $SealReactiveBlock$$Interface, $FurnaceBEAccessor$$Interface {
 "inventoryChangeListeners": $ReferenceArraySet
readonly "dataAccess": $ContainerData
static readonly "DATA_LIT_DURATION": integer
 "level": $Level
 "cookingTotalTime": integer
static readonly "SLOT_INPUT": integer
static readonly "DATA_COOKING_PROGRESS": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventoryHandlingTypeListeners": $ReferenceArraySet
static readonly "BURN_COOL_SPEED": integer
 "remove": boolean
 "cookingProgress": integer
 "litDuration": integer
 "worldPosition": $BlockPos
static readonly "DATA_COOKING_TOTAL_TIME": integer
static readonly "BURN_TIME_STANDARD": integer
static readonly "SLOT_RESULT": integer
 "lockKey": $LockCode
 "hasComparators": byte
static readonly "NUM_DATA_VALUES": integer
 "litTime": integer
static readonly "DATA_LIT_TIME": integer
 "items": $NonNullList<($ItemStack)>
static readonly "SLOT_FUEL": integer

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $RecipeType$$Type<($AbstractCookingRecipe$$Type)>)

public static "add"(arg0: $Map$$Type<($Item$$Type), (integer)>, arg1: $TagKey$$Type<($Item)>, arg2: integer): void
public static "add"(arg0: $Map$$Type<($Item$$Type), (integer)>, arg1: $ItemLike$$Type, arg2: integer): void
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "awardUsedRecipesAndPopExperience"(arg0: $ServerPlayer$$Type): void
public "getContainerSize"(): integer
public "getRecipesToAwardAndPopExperience"(arg0: $ServerLevel$$Type, arg1: $Vec3$$Type): $List<($RecipeHolder<(never)>)>
/**
 * 
 * @deprecated
 */
public static "getFuel"(): $Map<($Item), (integer)>
public static "buildFuels"(arg0: $ObjIntConsumer$$Type<($Either<($Item), ($TagKey<($Item)>)>)>): void
public static "isFuel"(arg0: $ItemStack$$Type): boolean
public "getItems"(): $NonNullList
public "getCookingTotalTime"(): integer
public "lithium$setTickWrapper"(arg0: $WrappedBlockEntityTickInvokerAccessor$$Type): void
public "lithium$getSleepingTicker"(): $TickingBlockEntity
public "getCookingTotalTime$D2D"(): integer
public "getCookingProgress$D2D"(): integer
public "canTakeItemThroughFace"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "lithium$getTickWrapper"(): $WrappedBlockEntityTickInvokerAccessor
public "canPlaceItemThroughFace"(arg0: integer, arg1: $ItemStack$$Type, arg2: $Direction$$Type): boolean
public "lithium$setSleepingTicker"(arg0: $TickingBlockEntity$$Type): void
public "fillStackedContents"(arg0: $StackedContents$$Type): void
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "northstar$onSealUpdated"(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, mode: $SealingMode$$Type): void
public "fabric_setSuppress"(arg0: boolean): void
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $AbstractFurnaceBlockEntity$$Type): void
public "setItems"(arg0: $NonNullList$$Type<($ItemStack$$Type)>): void
public "handler$emh000$fabric_transfer_api_v1$setStackSuppressUpdate"(arg0: integer, arg1: $ItemStack$$Type, arg2: $CallbackInfo$$Type): void
public "lithium$handleSetChanged"(): void
public "getInventoryLithium"(): $NonNullList
public "setInventoryLithium"(arg0: $NonNullList$$Type): void
public "fabric_onFinalCommit"(arg0: integer, arg1: $ItemStack$$Type, arg2: $ItemStack$$Type): void
public "setRecipeUsed"(arg0: $RecipeHolder$$Type<(never)>): void
public "awardUsedRecipes"(arg0: $Player$$Type, arg1: $List$$Type<($ItemStack$$Type)>): void
public static "invalidateCache"(): void
public "getBurnDuration"(arg0: $ItemStack$$Type): integer
public "getRecipeUsed"(): $RecipeHolder<(never)>
public "getCookingProgress"(): integer
public "getSlotsForFace"(arg0: $Direction$$Type): (integer)[]
public "setRecipeUsed"(arg0: $Level$$Type, arg1: $ServerPlayer$$Type, arg2: $RecipeHolder$$Type<(never)>): boolean
public "generateLootLithium"(): void
public "stopListenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "listenForMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "listenForContentChangesOnce"(arg0: $LithiumStackList$$Type, arg1: $InventoryChangeListener$$Type): void
public "isSleeping"(): boolean
public "setTicker"(arg0: $TickingBlockEntity$$Type): void
public "wakeUpNow"(): void
public "sleepOnlyCurrentTick"(): void
public "lithium$startSleeping"(): boolean
public "setChanged"(): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public static "tryClear"(arg0: any): void
get "containerSize"(): integer
get "fuel"(): $Map<($Item), (integer)>
get "cookingTotalTime$D2D"(): integer
get "cookingProgress$D2D"(): integer
get "inventoryLithium"(): $NonNullList
set "inventoryLithium"(value: $NonNullList$$Type)
set "recipeUsed"(value: $RecipeHolder$$Type<(never)>)
get "recipeUsed"(): $RecipeHolder<(never)>
get "sleeping"(): boolean
set "ticker"(value: $TickingBlockEntity$$Type)
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractFurnaceBlockEntity$$Type = ($AbstractFurnaceBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AbstractFurnaceBlockEntity$$Original = $AbstractFurnaceBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.MegaJungleFoliagePlacer" {
import {$FoliagePlacerType} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacerType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$FoliagePlacer$FoliageSetter$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageSetter"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$FoliagePlacer$FoliageAttachment$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $MegaJungleFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($MegaJungleFoliagePlacer)>
readonly "offset": $IntProvider
readonly "radius": $IntProvider
readonly "height": integer

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: integer)

public "type"(): $FoliagePlacerType<(never)>
public "createFoliage"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: integer, arg5: $FoliagePlacer$FoliageAttachment$$Type, arg6: integer, arg7: integer, arg8: integer): void
public "shouldSkipLocation"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: boolean): boolean
public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MegaJungleFoliagePlacer$$Type = ($MegaJungleFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MegaJungleFoliagePlacer$$Original = $MegaJungleFoliagePlacer;}
declare module "net.minecraft.world.level.block.entity.ChiseledBookShelfBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$Container, $Container$$Type, $Container$$Interface} from "net.minecraft.world.Container"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$LithiumTransferConditionInventory$$Interface} from "net.caffeinemc.mods.lithium.api.inventory.LithiumTransferConditionInventory"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$Set$$Type} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ChiseledBookShelfBlockEntity extends $BlockEntity implements $Container$$Interface, $LithiumTransferConditionInventory$$Interface {
 "worldPosition": $BlockPos
static readonly "MAX_BOOKS_IN_STORAGE": integer
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "isEmpty"(): boolean
public "count"(): integer
public "getItem"(arg0: integer): $ItemStack
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "removeItemNoUpdate"(arg0: integer): $ItemStack
public "getContainerSize"(): integer
public "getLastInteractedSlot"(): integer
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getMaxStackSize"(): integer
public "stillValid"(arg0: $Player$$Type): boolean
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public "clearContent"(): void
public "canTakeItem"(arg0: $Container$$Type, arg1: integer, arg2: $ItemStack$$Type): boolean
public "lithium$itemInsertionTestRequiresStackSize1"(): boolean
public "collectImplicitComponents"(arg0: $DataComponentMap$Builder$$Type): void
public "applyImplicitComponents"(arg0: $BlockEntity$DataComponentInput$$Type): void
public "getMaxStackSize"(arg0: $ItemStack$$Type): integer
public "hasAnyMatching"(arg0: $Predicate$$Type<($ItemStack)>): boolean
public "setChanged"(): void
public "stopOpen"(arg0: $Player$$Type): void
public "hasAnyOf"(arg0: $Set$$Type<($Item$$Type)>): boolean
public "countItem"(arg0: $Item$$Type): integer
public "startOpen"(arg0: $Player$$Type): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public static "tryClear"(arg0: any): void
public "canReceiveTransferCooldown"(): boolean
public "setTransferCooldown"(arg0: long): void
public "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "getWidth"(): integer
public "getHeight"(): integer
public "isMutable"(): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
public "getSlots"(): integer
public "getSlotLimit"(slot: integer): integer
public "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
public "setChanged"(): void
public "getStackInSlot"(slot: integer): $ItemStack
public "asContainer"(): $Container
public "clear"(): void
public "self"(): $Container
public "getBlock"(level: $Level$$Type): $LevelBlock
public "isEmpty"(): boolean
public "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
public "countNonEmpty"(): integer
public "countNonEmpty"(match: $ItemPredicate$$Type): integer
public "getAllItems"(): $List<($ItemStack)>
public "clear"(match: $ItemPredicate$$Type): void
public "find"(): integer
public "find"(match: $ItemPredicate$$Type): integer
public "count"(): integer
public "count"(match: $ItemPredicate$$Type): integer
get "empty"(): boolean
get "containerSize"(): integer
get "lastInteractedSlot"(): integer
get "maxStackSize"(): integer
get "changed"(): void
set "transferCooldown"(value: long)
get "width"(): integer
get "height"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "changed"(): void
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChiseledBookShelfBlockEntity$$Type = ($ChiseledBookShelfBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChiseledBookShelfBlockEntity$$Original = $ChiseledBookShelfBlockEntity;}
declare module "net.minecraft.world.level.storage.LevelVersion" {
import {$Dynamic$$Type} from "com.mojang.serialization.Dynamic"
import {$DataVersion} from "net.minecraft.world.level.storage.DataVersion"

export class $LevelVersion {
public "snapshot"(): boolean
public static "parse"(arg0: $Dynamic$$Type<(never)>): $LevelVersion
public "lastPlayed"(): long
public "minecraftVersion"(): $DataVersion
public "levelDataVersion"(): integer
public "minecraftVersionName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelVersion$$Type = ($LevelVersion);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelVersion$$Original = $LevelVersion;}
declare module "net.minecraft.world.level.block.state.BlockBehaviour" {
import {$BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$LootParams$Builder$$Type} from "net.minecraft.world.level.storage.loot.LootParams$Builder"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Projectile$$Type} from "net.minecraft.world.entity.projectile.Projectile"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$Holder} from "net.minecraft.core.Holder"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$FeatureElement$$Interface} from "net.minecraft.world.flag.FeatureElement"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$SoundType, $SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$PathComputationType$$Type} from "net.minecraft.world.level.pathfinder.PathComputationType"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$AbstractBlockAccessor$$Interface} from "net.fabricmc.fabric.mixin.object.builder.AbstractBlockAccessor"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$FeatureFlagSet, $FeatureFlagSet$$Type} from "net.minecraft.world.flag.FeatureFlagSet"
import {$MapColor} from "net.minecraft.world.level.material.MapColor"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$List} from "java.util.List"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$MenuProvider} from "net.minecraft.world.MenuProvider"
import {$BlockBehaviourKJS$$Interface} from "dev.latvian.mods.kubejs.core.BlockBehaviourKJS"
import {$Function$$Type} from "java.util.function.Function"
import {$Item} from "net.minecraft.world.item.Item"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Map} from "java.util.Map"
import {$RenderShape} from "net.minecraft.world.level.block.RenderShape"
import {$BlockBehaviourInvoker$$Interface} from "org.embeddedt.modernfix.common.mixin.perf.reduce_blockstate_cache_rebuilds.BlockBehaviourInvoker"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockBehaviourAccessor$$Interface} from "com.simibubi.create.foundation.mixin.accessor.BlockBehaviourAccessor"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$ItemInteractionResult} from "net.minecraft.world.ItemInteractionResult"
import {$RecordCodecBuilder} from "com.mojang.serialization.codecs.RecordCodecBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ShapeUpdateHandlingBlockBehaviour$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.ShapeUpdateHandlingBlockBehaviour"

export class $BlockBehaviour implements $FeatureElement$$Interface, $BlockBehaviourInvoker$$Interface, $ShapeUpdateHandlingBlockBehaviour$$Interface, $AbstractBlockAccessor$$Interface, $BlockBehaviourKJS$$Interface, $BlockBehaviourAccessor$$Interface {
 "explosionResistance": float
 "drops": $ResourceKey<($LootTable)>
readonly "dynamicShape": boolean
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
 "speedFactor": float
 "hasCollision": boolean
 "soundType": $SoundType
 "friction": float
 "jumpFactor": float

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getProperties"(): $BlockBehaviour$Properties
public "properties"(): $BlockBehaviour$Properties
public "rotate"(arg0: $BlockState$$Type, arg1: $Rotation$$Type): $BlockState
public "tick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "getSeed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type): long
public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "attack"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): void
public "mirror"(arg0: $BlockState$$Type, arg1: $Mirror$$Type): $BlockState
public "requiredFeatures"(): $FeatureFlagSet
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "useItemOn"(arg0: $ItemStack$$Type, arg1: $BlockState$$Type, arg2: $Level$$Type, arg3: $BlockPos$$Type, arg4: $Player$$Type, arg5: $InteractionHand$$Type, arg6: $BlockHitResult$$Type): $ItemInteractionResult
public "isAir"(arg0: $BlockState$$Type): boolean
public "isCollisionShapeFullBlock"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "getCollisionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "entityInside"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Entity$$Type): void
public "onExplosionHit"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Explosion$$Type, arg4: $BiConsumer$$Type<($ItemStack), ($BlockPos)>): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
public "getLightBlock"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): integer
public "triggerEvent"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: integer, arg4: integer): boolean
public "updateIndirectNeighbourShapes"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: integer, arg4: integer): void
public "asItem"(): $Item
public "getInteractionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "getSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "getRenderShape"(arg0: $BlockState$$Type): $RenderShape
public "getDirectSignal"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): integer
public "isSignalSource"(arg0: $BlockState$$Type): boolean
public "canBeReplaced"(arg0: $BlockState$$Type, arg1: $Fluid$$Type): boolean
public "canBeReplaced"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): boolean
public "codec"(): $MapCodec<($Block)>
public "onRemove"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "onProjectileHit"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockHitResult$$Type, arg3: $Projectile$$Type): void
public "skipRendering"(arg0: $BlockState$$Type, arg1: $BlockState$$Type, arg2: $Direction$$Type): boolean
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public static "simpleCodec"<B extends $Block>(arg0: $Function$$Type<($BlockBehaviour$Properties), (B)>): $MapCodec<(B)>
public "hasAnalogOutputSignal"(arg0: $BlockState$$Type): boolean
public "getDrops"(arg0: $BlockState$$Type, arg1: $LootParams$Builder$$Type): $List<($ItemStack)>
public "asBlock"(): $Block
public "onPlace"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: boolean): void
public "randomTick"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): void
public "spawnAfterBreak"(arg0: $BlockState$$Type, arg1: $ServerLevel$$Type, arg2: $BlockPos$$Type, arg3: $ItemStack$$Type, arg4: boolean): void
public "setSoundType"(arg0: $SoundType$$Type): void
public "setFriction"(arg0: float): void
public "isRandomlyTicking"(arg0: $BlockState$$Type): boolean
public "getMenuProvider"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): $MenuProvider
public "useWithoutItem"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type, arg4: $BlockHitResult$$Type): $InteractionResult
public "getVisualShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "setSpeedFactor"(arg0: float): void
public "defaultMapColor"(): $MapColor
public "create$getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "defaultDestroyTime"(): float
public "getDestroyProgress"(arg0: $BlockState$$Type, arg1: $Player$$Type, arg2: $BlockGetter$$Type, arg3: $BlockPos$$Type): float
public "getShadeBrightness"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): float
public static "propertiesCodec"<B extends $Block>(): $RecordCodecBuilder<(B), ($BlockBehaviour$Properties)>
public "isPathfindable"(arg0: $BlockState$$Type, arg1: $PathComputationType$$Type): boolean
public "getOcclusionShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "setJumpFactor"(arg0: float): void
public "setRandomTickCallback"(callback: $Consumer$$Type): void
public "setIsRandomlyTicking"(arg0: boolean): void
public "invokeGetFluidState"(arg0: $BlockState$$Type): $FluidState
public "getMaxHorizontalOffset"(): float
public "getMaxVerticalOffset"(): float
public "setHasCollision"(arg0: boolean): void
public "setExplosionResistance"(arg0: float): void
public "isOcclusionShapeFullBlock"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "getBlockSupportShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): $VoxelShape
public "propagatesSkylightDown"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type): boolean
public "useShapeForLightOcclusion"(arg0: $BlockState$$Type): boolean
public "getAnalogOutputSignal"(arg0: $BlockState$$Type, arg1: $Level$$Type, arg2: $BlockPos$$Type): integer
public "invokeIsRandomlyTicking"(arg0: $BlockState$$Type): boolean
public "canSurvive"(arg0: $BlockState$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type): boolean
public "getLootTable"(): $ResourceKey<($LootTable)>
/**
 * 
 * @deprecated
 */
public "getSoundType"(arg0: $BlockState$$Type): $SoundType
public "isEnabled"(arg0: $FeatureFlagSet$$Type): boolean
public "lithium$handleShapeUpdate"(arg0: $LevelReader$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type, arg4: $BlockState$$Type): void
public "getId"(): StringJS
public "getKey"(): $ResourceKey<($Block)>
public "getTypeData"(): $Map<(StringJS), (any)>
public "asHolder"(): $Holder<($Block)>
public "getRegistry"(): $Registry<($Block)>
public "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
public "getBlock"(): $Block
public "specialEquals"(o: any, shallow: boolean): boolean
public "getMod"(): StringJS
public "hasTag"(tag: $ResourceLocation$$Type): boolean
public "getIdLocation"(): $ResourceLocation
public "getTagKeys"(): $List<($TagKey<($Block)>)>
public "getTags"(): $List<($ResourceLocation)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
set "randomTickCallback"(value: $Consumer$$Type)
get "maxHorizontalOffset"(): float
get "maxVerticalOffset"(): float
get "lootTable"(): $ResourceKey<($LootTable)>
get "id"(): StringJS
get "key"(): $ResourceKey<($Block)>
get "typeData"(): $Map<(StringJS), (any)>
get "registry"(): $Registry<($Block)>
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "block"(): $Block
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviour$$Type = ($BlockBehaviour);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviour$$Original = $BlockBehaviour;}
declare module "net.minecraft.world.level.biome.Biome$TemperatureModifier" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $Biome$TemperatureModifier extends $Enum<($Biome$TemperatureModifier)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($Biome$TemperatureModifier)>
static readonly "NONE": $Biome$TemperatureModifier
static readonly "FROZEN": $Biome$TemperatureModifier

public "getName"(): StringJS
public static "values"(): ($Biome$TemperatureModifier)[]
public static "valueOf"(arg0: StringJS): $Biome$TemperatureModifier
public "modifyTemperature"(arg0: $BlockPos$$Type, arg1: float): float
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "name"(): StringJS
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Biome$TemperatureModifier$$Type = (("none") | ("frozen"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Biome$TemperatureModifier$$Original = $Biome$TemperatureModifier;}
declare module "net.minecraft.world.level.levelgen.NoiseBasedChunkGenerator" {
import {$NoiseGeneratorSettings, $NoiseGeneratorSettings$$Type} from "net.minecraft.world.level.levelgen.NoiseGeneratorSettings"
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$List, $List$$Type} from "java.util.List"
import {$MutableObject$$Type} from "org.apache.commons.lang3.mutable.MutableObject"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$ChunkAccess, $ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$Blender$$Type} from "net.minecraft.world.level.levelgen.blending.Blender"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$BiomeSource, $BiomeSource$$Type} from "net.minecraft.world.level.biome.BiomeSource"
import {$Supplier} from "java.util.function.Supplier"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BiomeManager$$Type} from "net.minecraft.world.level.biome.BiomeManager"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$FeatureSorter$StepFeatureData} from "net.minecraft.world.level.biome.FeatureSorter$StepFeatureData"
import {$NoiseColumn, $NoiseColumn$$Type} from "net.minecraft.world.level.NoiseColumn"
import {$GenerationStep$Carving$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Carving"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$OptionalInt} from "java.util.OptionalInt"
import {$ChunkGenerator} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$WorldGenerationContext$$Type} from "net.minecraft.world.level.levelgen.WorldGenerationContext"
import {$WorldGenRegion$$Type} from "net.minecraft.server.level.WorldGenRegion"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $NoiseBasedChunkGenerator extends $ChunkGenerator {
 "featuresPerStep": $Supplier<($List<($FeatureSorter$StepFeatureData)>)>
static readonly "CODEC": $MapCodec<($NoiseBasedChunkGenerator)>
readonly "biomeSource": $BiomeSource

constructor(arg0: $BiomeSource$$Type, arg1: $Holder$$Type<($NoiseGeneratorSettings)>)

public "getGenDepth"(): integer
public "getSeaLevel"(): integer
public "codec"(): $MapCodec<($ChunkGenerator)>
public "stable"(arg0: $ResourceKey$$Type<($NoiseGeneratorSettings)>): boolean
public "getBaseHeight"(arg0: integer, arg1: integer, arg2: $Heightmap$Types$$Type, arg3: $LevelHeightAccessor$$Type, arg4: $RandomState$$Type): integer
public "getBaseColumn"(arg0: integer, arg1: integer, arg2: $LevelHeightAccessor$$Type, arg3: $RandomState$$Type): $NoiseColumn
public "spawnOriginalMobs"(arg0: $WorldGenRegion$$Type): void
public "generatorSettings"(): $Holder<($NoiseGeneratorSettings)>
public "iterateNoiseColumn"(arg0: $LevelHeightAccessor$$Type, arg1: $RandomState$$Type, arg2: integer, arg3: integer, arg4: $MutableObject$$Type<($NoiseColumn$$Type)>, arg5: $Predicate$$Type<($BlockState)>): $OptionalInt
public "createBiomes"(arg0: $RandomState$$Type, arg1: $Blender$$Type, arg2: $StructureManager$$Type, arg3: $ChunkAccess$$Type): $CompletableFuture<($ChunkAccess)>
public "addDebugScreenInfo"(arg0: $List$$Type<(StringJS)>, arg1: $RandomState$$Type, arg2: $BlockPos$$Type): void
public "applyCarvers"(arg0: $WorldGenRegion$$Type, arg1: long, arg2: $RandomState$$Type, arg3: $BiomeManager$$Type, arg4: $StructureManager$$Type, arg5: $ChunkAccess$$Type, arg6: $GenerationStep$Carving$$Type): void
public "buildSurface"(arg0: $ChunkAccess$$Type, arg1: $WorldGenerationContext$$Type, arg2: $RandomState$$Type, arg3: $StructureManager$$Type, arg4: $BiomeManager$$Type, arg5: $Registry$$Type<($Biome$$Type)>, arg6: $Blender$$Type): void
public "buildSurface"(arg0: $WorldGenRegion$$Type, arg1: $StructureManager$$Type, arg2: $RandomState$$Type, arg3: $ChunkAccess$$Type): void
public "fillFromNoise"(arg0: $Blender$$Type, arg1: $RandomState$$Type, arg2: $StructureManager$$Type, arg3: $ChunkAccess$$Type): $CompletableFuture<($ChunkAccess)>
public "getMinY"(): integer
get "genDepth"(): integer
get "seaLevel"(): integer
get "minY"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseBasedChunkGenerator$$Type = ($NoiseBasedChunkGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseBasedChunkGenerator$$Original = $NoiseBasedChunkGenerator;}
declare module "net.minecraft.world.level.GameRules$Category" {
import {$Enum} from "java.lang.Enum"

export class $GameRules$Category extends $Enum<($GameRules$Category)> {
static readonly "PLAYER": $GameRules$Category
static readonly "DROPS": $GameRules$Category
static readonly "MOBS": $GameRules$Category
static readonly "CHAT": $GameRules$Category
static readonly "UPDATES": $GameRules$Category
static readonly "MISC": $GameRules$Category
static readonly "SPAWNING": $GameRules$Category

public static "values"(): ($GameRules$Category)[]
public static "valueOf"(arg0: StringJS): $GameRules$Category
public "getDescriptionId"(): StringJS
get "descriptionId"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$Category$$Type = (("player") | ("mobs") | ("spawning") | ("drops") | ("updates") | ("chat") | ("misc"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$Category$$Original = $GameRules$Category;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTestType" {
import {$RandomBlockMatchTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RandomBlockMatchTest"
import {$AlwaysTrueTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.AlwaysTrueTest"
import {$BlockStateMatchTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.BlockStateMatchTest"
import {$BlockMatchTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.BlockMatchTest"
import {$RandomBlockStateMatchTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RandomBlockStateMatchTest"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$TagMatchTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.TagMatchTest"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export interface $RuleTestType$$Interface<P extends $RuleTest> {

(): $MapCodec$$Type<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.RuleTest
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.RuleTestTag
}

export class $RuleTestType<P extends $RuleTest> implements $RuleTestType$$Interface {
static readonly "ALWAYS_TRUE_TEST": $RuleTestType<($AlwaysTrueTest)>
static readonly "TAG_TEST": $RuleTestType<($TagMatchTest)>
static readonly "BLOCKSTATE_TEST": $RuleTestType<($BlockStateMatchTest)>
static readonly "RANDOM_BLOCK_TEST": $RuleTestType<($RandomBlockMatchTest)>
static readonly "BLOCK_TEST": $RuleTestType<($BlockMatchTest)>
static readonly "RANDOM_BLOCKSTATE_TEST": $RuleTestType<($RandomBlockStateMatchTest)>

static "register"<P extends $RuleTest>(arg0: StringJS, arg1: $MapCodec$$Type<(P)>): $RuleTestType<(P)>
 "codec"(): $MapCodec<(P)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuleTestType$$Type<P> = (Special.RuleTest) | (() => $MapCodec$$Type<(P)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuleTestType$$Original<P> = $RuleTestType<(P)>;}
declare module "net.minecraft.world.level.levelgen.carver.CarverConfiguration" {
import {$VerticalAnchor, $VerticalAnchor$$Type} from "net.minecraft.world.level.levelgen.VerticalAnchor"
import {$ProbabilityFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$FloatProvider, $FloatProvider$$Type} from "net.minecraft.util.valueproviders.FloatProvider"
import {$CarverDebugSettings, $CarverDebugSettings$$Type} from "net.minecraft.world.level.levelgen.carver.CarverDebugSettings"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$HeightProvider, $HeightProvider$$Type} from "net.minecraft.world.level.levelgen.heightproviders.HeightProvider"

export class $CarverConfiguration extends $ProbabilityFeatureConfiguration {
readonly "lavaLevel": $VerticalAnchor
readonly "debugSettings": $CarverDebugSettings
static readonly "CODEC": $MapCodec<($CarverConfiguration)>
readonly "probability": float
readonly "replaceable": $HolderSet<($Block)>
readonly "y": $HeightProvider
readonly "yScale": $FloatProvider

constructor(arg0: float, arg1: $HeightProvider$$Type, arg2: $FloatProvider$$Type, arg3: $VerticalAnchor$$Type, arg4: $CarverDebugSettings$$Type, arg5: $HolderSet$$Type<($Block)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarverConfiguration$$Type = ($CarverConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarverConfiguration$$Original = $CarverConfiguration;}
declare module "net.minecraft.world.level.chunk.ChunkGenerator" {
import {$ChunkGeneratorStructureState, $ChunkGeneratorStructureState$$Type} from "net.minecraft.world.level.chunk.ChunkGeneratorStructureState"
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$StructureSet$$Type} from "net.minecraft.world.level.levelgen.structure.StructureSet"
import {$Optional} from "java.util.Optional"
import {$List, $List$$Type} from "java.util.List"
import {$WeightedRandomList} from "net.minecraft.util.random.WeightedRandomList"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$ChunkAccess, $ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$Blender$$Type} from "net.minecraft.world.level.levelgen.blending.Blender"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$BiomeSource, $BiomeSource$$Type} from "net.minecraft.world.level.biome.BiomeSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure, $Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier} from "java.util.function.Supplier"
import {$BiomeGenerationSettings, $BiomeGenerationSettings$$Type} from "net.minecraft.world.level.biome.BiomeGenerationSettings"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$HolderLookup$$Type} from "net.minecraft.core.HolderLookup"
import {$BiomeManager$$Type} from "net.minecraft.world.level.biome.BiomeManager"
import {$Pair} from "com.mojang.datafixers.util.Pair"
import {$RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$FeatureSorter$StepFeatureData} from "net.minecraft.world.level.biome.FeatureSorter$StepFeatureData"
import {$MobSpawnSettings$SpawnerData} from "net.minecraft.world.level.biome.MobSpawnSettings$SpawnerData"
import {$NoiseColumn} from "net.minecraft.world.level.NoiseColumn"
import {$GenerationStep$Carving$$Type} from "net.minecraft.world.level.levelgen.GenerationStep$Carving"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$MobCategory$$Type} from "net.minecraft.world.entity.MobCategory"
import {$WorldGenRegion$$Type} from "net.minecraft.server.level.WorldGenRegion"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"

export class $ChunkGenerator {
 "featuresPerStep": $Supplier<($List<($FeatureSorter$StepFeatureData)>)>
static readonly "CODEC": $Codec<($ChunkGenerator)>
readonly "biomeSource": $BiomeSource

constructor(arg0: $BiomeSource$$Type)
constructor(arg0: $BiomeSource$$Type, arg1: $Function$$Type<($Holder<($Biome)>), ($BiomeGenerationSettings$$Type)>)

public "validate"(): void
public "getGenDepth"(): integer
public "getTypeNameForDataFixer"(): $Optional<($ResourceKey<($MapCodec<($ChunkGenerator)>)>)>
public "applyBiomeDecoration"(arg0: $WorldGenLevel$$Type, arg1: $ChunkAccess$$Type, arg2: $StructureManager$$Type): void
public "refreshFeaturesPerStep"(): void
/**
 * 
 * @deprecated
 */
public "getBiomeGenerationSettings"(arg0: $Holder$$Type<($Biome)>): $BiomeGenerationSettings
public "getMobsAt"(arg0: $Holder$$Type<($Biome)>, arg1: $StructureManager$$Type, arg2: $MobCategory$$Type, arg3: $BlockPos$$Type): $WeightedRandomList<($MobSpawnSettings$SpawnerData)>
public "getBiomeSource"(): $BiomeSource
public "getSeaLevel"(): integer
public "codec"(): $MapCodec<($ChunkGenerator)>
public "createState"(arg0: $HolderLookup$$Type<($StructureSet$$Type)>, arg1: $RandomState$$Type, arg2: long): $ChunkGeneratorStructureState
public "findNearestMapStructure"(arg0: $ServerLevel$$Type, arg1: $HolderSet$$Type<($Structure)>, arg2: $BlockPos$$Type, arg3: integer, arg4: boolean): $Pair<($BlockPos), ($Holder<($Structure)>)>
public "getBaseHeight"(arg0: integer, arg1: integer, arg2: $Heightmap$Types$$Type, arg3: $LevelHeightAccessor$$Type, arg4: $RandomState$$Type): integer
public "getBaseColumn"(arg0: integer, arg1: integer, arg2: $LevelHeightAccessor$$Type, arg3: $RandomState$$Type): $NoiseColumn
public "spawnOriginalMobs"(arg0: $WorldGenRegion$$Type): void
public "createBiomes"(arg0: $RandomState$$Type, arg1: $Blender$$Type, arg2: $StructureManager$$Type, arg3: $ChunkAccess$$Type): $CompletableFuture<($ChunkAccess)>
public "addDebugScreenInfo"(arg0: $List$$Type<(StringJS)>, arg1: $RandomState$$Type, arg2: $BlockPos$$Type): void
public "applyCarvers"(arg0: $WorldGenRegion$$Type, arg1: long, arg2: $RandomState$$Type, arg3: $BiomeManager$$Type, arg4: $StructureManager$$Type, arg5: $ChunkAccess$$Type, arg6: $GenerationStep$Carving$$Type): void
public "buildSurface"(arg0: $WorldGenRegion$$Type, arg1: $StructureManager$$Type, arg2: $RandomState$$Type, arg3: $ChunkAccess$$Type): void
public "fillFromNoise"(arg0: $Blender$$Type, arg1: $RandomState$$Type, arg2: $StructureManager$$Type, arg3: $ChunkAccess$$Type): $CompletableFuture<($ChunkAccess)>
public "getFirstFreeHeight"(arg0: integer, arg1: integer, arg2: $Heightmap$Types$$Type, arg3: $LevelHeightAccessor$$Type, arg4: $RandomState$$Type): integer
public "createStructures"(arg0: $RegistryAccess$$Type, arg1: $ChunkGeneratorStructureState$$Type, arg2: $StructureManager$$Type, arg3: $ChunkAccess$$Type, arg4: $StructureTemplateManager$$Type): void
public "createReferences"(arg0: $WorldGenLevel$$Type, arg1: $StructureManager$$Type, arg2: $ChunkAccess$$Type): void
public "getSpawnHeight"(arg0: $LevelHeightAccessor$$Type): integer
public "getFirstOccupiedHeight"(arg0: integer, arg1: integer, arg2: $Heightmap$Types$$Type, arg3: $LevelHeightAccessor$$Type, arg4: $RandomState$$Type): integer
public "getMinY"(): integer
get "genDepth"(): integer
get "typeNameForDataFixer"(): $Optional<($ResourceKey<($MapCodec<($ChunkGenerator)>)>)>
get "seaLevel"(): integer
get "minY"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkGenerator$$Type = ($ChunkGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkGenerator$$Original = $ChunkGenerator;}
declare module "net.minecraft.world.level.storage.loot.providers.number.NumberProvider" {
import {$LootContextParam} from "net.minecraft.world.level.storage.loot.parameters.LootContextParam"
import {$LootNumberProviderType} from "net.minecraft.world.level.storage.loot.providers.number.LootNumberProviderType"
import {$LootContext$$Type} from "net.minecraft.world.level.storage.loot.LootContext"
import {$Set} from "java.util.Set"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$LootContextUser$$Interface} from "net.minecraft.world.level.storage.loot.LootContextUser"

export interface $NumberProvider$$Interface extends $LootContextUser$$Interface {
get "type"(): $LootNumberProviderType
get "referencedContextParams"(): $Set<($LootContextParam<(never)>)>
}

export class $NumberProvider implements $NumberProvider$$Interface {
 "getInt"(arg0: $LootContext$$Type): integer
 "getFloat"(arg0: $LootContext$$Type): float
 "getType"(): $LootNumberProviderType
 "validate"(arg0: $ValidationContext$$Type): void
 "getReferencedContextParams"(): $Set<($LootContextParam<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NumberProvider$$Type = (double) | ([min: double, max: double]) | ({"min": double, "max": double}) | ({"n": double, "p": double}) | ({"value": double});
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NumberProvider$$Original = $NumberProvider;}
declare module "net.minecraft.world.level.LevelSimulatedRW" {
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Optional} from "java.util.Optional"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelWriter$$Interface} from "net.minecraft.world.level.LevelWriter"
import {$LevelSimulatedReader$$Interface} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $LevelSimulatedRW$$Interface extends $LevelSimulatedReader$$Interface, $LevelWriter$$Interface {
}

export class $LevelSimulatedRW implements $LevelSimulatedRW$$Interface {
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "isStateAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($BlockState)>): boolean
 "isFluidAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($FluidState)>): boolean
 "removeBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "addFreshEntity"(arg0: $Entity$$Type): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type, arg3: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelSimulatedRW$$Type = ($LevelSimulatedRW);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelSimulatedRW$$Original = $LevelSimulatedRW;}
declare module "net.minecraft.world.level.levelgen.feature.SeagrassFeature" {
import {$GeodeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration"
import {$VegetationPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.VegetationPatchConfiguration"
import {$SpringConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpringConfiguration"
import {$ReplaceSphereConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceSphereConfiguration"
import {$TwistingVinesConfig} from "net.minecraft.world.level.levelgen.feature.configurations.TwistingVinesConfig"
import {$BlockStateConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockStateConfiguration"
import {$BlockPileConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockPileConfiguration"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"
import {$EndGatewayConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.EndGatewayConfiguration"
import {$UnderwaterMagmaConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.UnderwaterMagmaConfiguration"
import {$LakeFeature$Configuration} from "net.minecraft.world.level.levelgen.feature.LakeFeature$Configuration"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$RootSystemConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RootSystemConfiguration"
import {$BonusChestFeature} from "net.minecraft.world.level.levelgen.feature.BonusChestFeature"
import {$OreConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration"
import {$NetherForestVegetationConfig} from "net.minecraft.world.level.levelgen.feature.configurations.NetherForestVegetationConfig"
import {$RandomBooleanFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomBooleanFeatureConfiguration"
import {$CountConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.CountConfiguration"
import {$RandomPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomPatchConfiguration"
import {$RandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration"
import {$HugeMushroomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.HugeMushroomFeatureConfiguration"
import {$SimpleBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleBlockConfiguration"
import {$MultifaceGrowthConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.MultifaceGrowthConfiguration"
import {$DeltaFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DeltaFeatureConfiguration"
import {$LayerConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LayerConfiguration"
import {$ProbabilityFeatureConfiguration, $ProbabilityFeatureConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration"
import {$ReplaceBlockConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration"
import {$Feature} from "net.minecraft.world.level.levelgen.feature.Feature"
import {$BlockColumnConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration"
import {$FossilFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration"
import {$LargeDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.LargeDripstoneConfiguration"
import {$ColumnFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.ColumnFeatureConfiguration"
import {$FeaturePlaceContext$$Type} from "net.minecraft.world.level.levelgen.feature.FeaturePlaceContext"
import {$SpikeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SpikeConfiguration"
import {$HugeFungusConfiguration} from "net.minecraft.world.level.levelgen.feature.HugeFungusConfiguration"
import {$TreeConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$DiskConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DiskConfiguration"
import {$PointedDripstoneConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration"
import {$SimpleRandomFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SimpleRandomFeatureConfiguration"
import {$SculkPatchConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration"
import {$DripstoneClusterConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration"

export class $SeagrassFeature extends $Feature<($ProbabilityFeatureConfiguration)> {
static readonly "VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CHORUS_PLANT": $Feature<($NoneFeatureConfiguration)>
static readonly "MONSTER_ROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "FREEZE_TOP_LAYER": $Feature<($NoneFeatureConfiguration)>
static readonly "BLOCK_COLUMN": $Feature<($BlockColumnConfiguration)>
static readonly "REPLACE_SINGLE_BLOCK": $Feature<($ReplaceBlockConfiguration)>
static readonly "FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "BLOCK_PILE": $Feature<($BlockPileConfiguration)>
static readonly "SPRING": $Feature<($SpringConfiguration)>
static readonly "UNDERWATER_MAGMA": $Feature<($UnderwaterMagmaConfiguration)>
static readonly "BAMBOO": $Feature<($ProbabilityFeatureConfiguration)>
static readonly "DELTA_FEATURE": $Feature<($DeltaFeatureConfiguration)>
static readonly "ROOT_SYSTEM": $Feature<($RootSystemConfiguration)>
static readonly "NETHER_FOREST_VEGETATION": $Feature<($NetherForestVegetationConfig)>
static readonly "WEEPING_VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "LAKE": $Feature<($LakeFeature$Configuration)>
static readonly "TWISTING_VINES": $Feature<($TwistingVinesConfig)>
static readonly "END_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_RED_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "SIMPLE_BLOCK": $Feature<($SimpleBlockConfiguration)>
static readonly "RANDOM_SELECTOR": $Feature<($RandomFeatureConfiguration)>
static readonly "END_ISLAND": $Feature<($NoneFeatureConfiguration)>
static readonly "REPLACE_BLOBS": $Feature<($ReplaceSphereConfiguration)>
static readonly "VINES": $Feature<($NoneFeatureConfiguration)>
static readonly "TREE": $Feature<($TreeConfiguration)>
static readonly "CORAL_CLAW": $Feature<($NoneFeatureConfiguration)>
static readonly "DISK": $Feature<($DiskConfiguration)>
static readonly "FOSSIL": $Feature<($FossilFeatureConfiguration)>
static readonly "FILL_LAYER": $Feature<($LayerConfiguration)>
static readonly "SIMPLE_RANDOM_SELECTOR": $Feature<($SimpleRandomFeatureConfiguration)>
static readonly "ICE_SPIKE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_BONEMEAL_FLOWER": $Feature<($RandomPatchConfiguration)>
static readonly "ORE": $Feature<($OreConfiguration)>
static readonly "ICEBERG": $Feature<($BlockStateConfiguration)>
static readonly "BASALT_COLUMNS": $Feature<($ColumnFeatureConfiguration)>
static readonly "RANDOM_BOOLEAN_SELECTOR": $Feature<($RandomBooleanFeatureConfiguration)>
static readonly "RANDOM_PATCH": $Feature<($RandomPatchConfiguration)>
static readonly "LARGE_DRIPSTONE": $Feature<($LargeDripstoneConfiguration)>
static readonly "SEAGRASS": $SeagrassFeature
static readonly "POINTED_DRIPSTONE": $Feature<($PointedDripstoneConfiguration)>
static readonly "GLOWSTONE_BLOB": $Feature<($NoneFeatureConfiguration)>
static readonly "WATERLOGGED_VEGETATION_PATCH": $Feature<($VegetationPatchConfiguration)>
static readonly "CORAL_MUSHROOM": $Feature<($NoneFeatureConfiguration)>
static readonly "VOID_START_PLATFORM": $Feature<($NoneFeatureConfiguration)>
static readonly "DESERT_WELL": $Feature<($NoneFeatureConfiguration)>
static readonly "HUGE_BROWN_MUSHROOM": $Feature<($HugeMushroomFeatureConfiguration)>
static readonly "END_GATEWAY": $Feature<($EndGatewayConfiguration)>
static readonly "END_SPIKE": $Feature<($SpikeConfiguration)>
static readonly "BASALT_PILLAR": $Feature<($NoneFeatureConfiguration)>
static readonly "FOREST_ROCK": $Feature<($BlockStateConfiguration)>
static readonly "SCULK_PATCH": $Feature<($SculkPatchConfiguration)>
static readonly "HUGE_FUNGUS": $Feature<($HugeFungusConfiguration)>
static readonly "BLUE_ICE": $Feature<($NoneFeatureConfiguration)>
static readonly "NO_OP": $Feature<($NoneFeatureConfiguration)>
static readonly "SEA_PICKLE": $Feature<($CountConfiguration)>
static readonly "BONUS_CHEST": $BonusChestFeature
static readonly "MULTIFACE_GROWTH": $Feature<($MultifaceGrowthConfiguration)>
static readonly "SCATTERED_ORE": $Feature<($OreConfiguration)>
static readonly "CORAL_TREE": $Feature<($NoneFeatureConfiguration)>
static readonly "DRIPSTONE_CLUSTER": $Feature<($DripstoneClusterConfiguration)>
static readonly "GEODE": $Feature<($GeodeConfiguration)>
static readonly "KELP": $Feature<($NoneFeatureConfiguration)>

constructor(arg0: $Codec$$Type<($ProbabilityFeatureConfiguration$$Type)>)

public "place"(arg0: $FeaturePlaceContext$$Type<($ProbabilityFeatureConfiguration$$Type)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SeagrassFeature$$Type = ($SeagrassFeature);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SeagrassFeature$$Original = $SeagrassFeature;}
declare module "net.minecraft.world.level.LocalMobCapCalculator" {
import {$MobCategory$$Type} from "net.minecraft.world.entity.MobCategory"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$ChunkMap$$Type} from "net.minecraft.server.level.ChunkMap"

export class $LocalMobCapCalculator {
constructor(arg0: $ChunkMap$$Type)

public "addMob"(arg0: $ChunkPos$$Type, arg1: $MobCategory$$Type): void
public "canSpawn"(arg0: $MobCategory$$Type, arg1: $ChunkPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LocalMobCapCalculator$$Type = ($LocalMobCapCalculator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LocalMobCapCalculator$$Original = $LocalMobCapCalculator;}
declare module "net.minecraft.world.level.block.entity.BannerBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$BannerPatternLayers} from "net.minecraft.world.level.block.entity.BannerPatternLayers"
import {$Level} from "net.minecraft.world.level.Level"
import {$DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$Component} from "net.minecraft.network.chat.Component"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Nameable$$Interface} from "net.minecraft.world.Nameable"
import {$BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BannerBlockEntity extends $BlockEntity implements $Nameable$$Interface {
static readonly "MAX_PATTERNS": integer
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)
constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $DyeColor$$Type)

public "getName"(): $Component
public "getItem"(): $ItemStack
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "getBaseColor"(): $DyeColor
public "getPatterns"(): $BannerPatternLayers
public "getCustomName"(): $Component
public "fromItem"(arg0: $ItemStack$$Type, arg1: $DyeColor$$Type): void
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "collectImplicitComponents"(arg0: $DataComponentMap$Builder$$Type): void
public "applyImplicitComponents"(arg0: $BlockEntity$DataComponentInput$$Type): void
public "getDisplayName"(): $Component
public "hasCustomName"(): boolean
get "name"(): $Component
get "item"(): $ItemStack
get "baseColor"(): $DyeColor
get "patterns"(): $BannerPatternLayers
get "customName"(): $Component
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "displayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BannerBlockEntity$$Type = ($BannerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BannerBlockEntity$$Original = $BannerBlockEntity;}
declare module "net.minecraft.world.level.block.entity.BeaconBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$MobEffect, $MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"
import {$Nameable$$Interface} from "net.minecraft.world.Nameable"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$MenuProvider$$Interface} from "net.minecraft.world.MenuProvider"
import {$BeaconBlockEntity$BeaconBeamSection} from "net.minecraft.world.level.block.entity.BeaconBlockEntity$BeaconBeamSection"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BeaconBlockEntity extends $BlockEntity implements $MenuProvider$$Interface, $Nameable$$Interface {
 "primaryPower": $Holder<($MobEffect)>
static readonly "BEACON_EFFECTS": $List<($List<($Holder<($MobEffect)>)>)>
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "remove": boolean
 "beamSections": $List<($BeaconBlockEntity$BeaconBeamSection)>
 "worldPosition": $BlockPos
 "secondaryPower": $Holder<($MobEffect)>
static readonly "DATA_SECONDARY": integer
 "hasComparators": byte
static readonly "NUM_DATA_VALUES": integer
static readonly "DATA_LEVELS": integer
 "levels": integer
static readonly "DATA_PRIMARY": integer

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getName"(): $Component
public "getDisplayName"(): $Component
public static "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BeaconBlockEntity$$Type): void
public "setLevel"(arg0: $Level$$Type): void
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "getBeamSections"(): $List<($BeaconBlockEntity$BeaconBeamSection)>
public static "filterEffect"(arg0: $Holder$$Type<($MobEffect)>): $Holder<($MobEffect)>
public "getCustomName"(): $Component
public "setCustomName"(arg0: $Component$$Type): void
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "setRemoved"(): void
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public static "playSound"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type): void
public "collectImplicitComponents"(arg0: $DataComponentMap$Builder$$Type): void
public "applyImplicitComponents"(arg0: $BlockEntity$DataComponentInput$$Type): void
public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "shouldTriggerClientSideContainerClosingOnOpen"(): boolean
public "hasCustomName"(): boolean
public "writeClientSideData"(arg0: $AbstractContainerMenu$$Type, arg1: $RegistryFriendlyByteBuf$$Type): void
public "shouldCloseCurrentScreen"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "customName"(): $Component
set "customName"(value: $Component$$Type)
get "removed"(): void
get "updatePacket"(): $ClientboundBlockEntityDataPacket
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeaconBlockEntity$$Type = ($BeaconBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeaconBlockEntity$$Original = $BeaconBlockEntity;}
declare module "net.minecraft.world.level.GameRules" {
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$GameRules$Type, $GameRules$Type$$Type} from "net.minecraft.world.level.GameRules$Type"
import {$GameRulesKJS$$Interface} from "dev.latvian.mods.kubejs.core.GameRulesKJS"
import {$GameRules$Category$$Type} from "net.minecraft.world.level.GameRules$Category"
import {$GameRulesAccessor$$Interface} from "net.fabricmc.fabric.mixin.gamerule.GameRulesAccessor"
import {$GameRules$Value} from "net.minecraft.world.level.GameRules$Value"
import {$GameRules$GameRuleTypeVisitor$$Type} from "net.minecraft.world.level.GameRules$GameRuleTypeVisitor"
import {$GameRules$BooleanValue, $GameRules$BooleanValue$$Type} from "net.minecraft.world.level.GameRules$BooleanValue"
import {$DynamicLike$$Type} from "com.mojang.serialization.DynamicLike"
import {$GameRules$Key, $GameRules$Key$$Type} from "net.minecraft.world.level.GameRules$Key"
import {$Logger} from "org.slf4j.Logger"
import {$GameRules$IntegerValue, $GameRules$IntegerValue$$Type} from "net.minecraft.world.level.GameRules$IntegerValue"
import {$MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export class $GameRules implements $GameRulesAccessor$$Interface, $GameRulesKJS$$Interface {
static readonly "RULE_MAX_COMMAND_CHAIN_LENGTH": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_DROWNING_DAMAGE": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_LOGADMINCOMMANDS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_REDUCEDDEBUGINFO": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_WEATHER_CYCLE": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_FORGIVE_DEAD_PLAYERS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "DEFAULT_RANDOM_TICK_SPEED": integer
static readonly "RULE_TNT_EXPLOSION_DROP_DECAY": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_NATURAL_REGENERATION": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DISABLE_ELYTRA_MOVEMENT_CHECK": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_COMMAND_MODIFICATION_BLOCK_LIMIT": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_SPAWN_CHUNK_RADIUS": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "GAME_RULE_TYPES": $Map<($GameRules$Key<(never)>), ($GameRules$Type<(never)>)>
static readonly "RULE_ANNOUNCE_ADVANCEMENTS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_COMMANDBLOCKOUTPUT": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DOMOBSPAWNING": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_PROJECTILESCANBREAKBLOCKS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DAYLIGHT": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DISABLE_RAIDS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_FIRE_DAMAGE": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_PLAYERS_SLEEPING_PERCENTAGE": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_WATER_SOURCE_CONVERSION": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DOBLOCKDROPS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_BLOCK_EXPLOSION_DROP_DECAY": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_SPECTATORSGENERATECHUNKS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DO_VINES_SPREAD": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DO_IMMEDIATE_RESPAWN": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DOENTITYDROPS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_KEEPINVENTORY": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_RANDOMTICKING": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_DO_TRADER_SPAWNING": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DOMOBLOOT": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_GLOBAL_SOUND_EVENTS": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "LOGGER": $Logger
static readonly "RULE_DO_PATROL_SPAWNING": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_PLAYERS_NETHER_PORTAL_DEFAULT_DELAY": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_FALL_DAMAGE": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DOINSOMNIA": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_MOB_EXPLOSION_DROP_DECAY": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_LIMITED_CRAFTING": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DO_WARDEN_SPAWNING": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_DOFIRETICK": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_MOBGRIEFING": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_PLAYERS_NETHER_PORTAL_CREATIVE_DELAY": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_SHOWDEATHMESSAGES": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_MAX_ENTITY_CRAMMING": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_SPAWN_RADIUS": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_UNIVERSAL_ANGER": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_FREEZE_DAMAGE": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_SNOW_ACCUMULATION_HEIGHT": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_LAVA_SOURCE_CONVERSION": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_SENDCOMMANDFEEDBACK": $GameRules$Key<($GameRules$BooleanValue)>
static readonly "RULE_MAX_COMMAND_FORK_COUNT": $GameRules$Key<($GameRules$IntegerValue)>
static readonly "RULE_ENDER_PEARLS_VANISH_ON_DEATH": $GameRules$Key<($GameRules$BooleanValue)>

constructor()
constructor(arg0: $DynamicLike$$Type<(never)>)

public "getBoolean"(arg0: $GameRules$Key$$Type<($GameRules$BooleanValue$$Type)>): boolean
public "getInt"(arg0: $GameRules$Key$$Type<($GameRules$IntegerValue$$Type)>): integer
public static "register"<T extends $GameRules$Value<(object)>>(arg0: StringJS, arg1: $GameRules$Category$$Type, arg2: $GameRules$Type$$Type<(T)>): $GameRules$Key<(T)>
public "copy"(): $GameRules
public static "visitGameRuleTypes"(arg0: $GameRules$GameRuleTypeVisitor$$Type): void
public "get"(rule: StringJS): $GameRules$Value
public "set"(rule: StringJS, value: StringJS): void
public "createTag"(): $CompoundTag
public "getRule"<T extends $GameRules$Value<(object)>>(arg0: $GameRules$Key$$Type<(T)>): T
public "assignFrom"(arg0: $GameRules$$Type, arg1: $MinecraftServer$$Type): void
public static "getRuleTypes$fabric_game_rule_api_v1_$md$6d3b50$0"(): $Map
public static "getRuleTypes"(): $Map<($GameRules$Key<(never)>), ($GameRules$Type<(never)>)>
public "kjs$getBoolean"(rule: StringJS): boolean
public "kjs$getString"(rule: StringJS): StringJS
public "kjs$getInt"(rule: StringJS): integer
get "ruleTypes$fabric_game_rule_api_v1_$md$6d3b50$0"(): $Map
get "ruleTypes"(): $Map<($GameRules$Key<(never)>), ($GameRules$Type<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$$Type = ($GameRules);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$$Original = $GameRules;}
declare module "net.minecraft.world.level.biome.BiomeSpecialEffects" {
import {$AmbientMoodSettings, $AmbientMoodSettings$$Type} from "net.minecraft.world.level.biome.AmbientMoodSettings"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BiomeSpecialEffects$GrassColorModifier, $BiomeSpecialEffects$GrassColorModifier$$Type} from "net.minecraft.world.level.biome.BiomeSpecialEffects$GrassColorModifier"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$AmbientParticleSettings, $AmbientParticleSettings$$Type} from "net.minecraft.world.level.biome.AmbientParticleSettings"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$AmbientAdditionsSettings, $AmbientAdditionsSettings$$Type} from "net.minecraft.world.level.biome.AmbientAdditionsSettings"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Music, $Music$$Type} from "net.minecraft.sounds.Music"

export class $BiomeSpecialEffects {
 "skyColor": integer
static readonly "CODEC": $Codec<($BiomeSpecialEffects)>
 "waterFogColor": integer
 "ambientLoopSoundEvent": $Optional<($Holder<($SoundEvent)>)>
 "foliageColorOverride": $Optional<(integer)>
 "grassColorOverride": $Optional<(integer)>
 "ambientAdditionsSettings": $Optional<($AmbientAdditionsSettings)>
 "ambientParticleSettings": $Optional<($AmbientParticleSettings)>
 "waterColor": integer
 "backgroundMusic": $Optional<($Music)>
 "grassColorModifier": $BiomeSpecialEffects$GrassColorModifier
 "fogColor": integer
 "ambientMoodSettings": $Optional<($AmbientMoodSettings)>

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: (integer)?, arg5: (integer)?, arg6: $BiomeSpecialEffects$GrassColorModifier$$Type, arg7: ($AmbientParticleSettings$$Type)?, arg8: ($Holder$$Type<($SoundEvent$$Type)>)?, arg9: ($AmbientMoodSettings$$Type)?, arg10: ($AmbientAdditionsSettings$$Type)?, arg11: ($Music$$Type)?)

public "getBackgroundMusic"(): $Optional<($Music)>
public "getFogColor"(): integer
public "getWaterColor"(): integer
public "getWaterFogColor"(): integer
public "getSkyColor"(): integer
public "getAmbientAdditionsSettings"(): $Optional<($AmbientAdditionsSettings)>
public "getAmbientLoopSoundEvent"(): $Optional<($Holder<($SoundEvent)>)>
public "getAmbientMoodSettings"(): $Optional<($AmbientMoodSettings)>
public "getAmbientParticleSettings"(): $Optional<($AmbientParticleSettings)>
public "getGrassColorOverride"(): $Optional<(integer)>
public "getFoliageColorOverride"(): $Optional<(integer)>
public "getGrassColorModifier"(): $BiomeSpecialEffects$GrassColorModifier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeSpecialEffects$$Type = ($BiomeSpecialEffects);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeSpecialEffects$$Original = $BiomeSpecialEffects;}
declare module "net.minecraft.world.level.levelgen.SurfaceRules$Context" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $SurfaceRules$Context {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SurfaceRules$Context$$Type = ($SurfaceRules$Context);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SurfaceRules$Context$$Original = $SurfaceRules$Context;}
declare module "net.minecraft.world.level.storage.LevelStorageSource$LevelStorageAccess" {
import {$PlayerDataStorage} from "net.minecraft.world.level.storage.PlayerDataStorage"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Optional} from "java.util.Optional"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$Dynamic, $Dynamic$$Type} from "com.mojang.serialization.Dynamic"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$LevelStorageSource$LevelDirectory} from "net.minecraft.world.level.storage.LevelStorageSource$LevelDirectory"
import {$DirectoryLock} from "net.minecraft.util.DirectoryLock"
import {$LevelResource$$Type} from "net.minecraft.world.level.storage.LevelResource"
import {$LevelStorageSource, $LevelStorageSource$$Type} from "net.minecraft.world.level.storage.LevelStorageSource"
import {$WorldData$$Type} from "net.minecraft.world.level.storage.WorldData"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$LevelSummary} from "net.minecraft.world.level.storage.LevelSummary"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"
import {$Instant} from "java.time.Instant"

export class $LevelStorageSource$LevelStorageAccess implements $AutoCloseable$$Interface {
readonly "levelDirectory": $LevelStorageSource$LevelDirectory
readonly "this$0": $LevelStorageSource
readonly "lock": $DirectoryLock

constructor(arg0: $LevelStorageSource$$Type, arg1: StringJS, arg2: $Path$$Type)

public "parent"(): $LevelStorageSource
public "close"(): void
public "getLevelId"(): StringJS
public "saveDataTag"(arg0: $RegistryAccess$$Type, arg1: $WorldData$$Type, arg2: $CompoundTag$$Type): void
public "saveDataTag"(arg0: $RegistryAccess$$Type, arg1: $WorldData$$Type): void
public "getDimensionPath"(arg0: $ResourceKey$$Type<($Level)>): $Path
public "hasWorldData"(): boolean
public "deleteLevel"(): void
public "getSummary"(arg0: $Dynamic$$Type<(never)>): $LevelSummary
public "createPlayerStorage"(): $PlayerDataStorage
public "getLevelDirectory"(): $LevelStorageSource$LevelDirectory
public "getIconFile"(): $Optional<($Path)>
public "getLevelPath"(arg0: $LevelResource$$Type): $Path
public "readAdditionalLevelSaveData"(arg0: boolean): void
public "getFileModificationTime"(arg0: boolean): $Instant
public "getDataTag"(): $Dynamic<(never)>
public "safeClose"(): void
public "renameLevel"(arg0: StringJS): void
public "makeWorldBackup"(): long
public "restoreLevelDataFromOld"(): boolean
public "checkForLowDiskSpace"(): boolean
public "renameAndDropPlayer"(arg0: StringJS): void
public "handler$ckb000$xaerominimap$onDeleteLevel"(arg0: $CallbackInfo$$Type): void
public "handler$dba001$xaeroworldmap$onDeleteLevel"(arg0: $CallbackInfo$$Type): void
public "estimateDiskSpace"(): long
public "getDataTagFallback"(): $Dynamic<(never)>
public "getWorldDir"(): $Path
get "levelId"(): StringJS
get "iconFile"(): $Optional<($Path)>
get "dataTag"(): $Dynamic<(never)>
get "dataTagFallback"(): $Dynamic<(never)>
get "worldDir"(): $Path
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelStorageSource$LevelStorageAccess$$Type = ($LevelStorageSource$LevelStorageAccess);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelStorageSource$LevelStorageAccess$$Original = $LevelStorageSource$LevelStorageAccess;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.AlwaysTrueTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$RuleTestType} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTestType"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $AlwaysTrueTest extends $RuleTest {
static readonly "CODEC": $MapCodec<($AlwaysTrueTest)>
static readonly "INSTANCE": $AlwaysTrueTest

public "test"(arg0: $BlockState$$Type, arg1: $RandomSource$$Type): boolean
public "getType"(): $RuleTestType<(never)>
get "type"(): $RuleTestType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlwaysTrueTest$$Type = ($AlwaysTrueTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AlwaysTrueTest$$Original = $AlwaysTrueTest;}
declare module "net.minecraft.world.level.dimension.LevelStem" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ChunkGenerator, $ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$DimensionType, $DimensionType$$Type} from "net.minecraft.world.level.dimension.DimensionType"
import {$Record} from "java.lang.Record"

export class $LevelStem extends $Record {
static readonly "CODEC": $Codec<($LevelStem)>
static readonly "OVERWORLD": $ResourceKey<($LevelStem)>
static readonly "NETHER": $ResourceKey<($LevelStem)>
static readonly "END": $ResourceKey<($LevelStem)>

constructor(arg0: $Holder$$Type<($DimensionType)>, arg1: $ChunkGenerator$$Type)

public "type"(): $Holder<($DimensionType)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "generator"(): $ChunkGenerator
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.Dimension
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.DimensionTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelStem$$Type = ({"generator"?: $ChunkGenerator$$Type, "type"?: $Holder$$Type<($DimensionType)>}) | ([generator?: $ChunkGenerator$$Type, type?: $Holder$$Type<($DimensionType)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelStem$$Original = $LevelStem;}
declare module "net.minecraft.world.level.levelgen.WorldgenRandom" {
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PositionalRandomFactory} from "net.minecraft.world.level.levelgen.PositionalRandomFactory"
import {$LegacyRandomSource} from "net.minecraft.world.level.levelgen.LegacyRandomSource"

export class $WorldgenRandom extends $LegacyRandomSource {
constructor(arg0: $RandomSource$$Type)

public "next"(arg0: integer): integer
public "getCount"(): integer
public "setSeed"(arg0: long): void
public "fork"(): $RandomSource
public "forkPositional"(): $PositionalRandomFactory
public "setDecorationSeed"(arg0: long, arg1: integer, arg2: integer): long
public "setFeatureSeed"(arg0: long, arg1: integer, arg2: integer): void
public "setLargeFeatureWithSalt"(arg0: long, arg1: integer, arg2: integer, arg3: integer): void
public "setLargeFeatureSeed"(arg0: long, arg1: integer, arg2: integer): void
public static "seedSlimeChunk"(arg0: integer, arg1: integer, arg2: long, arg3: long): $RandomSource
public static "create"(arg0: long): $RandomSource
public static "create"(): $RandomSource
public static "createNewThreadLocalInstance"(): $RandomSource
/**
 * 
 * @deprecated
 */
public static "createThreadSafe"(): $RandomSource
get "count"(): integer
set "seed"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldgenRandom$$Type = ($WorldgenRandom);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldgenRandom$$Original = $WorldgenRandom;}
declare module "net.minecraft.world.level.storage.loot.entries.LootPoolEntryType" {
import {$LootPoolEntryContainer, $LootPoolEntryContainer$$Type} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $LootPoolEntryType extends $Record {
constructor(arg0: $MapCodec$$Type<($LootPoolEntryContainer$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "codec"(): $MapCodec<($LootPoolEntryContainer)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.LootPoolEntryType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.LootPoolEntryTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootPoolEntryType$$Type = (Special.LootPoolEntryType) | ({"codec"?: $MapCodec$$Type<($LootPoolEntryContainer$$Type)>}) | ([codec?: $MapCodec$$Type<($LootPoolEntryContainer$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootPoolEntryType$$Original = $LootPoolEntryType;}
declare module "net.minecraft.world.level.block.entity.TrappedChestBlockEntity" {
import {$ChestBlockEntity} from "net.minecraft.world.level.block.entity.ChestBlockEntity"
import {$ContainerOpenersCounter} from "net.minecraft.world.level.block.entity.ContainerOpenersCounter"
import {$ReferenceArraySet} from "it.unimi.dsi.fastutil.objects.ReferenceArraySet"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$InventoryChangeListener$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeListener"
import {$InventoryChangeTracker$$Type} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_change_tracking.InventoryChangeTracker"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$LithiumStackList$$Type} from "net.caffeinemc.mods.lithium.common.hopper.LithiumStackList"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TrappedChestBlockEntity extends $ChestBlockEntity {
 "inventoryChangeListeners": $ReferenceArraySet
 "worldPosition": $BlockPos
readonly "openersCounter": $ContainerOpenersCounter
 "lootTable": $ResourceKey<($LootTable)>
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventoryHandlingTypeListeners": $ReferenceArraySet
 "lockKey": $LockCode
 "hasComparators": byte
 "lootTableSeed": long
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "signalOpenCount"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: integer, arg4: integer): void
public "lithium$emitFirstComparatorAdded"(): void
public "lithium$emitContentModified"(): void
public "lithium$emitStackListReplaced"(): void
public "lithium$forwardContentChangeOnce"(arg0: $InventoryChangeListener$$Type, arg1: $LithiumStackList$$Type, arg2: $InventoryChangeTracker$$Type): void
public "lithium$forwardMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$stopForwardingMajorInventoryChanges"(arg0: $InventoryChangeListener$$Type): void
public "lithium$emitRemoved"(): void
public "stillValid"(arg0: $Player$$Type): boolean
public "setChanged"(): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public static "tryClear"(arg0: any): void
get "changed"(): void
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrappedChestBlockEntity$$Type = ($TrappedChestBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrappedChestBlockEntity$$Original = $TrappedChestBlockEntity;}
declare module "net.minecraft.world.level.levelgen.carver.ConfiguredWorldCarver" {
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Aquifer$$Type} from "net.minecraft.world.level.levelgen.Aquifer"
import {$CarvingContext$$Type} from "net.minecraft.world.level.levelgen.carver.CarvingContext"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function$$Type} from "java.util.function.Function"
import {$CarvingMask$$Type} from "net.minecraft.world.level.chunk.CarvingMask"
import {$WorldCarver, $WorldCarver$$Type} from "net.minecraft.world.level.levelgen.carver.WorldCarver"
import {$HolderSet} from "net.minecraft.core.HolderSet"
import {$CarverConfiguration, $CarverConfiguration$$Type} from "net.minecraft.world.level.levelgen.carver.CarverConfiguration"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$Record} from "java.lang.Record"

export class $ConfiguredWorldCarver<WC extends $CarverConfiguration> extends $Record {
static readonly "CODEC": $Codec<($Holder<($ConfiguredWorldCarver<(never)>)>)>
static readonly "DIRECT_CODEC": $Codec<($ConfiguredWorldCarver<(never)>)>
static readonly "LIST_CODEC": $Codec<($HolderSet<($ConfiguredWorldCarver<(never)>)>)>

constructor(arg0: $WorldCarver$$Type<(WC)>, arg1: WC)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "config"(): WC
public "isStartChunk"(arg0: $RandomSource$$Type): boolean
public "worldCarver"(): $WorldCarver<(WC)>
public "carve"(arg0: $CarvingContext$$Type, arg1: $ChunkAccess$$Type, arg2: $Function$$Type<($BlockPos), ($Holder$$Type<($Biome$$Type)>)>, arg3: $RandomSource$$Type, arg4: $Aquifer$$Type, arg5: $ChunkPos$$Type, arg6: $CarvingMask$$Type): boolean
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenConfiguredCarver
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenConfiguredCarverTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfiguredWorldCarver$$Type<WC> = (Special.WorldgenConfiguredCarver) | ({"worldCarver"?: $WorldCarver$$Type<(WC)>, "config"?: WC}) | ([worldCarver?: $WorldCarver$$Type<(WC)>, config?: WC]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConfiguredWorldCarver$$Original<WC> = $ConfiguredWorldCarver<(WC)>;}
declare module "net.minecraft.world.level.levelgen.structure.pools.DimensionPadding" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Record} from "java.lang.Record"

export class $DimensionPadding extends $Record {
static readonly "ZERO": $DimensionPadding
static readonly "CODEC": $Codec<($DimensionPadding)>

constructor(arg0: integer)
constructor(arg0: integer, arg1: integer)

public "bottom"(): integer
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "top"(): integer
public "hasEqualTopAndBottom"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionPadding$$Type = ({"top"?: integer, "bottom"?: integer}) | ([top?: integer, bottom?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DimensionPadding$$Original = $DimensionPadding;}
declare module "net.minecraft.world.level.block.state.properties.DoubleBlockHalf" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Direction} from "net.minecraft.core.Direction"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $DoubleBlockHalf extends $Enum<($DoubleBlockHalf)> implements $StringRepresentable$$Interface {
static readonly "UPPER": $DoubleBlockHalf
static readonly "LOWER": $DoubleBlockHalf

public "toString"(): StringJS
public static "values"(): ($DoubleBlockHalf)[]
public static "valueOf"(arg0: StringJS): $DoubleBlockHalf
public "getDirectionToOther"(): $Direction
public "getSerializedName"(): StringJS
public "getOtherHalf"(): $DoubleBlockHalf
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "directionToOther"(): $Direction
get "serializedName"(): StringJS
get "otherHalf"(): $DoubleBlockHalf
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleBlockHalf$$Type = (("upper") | ("lower"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoubleBlockHalf$$Original = $DoubleBlockHalf;}
declare module "net.minecraft.world.level.block.entity.BeaconBlockEntity$BeaconBeamSection" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $BeaconBlockEntity$BeaconBeamSection {
readonly "color": integer

constructor(arg0: integer)

public "increaseHeight"(): void
public "getColor"(): integer
public "getHeight"(): integer
get "height"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeaconBlockEntity$BeaconBeamSection$$Type = ($BeaconBlockEntity$BeaconBeamSection);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeaconBlockEntity$BeaconBeamSection$$Original = $BeaconBlockEntity$BeaconBeamSection;}
declare module "net.minecraft.world.level.levelgen.feature.FossilFeatureConfiguration" {
import {$StructureProcessorList, $StructureProcessorList$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessorList"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$List, $List$$Type} from "java.util.List"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $FossilFeatureConfiguration implements $FeatureConfiguration$$Interface {
readonly "overlayStructures": $List<($ResourceLocation)>
readonly "overlayProcessors": $Holder<($StructureProcessorList)>
static readonly "CODEC": $Codec<($FossilFeatureConfiguration)>
readonly "maxEmptyCornersAllowed": integer
readonly "fossilStructures": $List<($ResourceLocation)>
readonly "fossilProcessors": $Holder<($StructureProcessorList)>

constructor(arg0: $List$$Type<($ResourceLocation$$Type)>, arg1: $List$$Type<($ResourceLocation$$Type)>, arg2: $Holder$$Type<($StructureProcessorList)>, arg3: $Holder$$Type<($StructureProcessorList)>, arg4: integer)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FossilFeatureConfiguration$$Type = ($FossilFeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FossilFeatureConfiguration$$Original = $FossilFeatureConfiguration;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacerType" {
import {$BushFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.BushFoliagePlacer"
import {$DarkOakFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.DarkOakFoliagePlacer"
import {$FancyFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FancyFoliagePlacer"
import {$BlobFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.BlobFoliagePlacer"
import {$SpruceFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.SpruceFoliagePlacer"
import {$AcaciaFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.AcaciaFoliagePlacer"
import {$PineFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.PineFoliagePlacer"
import {$MegaPineFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.MegaPineFoliagePlacer"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$RandomSpreadFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.RandomSpreadFoliagePlacer"
import {$MegaJungleFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.MegaJungleFoliagePlacer"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$CherryFoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.CherryFoliagePlacer"

export class $FoliagePlacerType<P extends $FoliagePlacer> {
static readonly "MEGA_PINE_FOLIAGE_PLACER": $FoliagePlacerType<($MegaPineFoliagePlacer)>
static readonly "PINE_FOLIAGE_PLACER": $FoliagePlacerType<($PineFoliagePlacer)>
static readonly "RANDOM_SPREAD_FOLIAGE_PLACER": $FoliagePlacerType<($RandomSpreadFoliagePlacer)>
static readonly "MEGA_JUNGLE_FOLIAGE_PLACER": $FoliagePlacerType<($MegaJungleFoliagePlacer)>
static readonly "SPRUCE_FOLIAGE_PLACER": $FoliagePlacerType<($SpruceFoliagePlacer)>
static readonly "BUSH_FOLIAGE_PLACER": $FoliagePlacerType<($BushFoliagePlacer)>
static readonly "ACACIA_FOLIAGE_PLACER": $FoliagePlacerType<($AcaciaFoliagePlacer)>
static readonly "BLOB_FOLIAGE_PLACER": $FoliagePlacerType<($BlobFoliagePlacer)>
static readonly "DARK_OAK_FOLIAGE_PLACER": $FoliagePlacerType<($DarkOakFoliagePlacer)>
static readonly "CHERRY_FOLIAGE_PLACER": $FoliagePlacerType<($CherryFoliagePlacer)>
static readonly "FANCY_FOLIAGE_PLACER": $FoliagePlacerType<($FancyFoliagePlacer)>

constructor(arg0: $MapCodec$$Type<(P)>)

public "codec"(): $MapCodec<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenFoliagePlacerType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenFoliagePlacerTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoliagePlacerType$$Type<P> = (Special.WorldgenFoliagePlacerType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FoliagePlacerType$$Original<P> = $FoliagePlacerType<(P)>;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.PointedDripstoneConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $PointedDripstoneConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($PointedDripstoneConfiguration)>
readonly "chanceOfTallerDripstone": float
readonly "chanceOfSpreadRadius3": float
readonly "chanceOfSpreadRadius2": float
readonly "chanceOfDirectionalSpread": float

constructor(arg0: float, arg1: float, arg2: float, arg3: float)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PointedDripstoneConfiguration$$Type = ($PointedDripstoneConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PointedDripstoneConfiguration$$Original = $PointedDripstoneConfiguration;}
declare module "net.minecraft.world.level.chunk.PalettedContainerRO$PackedData" {
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$List, $List$$Type} from "java.util.List"
import {$LongStream, $LongStream$$Type} from "java.util.stream.LongStream"
import {$Record} from "java.lang.Record"

export class $PalettedContainerRO$PackedData<T> extends $Record {
constructor(arg0: $List$$Type<(T)>, arg1: ($LongStream$$Type)?)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "storage"(): $Optional<($LongStream)>
public "paletteEntries"(): $List<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PalettedContainerRO$PackedData$$Type<T> = ({"paletteEntries"?: $List$$Type<(T)>, "storage"?: ($LongStream$$Type)?}) | ([paletteEntries?: $List$$Type<(T)>, storage?: ($LongStream$$Type)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PalettedContainerRO$PackedData$$Original<T> = $PalettedContainerRO$PackedData<(T)>;}
declare module "net.minecraft.world.level.block.state.properties.BlockStateProperties" {
import {$TrialSpawnerState} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerState"
import {$WallSide} from "net.minecraft.world.level.block.state.properties.WallSide"
import {$ChestType} from "net.minecraft.world.level.block.state.properties.ChestType"
import {$Tilt} from "net.minecraft.world.level.block.state.properties.Tilt"
import {$DoubleBlockHalf} from "net.minecraft.world.level.block.state.properties.DoubleBlockHalf"
import {$Half} from "net.minecraft.world.level.block.state.properties.Half"
import {$DoorHingeSide} from "net.minecraft.world.level.block.state.properties.DoorHingeSide"
import {$SlabType} from "net.minecraft.world.level.block.state.properties.SlabType"
import {$NoteBlockInstrument} from "net.minecraft.world.level.block.state.properties.NoteBlockInstrument"
import {$StructureMode} from "net.minecraft.world.level.block.state.properties.StructureMode"
import {$DripstoneThickness} from "net.minecraft.world.level.block.state.properties.DripstoneThickness"
import {$VaultState} from "net.minecraft.world.level.block.entity.vault.VaultState"
import {$BedPart} from "net.minecraft.world.level.block.state.properties.BedPart"
import {$StairsShape} from "net.minecraft.world.level.block.state.properties.StairsShape"
import {$RailShape} from "net.minecraft.world.level.block.state.properties.RailShape"
import {$IntegerProperty} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$SculkSensorPhase} from "net.minecraft.world.level.block.state.properties.SculkSensorPhase"
import {$PistonType} from "net.minecraft.world.level.block.state.properties.PistonType"
import {$BellAttachType} from "net.minecraft.world.level.block.state.properties.BellAttachType"
import {$ComparatorMode} from "net.minecraft.world.level.block.state.properties.ComparatorMode"
import {$Direction$Axis} from "net.minecraft.core.Direction$Axis"
import {$AttachFace} from "net.minecraft.world.level.block.state.properties.AttachFace"
import {$FrontAndTop} from "net.minecraft.core.FrontAndTop"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$BambooLeaves} from "net.minecraft.world.level.block.state.properties.BambooLeaves"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$RedstoneSide} from "net.minecraft.world.level.block.state.properties.RedstoneSide"
import {$DirectionProperty} from "net.minecraft.world.level.block.state.properties.DirectionProperty"

export class $BlockStateProperties {
static readonly "MAX_RESPAWN_ANCHOR_CHARGES": integer
static readonly "BAMBOO_LEAVES": $EnumProperty<($BambooLeaves)>
static readonly "HANGING": $BooleanProperty
static readonly "WEST_WALL": $EnumProperty<($WallSide)>
static readonly "CHISELED_BOOKSHELF_SLOT_5_OCCUPIED": $BooleanProperty
static readonly "BOTTOM": $BooleanProperty
static readonly "DUSTED": $IntegerProperty
static readonly "EYE": $BooleanProperty
static readonly "HALF": $EnumProperty<($Half)>
static readonly "DRAG": $BooleanProperty
static readonly "SOUTH": $BooleanProperty
static readonly "MIN_RESPAWN_ANCHOR_CHARGES": integer
static readonly "DISTANCE": $IntegerProperty
static readonly "LOCKED": $BooleanProperty
static readonly "EXTENDED": $BooleanProperty
static readonly "BLOOM": $BooleanProperty
static readonly "SCULK_SENSOR_PHASE": $EnumProperty<($SculkSensorPhase)>
static readonly "LEVEL": $IntegerProperty
static readonly "DOOR_HINGE": $EnumProperty<($DoorHingeSide)>
static readonly "STAIRS_SHAPE": $EnumProperty<($StairsShape)>
static readonly "EGGS": $IntegerProperty
static readonly "LAYERS": $IntegerProperty
static readonly "CONDITIONAL": $BooleanProperty
static readonly "EAST_WALL": $EnumProperty<($WallSide)>
static readonly "HATCH": $IntegerProperty
static readonly "ORIENTATION": $EnumProperty<($FrontAndTop)>
static readonly "LEVEL_CAULDRON": $IntegerProperty
static readonly "RAIL_SHAPE_STRAIGHT": $EnumProperty<($RailShape)>
static readonly "CHISELED_BOOKSHELF_SLOT_0_OCCUPIED": $BooleanProperty
static readonly "SIGNAL_FIRE": $BooleanProperty
static readonly "STRUCTUREBLOCK_MODE": $EnumProperty<($StructureMode)>
static readonly "PISTON_TYPE": $EnumProperty<($PistonType)>
static readonly "CAN_SUMMON": $BooleanProperty
static readonly "MIN_LEVEL": integer
static readonly "HAS_BOOK": $BooleanProperty
static readonly "OMINOUS": $BooleanProperty
static readonly "ATTACH_FACE": $EnumProperty<($AttachFace)>
static readonly "WATERLOGGED": $BooleanProperty
static readonly "SHRIEKING": $BooleanProperty
static readonly "FALLING": $BooleanProperty
static readonly "AGE_25": $IntegerProperty
static readonly "CRAFTING": $BooleanProperty
static readonly "TRIGGERED": $BooleanProperty
static readonly "MAX_LEVEL_8": integer
static readonly "CRACKED": $BooleanProperty
static readonly "CHISELED_BOOKSHELF_SLOT_4_OCCUPIED": $BooleanProperty
static readonly "UNSTABLE": $BooleanProperty
static readonly "CHEST_TYPE": $EnumProperty<($ChestType)>
static readonly "AGE_5": $IntegerProperty
static readonly "SOUTH_WALL": $EnumProperty<($WallSide)>
static readonly "AGE_4": $IntegerProperty
static readonly "AGE_7": $IntegerProperty
static readonly "STABILITY_MAX_DISTANCE": integer
static readonly "BELL_ATTACHMENT": $EnumProperty<($BellAttachType)>
static readonly "AGE_1": $IntegerProperty
static readonly "MAX_LEVEL_3": integer
static readonly "ATTACHED": $BooleanProperty
static readonly "AGE_3": $IntegerProperty
static readonly "STAGE": $IntegerProperty
static readonly "AGE_2": $IntegerProperty
static readonly "VAULT_STATE": $EnumProperty<($VaultState)>
static readonly "POWER": $IntegerProperty
static readonly "MAX_DISTANCE": integer
static readonly "HAS_BOTTLE_1": $BooleanProperty
static readonly "HAS_BOTTLE_0": $BooleanProperty
static readonly "PICKLES": $IntegerProperty
static readonly "HAS_BOTTLE_2": $BooleanProperty
static readonly "OPEN": $BooleanProperty
static readonly "DRIPSTONE_THICKNESS": $EnumProperty<($DripstoneThickness)>
static readonly "AGE_15": $IntegerProperty
static readonly "LEVEL_HONEY": $IntegerProperty
static readonly "CANDLES": $IntegerProperty
static readonly "LEVEL_COMPOSTER": $IntegerProperty
static readonly "LIT": $BooleanProperty
static readonly "EAST_REDSTONE": $EnumProperty<($RedstoneSide)>
static readonly "OCCUPIED": $BooleanProperty
static readonly "MODE_COMPARATOR": $EnumProperty<($ComparatorMode)>
static readonly "NORTH_REDSTONE": $EnumProperty<($RedstoneSide)>
static readonly "IN_WALL": $BooleanProperty
static readonly "SNOWY": $BooleanProperty
static readonly "DOWN": $BooleanProperty
static readonly "TRIAL_SPAWNER_STATE": $EnumProperty<($TrialSpawnerState)>
static readonly "WEST": $BooleanProperty
static readonly "CHISELED_BOOKSHELF_SLOT_2_OCCUPIED": $BooleanProperty
static readonly "NORTH_WALL": $EnumProperty<($WallSide)>
static readonly "MIN_LEVEL_CAULDRON": integer
static readonly "BED_PART": $EnumProperty<($BedPart)>
static readonly "NORTH": $BooleanProperty
static readonly "LEVEL_FLOWING": $IntegerProperty
static readonly "TILT": $EnumProperty<($Tilt)>
static readonly "UP": $BooleanProperty
static readonly "SOUTH_REDSTONE": $EnumProperty<($RedstoneSide)>
static readonly "MAX_AGE_15": integer
static readonly "HORIZONTAL_FACING": $DirectionProperty
static readonly "BITES": $IntegerProperty
static readonly "SLAB_TYPE": $EnumProperty<($SlabType)>
static readonly "MAX_AGE_2": integer
static readonly "MAX_AGE_1": integer
static readonly "ROTATION_16": $IntegerProperty
static readonly "CHISELED_BOOKSHELF_SLOT_1_OCCUPIED": $BooleanProperty
static readonly "MAX_AGE_7": integer
static readonly "STABILITY_DISTANCE": $IntegerProperty
static readonly "MAX_AGE_5": integer
static readonly "MAX_AGE_4": integer
static readonly "MAX_AGE_3": integer
static readonly "MAX_AGE_25": integer
static readonly "DELAY": $IntegerProperty
static readonly "AXIS": $EnumProperty<($Direction$Axis)>
static readonly "MAX_LEVEL_15": integer
static readonly "HORIZONTAL_AXIS": $EnumProperty<($Direction$Axis)>
static readonly "RAIL_SHAPE": $EnumProperty<($RailShape)>
static readonly "MOISTURE": $IntegerProperty
static readonly "VERTICAL_DIRECTION": $DirectionProperty
static readonly "FLOWER_AMOUNT": $IntegerProperty
static readonly "DOUBLE_BLOCK_HALF": $EnumProperty<($DoubleBlockHalf)>
static readonly "NOTE": $IntegerProperty
static readonly "BERRIES": $BooleanProperty
static readonly "RESPAWN_ANCHOR_CHARGES": $IntegerProperty
static readonly "EAST": $BooleanProperty
static readonly "PERSISTENT": $BooleanProperty
static readonly "HAS_RECORD": $BooleanProperty
static readonly "FACING_HOPPER": $DirectionProperty
static readonly "NOTEBLOCK_INSTRUMENT": $EnumProperty<($NoteBlockInstrument)>
static readonly "POWERED": $BooleanProperty
static readonly "SHORT": $BooleanProperty
static readonly "CHISELED_BOOKSHELF_SLOT_3_OCCUPIED": $BooleanProperty
static readonly "WEST_REDSTONE": $EnumProperty<($RedstoneSide)>
static readonly "ENABLED": $BooleanProperty
static readonly "INVERTED": $BooleanProperty
static readonly "FACING": $DirectionProperty
static readonly "DISARMED": $BooleanProperty

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateProperties$$Type = ($BlockStateProperties);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateProperties$$Original = $BlockStateProperties;}
declare module "net.minecraft.world.level.CustomSpawner" {
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"

export interface $CustomSpawner$$Interface {

(arg0: $ServerLevel, arg1: boolean, arg2: boolean): integer
}

export class $CustomSpawner implements $CustomSpawner$$Interface {
 "tick"(arg0: $ServerLevel$$Type, arg1: boolean, arg2: boolean): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomSpawner$$Type = ((arg0: $ServerLevel, arg1: boolean, arg2: boolean) => integer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomSpawner$$Original = $CustomSpawner;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.AcaciaFoliagePlacer" {
import {$FoliagePlacerType} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacerType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$FoliagePlacer$FoliageSetter$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageSetter"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$FoliagePlacer$FoliageAttachment$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $AcaciaFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($AcaciaFoliagePlacer)>
readonly "offset": $IntProvider
readonly "radius": $IntProvider

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type)

public "type"(): $FoliagePlacerType<(never)>
public "createFoliage"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: integer, arg5: $FoliagePlacer$FoliageAttachment$$Type, arg6: integer, arg7: integer, arg8: integer): void
public "shouldSkipLocation"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: boolean): boolean
public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AcaciaFoliagePlacer$$Type = ($AcaciaFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AcaciaFoliagePlacer$$Original = $AcaciaFoliagePlacer;}
declare module "net.minecraft.world.level.LightLayer" {
import {$Enum} from "java.lang.Enum"

export class $LightLayer extends $Enum<($LightLayer)> {
static readonly "SKY": $LightLayer
static readonly "BLOCK": $LightLayer

public static "values"(): ($LightLayer)[]
public static "valueOf"(arg0: StringJS): $LightLayer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LightLayer$$Type = (("sky") | ("block"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LightLayer$$Original = $LightLayer;}
declare module "net.minecraft.world.level.chunk.status.ChunkType" {
import {$Enum} from "java.lang.Enum"

export class $ChunkType extends $Enum<($ChunkType)> {
static readonly "LEVELCHUNK": $ChunkType
static readonly "PROTOCHUNK": $ChunkType

public static "values"(): ($ChunkType)[]
public static "valueOf"(arg0: StringJS): $ChunkType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkType$$Type = (("protochunk") | ("levelchunk"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkType$$Original = $ChunkType;}
declare module "net.minecraft.world.level.levelgen.DensityFunction$SimpleFunction" {
import {$DensityFunction$Visitor$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$Visitor"
import {$DensityFunction$ContextProvider$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider"
import {$KeyDispatchDataCodec} from "net.minecraft.util.KeyDispatchDataCodec"
import {$DensityFunction$FunctionContext$$Type} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$DensityFunction, $DensityFunction$$Interface} from "net.minecraft.world.level.levelgen.DensityFunction"

export interface $DensityFunction$SimpleFunction$$Interface extends $DensityFunction$$Interface {
}

export class $DensityFunction$SimpleFunction implements $DensityFunction$SimpleFunction$$Interface {
 "fillArray"(arg0: (double)[], arg1: $DensityFunction$ContextProvider$$Type): void
 "mapAll"(arg0: $DensityFunction$Visitor$$Type): $DensityFunction
 "abs"(): $DensityFunction
 "clamp"(arg0: double, arg1: double): $DensityFunction
 "compute"(arg0: $DensityFunction$FunctionContext$$Type): double
 "maxValue"(): double
 "square"(): $DensityFunction
 "halfNegative"(): $DensityFunction
 "quarterNegative"(): $DensityFunction
 "minValue"(): double
 "codec"(): $KeyDispatchDataCodec<($DensityFunction)>
 "cube"(): $DensityFunction
 "squeeze"(): $DensityFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunction$SimpleFunction$$Type = ($DensityFunction$SimpleFunction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunction$SimpleFunction$$Original = $DensityFunction$SimpleFunction;}
declare module "net.minecraft.world.level.storage.loot.entries.AlternativesEntry$Builder" {
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$LootPoolEntryContainer} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer"
import {$LootPoolEntryContainer$Builder, $LootPoolEntryContainer$Builder$$Type} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer$Builder"
import {$ConditionUserBuilder} from "net.minecraft.world.level.storage.loot.predicates.ConditionUserBuilder"

export class $AlternativesEntry$Builder extends $LootPoolEntryContainer$Builder<($AlternativesEntry$Builder)> {
constructor(...arg0: ($LootPoolEntryContainer$Builder$$Type<(never)>)[])

public "build"(): $LootPoolEntryContainer
public "getThis"(): $LootPoolEntryContainer$Builder
public "otherwise"(arg0: $LootPoolEntryContainer$Builder$$Type<(never)>): $AlternativesEntry$Builder
public "when"(arg0: $LootItemCondition$Builder$$Type): $ConditionUserBuilder
get "this"(): $LootPoolEntryContainer$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlternativesEntry$Builder$$Type = ($AlternativesEntry$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AlternativesEntry$Builder$$Original = $AlternativesEntry$Builder;}
declare module "net.minecraft.world.level.entity.ChunkEntities" {
import {$List$$Type} from "java.util.List"
import {$Stream} from "java.util.stream.Stream"
import {$ChunkPos, $ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"

export class $ChunkEntities<T> {
constructor(arg0: $ChunkPos$$Type, arg1: $List$$Type<(T)>)

public "isEmpty"(): boolean
public "getPos"(): $ChunkPos
public "getEntities"(): $Stream<(T)>
get "empty"(): boolean
get "pos"(): $ChunkPos
get "entities"(): $Stream<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkEntities$$Type<T> = ($ChunkEntities<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkEntities$$Original<T> = $ChunkEntities<(T)>;}
declare module "net.minecraft.world.level.chunk.PalettedContainer$Configuration" {
import {$PalettedContainer$Data} from "net.minecraft.world.level.chunk.PalettedContainer$Data"
import {$Palette$Factory, $Palette$Factory$$Type} from "net.minecraft.world.level.chunk.Palette$Factory"
import {$IdMap$$Type} from "net.minecraft.core.IdMap"
import {$PaletteResize$$Type} from "net.minecraft.world.level.chunk.PaletteResize"
import {$Record} from "java.lang.Record"

export class $PalettedContainer$Configuration<T> extends $Record {
constructor(factory: $Palette$Factory$$Type, bits: integer)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "factory"(): $Palette$Factory
public "bits"(): integer
public "createData"(arg0: $IdMap$$Type<(T)>, arg1: $PaletteResize$$Type<(T)>, arg2: integer): $PalettedContainer$Data<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PalettedContainer$Configuration$$Type<T> = ({"bits"?: integer, "factory"?: $Palette$Factory$$Type}) | ([bits?: integer, factory?: $Palette$Factory$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PalettedContainer$Configuration$$Original<T> = $PalettedContainer$Configuration<(T)>;}
declare module "net.minecraft.world.level.entity.EntityInLevelCallback" {
import {$Entity$RemovalReason$$Type} from "net.minecraft.world.entity.Entity$RemovalReason"

export interface $EntityInLevelCallback$$Interface {
}

export class $EntityInLevelCallback implements $EntityInLevelCallback$$Interface {
static readonly "NULL": $EntityInLevelCallback

 "onRemove"(arg0: $Entity$RemovalReason$$Type): void
 "onMove"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityInLevelCallback$$Type = ($EntityInLevelCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityInLevelCallback$$Original = $EntityInLevelCallback;}
declare module "net.minecraft.world.level.entity.EntityLookup" {
import {$Iterable} from "java.lang.Iterable"
import {$EntityAccess, $EntityAccess$$Type} from "net.minecraft.world.level.entity.EntityAccess"
import {$UUID$$Type} from "java.util.UUID"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$AbortableIterationConsumer$$Type} from "net.minecraft.util.AbortableIterationConsumer"

export class $EntityLookup<T extends $EntityAccess> {
constructor()

public "remove"(arg0: T): void
public "add"(arg0: T): void
public "count"(): integer
public "getEntities"<U extends $EntityAccess>(arg0: $EntityTypeTest$$Type<(T), (U)>, arg1: $AbortableIterationConsumer$$Type<(U)>): void
public "getAllEntities"(): $Iterable<(T)>
public "getEntity"(arg0: $UUID$$Type): T
public "getEntity"(arg0: integer): T
get "allEntities"(): $Iterable<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityLookup$$Type<T> = ($EntityLookup<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityLookup$$Original<T> = $EntityLookup<(T)>;}
declare module "net.minecraft.world.level.block.MultifaceSpreader" {
import {$MultifaceSpreader$SpreadPredicate$$Type} from "net.minecraft.world.level.block.MultifaceSpreader$SpreadPredicate"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$MultifaceBlock$$Type} from "net.minecraft.world.level.block.MultifaceBlock"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$MultifaceSpreader$SpreadType} from "net.minecraft.world.level.block.MultifaceSpreader$SpreadType"
import {$MultifaceSpreader$SpreadPos, $MultifaceSpreader$SpreadPos$$Type} from "net.minecraft.world.level.block.MultifaceSpreader$SpreadPos"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$MultifaceSpreader$SpreadConfig$$Type} from "net.minecraft.world.level.block.MultifaceSpreader$SpreadConfig"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $MultifaceSpreader {
static readonly "DEFAULT_SPREAD_ORDER": ($MultifaceSpreader$SpreadType)[]

constructor(arg0: $MultifaceBlock$$Type)
constructor(arg0: $MultifaceSpreader$SpreadConfig$$Type)

public "spreadFromRandomFaceTowardRandomDirection"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $RandomSource$$Type): $Optional<($MultifaceSpreader$SpreadPos)>
public "canSpreadInAnyDirection"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type): boolean
public "spreadToFace"(arg0: $LevelAccessor$$Type, arg1: $MultifaceSpreader$SpreadPos$$Type, arg2: boolean): $Optional<($MultifaceSpreader$SpreadPos)>
public "spreadFromFaceTowardRandomDirection"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $RandomSource$$Type, arg5: boolean): $Optional<($MultifaceSpreader$SpreadPos)>
public "spreadAll"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: boolean): long
public "spreadFromFaceTowardDirection"(arg0: $BlockState$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $Direction$$Type, arg5: boolean): $Optional<($MultifaceSpreader$SpreadPos)>
public "getSpreadFromFaceTowardDirection"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $Direction$$Type, arg4: $Direction$$Type, arg5: $MultifaceSpreader$SpreadPredicate$$Type): $Optional<($MultifaceSpreader$SpreadPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultifaceSpreader$$Type = ($MultifaceSpreader);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultifaceSpreader$$Original = $MultifaceSpreader;}
declare module "net.minecraft.world.level.dimension.DimensionType" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$DataResult} from "com.mojang.serialization.DataResult"
import {$Dynamic$$Type} from "com.mojang.serialization.Dynamic"
import {$OptionalLong, $OptionalLong$$Type} from "java.util.OptionalLong"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$IntProvider} from "net.minecraft.util.valueproviders.IntProvider"
import {$DimensionTypeAccessor$$Interface} from "net.irisshaders.iris.mixin.DimensionTypeAccessor"
import {$Holder} from "net.minecraft.core.Holder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$DimensionType$MonsterSettings, $DimensionType$MonsterSettings$$Type} from "net.minecraft.world.level.dimension.DimensionType$MonsterSettings"
import {$Record} from "java.lang.Record"

export class $DimensionType extends $Record implements $DimensionTypeAccessor$$Interface {
static readonly "MIN_Y": integer
static readonly "CODEC": $Codec<($Holder<($DimensionType)>)>
static readonly "MIN_HEIGHT": integer
static readonly "MAX_Y": integer
static readonly "Y_SIZE": integer
static readonly "WAY_ABOVE_MAX_Y": integer
static readonly "WAY_BELOW_MIN_Y": integer
static readonly "DIRECT_CODEC": $Codec<($DimensionType)>
static readonly "BITS_FOR_Y": integer
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($Holder<($DimensionType)>)>
static readonly "MOON_BRIGHTNESS_PER_PHASE": (float)[]

constructor(arg0: $OptionalLong$$Type, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: double, arg6: boolean, arg7: boolean, arg8: integer, arg9: integer, arg10: integer, arg11: $TagKey$$Type<($Block)>, arg12: $ResourceLocation$$Type, arg13: float, arg14: $DimensionType$MonsterSettings$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "timeOfDay"(arg0: long): float
/**
 * 
 * @deprecated
 */
public static "parseLegacy"(arg0: $Dynamic$$Type<(never)>): $DataResult<($ResourceKey<($Level)>)>
public "respawnAnchorWorks"(): boolean
public "monsterSpawnBlockLightLimit"(): integer
public "effectsLocation"(): $ResourceLocation
public "getFixedTime"(): $OptionalLong
public "getAmbientLight"(): float
public static "getStorageFolder"(arg0: $ResourceKey$$Type<($Level)>, arg1: $Path$$Type): $Path
public "monsterSettings"(): $DimensionType$MonsterSettings
public "logicalHeight"(): integer
public static "getTeleportationScale"(arg0: $DimensionType$$Type, arg1: $DimensionType$$Type): double
public "hasFixedTime"(): boolean
public "coordinateScale"(): double
public "hasSkyLight"(): boolean
public "natural"(): boolean
public "hasCeiling"(): boolean
public "minY"(): integer
public "moonPhase"(arg0: long): integer
public "height"(): integer
public "ambientLight"(): float
public "ultraWarm"(): boolean
public "piglinSafe"(): boolean
public "infiniburn"(): $TagKey<($Block)>
public "bedWorks"(): boolean
public "monsterSpawnLightTest"(): $IntProvider
public "hasRaids"(): boolean
public "fixedTime"(): $OptionalLong
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.DimensionType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.DimensionTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DimensionType$$Type = (Special.DimensionType) | ({"logicalHeight"?: integer, "hasSkyLight"?: boolean, "ambientLight"?: float, "effectsLocation"?: $ResourceLocation$$Type, "monsterSettings"?: $DimensionType$MonsterSettings$$Type, "natural"?: boolean, "fixedTime"?: $OptionalLong$$Type, "coordinateScale"?: double, "infiniburn"?: $TagKey$$Type<($Block)>, "respawnAnchorWorks"?: boolean, "minY"?: integer, "ultraWarm"?: boolean, "bedWorks"?: boolean, "height"?: integer, "hasCeiling"?: boolean}) | ([logicalHeight?: integer, hasSkyLight?: boolean, ambientLight?: float, effectsLocation?: $ResourceLocation$$Type, monsterSettings?: $DimensionType$MonsterSettings$$Type, natural?: boolean, fixedTime?: $OptionalLong$$Type, coordinateScale?: double, infiniburn?: $TagKey$$Type<($Block)>, respawnAnchorWorks?: boolean, minY?: integer, ultraWarm?: boolean, bedWorks?: boolean, height?: integer, hasCeiling?: boolean]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DimensionType$$Original = $DimensionType;}
declare module "net.minecraft.world.level.PotentialCalculator" {
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $PotentialCalculator {
constructor()

public "addCharge"(arg0: $BlockPos$$Type, arg1: double): void
public "getPotentialEnergyChange"(arg0: $BlockPos$$Type, arg1: double): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotentialCalculator$$Type = ($PotentialCalculator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PotentialCalculator$$Original = $PotentialCalculator;}
declare module "net.minecraft.world.level.entity.EntityPersistentStorage" {
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$ChunkEntities, $ChunkEntities$$Type} from "net.minecraft.world.level.entity.ChunkEntities"

export interface $EntityPersistentStorage$$Interface<T> extends $AutoCloseable$$Interface {
}

export class $EntityPersistentStorage<T> implements $EntityPersistentStorage$$Interface {
 "flush"(arg0: boolean): void
 "close"(): void
 "loadEntities"(arg0: $ChunkPos$$Type): $CompletableFuture<($ChunkEntities<(T)>)>
 "storeEntities"(arg0: $ChunkEntities$$Type<(T)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityPersistentStorage$$Type<T> = ($EntityPersistentStorage<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityPersistentStorage$$Original<T> = $EntityPersistentStorage<(T)>;}
declare module "net.minecraft.world.level.chunk.storage.RegionFile" {
import {$RegionFileVersion, $RegionFileVersion$$Type} from "net.minecraft.world.level.chunk.storage.RegionFileVersion"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$DataInputStream} from "java.io.DataInputStream"
import {$DataOutputStream} from "java.io.DataOutputStream"
import {$RegionStorageInfo, $RegionStorageInfo$$Type} from "net.minecraft.world.level.chunk.storage.RegionStorageInfo"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$RegionBitmap} from "net.minecraft.world.level.chunk.storage.RegionBitmap"
import {$ByteBuffer$$Type} from "java.nio.ByteBuffer"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"

export class $RegionFile implements $AutoCloseable$$Interface {
readonly "usedSectors": $RegionBitmap
readonly "version": $RegionFileVersion
static readonly "SECTOR_INTS": integer
readonly "info": $RegionStorageInfo

constructor(arg0: $RegionStorageInfo$$Type, arg1: $Path$$Type, arg2: $Path$$Type, arg3: boolean)
constructor(arg0: $RegionStorageInfo$$Type, arg1: $Path$$Type, arg2: $Path$$Type, arg3: $RegionFileVersion$$Type, arg4: boolean)

public "clear"(arg0: $ChunkPos$$Type): void
public "flush"(): void
public "write"(arg0: $ChunkPos$$Type, arg1: $ByteBuffer$$Type): void
public "close"(): void
public "getPath"(): $Path
public "getChunkDataInputStream"(arg0: $ChunkPos$$Type): $DataInputStream
public "getChunkDataOutputStream"(arg0: $ChunkPos$$Type): $DataOutputStream
public "hasChunk"(arg0: $ChunkPos$$Type): boolean
public "doesChunkExist"(arg0: $ChunkPos$$Type): boolean
get "path"(): $Path
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegionFile$$Type = ($RegionFile);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegionFile$$Original = $RegionFile;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RuleTestType} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTestType"
import {$BlockStatePredicate$$Type} from "dev.latvian.mods.kubejs.block.state.BlockStatePredicate"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RuleTest {
static readonly "CODEC": $Codec<($RuleTest)>

constructor()

public "test"(arg0: $BlockState$$Type, arg1: $RandomSource$$Type): boolean
public "getType"(): $RuleTestType<(never)>
get "type"(): $RuleTestType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RuleTest$$Type = ($BlockStatePredicate) | ($CompoundTag$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RuleTest$$Original = $RuleTest;}
declare module "net.minecraft.world.level.block.entity.BeehiveBlockEntity$Occupant" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CustomData, $CustomData$$Type} from "net.minecraft.world.item.component.CustomData"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$Record} from "java.lang.Record"

export class $BeehiveBlockEntity$Occupant extends $Record {
static readonly "CODEC": $Codec<($BeehiveBlockEntity$Occupant)>
static readonly "LIST_CODEC": $Codec<($List<($BeehiveBlockEntity$Occupant)>)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($BeehiveBlockEntity$Occupant)>

constructor(arg0: $CustomData$$Type, arg1: integer, arg2: integer)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "of"(arg0: $Entity$$Type): $BeehiveBlockEntity$Occupant
public static "create"(arg0: integer): $BeehiveBlockEntity$Occupant
public "createEntity"(arg0: $Level$$Type, arg1: $BlockPos$$Type): $Entity
public "ticksInHive"(): integer
public "minTicksInHive"(): integer
public "entityData"(): $CustomData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeehiveBlockEntity$Occupant$$Type = ({"ticksInHive"?: integer, "minTicksInHive"?: integer, "entityData"?: $CustomData$$Type}) | ([ticksInHive?: integer, minTicksInHive?: integer, entityData?: $CustomData$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeehiveBlockEntity$Occupant$$Original = $BeehiveBlockEntity$Occupant;}
declare module "net.minecraft.world.level.pathfinder.Target" {
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$PathType} from "net.minecraft.world.level.pathfinder.PathType"
import {$Node, $Node$$Type} from "net.minecraft.world.level.pathfinder.Node"

export class $Target extends $Node {
 "cameFrom": $Node
 "f": float
 "g": float
readonly "x": integer
 "h": float
readonly "y": integer
 "closed": boolean
readonly "z": integer
 "walkedDistance": float
 "costMalus": float
 "type": $PathType
 "heapIdx": integer

constructor(arg0: $Node$$Type)
constructor(arg0: integer, arg1: integer, arg2: integer)

public "getBestNode"(): $Node
public static "createFromStream"(arg0: $FriendlyByteBuf$$Type): $Target
public "isReached"(): boolean
public "updateBest"(arg0: float, arg1: $Node$$Type): void
public "setReached"(): void
get "bestNode"(): $Node
get "reached"(): boolean
get "reached"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Target$$Type = ($Target);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Target$$Original = $Target;}
declare module "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer" {
import {$LootPoolEntryAccessor$$Interface} from "fzzyhmstrs.emi_loot.mixins.LootPoolEntryAccessor"
import {$Products$P1} from "com.mojang.datafixers.Products$P1"
import {$RecordCodecBuilder$Instance$$Type} from "com.mojang.serialization.codecs.RecordCodecBuilder$Instance"
import {$LootPoolEntryType} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryType"
import {$LootContext$$Type} from "net.minecraft.world.level.storage.loot.LootContext"
import {$RecordCodecBuilder$Mu} from "com.mojang.serialization.codecs.RecordCodecBuilder$Mu"
import {$List, $List$$Type} from "java.util.List"
import {$ComposableEntryContainer$$Interface} from "net.minecraft.world.level.storage.loot.entries.ComposableEntryContainer"
import {$ValidationContext$$Type} from "net.minecraft.world.level.storage.loot.ValidationContext"
import {$LootItemCondition, $LootItemCondition$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"

export class $LootPoolEntryContainer implements $ComposableEntryContainer$$Interface, $LootPoolEntryAccessor$$Interface {
readonly "conditions": $List<($LootItemCondition)>

constructor(arg0: $List$$Type<($LootItemCondition$$Type)>)

public "validate"(arg0: $ValidationContext$$Type): void
public "getType"(): $LootPoolEntryType
public static "commonFields"<T extends $LootPoolEntryContainer>(arg0: $RecordCodecBuilder$Instance$$Type<(T)>): $Products$P1<($RecordCodecBuilder$Mu<(T)>), ($List<($LootItemCondition)>)>
public "getConditions"(): $List
public "canRun"(arg0: $LootContext$$Type): boolean
get "type"(): $LootPoolEntryType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootPoolEntryContainer$$Type = ($LootPoolEntryContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootPoolEntryContainer$$Original = $LootPoolEntryContainer;}
declare module "net.minecraft.world.level.entity.EntityAccess" {
import {$UUID} from "java.util.UUID"
import {$EntityInLevelCallback$$Type} from "net.minecraft.world.level.entity.EntityInLevelCallback"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$AABB} from "net.minecraft.world.phys.AABB"
import {$Entity$RemovalReason$$Type} from "net.minecraft.world.entity.Entity$RemovalReason"

export interface $EntityAccess$$Interface {
get "id"(): integer
get "UUID"(): $UUID
get "selfAndPassengers"(): $Stream<($EntityAccess)>
get "passengersAndSelf"(): $Stream<($EntityAccess)>
get "alwaysTicking"(): boolean
set "levelCallback"(value: $EntityInLevelCallback$$Type)
set "removed"(value: $Entity$RemovalReason$$Type)
get "boundingBox"(): $AABB
}

export class $EntityAccess implements $EntityAccess$$Interface {
 "getId"(): integer
 "getUUID"(): $UUID
 "getSelfAndPassengers"(): $Stream<($EntityAccess)>
 "getPassengersAndSelf"(): $Stream<($EntityAccess)>
 "shouldBeSaved"(): boolean
 "isAlwaysTicking"(): boolean
 "setLevelCallback"(arg0: $EntityInLevelCallback$$Type): void
 "setRemoved"(arg0: $Entity$RemovalReason$$Type): void
 "blockPosition"(): $BlockPos
 "getBoundingBox"(): $AABB
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityAccess$$Type = ($EntityAccess);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityAccess$$Original = $EntityAccess;}
declare module "net.minecraft.world.level.levelgen.WorldgenRandom$Algorithm" {
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$Enum} from "java.lang.Enum"

export class $WorldgenRandom$Algorithm extends $Enum<($WorldgenRandom$Algorithm)> {
static readonly "LEGACY": $WorldgenRandom$Algorithm
static readonly "XOROSHIRO": $WorldgenRandom$Algorithm

public static "values"(): ($WorldgenRandom$Algorithm)[]
public static "valueOf"(arg0: StringJS): $WorldgenRandom$Algorithm
public "newInstance"(arg0: long): $RandomSource
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldgenRandom$Algorithm$$Type = (("legacy") | ("xoroshiro"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldgenRandom$Algorithm$$Original = $WorldgenRandom$Algorithm;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.RandomBlockStateMatchTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$RuleTestType} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTestType"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RandomBlockStateMatchTest extends $RuleTest {
static readonly "CODEC": $MapCodec<($RandomBlockStateMatchTest)>

constructor(arg0: $BlockState$$Type, arg1: float)

public "test"(arg0: $BlockState$$Type, arg1: $RandomSource$$Type): boolean
public "getType"(): $RuleTestType<(never)>
get "type"(): $RuleTestType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomBlockStateMatchTest$$Type = ($RandomBlockStateMatchTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomBlockStateMatchTest$$Original = $RandomBlockStateMatchTest;}
declare module "net.minecraft.world.level.block.entity.BeehiveBlockEntity$BeeReleaseStatus" {
import {$Enum} from "java.lang.Enum"

export class $BeehiveBlockEntity$BeeReleaseStatus extends $Enum<($BeehiveBlockEntity$BeeReleaseStatus)> {
static readonly "BEE_RELEASED": $BeehiveBlockEntity$BeeReleaseStatus
static readonly "EMERGENCY": $BeehiveBlockEntity$BeeReleaseStatus
static readonly "HONEY_DELIVERED": $BeehiveBlockEntity$BeeReleaseStatus

public static "values"(): ($BeehiveBlockEntity$BeeReleaseStatus)[]
public static "valueOf"(arg0: StringJS): $BeehiveBlockEntity$BeeReleaseStatus
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeehiveBlockEntity$BeeReleaseStatus$$Type = (("honey_delivered") | ("bee_released") | ("emergency"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeehiveBlockEntity$BeeReleaseStatus$$Original = $BeehiveBlockEntity$BeeReleaseStatus;}
declare module "net.minecraft.world.level.block.entity.LidBlockEntity" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $LidBlockEntity$$Interface {

(arg0: float): float
}

export class $LidBlockEntity implements $LidBlockEntity$$Interface {
 "getOpenNess"(arg0: float): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LidBlockEntity$$Type = ((arg0: float) => float);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LidBlockEntity$$Original = $LidBlockEntity;}
declare module "net.minecraft.world.level.chunk.PalettedContainer" {
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$PalettedContainer$CountConsumer$$Type} from "net.minecraft.world.level.chunk.PalettedContainer$CountConsumer"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$List$$Type} from "java.util.List"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$PalettedContainer$Strategy$$Type} from "net.minecraft.world.level.chunk.PalettedContainer$Strategy"
import {$BitStorage$$Type} from "net.minecraft.util.BitStorage"
import {$IdMap$$Type} from "net.minecraft.core.IdMap"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$PalettedContainerROExtension, $PalettedContainerROExtension$$Interface} from "net.caffeinemc.mods.sodium.client.world.PalettedContainerROExtension"
import {$PalettedContainer$Configuration$$Type} from "net.minecraft.world.level.chunk.PalettedContainer$Configuration"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$PalettedContainerRO$PackedData} from "net.minecraft.world.level.chunk.PalettedContainerRO$PackedData"
import {$PaletteResize$$Interface} from "net.minecraft.world.level.chunk.PaletteResize"
import {$PalettedContainerRO, $PalettedContainerRO$$Type, $PalettedContainerRO$$Interface} from "net.minecraft.world.level.chunk.PalettedContainerRO"

export class $PalettedContainer<T> implements $PaletteResize$$Interface<(T)>, $PalettedContainerRO$$Interface<(T)>, $PalettedContainerROExtension$$Interface {
constructor(arg0: $IdMap$$Type<(T)>, arg1: $PalettedContainer$Strategy$$Type, arg2: $PalettedContainer$Configuration$$Type<(T)>, arg3: $BitStorage$$Type, arg4: $List$$Type<(T)>)
constructor(arg0: $IdMap$$Type<(T)>, arg1: T, arg2: $PalettedContainer$Strategy$$Type)

public "maybeHas"(arg0: $Predicate$$Type<(T)>): boolean
public "get"(arg0: integer): T
public "get"(arg0: integer, arg1: integer, arg2: integer): T
public "count"(arg0: $PalettedContainer$CountConsumer$$Type<(T)>): void
public "set"(arg0: integer, arg1: integer, arg2: integer, arg3: T): void
public "write"(arg0: $FriendlyByteBuf$$Type): void
public "read"(arg0: $FriendlyByteBuf$$Type): void
public "copy"(): $PalettedContainer<(T)>
public "getAndSet"(arg0: integer, arg1: integer, arg2: integer, arg3: T): T
public "release"(): void
public "acquire"(): void
public "getAll"(arg0: $Consumer$$Type<(T)>): void
public "onResize"(arg0: integer, arg1: T): integer
public "pack"(arg0: $IdMap$$Type, arg1: $PalettedContainer$Strategy$$Type): $PalettedContainerRO$PackedData
public "getSerializedSize"(): integer
public "getAndSetUnchecked"(arg0: integer, arg1: integer, arg2: integer, arg3: T): T
public "sodium$copy"(): $PalettedContainerRO
public "handler$bma000$lithium$count"(arg0: $PalettedContainer$CountConsumer$$Type, arg1: $CallbackInfo$$Type): void
public "sodium$unpack"(arg0: (any)[]): void
public "sodium$unpack"(arg0: (any)[], arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): void
public "recreate"(): $PalettedContainer<(T)>
public static "codecRO"<T>(arg0: $IdMap$$Type<(T)>, arg1: $Codec$$Type<(T)>, arg2: $PalettedContainer$Strategy$$Type, arg3: T): $Codec<($PalettedContainerRO<(T)>)>
public static "codecRW"<T>(arg0: $IdMap$$Type<(T)>, arg1: $Codec$$Type<(T)>, arg2: $PalettedContainer$Strategy$$Type, arg3: T): $Codec<($PalettedContainer<(T)>)>
public "handler$bln000$lithium$removeLockHelper"(arg0: $CallbackInfo$$Type): void
public static "clone"<T>(arg0: $PalettedContainerRO$$Type<(any)>): $PalettedContainerRO<(any)>
public static "of"<T>(arg0: $PalettedContainerRO$$Type<(any)>): $PalettedContainerROExtension<(any)>
get "serializedSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PalettedContainer$$Type<T> = ($PalettedContainer<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PalettedContainer$$Original<T> = $PalettedContainer<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.GiantTrunkPlacer" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$TrunkPlacerType} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacerType"
import {$List} from "java.util.List"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $GiantTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($GiantTrunkPlacer)>
static readonly "MAX_HEIGHT": integer
readonly "baseHeight": integer
readonly "heightRandA": integer
readonly "heightRandB": integer

constructor(arg0: integer, arg1: integer, arg2: integer)

public "type"(): $TrunkPlacerType<(never)>
public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GiantTrunkPlacer$$Type = ($GiantTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GiantTrunkPlacer$$Original = $GiantTrunkPlacer;}
declare module "net.minecraft.world.level.block.entity.SkullBlockEntity" {
import {$Optional} from "java.util.Optional"
import {$UUID$$Type} from "java.util.UUID"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$PlayerModelPart$$Type} from "net.minecraft.world.entity.player.PlayerModelPart"
import {$Component} from "net.minecraft.network.chat.Component"
import {$DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$LoadingCache} from "com.google.common.cache.LoadingCache"
import {$Inventory} from "net.minecraft.world.entity.player.Inventory"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Executor, $Executor$$Type} from "java.util.concurrent.Executor"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BooleanSupplier$$Type} from "java.util.function.BooleanSupplier"
import {$ETFPlayerEntity$$Interface} from "traben.entity_texture_features.features.player.ETFPlayerEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$SkullSettings$$Interface} from "dev.tr7zw.skinlayers.accessor.SkullSettings"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$Mesh, $Mesh$$Type} from "dev.tr7zw.skinlayers.api.Mesh"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$Services$$Type} from "net.minecraft.server.Services"
import {$ResolvableProfile, $ResolvableProfile$$Type} from "net.minecraft.world.item.component.ResolvableProfile"

export class $SkullBlockEntity extends $BlockEntity implements $ETFPlayerEntity$$Interface, $SkullSettings$$Interface {
static "profileCacheByName": $LoadingCache<(StringJS), ($CompletableFuture<($Optional<($GameProfile)>)>)>
 "worldPosition": $BlockPos
static readonly "CHECKED_MAIN_THREAD_EXECUTOR": $Executor
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public static "clear"(): void
public static "setup"(arg0: $Services$$Type, arg1: $Executor$$Type): void
public "initialized"(): boolean
public "setOwner"(arg0: $ResolvableProfile$$Type): void
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public static "fetchProfileByName"(arg0: StringJS, arg1: $Services$$Type): $CompletableFuture<($Optional<($GameProfile)>)>
public "setLastTexture"(texture: $ResourceLocation$$Type): void
public static "fetchProfileById"(arg0: $UUID$$Type, arg1: $Services$$Type, arg2: $BooleanSupplier$$Type): $CompletableFuture<($Optional<($GameProfile)>)>
public "setupHeadLayers"(box: $Mesh$$Type): void
public "getAnimation"(arg0: float): float
public "getHeadLayers"(): $Mesh
public "getOwnerProfile"(): $ResolvableProfile
public "getLastTexture"(): $ResourceLocation
public static "fetchGameProfile"(arg0: $UUID$$Type): $CompletableFuture<($Optional<($GameProfile)>)>
public static "fetchGameProfile"(arg0: StringJS): $CompletableFuture<($Optional<($GameProfile)>)>
public "etf$getUuidAsString"(): StringJS
public static "animation"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $SkullBlockEntity$$Type): void
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "setInitialized"(initialized: boolean): void
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "etf$isPartVisible"(part: $PlayerModelPart$$Type): boolean
public "etf$isTeammate"(player: $Player$$Type): boolean
public "etf$getEntity"(): $Entity
public "etf$getName"(): $Component
public "etf$getInventory"(): $Inventory
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "getNoteBlockSound"(): $ResourceLocation
public "collectImplicitComponents"(arg0: $DataComponentMap$Builder$$Type): void
public "applyImplicitComponents"(arg0: $BlockEntity$DataComponentInput$$Type): void
public "getMesh"(): $Mesh
set "owner"(value: $ResolvableProfile$$Type)
set "lastTexture"(value: $ResourceLocation$$Type)
set "upHeadLayers"(value: $Mesh$$Type)
get "headLayers"(): $Mesh
get "ownerProfile"(): $ResolvableProfile
get "lastTexture"(): $ResourceLocation
get "updatePacket"(): $ClientboundBlockEntityDataPacket
get "noteBlockSound"(): $ResourceLocation
get "mesh"(): $Mesh
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SkullBlockEntity$$Type = ($SkullBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SkullBlockEntity$$Original = $SkullBlockEntity;}
declare module "net.minecraft.world.level.storage.loot.functions.LootItemFunctionType" {
import {$LootItemFunction} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $LootItemFunctionType<T extends $LootItemFunction> extends $Record {
constructor(arg0: $MapCodec$$Type<(T)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "codec"(): $MapCodec<(T)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.LootFunctionType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.LootFunctionTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootItemFunctionType$$Type<T> = (Special.LootFunctionType) | ({"codec"?: $MapCodec$$Type<(T)>}) | ([codec?: $MapCodec$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootItemFunctionType$$Original<T> = $LootItemFunctionType<(T)>;}
declare module "net.minecraft.world.level.chunk.status.ChunkStatus" {
import {$Heightmap$Types, $Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$List} from "java.util.List"
import {$EnumSet, $EnumSet$$Type} from "java.util.EnumSet"
import {$ChunkType, $ChunkType$$Type} from "net.minecraft.world.level.chunk.status.ChunkType"

export class $ChunkStatus {
static readonly "LIGHT": $ChunkStatus
static readonly "NOISE": $ChunkStatus
static readonly "MAX_STRUCTURE_DISTANCE": integer
static readonly "SPAWN": $ChunkStatus
static readonly "FULL": $ChunkStatus
static readonly "FEATURES": $ChunkStatus
static readonly "STRUCTURE_STARTS": $ChunkStatus
static readonly "STRUCTURE_REFERENCES": $ChunkStatus
static readonly "FINAL_HEIGHTMAPS": $EnumSet<($Heightmap$Types)>
static readonly "SURFACE": $ChunkStatus
static readonly "INITIALIZE_LIGHT": $ChunkStatus
static readonly "BIOMES": $ChunkStatus
static readonly "CARVERS": $ChunkStatus
static readonly "EMPTY": $ChunkStatus

constructor(arg0: $ChunkStatus$$Type, arg1: $EnumSet$$Type<($Heightmap$Types$$Type)>, arg2: $ChunkType$$Type)

public "getName"(): StringJS
public "toString"(): StringJS
public static "max"(arg0: $ChunkStatus$$Type, arg1: $ChunkStatus$$Type): $ChunkStatus
public "getParent"(): $ChunkStatus
public "getIndex"(): integer
public "isAfter"(arg0: $ChunkStatus$$Type): boolean
public "isBefore"(arg0: $ChunkStatus$$Type): boolean
public "isOrBefore"(arg0: $ChunkStatus$$Type): boolean
public "getChunkType"(): $ChunkType
public static "getStatusList"(): $List<($ChunkStatus)>
public static "byName"(arg0: StringJS): $ChunkStatus
public "isOrAfter"(arg0: $ChunkStatus$$Type): boolean
public "heightmapsAfter"(): $EnumSet<($Heightmap$Types)>
get "name"(): StringJS
get "parent"(): $ChunkStatus
get "index"(): integer
get "chunkType"(): $ChunkType
get "statusList"(): $List<($ChunkStatus)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.ChunkStatus
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.ChunkStatusTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkStatus$$Type = (Special.ChunkStatus);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkStatus$$Original = $ChunkStatus;}
declare module "net.minecraft.world.level.gameevent.vibrations.VibrationInfo" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Optional} from "java.util.Optional"
import {$GameEvent, $GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $VibrationInfo extends $Record {
static readonly "CODEC": $Codec<($VibrationInfo)>

constructor(arg0: $Holder$$Type<($GameEvent)>, arg1: float, arg2: $Vec3$$Type, arg3: $UUID$$Type, arg4: $UUID$$Type, arg5: $Entity$$Type)
constructor(arg0: $Holder$$Type<($GameEvent)>, arg1: float, arg2: $Vec3$$Type, arg3: $Entity$$Type)
constructor(arg0: $Holder$$Type<($GameEvent)>, arg1: float, arg2: $Vec3$$Type, arg3: $UUID$$Type, arg4: $UUID$$Type)

public "projectileOwnerUuid"(): $UUID
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "pos"(): $Vec3
public "distance"(): float
public "entity"(): $Entity
public "getEntity"(arg0: $ServerLevel$$Type): $Optional<($Entity)>
public "uuid"(): $UUID
public "gameEvent"(): $Holder<($GameEvent)>
public "getProjectileOwner"(arg0: $ServerLevel$$Type): $Optional<($Entity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VibrationInfo$$Type = ({"gameEvent"?: $Holder$$Type<($GameEvent)>, "projectileOwnerUuid"?: $UUID$$Type, "entity"?: $Entity$$Type, "distance"?: float, "pos"?: $Vec3$$Type, "uuid"?: $UUID$$Type}) | ([gameEvent?: $Holder$$Type<($GameEvent)>, projectileOwnerUuid?: $UUID$$Type, entity?: $Entity$$Type, distance?: float, pos?: $Vec3$$Type, uuid?: $UUID$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VibrationInfo$$Original = $VibrationInfo;}
declare module "net.minecraft.world.level.saveddata.SavedData" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$File$$Type} from "java.io.File"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $SavedData {
constructor()

public "save"(arg0: $File$$Type, arg1: $HolderLookup$Provider$$Type): void
public "save"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public "isDirty"(): boolean
public "setDirty"(arg0: boolean): void
public "setDirty"(): void
get "dirty"(): boolean
set "dirty"(value: boolean)
get "dirty"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SavedData$$Type = ($SavedData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SavedData$$Original = $SavedData;}
declare module "net.minecraft.world.level.biome.Climate$ParameterPoint" {
import {$Climate$TargetPoint$$Type} from "net.minecraft.world.level.biome.Climate$TargetPoint"
import {$Codec} from "com.mojang.serialization.Codec"
import {$List} from "java.util.List"
import {$Climate$Parameter, $Climate$Parameter$$Type} from "net.minecraft.world.level.biome.Climate$Parameter"
import {$Record} from "java.lang.Record"

export class $Climate$ParameterPoint extends $Record {
static readonly "CODEC": $Codec<($Climate$ParameterPoint)>

constructor(arg0: $Climate$Parameter$$Type, arg1: $Climate$Parameter$$Type, arg2: $Climate$Parameter$$Type, arg3: $Climate$Parameter$$Type, arg4: $Climate$Parameter$$Type, arg5: $Climate$Parameter$$Type, arg6: long)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "offset"(): long
public "depth"(): $Climate$Parameter
public "temperature"(): $Climate$Parameter
public "weirdness"(): $Climate$Parameter
public "fitness"(arg0: $Climate$TargetPoint$$Type): long
public "erosion"(): $Climate$Parameter
public "humidity"(): $Climate$Parameter
public "continentalness"(): $Climate$Parameter
public "parameterSpace"(): $List<($Climate$Parameter)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Climate$ParameterPoint$$Type = ({"continentalness"?: $Climate$Parameter$$Type, "offset"?: long, "weirdness"?: $Climate$Parameter$$Type, "erosion"?: $Climate$Parameter$$Type, "temperature"?: $Climate$Parameter$$Type, "depth"?: $Climate$Parameter$$Type, "humidity"?: $Climate$Parameter$$Type}) | ([continentalness?: $Climate$Parameter$$Type, offset?: long, weirdness?: $Climate$Parameter$$Type, erosion?: $Climate$Parameter$$Type, temperature?: $Climate$Parameter$$Type, depth?: $Climate$Parameter$$Type, humidity?: $Climate$Parameter$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Climate$ParameterPoint$$Original = $Climate$ParameterPoint;}
declare module "net.minecraft.world.level.storage.loot.entries.ComposableEntryContainer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ComposableEntryContainer$$Interface {
}

export class $ComposableEntryContainer implements $ComposableEntryContainer$$Interface {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComposableEntryContainer$$Type = ($ComposableEntryContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComposableEntryContainer$$Original = $ComposableEntryContainer;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.SpruceFoliagePlacer" {
import {$FoliagePlacerType} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacerType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$FoliagePlacer$FoliageSetter$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageSetter"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$FoliagePlacer$FoliageAttachment$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $SpruceFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($SpruceFoliagePlacer)>
readonly "offset": $IntProvider
readonly "radius": $IntProvider

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: $IntProvider$$Type)

public "type"(): $FoliagePlacerType<(never)>
public "createFoliage"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: integer, arg5: $FoliagePlacer$FoliageAttachment$$Type, arg6: integer, arg7: integer, arg8: integer): void
public "shouldSkipLocation"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: boolean): boolean
public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpruceFoliagePlacer$$Type = ($SpruceFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpruceFoliagePlacer$$Original = $SpruceFoliagePlacer;}
declare module "net.minecraft.world.level.block.entity.TheEndGatewayBlockEntity" {
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ClientboundBlockEntityDataPacket} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$TheEndPortalBlockEntity} from "net.minecraft.world.level.block.entity.TheEndPortalBlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TheEndGatewayBlockEntity extends $TheEndPortalBlockEntity {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public static "beamAnimationTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $TheEndGatewayBlockEntity$$Type): void
public "getParticleAmount"(): integer
public "getPortalPosition"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type): $Vec3
public "isCoolingDown"(): boolean
public static "triggerCooldown"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $TheEndGatewayBlockEntity$$Type): void
public "getSpawnPercent"(arg0: float): float
public "setExitPosition"(arg0: $BlockPos$$Type, arg1: boolean): void
public static "portalTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $TheEndGatewayBlockEntity$$Type): void
public "triggerEvent"(arg0: integer, arg1: integer): boolean
public "isSpawning"(): boolean
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getCooldownPercent"(arg0: float): float
public "getUpdatePacket"(): $ClientboundBlockEntityDataPacket
public "shouldRenderFace"(arg0: $Direction$$Type): boolean
get "particleAmount"(): integer
get "coolingDown"(): boolean
get "spawning"(): boolean
get "updatePacket"(): $ClientboundBlockEntityDataPacket
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TheEndGatewayBlockEntity$$Type = ($TheEndGatewayBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TheEndGatewayBlockEntity$$Original = $TheEndGatewayBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.SculkPatchConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$Record} from "java.lang.Record"

export class $SculkPatchConfiguration extends $Record implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($SculkPatchConfiguration)>

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: $IntProvider$$Type, arg6: float)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "spreadRounds"(): integer
public "growthRounds"(): integer
public "catalystChance"(): float
public "spreadAttempts"(): integer
public "chargeCount"(): integer
public "extraRareGrowths"(): $IntProvider
public "amountPerCharge"(): integer
public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkPatchConfiguration$$Type = ({"growthRounds"?: integer, "spreadRounds"?: integer, "spreadAttempts"?: integer, "extraRareGrowths"?: $IntProvider$$Type, "chargeCount"?: integer, "amountPerCharge"?: integer, "catalystChance"?: float}) | ([growthRounds?: integer, spreadRounds?: integer, spreadAttempts?: integer, extraRareGrowths?: $IntProvider$$Type, chargeCount?: integer, amountPerCharge?: integer, catalystChance?: float]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkPatchConfiguration$$Original = $SculkPatchConfiguration;}
declare module "net.minecraft.world.level.chunk.DataLayer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DataLayer {
 "data": (byte)[]
static readonly "LAYER_COUNT": integer
static readonly "SIZE": integer
static readonly "LAYER_SIZE": integer

constructor(arg0: (byte)[])
constructor(arg0: integer)
constructor()

public "get"(arg0: integer, arg1: integer, arg2: integer): integer
public "toString"(): StringJS
public "isEmpty"(): boolean
public "fill"(arg0: integer): void
public "set"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): void
public "copy"(): $DataLayer
public "getData"(): (byte)[]
public "isDefinitelyFilledWith"(arg0: integer): boolean
public "isDefinitelyHomogenous"(): boolean
public "layerToString"(arg0: integer): StringJS
get "empty"(): boolean
get "definitelyHomogenous"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataLayer$$Type = ($DataLayer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataLayer$$Original = $DataLayer;}
declare module "net.minecraft.world.level.block.entity.trialspawner.TrialSpawner$StateAccessor" {
import {$TrialSpawnerState, $TrialSpawnerState$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerState"
import {$Level$$Type} from "net.minecraft.world.level.Level"

export interface $TrialSpawner$StateAccessor$$Interface {
get "state"(): $TrialSpawnerState
}

export class $TrialSpawner$StateAccessor implements $TrialSpawner$StateAccessor$$Interface {
 "getState"(): $TrialSpawnerState
 "setState"(arg0: $Level$$Type, arg1: $TrialSpawnerState$$Type): void
 "markUpdated"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrialSpawner$StateAccessor$$Type = ($TrialSpawner$StateAccessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrialSpawner$StateAccessor$$Original = $TrialSpawner$StateAccessor;}
declare module "net.minecraft.world.level.timers.TimerCallback$Serializer" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$TimerCallback, $TimerCallback$$Type} from "net.minecraft.world.level.timers.TimerCallback"

export class $TimerCallback$Serializer<T, C extends $TimerCallback<(object)>> {
constructor(arg0: $ResourceLocation$$Type, arg1: $Class$$Type<(never)>)

public "getId"(): $ResourceLocation
public "serialize"(arg0: $CompoundTag$$Type, arg1: C): void
public "deserialize"(arg0: $CompoundTag$$Type): C
public "getCls"(): $Class<(never)>
get "id"(): $ResourceLocation
get "cls"(): $Class<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimerCallback$Serializer$$Type<T, C> = ($TimerCallback$Serializer<(T), (C)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TimerCallback$Serializer$$Original<T, C> = $TimerCallback$Serializer<(T), (C)>;}
declare module "net.minecraft.world.level.lighting.LayerLightSectionStorage$SectionType" {
import {$Enum} from "java.lang.Enum"

export class $LayerLightSectionStorage$SectionType extends $Enum<($LayerLightSectionStorage$SectionType)> {
static readonly "LIGHT_ONLY": $LayerLightSectionStorage$SectionType
static readonly "LIGHT_AND_DATA": $LayerLightSectionStorage$SectionType
static readonly "EMPTY": $LayerLightSectionStorage$SectionType

public static "values"(): ($LayerLightSectionStorage$SectionType)[]
public static "valueOf"(arg0: StringJS): $LayerLightSectionStorage$SectionType
public "display"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LayerLightSectionStorage$SectionType$$Type = (("empty") | ("light_only") | ("light_and_data"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LayerLightSectionStorage$SectionType$$Original = $LayerLightSectionStorage$SectionType;}
declare module "net.minecraft.world.level.storage.loot.LootParams$DynamicDrop" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export interface $LootParams$DynamicDrop$$Interface {

(arg0: $Consumer<($ItemStack)>): void
}

export class $LootParams$DynamicDrop implements $LootParams$DynamicDrop$$Interface {
 "add"(arg0: $Consumer$$Type<($ItemStack)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootParams$DynamicDrop$$Type = ((arg0: $Consumer<($ItemStack)>) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootParams$DynamicDrop$$Original = $LootParams$DynamicDrop;}
declare module "net.minecraft.world.level.chunk.storage.SimpleRegionStorage" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Optional} from "java.util.Optional"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$DataFixTypes$$Type} from "net.minecraft.util.datafix.DataFixTypes"
import {$Dynamic, $Dynamic$$Type} from "com.mojang.serialization.Dynamic"
import {$RegionStorageInfo, $RegionStorageInfo$$Type} from "net.minecraft.world.level.chunk.storage.RegionStorageInfo"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$Path$$Type} from "java.nio.file.Path"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$DataFixer$$Type} from "com.mojang.datafixers.DataFixer"

export class $SimpleRegionStorage implements $AutoCloseable$$Interface {
constructor(arg0: $RegionStorageInfo$$Type, arg1: $Path$$Type, arg2: $DataFixer$$Type, arg3: boolean, arg4: $DataFixTypes$$Type)

public "write"(arg0: $ChunkPos$$Type, arg1: $CompoundTag$$Type): $CompletableFuture<(void)>
public "read"(arg0: $ChunkPos$$Type): $CompletableFuture<($Optional<($CompoundTag)>)>
public "close"(): void
public "storageInfo"(): $RegionStorageInfo
public "upgradeChunkTag"(arg0: $CompoundTag$$Type, arg1: integer): $CompoundTag
public "upgradeChunkTag"(arg0: $Dynamic$$Type<($Tag$$Type)>, arg1: integer): $Dynamic<($Tag)>
public "synchronize"(arg0: boolean): $CompletableFuture<(void)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleRegionStorage$$Type = ($SimpleRegionStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleRegionStorage$$Original = $SimpleRegionStorage;}
declare module "net.minecraft.world.level.SpawnData$CustomSpawnRules" {
import {$InclusiveRange, $InclusiveRange$$Type} from "net.minecraft.util.InclusiveRange"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Record} from "java.lang.Record"

export class $SpawnData$CustomSpawnRules extends $Record {
static readonly "CODEC": $Codec<($SpawnData$CustomSpawnRules)>

constructor(arg0: $InclusiveRange$$Type<(integer)>, arg1: $InclusiveRange$$Type<(integer)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isValidPosition"(arg0: $BlockPos$$Type, arg1: $ServerLevel$$Type): boolean
public "blockLightLimit"(): $InclusiveRange<(integer)>
public "skyLightLimit"(): $InclusiveRange<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpawnData$CustomSpawnRules$$Type = ({"blockLightLimit"?: $InclusiveRange$$Type<(integer)>, "skyLightLimit"?: $InclusiveRange$$Type<(integer)>}) | ([blockLightLimit?: $InclusiveRange$$Type<(integer)>, skyLightLimit?: $InclusiveRange$$Type<(integer)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpawnData$CustomSpawnRules$$Original = $SpawnData$CustomSpawnRules;}
declare module "net.minecraft.world.level.BlockAndTintGetter" {
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$Holder} from "net.minecraft.core.Holder"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter$$Interface} from "net.minecraft.world.level.BlockGetter"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$IBlockAndTintGetterExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IBlockAndTintGetterExtension"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"

export interface $BlockAndTintGetter$$Interface extends $BlockGetter$$Interface, $IBlockAndTintGetterExtension$$Interface {
get "lightEngine"(): $LevelLightEngine
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "maxSection"(): integer
get "minSection"(): integer
get "sectionsCount"(): integer
get "height"(): integer
get "minBuildHeight"(): integer
}

export class $BlockAndTintGetter implements $BlockAndTintGetter$$Interface {
 "getLightEngine"(): $LevelLightEngine
 "canSeeSky"(arg0: $BlockPos$$Type): boolean
 "getShade"(arg0: $Direction$$Type, arg1: boolean): float
 "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
 "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
 "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
 "getMaxLightLevel"(): integer
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getMaxBuildHeight"(): integer
 "getSectionIndex"(arg0: integer): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionsCount"(): integer
 "getHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getMinBuildHeight"(): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
 "getBlockEntityRenderData"(arg0: $BlockPos$$Type): any
 "hasBiomes"(): boolean
 "getBiomeFabric"(arg0: $BlockPos$$Type): $Holder<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockAndTintGetter$$Type = ($BlockAndTintGetter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockAndTintGetter$$Original = $BlockAndTintGetter;}
declare module "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool$Projection" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StructureProcessor} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$ImmutableList} from "com.google.common.collect.ImmutableList"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $StructureTemplatePool$Projection extends $Enum<($StructureTemplatePool$Projection)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $StringRepresentable$EnumCodec<($StructureTemplatePool$Projection)>
static readonly "TERRAIN_MATCHING": $StructureTemplatePool$Projection
static readonly "RIGID": $StructureTemplatePool$Projection

public "getName"(): StringJS
public static "values"(): ($StructureTemplatePool$Projection)[]
public static "valueOf"(arg0: StringJS): $StructureTemplatePool$Projection
public "getProcessors"(): $ImmutableList<($StructureProcessor)>
public "getSerializedName"(): StringJS
public static "byName"(arg0: StringJS): $StructureTemplatePool$Projection
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "name"(): StringJS
get "processors"(): $ImmutableList<($StructureProcessor)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureTemplatePool$Projection$$Type = (("terrain_matching") | ("rigid"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureTemplatePool$Projection$$Original = $StructureTemplatePool$Projection;}
declare module "net.minecraft.world.level.lighting.LevelLightEngine" {
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$LayerLightSectionStorage$SectionType} from "net.minecraft.world.level.lighting.LayerLightSectionStorage$SectionType"
import {$LayerLightEventListener} from "net.minecraft.world.level.lighting.LayerLightEventListener"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$LightChunkGetter$$Type} from "net.minecraft.world.level.chunk.LightChunkGetter"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$LightEventListener$$Interface} from "net.minecraft.world.level.lighting.LightEventListener"
import {$SectionPos$$Type} from "net.minecraft.core.SectionPos"
import {$DataLayer$$Type} from "net.minecraft.world.level.chunk.DataLayer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"

export class $LevelLightEngine implements $LightEventListener$$Interface {
static readonly "LIGHT_SECTION_PADDING": integer
readonly "levelHeightAccessor": $LevelHeightAccessor

constructor(arg0: $LightChunkGetter$$Type, arg1: boolean, arg2: boolean)

public "checkBlock"(arg0: $BlockPos$$Type): void
public "getLayerListener"(arg0: $LightLayer$$Type): $LayerLightEventListener
public "setLightEnabled"(arg0: $ChunkPos$$Type, arg1: boolean): void
public "runLightUpdates"(): integer
public "lightOnInSection"(arg0: $SectionPos$$Type): boolean
public "updateSectionStatus"(arg0: $SectionPos$$Type, arg1: boolean): void
public "getLightSectionCount"(): integer
public "retainData"(arg0: $ChunkPos$$Type, arg1: boolean): void
public "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
public "queueSectionData"(arg0: $LightLayer$$Type, arg1: $SectionPos$$Type, arg2: $DataLayer$$Type): void
public "getMaxLightSection"(): integer
public "getMinLightSection"(): integer
public "getDebugData"(arg0: $LightLayer$$Type, arg1: $SectionPos$$Type): StringJS
public "hasLightWork"(): boolean
public "propagateLightSources"(arg0: $ChunkPos$$Type): void
public "getDebugSectionType"(arg0: $LightLayer$$Type, arg1: $SectionPos$$Type): $LayerLightSectionStorage$SectionType
public "handler$zbp000$sodium_extra$doLightUpdates"(arg0: $CallbackInfoReturnable$$Type): void
public "handler$zbp000$sodium_extra$checkBlock"(arg0: $BlockPos$$Type, arg1: $CallbackInfo$$Type): void
public "updateSectionStatus"(arg0: $BlockPos$$Type, arg1: boolean): void
get "lightSectionCount"(): integer
get "maxLightSection"(): integer
get "minLightSection"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelLightEngine$$Type = ($LevelLightEngine);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelLightEngine$$Original = $LevelLightEngine;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.ReplaceBlockConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration$TargetBlockState"
import {$List, $List$$Type} from "java.util.List"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ReplaceBlockConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($ReplaceBlockConfiguration)>
readonly "targetStates": $List<($OreConfiguration$TargetBlockState)>

constructor(arg0: $BlockState$$Type, arg1: $BlockState$$Type)
constructor(arg0: $List$$Type<($OreConfiguration$TargetBlockState$$Type)>)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplaceBlockConfiguration$$Type = ($ReplaceBlockConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReplaceBlockConfiguration$$Original = $ReplaceBlockConfiguration;}
declare module "net.minecraft.world.level.levelgen.feature.trunkplacers.CherryTrunkPlacer" {
import {$List} from "java.util.List"
import {$IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$UniformInt$$Type} from "net.minecraft.util.valueproviders.UniformInt"
import {$TrunkPlacerType} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacerType"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$TrunkPlacer} from "net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$FoliagePlacer$FoliageAttachment} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"

export class $CherryTrunkPlacer extends $TrunkPlacer {
static readonly "CODEC": $MapCodec<($CherryTrunkPlacer)>
static readonly "MAX_HEIGHT": integer
readonly "baseHeight": integer
readonly "heightRandA": integer
readonly "heightRandB": integer

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: $IntProvider$$Type, arg4: $IntProvider$$Type, arg5: $UniformInt$$Type, arg6: $IntProvider$$Type)

public "type"(): $TrunkPlacerType<(never)>
public "placeTrunk"(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: integer, arg4: $BlockPos$$Type, arg5: $TreeConfiguration$$Type): $List<($FoliagePlacer$FoliageAttachment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CherryTrunkPlacer$$Type = ($CherryTrunkPlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CherryTrunkPlacer$$Original = $CherryTrunkPlacer;}
declare module "net.minecraft.world.level.validation.ForbiddenSymlinkInfo" {
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$Record} from "java.lang.Record"

export class $ForbiddenSymlinkInfo extends $Record {
constructor(arg0: $Path$$Type, arg1: $Path$$Type)

public "equals"(arg0: any): boolean
public "target"(): $Path
public "toString"(): StringJS
public "hashCode"(): integer
public "link"(): $Path
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForbiddenSymlinkInfo$$Type = ({"target"?: $Path$$Type, "link"?: $Path$$Type}) | ([target?: $Path$$Type, link?: $Path$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ForbiddenSymlinkInfo$$Original = $ForbiddenSymlinkInfo;}
declare module "net.minecraft.world.level.gameevent.vibrations.VibrationSystem" {
import {$ToIntFunction} from "java.util.function.ToIntFunction"
import {$VibrationSystem$Data} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$Data"
import {$GameEvent, $GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$List} from "java.util.List"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$VibrationSystem$User} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$User"

export interface $VibrationSystem$$Interface {
get "vibrationUser"(): $VibrationSystem$User
get "vibrationData"(): $VibrationSystem$Data
}

export class $VibrationSystem implements $VibrationSystem$$Interface {
static readonly "DEFAULT_VIBRATION_FREQUENCY": integer
static readonly "RESONANCE_EVENTS": $List<($ResourceKey<($GameEvent)>)>
/**
 * 
 * @deprecated
 */
static readonly "VIBRATION_FREQUENCY_FOR_EVENT": $ToIntFunction<($ResourceKey<($GameEvent)>)>

 "getVibrationUser"(): $VibrationSystem$User
 "getVibrationData"(): $VibrationSystem$Data
static "getResonanceEventByFrequency"(arg0: integer): $ResourceKey<($GameEvent)>
static "getRedstoneStrengthForDistance"(arg0: float, arg1: integer): integer
static "getGameEventFrequency"(arg0: $ResourceKey$$Type<($GameEvent)>): integer
static "getGameEventFrequency"(arg0: $Holder$$Type<($GameEvent)>): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VibrationSystem$$Type = ($VibrationSystem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VibrationSystem$$Original = $VibrationSystem;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.DripstoneClusterConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$FloatProvider, $FloatProvider$$Type} from "net.minecraft.util.valueproviders.FloatProvider"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $DripstoneClusterConfiguration implements $FeatureConfiguration$$Interface {
readonly "chanceOfDripstoneColumnAtMaxDistanceFromCenter": float
readonly "heightDeviation": integer
static readonly "CODEC": $Codec<($DripstoneClusterConfiguration)>
readonly "density": $FloatProvider
readonly "dripstoneBlockLayerThickness": $IntProvider
readonly "maxStalagmiteStalactiteHeightDiff": integer
readonly "floorToCeilingSearchRange": integer
readonly "wetness": $FloatProvider
readonly "radius": $IntProvider
readonly "maxDistanceFromCenterAffectingHeightBias": integer
readonly "maxDistanceFromEdgeAffectingChanceOfDripstoneColumn": integer
readonly "height": $IntProvider

constructor(arg0: integer, arg1: $IntProvider$$Type, arg2: $IntProvider$$Type, arg3: integer, arg4: integer, arg5: $IntProvider$$Type, arg6: $FloatProvider$$Type, arg7: $FloatProvider$$Type, arg8: float, arg9: integer, arg10: integer)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DripstoneClusterConfiguration$$Type = ($DripstoneClusterConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DripstoneClusterConfiguration$$Original = $DripstoneClusterConfiguration;}
declare module "net.minecraft.world.level.storage.LevelStorageSource$LevelCandidates" {
import {$Iterator} from "java.util.Iterator"
import {$Iterable$$Interface} from "java.lang.Iterable"
import {$Spliterator} from "java.util.Spliterator"
import {$List, $List$$Type} from "java.util.List"
import {$LevelStorageSource$LevelDirectory, $LevelStorageSource$LevelDirectory$$Type} from "net.minecraft.world.level.storage.LevelStorageSource$LevelDirectory"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$Record} from "java.lang.Record"

export class $LevelStorageSource$LevelCandidates extends $Record implements $Iterable$$Interface<($LevelStorageSource$LevelDirectory)> {
constructor(levels: $List$$Type<($LevelStorageSource$LevelDirectory$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public "iterator"(): $Iterator<($LevelStorageSource$LevelDirectory)>
public "levels"(): $List<($LevelStorageSource$LevelDirectory)>
public "spliterator"(): $Spliterator<($LevelStorageSource$LevelDirectory)>
public "forEach"(arg0: $Consumer$$Type<($LevelStorageSource$LevelDirectory)>): void
[Symbol.iterator](): IterableIterator<$LevelStorageSource$LevelDirectory>;
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelStorageSource$LevelCandidates$$Type = ({"levels"?: $List$$Type<($LevelStorageSource$LevelDirectory$$Type)>}) | ([levels?: $List$$Type<($LevelStorageSource$LevelDirectory$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelStorageSource$LevelCandidates$$Original = $LevelStorageSource$LevelCandidates;}
declare module "net.minecraft.world.level.gameevent.GameEventListener" {
import {$PositionSource} from "net.minecraft.world.level.gameevent.PositionSource"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$GameEventListener$DeliveryMode} from "net.minecraft.world.level.gameevent.GameEventListener$DeliveryMode"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export interface $GameEventListener$$Interface {
get "listenerRadius"(): integer
get "listenerSource"(): $PositionSource
get "deliveryMode"(): $GameEventListener$DeliveryMode
}

export class $GameEventListener implements $GameEventListener$$Interface {
 "getListenerRadius"(): integer
 "handleGameEvent"(arg0: $ServerLevel$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $GameEvent$Context$$Type, arg3: $Vec3$$Type): boolean
 "getListenerSource"(): $PositionSource
 "getDeliveryMode"(): $GameEventListener$DeliveryMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameEventListener$$Type = ($GameEventListener);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameEventListener$$Original = $GameEventListener;}
declare module "net.minecraft.world.level.NaturalSpawner$SpawnState" {
import {$Object2IntOpenHashMap$$Type} from "it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap"
import {$Object2IntMap} from "it.unimi.dsi.fastutil.objects.Object2IntMap"
import {$MobCategory, $MobCategory$$Type} from "net.minecraft.world.entity.MobCategory"
import {$LocalMobCapCalculator$$Type} from "net.minecraft.world.level.LocalMobCapCalculator"
import {$PotentialCalculator$$Type} from "net.minecraft.world.level.PotentialCalculator"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"

export class $NaturalSpawner$SpawnState {
constructor(arg0: integer, arg1: $Object2IntOpenHashMap$$Type<($MobCategory$$Type)>, arg2: $PotentialCalculator$$Type, arg3: $LocalMobCapCalculator$$Type)

public "getMobCategoryCounts"(): $Object2IntMap<($MobCategory)>
public "getSpawnableChunkCount"(): integer
public "canSpawnForCategory"(arg0: $MobCategory$$Type, arg1: $ChunkPos$$Type): boolean
get "mobCategoryCounts"(): $Object2IntMap<($MobCategory)>
get "spawnableChunkCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NaturalSpawner$SpawnState$$Type = ($NaturalSpawner$SpawnState);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NaturalSpawner$SpawnState$$Original = $NaturalSpawner$SpawnState;}
declare module "net.minecraft.world.level.block.SlabBlock" {
import {$Block$BlockStatePairKey} from "net.minecraft.world.level.block.Block$BlockStatePairKey"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$SlabType} from "net.minecraft.world.level.block.state.properties.SlabType"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$SimpleWaterloggedBlock$$Interface} from "net.minecraft.world.level.block.SimpleWaterloggedBlock"
import {$BlockBehaviour$Properties$$Type} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$StateDefinition$Builder$$Type} from "net.minecraft.world.level.block.state.StateDefinition$Builder"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$IdMapper} from "net.minecraft.core.IdMapper"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Item} from "net.minecraft.world.item.Item"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$StateDefinition} from "net.minecraft.world.level.block.state.StateDefinition"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Object2ByteLinkedOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap"
import {$SoundType} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$PathComputationType$$Type} from "net.minecraft.world.level.pathfinder.PathComputationType"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$ThreadLocal} from "java.lang.ThreadLocal"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$BooleanProperty} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $SlabBlock extends $Block implements $SimpleWaterloggedBlock$$Interface {
 "explosionResistance": float
static readonly "UPDATE_SHAPE_ORDER": ($Direction)[]
static readonly "OCCLUSION_CACHE": $ThreadLocal<($Object2ByteLinkedOpenHashMap<($Block$BlockStatePairKey)>)>
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_INVISIBLE": integer
 "stateDefinition": $StateDefinition<($Block), ($BlockState)>
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_LIMIT": integer
static readonly "UPDATE_ALL": integer
 "drops": $ResourceKey<($LootTable)>
static readonly "WATERLOGGED": $BooleanProperty
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
readonly "dynamicShape": boolean
static readonly "TYPE": $EnumProperty<($SlabType)>
 "soundType": $SoundType
 "jumpFactor": float
static readonly "TOP_AABB": $VoxelShape
static readonly "UPDATE_IMMEDIATE": integer
 "item": $Item
static readonly "CODEC": $MapCodec<($SlabBlock)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "INDESTRUCTIBLE": float
 "speedFactor": float
 "friction": float
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "BOTTOM_AABB": $VoxelShape
static readonly "INSTANT": float
static readonly "UPDATE_CLIENTS": integer
 "hasCollision": boolean

constructor(arg0: $BlockBehaviour$Properties$$Type)

public "getShape"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public "getFluidState"(arg0: $BlockState$$Type): $FluidState
public "canBeReplaced"(arg0: $BlockState$$Type, arg1: $BlockPlaceContext$$Type): boolean
public "codec"(): $MapCodec<($SlabBlock)>
public "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
public "canPlaceLiquid"(arg0: $Player$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type, arg4: $Fluid$$Type): boolean
public "placeLiquid"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $FluidState$$Type): boolean
public "isPathfindable"(arg0: $BlockState$$Type, arg1: $PathComputationType$$Type): boolean
public "useShapeForLightOcclusion"(arg0: $BlockState$$Type): boolean
public "createBlockStateDefinition"(arg0: $StateDefinition$Builder$$Type<($Block$$Type), ($BlockState$$Type)>): void
public "getStateForPlacement"(arg0: $BlockPlaceContext$$Type): $BlockState
public "pickupBlock"(arg0: $Player$$Type, arg1: $LevelAccessor$$Type, arg2: $BlockPos$$Type, arg3: $BlockState$$Type): $ItemStack
public "getPickupSound"(): $Optional<($SoundEvent)>
public "getPickupSound"(arg0: $BlockState$$Type): $Optional<($SoundEvent)>
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "pickupSound"(): $Optional<($SoundEvent)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlabBlock$$Type = ($SlabBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SlabBlock$$Original = $SlabBlock;}
declare module "net.minecraft.world.level.block.state.properties.BlockSetType$PressurePlateSensitivity" {
import {$Enum} from "java.lang.Enum"

export class $BlockSetType$PressurePlateSensitivity extends $Enum<($BlockSetType$PressurePlateSensitivity)> {
static readonly "MOBS": $BlockSetType$PressurePlateSensitivity
static readonly "EVERYTHING": $BlockSetType$PressurePlateSensitivity

public static "values"(): ($BlockSetType$PressurePlateSensitivity)[]
public static "valueOf"(arg0: StringJS): $BlockSetType$PressurePlateSensitivity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockSetType$PressurePlateSensitivity$$Type = (("everything") | ("mobs"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockSetType$PressurePlateSensitivity$$Original = $BlockSetType$PressurePlateSensitivity;}
declare module "net.minecraft.world.level.levelgen.structure.structures.DesertPyramidStructure" {
import {$WorldGenLevel$$Type} from "net.minecraft.world.level.WorldGenLevel"
import {$BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$StructureManager$$Type} from "net.minecraft.world.level.StructureManager"
import {$SinglePieceStructure} from "net.minecraft.world.level.levelgen.structure.SinglePieceStructure"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$PiecesContainer$$Type} from "net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $DesertPyramidStructure extends $SinglePieceStructure {
static readonly "CODEC": $MapCodec<($DesertPyramidStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "type"(): $StructureType<(never)>
public "afterPlace"(arg0: $WorldGenLevel$$Type, arg1: $StructureManager$$Type, arg2: $ChunkGenerator$$Type, arg3: $RandomSource$$Type, arg4: $BoundingBox$$Type, arg5: $ChunkPos$$Type, arg6: $PiecesContainer$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DesertPyramidStructure$$Type = ($DesertPyramidStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DesertPyramidStructure$$Original = $DesertPyramidStructure;}
declare module "net.minecraft.world.level.block.entity.CrafterBlockEntity" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CraftingInput$Positioned} from "net.minecraft.world.item.crafting.CraftingInput$Positioned"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$ContainerData} from "net.minecraft.world.inventory.ContainerData"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WrappedBlockEntityTickInvokerAccessor, $WrappedBlockEntityTickInvokerAccessor$$Type} from "net.caffeinemc.mods.lithium.mixin.world.block_entity_ticking.sleeping.WrappedBlockEntityTickInvokerAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CraftingInput} from "net.minecraft.world.item.crafting.CraftingInput"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$TickingBlockEntity, $TickingBlockEntity$$Type} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$RandomizableContainerBlockEntity} from "net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity"
import {$ReferenceArraySet} from "it.unimi.dsi.fastutil.objects.ReferenceArraySet"
import {$SetChangedHandlingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SetChangedHandlingBlockEntity"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$NonNullList$$Type} from "net.minecraft.core.NonNullList"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$SleepingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SleepingBlockEntity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$CraftingContainer$$Interface} from "net.minecraft.world.inventory.CraftingContainer"
import {$StackedContents$$Type} from "net.minecraft.world.entity.player.StackedContents"

export class $CrafterBlockEntity extends $RandomizableContainerBlockEntity implements $CraftingContainer$$Interface, $SleepingBlockEntity$$Interface, $SetChangedHandlingBlockEntity$$Interface {
 "inventoryChangeListeners": $ReferenceArraySet
static readonly "CONTAINER_WIDTH": integer
 "level": $Level
static readonly "SLOT_ENABLED": integer
static readonly "SLOT_DISABLED": integer
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventoryHandlingTypeListeners": $ReferenceArraySet
static readonly "NUM_DATA": integer
 "remove": boolean
static readonly "CONTAINER_HEIGHT": integer
 "worldPosition": $BlockPos
 "lootTable": $ResourceKey<($LootTable)>
static readonly "DATA_TRIGGERED": integer
static readonly "CONTAINER_SIZE": integer
 "lockKey": $LockCode
 "hasComparators": byte
readonly "containerData": $ContainerData
 "lootTableSeed": long

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "isEmpty"(): boolean
public "getItem"(arg0: integer): $ItemStack
public "canPlaceItem"(arg0: integer, arg1: $ItemStack$$Type): boolean
public "getDefaultName"(): $Component
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getRedstoneSignal"(): integer
public "getWidth"(): integer
public "setSlotState"(arg0: integer, arg1: boolean): void
public "isTriggered"(): boolean
public "isSlotDisabled"(arg0: integer): boolean
public "getContainerSize"(): integer
public "setCraftingTicksRemaining"(arg0: integer): void
public "getItems"(): $List
public "lithium$setTickWrapper"(arg0: $WrappedBlockEntityTickInvokerAccessor$$Type): void
public "lithium$getSleepingTicker"(): $TickingBlockEntity
public "lithium$getTickWrapper"(): $WrappedBlockEntityTickInvokerAccessor
public "lithium$setSleepingTicker"(arg0: $TickingBlockEntity$$Type): void
public "fillStackedContents"(arg0: $StackedContents$$Type): void
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "setTriggered"(arg0: boolean): void
public "stillValid"(arg0: $Player$$Type): boolean
public "getHeight"(): integer
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public static "serverTick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $CrafterBlockEntity$$Type): void
public "setItems"(arg0: $NonNullList$$Type<($ItemStack$$Type)>): void
public "lithium$handleSetChanged"(): void
public "createMenu"(arg0: integer, arg1: $Inventory$$Type): $AbstractContainerMenu
public "asCraftInput"(): $CraftingInput
public "asPositionedCraftInput"(): $CraftingInput$Positioned
public "isSleeping"(): boolean
public "setTicker"(arg0: $TickingBlockEntity$$Type): void
public "wakeUpNow"(): void
public "sleepOnlyCurrentTick"(): void
public "lithium$startSleeping"(): boolean
public "setChanged"(): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public "getLevel"(): $Level
public "getBlockPos"(): $BlockPos
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public static "tryClear"(arg0: any): void
get "empty"(): boolean
get "defaultName"(): $Component
get "redstoneSignal"(): integer
get "width"(): integer
get "triggered"(): boolean
get "containerSize"(): integer
set "craftingTicksRemaining"(value: integer)
get "items"(): $List
set "triggered"(value: boolean)
get "height"(): integer
set "items"(value: $NonNullList$$Type<($ItemStack$$Type)>)
get "sleeping"(): boolean
set "ticker"(value: $TickingBlockEntity$$Type)
get "changed"(): void
get "blockPos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CrafterBlockEntity$$Type = ($CrafterBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CrafterBlockEntity$$Original = $CrafterBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.BlockColumnConfiguration$Layer" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockStateProvider, $BlockStateProvider$$Type} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$Record} from "java.lang.Record"

export class $BlockColumnConfiguration$Layer extends $Record {
static readonly "CODEC": $Codec<($BlockColumnConfiguration$Layer)>

constructor(arg0: $IntProvider$$Type, arg1: $BlockStateProvider$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "state"(): $BlockStateProvider
public "height"(): $IntProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockColumnConfiguration$Layer$$Type = ({"state"?: $BlockStateProvider$$Type, "height"?: $IntProvider$$Type}) | ([state?: $BlockStateProvider$$Type, height?: $IntProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockColumnConfiguration$Layer$$Original = $BlockColumnConfiguration$Layer;}
declare module "net.minecraft.world.level.block.state.StateDefinition$Factory" {
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Reference2ObjectArrayMap, $Reference2ObjectArrayMap$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectArrayMap"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export interface $StateDefinition$Factory$$Interface<O, S> {

(arg0: O, arg1: $Reference2ObjectArrayMap<($Property<(never)>), ($Comparable<(never)>)>, arg2: $MapCodec<(S)>): S
}

export class $StateDefinition$Factory<O, S> implements $StateDefinition$Factory$$Interface {
 "create"(arg0: O, arg1: $Reference2ObjectArrayMap$$Type<($Property$$Type<(never)>), ($Comparable$$Type<(never)>)>, arg2: $MapCodec$$Type<(S)>): S
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StateDefinition$Factory$$Type<O, S> = ((arg0: O, arg1: $Reference2ObjectArrayMap<($Property<(never)>), ($Comparable<(never)>)>, arg2: $MapCodec<(S)>) => S);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StateDefinition$Factory$$Original<O, S> = $StateDefinition$Factory<(O), (S)>;}
declare module "net.minecraft.world.level.levelgen.structure.templatesystem.RandomBlockMatchTest" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$RuleTestType} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTestType"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RandomBlockMatchTest extends $RuleTest {
static readonly "CODEC": $MapCodec<($RandomBlockMatchTest)>

constructor(arg0: $Block$$Type, arg1: float)

public "test"(arg0: $BlockState$$Type, arg1: $RandomSource$$Type): boolean
public "getType"(): $RuleTestType<(never)>
get "type"(): $RuleTestType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomBlockMatchTest$$Type = ($RandomBlockMatchTest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomBlockMatchTest$$Original = $RandomBlockMatchTest;}
declare module "net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ReferenceArraySet} from "it.unimi.dsi.fastutil.objects.ReferenceArraySet"
import {$Level} from "net.minecraft.world.level.Level"
import {$DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$Inventory$$Type} from "net.minecraft.world.entity.player.Inventory"
import {$LootTable, $LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$BaseContainerBlockEntity} from "net.minecraft.world.level.block.entity.BaseContainerBlockEntity"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$RandomizableContainer$$Interface} from "net.minecraft.world.RandomizableContainer"
import {$LockCode} from "net.minecraft.world.LockCode"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $RandomizableContainerBlockEntity extends $BaseContainerBlockEntity implements $RandomizableContainer$$Interface {
 "inventoryChangeListeners": $ReferenceArraySet
 "worldPosition": $BlockPos
 "lootTable": $ResourceKey<($LootTable)>
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "inventoryHandlingTypeListeners": $ReferenceArraySet
 "lockKey": $LockCode
 "hasComparators": byte
 "lootTableSeed": long
 "remove": boolean

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "isEmpty"(): boolean
public "getItem"(arg0: integer): $ItemStack
public "removeItemNoUpdate"(arg0: integer): $ItemStack
public "removeItem"(arg0: integer, arg1: integer): $ItemStack
public "setLootTable"(arg0: $ResourceKey$$Type<($LootTable)>): void
public "setLootTableSeed"(arg0: long): void
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "setItem"(arg0: integer, arg1: $ItemStack$$Type): void
public "canOpen"(arg0: $Player$$Type): boolean
public "getLootTable"(): $ResourceKey<($LootTable)>
public "getLootTableSeed"(): long
public "collectImplicitComponents"(arg0: $DataComponentMap$Builder$$Type): void
public "applyImplicitComponents"(arg0: $BlockEntity$DataComponentInput$$Type): void
public "createMenu"(arg0: integer, arg1: $Inventory$$Type, arg2: $Player$$Type): $AbstractContainerMenu
public "getLevel"(): $Level
public "tryLoadLootTable"(arg0: $CompoundTag$$Type): boolean
public "trySaveLootTable"(arg0: $CompoundTag$$Type): boolean
public "unpackLootTable"(arg0: $Player$$Type): void
public "setLootTable"(arg0: $ResourceKey$$Type<($LootTable)>, arg1: long): void
public "getBlockPos"(): $BlockPos
public static "setBlockEntityLootTable"(arg0: $BlockGetter$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type, arg3: $ResourceKey$$Type<($LootTable)>): void
public "setChanged"(): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$$Type, arg1: $Player$$Type, arg2: float): boolean
public static "tryClear"(arg0: any): void
get "empty"(): boolean
get "blockPos"(): $BlockPos
get "changed"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomizableContainerBlockEntity$$Type = ($RandomizableContainerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomizableContainerBlockEntity$$Original = $RandomizableContainerBlockEntity;}
declare module "net.minecraft.world.level.levelgen.structure.StructurePieceAccessor" {
import {$StructurePiece, $StructurePiece$$Type} from "net.minecraft.world.level.levelgen.structure.StructurePiece"
import {$BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"

export interface $StructurePieceAccessor$$Interface {
}

export class $StructurePieceAccessor implements $StructurePieceAccessor$$Interface {
 "addPiece"(arg0: $StructurePiece$$Type): void
 "findCollisionPiece"(arg0: $BoundingBox$$Type): $StructurePiece
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePieceAccessor$$Type = ($StructurePieceAccessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePieceAccessor$$Original = $StructurePieceAccessor;}
declare module "net.minecraft.world.level.pathfinder.PathType" {
import {$Enum} from "java.lang.Enum"

export class $PathType extends $Enum<($PathType)> {
static readonly "LAVA": $PathType
static readonly "DANGER_POWDER_SNOW": $PathType
static readonly "LEAVES": $PathType
static readonly "BLOCKED": $PathType
static readonly "WALKABLE": $PathType
static readonly "TRAPDOOR": $PathType
static readonly "BREACH": $PathType
static readonly "POWDER_SNOW": $PathType
static readonly "DOOR_WOOD_CLOSED": $PathType
static readonly "DANGER_TRAPDOOR": $PathType
static readonly "DANGER_FIRE": $PathType
static readonly "DAMAGE_FIRE": $PathType
static readonly "WATER": $PathType
static readonly "WATER_BORDER": $PathType
static readonly "WALKABLE_DOOR": $PathType
static readonly "DOOR_IRON_CLOSED": $PathType
static readonly "FENCE": $PathType
static readonly "OPEN": $PathType
static readonly "RAIL": $PathType
static readonly "DAMAGE_OTHER": $PathType
static readonly "DOOR_OPEN": $PathType
static readonly "UNPASSABLE_RAIL": $PathType
static readonly "COCOA": $PathType
static readonly "DANGER_OTHER": $PathType
static readonly "STICKY_HONEY": $PathType
static readonly "DAMAGE_CAUTIOUS": $PathType

public static "values"(): ($PathType)[]
public static "valueOf"(arg0: StringJS): $PathType
public "getMalus"(): float
get "malus"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PathType$$Type = (("blocked") | ("open") | ("walkable") | ("walkable_door") | ("trapdoor") | ("powder_snow") | ("danger_powder_snow") | ("fence") | ("lava") | ("water") | ("water_border") | ("rail") | ("unpassable_rail") | ("danger_fire") | ("damage_fire") | ("danger_other") | ("damage_other") | ("door_open") | ("door_wood_closed") | ("door_iron_closed") | ("breach") | ("leaves") | ("sticky_honey") | ("cocoa") | ("damage_cautious") | ("danger_trapdoor"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PathType$$Original = $PathType;}
declare module "net.minecraft.world.level.Level" {
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$ExplosionDamageCalculator$$Type} from "net.minecraft.world.level.ExplosionDamageCalculator"
import {$DamageSources} from "net.minecraft.world.damagesource.DamageSources"
import {$NorthstarOxygen} from "com.lightning.northstar.world.oxygen.NorthstarOxygen"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ChunkRandomSource$$Interface} from "net.caffeinemc.mods.lithium.common.world.ChunkRandomSource"
import {$Stream} from "java.util.stream.Stream"
import {$LongCollection$$Type} from "it.unimi.dsi.fastutil.longs.LongCollection"
import {$TickRateManager} from "net.minecraft.world.TickRateManager"
import {$ArrayList} from "java.util.ArrayList"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$AttachmentChange$$Type} from "net.fabricmc.fabric.impl.attachment.sync.AttachmentChange"
import {$CrashReport$$Type} from "net.minecraft.CrashReport"
import {$Difficulty} from "net.minecraft.world.Difficulty"
import {$Thread} from "java.lang.Thread"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$NorthstarLevel$$Interface} from "com.lightning.northstar.accessor.NorthstarLevel"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$LevelAccessor$$Interface as $LevelAccessor$0$$Interface} from "net.caffeinemc.mods.lithium.mixin.util.accessors.LevelAccessor"
import {$ExplosionProperties$$Type} from "dev.latvian.mods.kubejs.level.ExplosionProperties"
import {$Packet$$Type} from "net.minecraft.network.protocol.Packet"
import {$LoadedChunksCache$$Interface} from "net.fabricmc.fabric.impl.event.lifecycle.LoadedChunksCache"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$CrashReportCategory} from "net.minecraft.CrashReportCategory"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"
import {$PotionBrewing} from "net.minecraft.world.item.alchemy.PotionBrewing"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$BlockSnapshot} from "net.neoforged.neoforge.common.util.BlockSnapshot"
import {$ChunkSource} from "net.minecraft.world.level.chunk.ChunkSource"
import {$TickPriority$$Type} from "net.minecraft.world.ticks.TickPriority"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$Level$ExplosionInteraction$$Type} from "net.minecraft.world.level.Level$ExplosionInteraction"
import {$Function$$Type} from "java.util.function.Function"
import {$Class$$Type} from "java.lang.Class"
import {$TargetingConditions$$Type} from "net.minecraft.world.entity.ai.targeting.TargetingConditions"
import {$NorthstarTemperature} from "com.lightning.northstar.world.temperature.NorthstarTemperature"
import {$ElectricityTicker$Access$$Interface} from "com.mrcrayfish.furniture.refurbished.electricity.ElectricityTicker$Access"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$BlockPos$MutableBlockPos$$Type} from "net.minecraft.core.BlockPos$MutableBlockPos"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$AttachmentHolder} from "net.neoforged.neoforge.attachment.AttachmentHolder"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$Iterable} from "java.lang.Iterable"
import {$MapId, $MapId$$Type} from "net.minecraft.world.level.saveddata.maps.MapId"
import {$LevelHeightAccessor, $LevelHeightAccessor$$Interface} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$ILevelExtension$$Interface} from "net.neoforged.neoforge.common.extensions.ILevelExtension"
import {$ProfilerFiller, $ProfilerFiller$$Type} from "net.minecraft.util.profiling.ProfilerFiller"
import {$PartEntity} from "net.neoforged.neoforge.entity.PartEntity"
import {$AttachmentType$$Type} from "net.fabricmc.fabric.api.attachment.v1.AttachmentType"
import {$WritableLevelData, $WritableLevelData$$Type} from "net.minecraft.world.level.storage.WritableLevelData"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$SoundSource$$Type} from "net.minecraft.sounds.SoundSource"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$Set} from "java.util.Set"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$MapItemSavedData, $MapItemSavedData$$Type} from "net.minecraft.world.level.saveddata.maps.MapItemSavedData"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BiomeManager} from "net.minecraft.world.level.biome.BiomeManager"
import {$RecipeManager} from "net.minecraft.world.item.crafting.RecipeManager"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LevelData} from "net.minecraft.world.level.storage.LevelData"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$GameRules} from "net.minecraft.world.level.GameRules"
import {$LithiumData$$Interface} from "net.caffeinemc.mods.lithium.common.world.LithiumData"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$LevelChunk, $LevelChunk$$Type} from "net.minecraft.world.level.chunk.LevelChunk"
import {$LevelExtension$$Interface} from "dev.engine_room.flywheel.impl.extension.LevelExtension"
import {$LevelKJS$$Interface} from "dev.latvian.mods.kubejs.core.LevelKJS"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelAccessor$$Interface} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntityGetter$$Interface} from "net.caffeinemc.mods.lithium.common.world.blockentity.BlockEntityGetter"
import {$AttachmentTargetImpl$$Interface} from "net.fabricmc.fabric.impl.attachment.AttachmentTargetImpl"
import {$ModelDataManager} from "net.neoforged.neoforge.client.model.data.ModelDataManager"
import {$UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$FireworkExplosion$$Type} from "net.minecraft.world.item.component.FireworkExplosion"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$ElectricityTicker} from "com.mrcrayfish.furniture.refurbished.electricity.ElectricityTicker"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$HolderLookup} from "net.minecraft.core.HolderLookup"
import {$TickingBlockEntity, $TickingBlockEntity$$Type} from "net.minecraft.world.level.block.entity.TickingBlockEntity"
import {$Collection, $Collection$$Type} from "java.util.Collection"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$LithiumData$Data} from "net.caffeinemc.mods.lithium.common.world.LithiumData$Data"
import {$AttachedData} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$NeighborUpdater} from "net.minecraft.world.level.redstone.NeighborUpdater"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$LevelTickAccess} from "net.minecraft.world.ticks.LevelTickAccess"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$DifficultyInstance} from "net.minecraft.world.DifficultyInstance"
import {$Scoreboard} from "net.minecraft.world.scores.Scoreboard"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$DimensionType, $DimensionType$$Type} from "net.minecraft.world.level.dimension.DimensionType"

export class $Level extends $AttachmentHolder implements $LevelAccessor$$Interface, $AutoCloseable$$Interface, $ILevelExtension$$Interface, $ChunkRandomSource$$Interface, $LevelAccessor$0$$Interface, $BlockEntityGetter$$Interface, $LithiumData$$Interface, $LevelHeightAccessor$$Interface, $AttachmentTargetImpl$$Interface, $ElectricityTicker$Access$$Interface, $LoadedChunksCache$$Interface, $LevelKJS$$Interface, $LevelExtension$$Interface, $NorthstarLevel$$Interface {
 "restoringBlockSnapshots": boolean
readonly "neighborUpdater": $NeighborUpdater
static readonly "LONG_PARTICLE_CLIP_RANGE": integer
 "randValue": integer
readonly "levelData": $WritableLevelData
 "thunderLevel": float
readonly "random": $RandomSource
 "capturedBlockSnapshots": $ArrayList<($BlockSnapshot)>
static readonly "MAX_ENTITY_SPAWN_Y": integer
static readonly "NETHER": $ResourceKey<($Level)>
static readonly "MAX_BRIGHTNESS": integer
static readonly "SHORT_PARTICLE_CLIP_RANGE": integer
 "rainLevel": float
 "oThunderLevel": float
static readonly "ATTACHMENTS_NBT_KEY": StringJS
readonly "addend": integer
static readonly "OVERWORLD": $ResourceKey<($Level)>
static readonly "TICKS_PER_DAY": integer
 "oRainLevel": float
static readonly "RESOURCE_KEY_CODEC": $Codec<($ResourceKey<($Level)>)>
static readonly "END": $ResourceKey<($Level)>
static readonly "MAX_LEVEL_SIZE": integer
static readonly "MIN_ENTITY_SPAWN_Y": integer
readonly "blockEntityTickers": $List<($TickingBlockEntity)>
 "captureBlockSnapshots": boolean

constructor(arg0: $WritableLevelData$$Type, arg1: $ResourceKey$$Type<($Level)>, arg2: $RegistryAccess$$Type, arg3: $Holder$$Type<($DimensionType)>, arg4: $Supplier$$Type<($ProfilerFiller$$Type)>, arg5: boolean, arg6: boolean, arg7: long, arg8: integer)

public "northstar$queueBlockUpdates"(positions: $LongCollection$$Type): void
public "lithium$getRandomPosInChunk"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: $BlockPos$MutableBlockPos$$Type): void
public "flywheel$getAllLoadedEntities"(): $Iterable
public "close"(): void
public "isDebug"(): boolean
public "isLoaded"(arg0: $BlockPos$$Type): boolean
public "getDimensionKey"(): $ResourceKey<($Level)>
public "getFluidState"(arg0: $BlockPos$$Type): $FluidState
public "dimensionTypeRegistration"(): $Holder<($DimensionType)>
public "northstar$temperature"(): $NorthstarTemperature
public "isRaining"(): boolean
public "explode"(arg0: $Entity$$Type, arg1: $DamageSource$$Type, arg2: $ExplosionDamageCalculator$$Type, arg3: $Vec3$$Type, arg4: float, arg5: boolean, arg6: $Level$ExplosionInteraction$$Type): $Explosion
public "explode"(arg0: $Entity$$Type, arg1: $DamageSource$$Type, arg2: $ExplosionDamageCalculator$$Type, arg3: double, arg4: double, arg5: double, arg6: float, arg7: boolean, arg8: $Level$ExplosionInteraction$$Type, arg9: boolean, arg10: $ParticleOptions$$Type, arg11: $ParticleOptions$$Type, arg12: $Holder$$Type<($SoundEvent)>): $Explosion
public "explode"(arg0: $Entity$$Type, arg1: $DamageSource$$Type, arg2: $ExplosionDamageCalculator$$Type, arg3: double, arg4: double, arg5: double, arg6: float, arg7: boolean, arg8: $Level$ExplosionInteraction$$Type, arg9: $ParticleOptions$$Type, arg10: $ParticleOptions$$Type, arg11: $Holder$$Type<($SoundEvent)>): $Explosion
public "explode"(arg0: $Entity$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: $Level$ExplosionInteraction$$Type): $Explosion
public "explode"(arg0: $Entity$$Type, arg1: double, arg2: double, arg3: double, arg4: float, arg5: boolean, arg6: $Level$ExplosionInteraction$$Type): $Explosion
public "explode"(arg0: $Entity$$Type, arg1: $DamageSource$$Type, arg2: $ExplosionDamageCalculator$$Type, arg3: double, arg4: double, arg5: double, arg6: float, arg7: boolean, arg8: $Level$ExplosionInteraction$$Type): $Explosion
public "disconnect"(): void
public "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
public "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type, arg2: $Predicate$$Type<($Entity)>): $List<($Entity)>
public "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>, arg3: $List$$Type<(T)>, arg4: integer): void
public "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>, arg3: $List$$Type<(T)>): void
public "acknowledgeSyncedEntry"(arg0: $AttachmentType$$Type, arg1: $AttachmentChange$$Type): void
public "fabric_shouldTryToSync"(): boolean
public "broadcastDamageEvent"(arg0: $Entity$$Type, arg1: $DamageSource$$Type): void
public static "isInSpawnableBounds"(arg0: $BlockPos$$Type): boolean
public "fillReportDetails"(arg0: $CrashReport$$Type): $CrashReportCategory
public "registryAccess"(): $RegistryAccess
public "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
public "getTime"(): long
public "getRecipeManager"(): $RecipeManager
public "getSharedSpawnPos"(): $BlockPos
public "isRainingAt"(arg0: $BlockPos$$Type): boolean
public "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional
public "mayInteract"(arg0: $Player$$Type, arg1: $BlockPos$$Type): boolean
public "getDayTimeFraction"(): float
public "destroyBlockProgress"(arg0: integer, arg1: $BlockPos$$Type, arg2: integer): void
public "addFreshBlockEntities"(arg0: $Collection$$Type<($BlockEntity$$Type)>): void
public "gatherChunkSourceStats"(): StringJS
public "updateSkyBrightness"(): void
public "neighborShapeChanged"(arg0: $Direction$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type, arg4: integer, arg5: integer): void
public "addDestroyBlockEffect"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): void
public "loadedAndEntityCanStandOn"(arg0: $BlockPos$$Type, arg1: $Entity$$Type): boolean
public "addAlwaysVisibleParticle"(arg0: $ParticleOptions$$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): void
public "addAlwaysVisibleParticle"(arg0: $ParticleOptions$$Type, arg1: boolean, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): void
public "addBlockEntityTicker"(arg0: $TickingBlockEntity$$Type): void
public "markAndNotifyBlock"(arg0: $BlockPos$$Type, arg1: $LevelChunk$$Type, arg2: $BlockState$$Type, arg3: $BlockState$$Type, arg4: integer, arg5: integer): void
public "neighborChanged"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $Block$$Type, arg3: $BlockPos$$Type, arg4: boolean): void
public "neighborChanged"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: $BlockPos$$Type): void
public "tickBlockEntities"(): void
public "onBlockStateChange"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type): void
public "sendBlockUpdated"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type, arg3: integer): void
public "northstar$oxygen"(): $NorthstarOxygen
public "setBlocksDirty"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $BlockState$$Type): void
public "setBlockEntity"(arg0: $BlockEntity$$Type): void
public "setBlockAndUpdate"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): boolean
public "getLightEngine"(): $LevelLightEngine
public "getSunAngle"(arg0: float): float
public "guardEntityTick"<T extends $Entity>(arg0: $Consumer$$Type<(T)>, arg1: T): void
public "dimensionType"(): $DimensionType
public "updateNeighborsAt"(arg0: $BlockPos$$Type, arg1: $Block$$Type): void
public "getSeaLevel"(): integer
public "setSpawnSettings"(arg0: boolean, arg1: boolean): void
public "removeBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
public "removeBlockEntity"(arg0: $BlockPos$$Type): void
public "getThunderLevel"(arg0: float): float
public "shouldTickBlocksAt"(arg0: long): boolean
public "shouldTickBlocksAt"(arg0: $BlockPos$$Type): boolean
public "getEntity"(arg0: integer): $Entity
public "broadcastEntityEvent"(arg0: $Entity$$Type, arg1: byte): void
public "isClientSide"(): boolean
public "addParticle"(arg0: $ParticleOptions$$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): void
public "addParticle"(arg0: $ParticleOptions$$Type, arg1: boolean, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): void
public "shouldTickDeath"(arg0: $Entity$$Type): boolean
public "playSeededSound"(arg0: $Player$$Type, arg1: double, arg2: double, arg3: double, arg4: $Holder$$Type<($SoundEvent)>, arg5: $SoundSource$$Type, arg6: float, arg7: float, arg8: long): void
public "playSeededSound"(arg0: $Player$$Type, arg1: double, arg2: double, arg3: double, arg4: $SoundEvent$$Type, arg5: $SoundSource$$Type, arg6: float, arg7: float, arg8: long): void
public "playSeededSound"(arg0: $Player$$Type, arg1: $Entity$$Type, arg2: $Holder$$Type<($SoundEvent)>, arg3: $SoundSource$$Type, arg4: float, arg5: float, arg6: long): void
public "getScoreboard"(): $Scoreboard
public "damageSources"(): $DamageSources
public "prepareWeather"(): void
public "getMaxEntityRadius"(): double
public "sendPacketToServer"(arg0: $Packet$$Type<(never)>): void
public "advanceDaytime"(): long
public "globalLevelEvent"(arg0: integer, arg1: $BlockPos$$Type, arg2: integer): void
public "setDayTimePerTick"(arg0: float): void
public "setThunderLevel"(arg0: float): void
public "getDayTimePerTick"(): float
public "blockEntityChanged"(arg0: $BlockPos$$Type): void
public "setSkyFlashTime"(arg0: integer): void
public "setDayTimeFraction"(arg0: float): void
public "nextSubTickCount"(): long
public "setRainLevel"(arg0: float): void
public "isThundering"(): boolean
public "createFireworks"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: $List$$Type<($FireworkExplosion$$Type)>): void
public "isStateAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($BlockState)>): boolean
public "getBlockRandomPos"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $BlockPos
public "potionBrewing"(): $PotionBrewing
public "getFreeMapId"(): $MapId
public "getSkyDarken"(): integer
public "isFluidAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($FluidState)>): boolean
public "getRandom"(): $RandomSource
public "setMapData"(arg0: $MapId$$Type, arg1: $MapItemSavedData$$Type): void
public "blockEvent"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer, arg3: integer): void
public "getMapData"(arg0: $MapId$$Type): $MapItemSavedData
public "noSave"(): boolean
public "loadedAndEntityCanStandOnFace"(arg0: $BlockPos$$Type, arg1: $Entity$$Type, arg2: $Direction$$Type): boolean
public "updateNeighbourForOutputSignal"(arg0: $BlockPos$$Type, arg1: $Block$$Type): void
public "updateNeighborsAtExceptFromFacing"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: $Direction$$Type): void
public "getChunkAt"(arg0: $BlockPos$$Type): $LevelChunk
public "getBlockState"(arg0: $BlockPos$$Type): $BlockState
public "getEntityByNetworkID"(id: integer): $Entity
public "fabric_markUnloaded"(arg0: $LevelChunk$$Type): void
public "getEntityByUUID"(id: $UUID$$Type): $Entity
public "fabric_getLoadedChunks"(): $Set
public "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
public "getThread"(): $Thread
public "getProfiler"(): $ProfilerFiller
public "getLevelData"(): $LevelData
public "getWorldBorder"(): $WorldBorder
public "tickRateManager"(): $TickRateManager
public "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer): boolean
public "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer): boolean
public "getBiomeManager"(): $BiomeManager
public "fabric_markLoaded"(arg0: $LevelChunk$$Type): void
public "lithium$getData"(): $LithiumData$Data
public "getMcEntities"(): $Iterable
public "redirect$eln000$observable$redirectTick"(blockEntity: $TickingBlockEntity$$Type): void
public "lithium$getLoadedExistingBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
public "refurbishedFurniture$GetElectricityTicker"(): $ElectricityTicker
public "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type, arg3: integer): boolean
public "getData"(): $AttachedData
public "getChunk"(arg0: integer, arg1: integer): $ChunkAccess
public "getChunk"(arg0: $BlockPos$$Type): $ChunkAccess
public "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type): $ChunkAccess
public "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
public "getDayTime"(): long
public "isDay"(): boolean
public "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
public "handler$fnk000$sliceanddice$isRainingAt"(arg0: $BlockPos$$Type, arg1: $CallbackInfoReturnable$$Type): void
public "fabric_computeInitialSyncChanges"(arg0: $ServerPlayer$$Type, arg1: $Consumer$$Type): void
public "fabric_getDynamicRegistryManager"(): $RegistryAccess
public "getCurrentDifficultyAt"(arg0: $BlockPos$$Type): $DifficultyInstance
public "getProfilerSupplier"(): $Supplier<($ProfilerFiller)>
public "increaseMaxEntityRadius"(arg0: double): double
public "getServer"(): $MinecraftServer
public "playSound"(arg0: $Player$$Type, arg1: double, arg2: double, arg3: double, arg4: $SoundEvent$$Type, arg5: $SoundSource$$Type): void
public "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type, arg4: float, arg5: float): void
public "playSound"(arg0: $Player$$Type, arg1: double, arg2: double, arg3: double, arg4: $SoundEvent$$Type, arg5: $SoundSource$$Type, arg6: float, arg7: float): void
public "playSound"(arg0: $Entity$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type, arg4: float, arg5: float): void
public "playSound"(arg0: $Player$$Type, arg1: double, arg2: double, arg3: double, arg4: $Holder$$Type<($SoundEvent)>, arg5: $SoundSource$$Type, arg6: float, arg7: float): void
public "playSound"(arg0: $Player$$Type, arg1: $Entity$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type, arg4: float, arg5: float): void
public "getRainLevel"(arg0: float): float
public "isInWorldBounds"(arg0: $BlockPos$$Type): boolean
public "playLocalSound"(arg0: $BlockPos$$Type, arg1: $SoundEvent$$Type, arg2: $SoundSource$$Type, arg3: float, arg4: float, arg5: boolean): void
public "playLocalSound"(arg0: $Entity$$Type, arg1: $SoundEvent$$Type, arg2: $SoundSource$$Type, arg3: float, arg4: float): void
public "playLocalSound"(arg0: double, arg1: double, arg2: double, arg3: $SoundEvent$$Type, arg4: $SoundSource$$Type, arg5: float, arg6: float, arg7: boolean): void
public "getGameRules"(): $GameRules
public "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
public "getSharedSpawnAngle"(): float
public "isNight"(): boolean
public "getChunkSource"(): $ChunkSource
public "blockUpdated"(arg0: $BlockPos$$Type, arg1: $Block$$Type): void
public "levelEvent"(arg0: $Player$$Type, arg1: integer, arg2: $BlockPos$$Type, arg3: integer): void
public "levelEvent"(arg0: integer, arg1: $BlockPos$$Type, arg2: integer): void
public "dayTime"(): long
public "getBlockTicks"(): $LevelTickAccess<($Block)>
public "getFluidTicks"(): $LevelTickAccess<($Fluid)>
public "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer): void
public "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer): void
public "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer, arg3: $TickPriority$$Type): void
public "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer, arg3: $TickPriority$$Type): void
public "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $Vec3$$Type): void
public "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $Vec3$$Type, arg2: $GameEvent$Context$$Type): void
public "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $BlockPos$$Type): void
public "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
public "gameEvent"(arg0: $ResourceKey$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
public "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type): void
public "getDifficulty"(): $Difficulty
public "hasChunk"(arg0: integer, arg1: integer): boolean
public "getDescription"(): $Component
public "getCapability"<T>(arg0: $BlockCapability$$Type<(T), (void)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockEntity$$Type): T
public "getCapability"<T, C>(arg0: $BlockCapability$$Type<(T), (C)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $BlockEntity$$Type, arg4: C): T
public "getCapability"<T, C>(arg0: $BlockCapability$$Type<(T), (C)>, arg1: $BlockPos$$Type, arg2: C): T
public "getCapability"<T>(arg0: $BlockCapability$$Type<(T), (void)>, arg1: $BlockPos$$Type): T
public "getPartEntities"(): $Collection<($PartEntity<(never)>)>
public "invalidateCapabilities"(arg0: $ChunkPos$$Type): void
public "invalidateCapabilities"(arg0: $BlockPos$$Type): void
public "getModelDataManager"(): $ModelDataManager
public "getDescriptionKey"(): StringJS
public static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
public "getSectionYFromSectionIndex"(arg0: integer): integer
public "getSectionIndexFromSectionY"(arg0: integer): integer
public "getMaxBuildHeight"(): integer
public "getSectionIndex"(arg0: integer): integer
public "getMaxSection"(): integer
public "getMinSection"(): integer
public "getSectionsCount"(): integer
public "getHeight"(): integer
public "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
public "isOutsideBuildHeight"(arg0: integer): boolean
public "getMinBuildHeight"(): integer
public "runCommand"(command: StringJS): void
public "getName"(): $Component
public "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean): void
public "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean, cause: $ServerPlayer$$Type): void
public "isOverworld"(): boolean
public "explode"(x: double, y: double, z: double, properties: $ExplosionProperties$$Type): $Explosion
public "createEntity"(type: $EntityType$$Type<(never)>): $Entity
public "spawnEntity"(type: $EntityType$$Type<(never)>, callback: $Consumer$$Type<($Entity)>): void
public "spawnFireworks"(x: double, y: double, z: double, fireworks: $Fireworks$$Type, lifetime: integer): void
public "spawnParticles"(options: $ParticleOptions$$Type, overrideLimiter: boolean, x: double, y: double, z: double, vx: double, vy: double, vz: double, count: integer, speed: double): void
public "getDimension"(): $ResourceLocation
public "setTime"(time: long): void
public "setStatusMessage"(message: $Component$$Type): void
public "runCommandSilent"(command: StringJS): void
public "setActivePostShader"(id: $ResourceLocation$$Type): void
public "self"(): $Level
public "tell"(message: $Component$$Type): void
public "getBlock"(x: integer, y: integer, z: integer): $LevelBlock
public "getBlock"(entity: $BlockEntity$$Type): $LevelBlock
public "getBlock"(pos: $BlockPos$$Type): $LevelBlock
public "getSide"(): $ScriptType
public static "getAllLoadedEntities"(level: $Level$$Type): $Iterable<($Entity)>
public "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
public "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
public "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
public "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
public "getTimeOfDay"(arg0: float): float
public "getMoonBrightness"(): float
public "getMoonPhase"(): integer
public "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
public "getPlayers"(): $EntityArrayList
public "getMcPlayers"(): $List<($Player)>
public "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($Entity)>
public "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type): $List<(T)>
public "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
public "hasNearbyAlivePlayer"(arg0: double, arg1: double, arg2: double, arg3: double): boolean
public "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: double, arg2: double, arg3: double): $Player
public "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: double, arg3: double, arg4: double): $Player
public "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type): $Player
public "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: $Predicate$$Type<($Entity)>): $Player
public "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): $Player
public "getNearestPlayer"(arg0: $Entity$$Type, arg1: double): $Player
public "getNearestEntity"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double, arg6: $AABB$$Type): T
public "getNearestEntity"<T extends $LivingEntity>(arg0: $List$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double): T
public "getNearbyPlayers"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: $AABB$$Type): $List<($Player)>
public "getNearbyEntities"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: $AABB$$Type): $List<(T)>
public "getPlayerByUUID"(arg0: $UUID$$Type): $Player
public "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
public "getBlockStatesIfLoaded"(arg0: $AABB$$Type): $Stream<($BlockState)>
/**
 * 
 * @deprecated
 */
public "hasChunksAt"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
public "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): boolean
/**
 * 
 * @deprecated
 */
public "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
public "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
public "getUncachedNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
public "canSeeSkyFromBelowWater"(arg0: $BlockPos$$Type): boolean
public "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
public "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type): integer
public "isWaterAt"(arg0: $BlockPos$$Type): boolean
public "hasBiomes"(): boolean
public "enabledFeatures"(): $FeatureFlagSet
public "getPathfindingCostFromLightLevels"(arg0: $BlockPos$$Type): float
public "isEmptyBlock"(arg0: $BlockPos$$Type): boolean
public "holderLookup"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>): $HolderLookup<(T)>
public "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
public "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
public "getBiomeFabric"(arg0: $BlockPos$$Type): $Holder
/**
 * 
 * @deprecated
 */
public "getLightLevelDependentMagicValue"(arg0: $BlockPos$$Type): float
/**
 * 
 * @deprecated
 */
public "hasChunkAt"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "hasChunkAt"(arg0: $BlockPos$$Type): boolean
public "containsAnyLiquid"(arg0: $AABB$$Type): boolean
public "getDisplayName"(): $Component
public "getEntities"(): $EntityArrayList
public "canSeeSky"(arg0: $BlockPos$$Type): boolean
public "getShade"(arg0: $Direction$$Type, arg1: boolean): float
public "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
public "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
public "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
public "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
public "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
public "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
public "isUnobstructed"(arg0: $Entity$$Type): boolean
public "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
public "noCollision"(arg0: $Entity$$Type): boolean
public "noCollision"(arg0: $AABB$$Type): boolean
public "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
public "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
public "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
public "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
public "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
public "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
public "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
public "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
public "holder"<T>(arg0: $ResourceKey$$Type<(T)>): $Optional<($Holder$Reference<(T)>)>
public "isAreaLoaded"(arg0: $BlockPos$$Type, arg1: integer): boolean
public "holderOrThrow"<T>(arg0: $ResourceKey$$Type<(T)>): $Holder<(T)>
/**
 * 
 * @deprecated
 */
public "getBlockEntityRenderAttachment"(arg0: $BlockPos$$Type): any
public "addFreshEntity"(arg0: $Entity$$Type): boolean
public "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
public "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type): boolean
public "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
public "getLightEmission"(arg0: $BlockPos$$Type): integer
public "clip"(arg0: $ClipContext$$Type): $BlockHitResult
public "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
public "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
public "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
public "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
public "getMaxLightLevel"(): integer
public static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
public "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
public "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
public "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
public "getModelData"(arg0: $BlockPos$$Type): $ModelData
public "getBlockEntityRenderData"(arg0: $BlockPos$$Type): any
get "debug"(): boolean
get "dimensionKey"(): $ResourceKey<($Level)>
get "raining"(): boolean
get "time"(): long
get "recipeManager"(): $RecipeManager
get "sharedSpawnPos"(): $BlockPos
get "dayTimeFraction"(): float
set "blockEntity"(value: $BlockEntity$$Type)
get "lightEngine"(): $LevelLightEngine
get "seaLevel"(): integer
get "clientSide"(): boolean
get "scoreboard"(): $Scoreboard
get "maxEntityRadius"(): double
set "dayTimePerTick"(value: float)
get "dayTimePerTick"(): float
set "skyFlashTime"(value: integer)
set "dayTimeFraction"(value: float)
get "thundering"(): boolean
get "freeMapId"(): $MapId
get "skyDarken"(): integer
get "thread"(): $Thread
get "profiler"(): $ProfilerFiller
get "worldBorder"(): $WorldBorder
get "biomeManager"(): $BiomeManager
get "mcEntities"(): $Iterable
get "data"(): $AttachedData
get "day"(): boolean
get "profilerSupplier"(): $Supplier<($ProfilerFiller)>
get "server"(): $MinecraftServer
get "gameRules"(): $GameRules
get "sharedSpawnAngle"(): float
get "night"(): boolean
get "chunkSource"(): $ChunkSource
get "blockTicks"(): $LevelTickAccess<($Block)>
get "fluidTicks"(): $LevelTickAccess<($Fluid)>
get "difficulty"(): $Difficulty
get "description"(): $Component
get "partEntities"(): $Collection<($PartEntity<(never)>)>
get "modelDataManager"(): $ModelDataManager
get "descriptionKey"(): StringJS
get "maxBuildHeight"(): integer
get "maxSection"(): integer
get "minSection"(): integer
get "sectionsCount"(): integer
get "height"(): integer
get "minBuildHeight"(): integer
get "name"(): $Component
get "overworld"(): boolean
get "dimension"(): $ResourceLocation
set "time"(value: long)
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "side"(): $ScriptType
get "moonBrightness"(): float
get "moonPhase"(): integer
get "players"(): $EntityArrayList
get "mcPlayers"(): $List<($Player)>
get "displayName"(): $Component
get "entities"(): $EntityArrayList
get "maxLightLevel"(): integer
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.Dimension
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.DimensionTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Level$$Type = (Special.Dimension);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Level$$Original = $Level;}
declare module "net.minecraft.world.level.block.entity.StructureBlockEntity$UpdateType" {
import {$Enum} from "java.lang.Enum"

export class $StructureBlockEntity$UpdateType extends $Enum<($StructureBlockEntity$UpdateType)> {
static readonly "UPDATE_DATA": $StructureBlockEntity$UpdateType
static readonly "SAVE_AREA": $StructureBlockEntity$UpdateType
static readonly "LOAD_AREA": $StructureBlockEntity$UpdateType
static readonly "SCAN_AREA": $StructureBlockEntity$UpdateType

public static "values"(): ($StructureBlockEntity$UpdateType)[]
public static "valueOf"(arg0: StringJS): $StructureBlockEntity$UpdateType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureBlockEntity$UpdateType$$Type = (("update_data") | ("save_area") | ("load_area") | ("scan_area"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureBlockEntity$UpdateType$$Original = $StructureBlockEntity$UpdateType;}
declare module "net.minecraft.world.level.chunk.PaletteResize" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $PaletteResize$$Interface<T> {

(arg0: integer, arg1: T): integer
}

export class $PaletteResize<T> implements $PaletteResize$$Interface {
 "onResize"(arg0: integer, arg1: T): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PaletteResize$$Type<T> = ((arg0: integer, arg1: T) => integer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PaletteResize$$Original<T> = $PaletteResize<(T)>;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageSetter" {
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $FoliagePlacer$FoliageSetter$$Interface {
}

export class $FoliagePlacer$FoliageSetter implements $FoliagePlacer$FoliageSetter$$Interface {
 "set"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): void
 "isSet"(arg0: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoliagePlacer$FoliageSetter$$Type = ($FoliagePlacer$FoliageSetter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FoliagePlacer$FoliageSetter$$Original = $FoliagePlacer$FoliageSetter;}
declare module "net.minecraft.world.level.levelgen.synth.NormalNoise" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$StringBuilder$$Type} from "java.lang.StringBuilder"
import {$NormalNoise$NoiseParameters, $NormalNoise$NoiseParameters$$Type} from "net.minecraft.world.level.levelgen.synth.NormalNoise$NoiseParameters"

export class $NormalNoise {
public "getValue"(arg0: double, arg1: double, arg2: double): double
public "parameters"(): $NormalNoise$NoiseParameters
public static "create"(arg0: $RandomSource$$Type, arg1: $NormalNoise$NoiseParameters$$Type): $NormalNoise
public static "create"(arg0: $RandomSource$$Type, arg1: integer, ...arg2: (double)[]): $NormalNoise
public "maxValue"(): double
/**
 * 
 * @deprecated
 */
public static "createLegacyNetherBiome"(arg0: $RandomSource$$Type, arg1: $NormalNoise$NoiseParameters$$Type): $NormalNoise
public "parityConfigString"(arg0: $StringBuilder$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NormalNoise$$Type = ($NormalNoise);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NormalNoise$$Original = $NormalNoise;}
declare module "net.minecraft.world.level.storage.LevelResource" {
import {$LevelResourceAccessor$$Interface} from "com.blackgear.platform.core.mixin.access.LevelResourceAccessor"

export class $LevelResource implements $LevelResourceAccessor$$Interface {
static readonly "PLAYER_ADVANCEMENTS_DIR": $LevelResource
static readonly "PLAYER_OLD_DATA_DIR": $LevelResource
static readonly "GENERATED_DIR": $LevelResource
static readonly "LEVEL_DATA_FILE": $LevelResource
static readonly "MAP_RESOURCE_FILE": $LevelResource
static readonly "ROOT": $LevelResource
static readonly "ICON_FILE": $LevelResource
static readonly "LOCK_FILE": $LevelResource
static readonly "OLD_LEVEL_DATA_FILE": $LevelResource
static readonly "PLAYER_STATS_DIR": $LevelResource
static readonly "PLAYER_DATA_DIR": $LevelResource
static readonly "DATAPACK_DIR": $LevelResource

constructor(arg0: StringJS)

public "toString"(): StringJS
public "getId"(): StringJS
public static "createLevelResource$platform_$md$6d3b50$0"(arg0: StringJS): $LevelResource
public static "createLevelResource"(string: StringJS): $LevelResource
get "id"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelResource$$Type = ($LevelResource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelResource$$Original = $LevelResource;}
declare module "net.minecraft.world.level.levelgen.structure.structures.NetherFortressStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$WeightedRandomList} from "net.minecraft.util.random.WeightedRandomList"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MobSpawnSettings$SpawnerData} from "net.minecraft.world.level.biome.MobSpawnSettings$SpawnerData"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $NetherFortressStructure extends $Structure {
static readonly "FORTRESS_ENEMIES": $WeightedRandomList<($MobSpawnSettings$SpawnerData)>
static readonly "CODEC": $MapCodec<($NetherFortressStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "type"(): $StructureType<(never)>
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetherFortressStructure$$Type = ($NetherFortressStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NetherFortressStructure$$Original = $NetherFortressStructure;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProviderType" {
import {$DualNoiseProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.DualNoiseProvider"
import {$RandomizedIntStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.RandomizedIntStateProvider"
import {$WeightedStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.WeightedStateProvider"
import {$NoiseThresholdProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.NoiseThresholdProvider"
import {$BlockStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider"
import {$NoiseProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.NoiseProvider"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$SimpleStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.SimpleStateProvider"
import {$RotatedBlockProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.RotatedBlockProvider"

export class $BlockStateProviderType<P extends $BlockStateProvider> {
static readonly "RANDOMIZED_INT_STATE_PROVIDER": $BlockStateProviderType<($RandomizedIntStateProvider)>
static readonly "DUAL_NOISE_PROVIDER": $BlockStateProviderType<($DualNoiseProvider)>
static readonly "ROTATED_BLOCK_PROVIDER": $BlockStateProviderType<($RotatedBlockProvider)>
static readonly "SIMPLE_STATE_PROVIDER": $BlockStateProviderType<($SimpleStateProvider)>
static readonly "WEIGHTED_STATE_PROVIDER": $BlockStateProviderType<($WeightedStateProvider)>
static readonly "NOISE_THRESHOLD_PROVIDER": $BlockStateProviderType<($NoiseThresholdProvider)>
static readonly "NOISE_PROVIDER": $BlockStateProviderType<($NoiseProvider)>

constructor(arg0: $MapCodec$$Type<(P)>)

public "codec"(): $MapCodec<(P)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenBlockStateProviderType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenBlockStateProviderTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateProviderType$$Type<P> = (Special.WorldgenBlockStateProviderType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateProviderType$$Original<P> = $BlockStateProviderType<(P)>;}
declare module "net.minecraft.world.level.entity.PersistentEntitySectionManager" {
import {$EntitySectionStorage} from "net.minecraft.world.level.entity.EntitySectionStorage"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$Visibility, $Visibility$$Type} from "net.minecraft.world.level.entity.Visibility"
import {$PersistentEntitySectionManagerAccessor$$Interface} from "net.caffeinemc.mods.lithium.mixin.util.accessors.PersistentEntitySectionManagerAccessor"
import {$EntitySection$$Type} from "net.minecraft.world.level.entity.EntitySection"
import {$LevelEntityGetter} from "net.minecraft.world.level.entity.LevelEntityGetter"
import {$LevelCallback, $LevelCallback$$Type} from "net.minecraft.world.level.entity.LevelCallback"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$FullChunkStatus$$Type} from "net.minecraft.server.level.FullChunkStatus"
import {$EntityPersistentStorage$$Type} from "net.minecraft.world.level.entity.EntityPersistentStorage"
import {$PersistentEntitySectionManagerAccessor$$Interface as $PersistentEntitySectionManagerAccessor$0$$Interface} from "net.caffeinemc.mods.lithium.mixin.minimal_nonvanilla.spawning.PersistentEntitySectionManagerAccessor"
import {$Writer$$Type} from "java.io.Writer"
import {$PersistentEntitySectionManagerAccessor$$Interface as $PersistentEntitySectionManagerAccessor$1$$Interface} from "net.caffeinemc.mods.lithium.mixin.util.entity_movement_tracking.PersistentEntitySectionManagerAccessor"
import {$EntityAccess, $EntityAccess$$Type} from "net.minecraft.world.level.entity.EntityAccess"
import {$Class$$Type} from "java.lang.Class"
import {$Set} from "java.util.Set"
import {$EntityLookup} from "net.minecraft.world.level.entity.EntityLookup"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream$$Type} from "java.util.stream.Stream"
import {$Logger} from "org.slf4j.Logger"

export class $PersistentEntitySectionManager<T extends $EntityAccess> implements $AutoCloseable$$Interface, $PersistentEntitySectionManagerAccessor$0$$Interface, $PersistentEntitySectionManagerAccessor$$Interface, $PersistentEntitySectionManagerAccessor$1$$Interface {
readonly "visibleEntityStorage": $EntityLookup<(T)>
readonly "callbacks": $LevelCallback<(T)>
static readonly "LOGGER": $Logger
readonly "sectionStorage": $EntitySectionStorage<(T)>
readonly "knownUuids": $Set<($UUID)>

constructor(arg0: $Class$$Type<(T)>, arg1: $LevelCallback$$Type<(T)>, arg2: $EntityPersistentStorage$$Type<(T)>)

public "count"(): integer
public "close"(): void
public "isLoaded"(arg0: $UUID$$Type): boolean
public "tick"(): void
public "getCache"(): $EntitySectionStorage
public static "getEffectiveStatus"<T extends $EntityAccess>(arg0: T, arg1: $Visibility$$Type): $Visibility
public "saveAll"(): void
public "autoSave"(): void
public "addNewEntityWithoutEvent"(arg0: T): boolean
public "updateChunkStatus"(arg0: $ChunkPos$$Type, arg1: $Visibility$$Type): void
public "updateChunkStatus"(arg0: $ChunkPos$$Type, arg1: $FullChunkStatus$$Type): void
public "areEntitiesLoaded"(arg0: long): boolean
public "canPositionTick"(arg0: $ChunkPos$$Type): boolean
public "canPositionTick"(arg0: $BlockPos$$Type): boolean
public "addNewEntity"(arg0: T): boolean
public "dumpSections"(arg0: $Writer$$Type): void
public "gatherStats"(): StringJS
public "stopTicking"(arg0: T): void
public "startTicking"(arg0: T): void
public "getEntityGetter"(): $LevelEntityGetter<(T)>
public "addLegacyChunkEntities"(arg0: $Stream$$Type<(T)>): void
public "addWorldGenChunkEntities"(arg0: $Stream$$Type<(T)>): void
public "removeSectionIfEmpty"(arg0: long, arg1: $EntitySection$$Type<(T)>): void
public "startTracking"(arg0: T): void
public "stopTracking"(arg0: T): void
public "redirect$chl000$smoothchunk$processUnloadsSafe"(arg0: $PersistentEntitySectionManager$$Type): void
get "cache"(): $EntitySectionStorage
get "entityGetter"(): $LevelEntityGetter<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PersistentEntitySectionManager$$Type<T> = ($PersistentEntitySectionManager<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PersistentEntitySectionManager$$Original<T> = $PersistentEntitySectionManager<(T)>;}
declare module "net.minecraft.world.level.block.SculkSpreader$ChargeCursor" {
import {$SculkSpreader$$Type} from "net.minecraft.world.level.block.SculkSpreader"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Direction} from "net.minecraft.core.Direction"
import {$Set} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"

export class $SculkSpreader$ChargeCursor {
 "charge": integer
static readonly "CODEC": $Codec<($SculkSpreader$ChargeCursor)>
static readonly "MAX_CURSOR_DECAY_DELAY": integer

constructor(arg0: $BlockPos$$Type, arg1: integer)

public "update"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type, arg3: $SculkSpreader$$Type, arg4: boolean): void
public "getPos"(): $BlockPos
public "getDecayDelay"(): integer
public "mergeWith"(arg0: $SculkSpreader$ChargeCursor$$Type): void
public "getCharge"(): integer
public "getFacingData"(): $Set<($Direction)>
get "pos"(): $BlockPos
get "decayDelay"(): integer
get "facingData"(): $Set<($Direction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkSpreader$ChargeCursor$$Type = ($SculkSpreader$ChargeCursor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkSpreader$ChargeCursor$$Original = $SculkSpreader$ChargeCursor;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration" {
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$Stream} from "java.util.stream.Stream"
import {$NoneFeatureConfiguration} from "net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration"

export interface $FeatureConfiguration$$Interface {
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}

export class $FeatureConfiguration implements $FeatureConfiguration$$Interface {
static readonly "NONE": $NoneFeatureConfiguration

 "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FeatureConfiguration$$Type = ($FeatureConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FeatureConfiguration$$Original = $FeatureConfiguration;}
declare module "net.minecraft.world.level.biome.BiomeManager$NoiseBiomeSource" {
import {$Biome, $Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export interface $BiomeManager$NoiseBiomeSource$$Interface {

(arg0: integer, arg1: integer, arg2: integer): $Holder$$Type<($Biome$$Type)>
}

export class $BiomeManager$NoiseBiomeSource implements $BiomeManager$NoiseBiomeSource$$Interface {
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeManager$NoiseBiomeSource$$Type = ((arg0: integer, arg1: integer, arg2: integer) => $Holder$$Type<($Biome$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BiomeManager$NoiseBiomeSource$$Original = $BiomeManager$NoiseBiomeSource;}
declare module "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$Data" {
import {$VibrationInfo, $VibrationInfo$$Type} from "net.minecraft.world.level.gameevent.vibrations.VibrationInfo"
import {$Codec} from "com.mojang.serialization.Codec"
import {$VibrationSelector} from "net.minecraft.world.level.gameevent.vibrations.VibrationSelector"

export class $VibrationSystem$Data {
readonly "selectionStrategy": $VibrationSelector
static "CODEC": $Codec<($VibrationSystem$Data)>
static readonly "NBT_TAG_KEY": StringJS
 "currentVibration": $VibrationInfo

constructor()

public "setReloadVibrationParticle"(arg0: boolean): void
public "setCurrentVibration"(arg0: $VibrationInfo$$Type): void
public "setTravelTimeInTicks"(arg0: integer): void
public "decrementTravelTime"(): void
public "getTravelTimeInTicks"(): integer
public "getCurrentVibration"(): $VibrationInfo
public "getSelectionStrategy"(): $VibrationSelector
public "shouldReloadVibrationParticle"(): boolean
set "reloadVibrationParticle"(value: boolean)
set "travelTimeInTicks"(value: integer)
get "travelTimeInTicks"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VibrationSystem$Data$$Type = ($VibrationSystem$Data);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VibrationSystem$Data$$Original = $VibrationSystem$Data;}
declare module "net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext" {
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$StructureTemplateManager, $StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$RegistryAccess, $RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"
import {$ResourceManager, $ResourceManager$$Type} from "net.minecraft.server.packs.resources.ResourceManager"
import {$Record} from "java.lang.Record"

export class $StructurePieceSerializationContext extends $Record {
constructor(arg0: $ResourceManager$$Type, arg1: $RegistryAccess$$Type, arg2: $StructureTemplateManager$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "registryAccess"(): $RegistryAccess
public "structureTemplateManager"(): $StructureTemplateManager
public "resourceManager"(): $ResourceManager
public static "fromLevel"(arg0: $ServerLevel$$Type): $StructurePieceSerializationContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructurePieceSerializationContext$$Type = ({"registryAccess"?: $RegistryAccess$$Type, "structureTemplateManager"?: $StructureTemplateManager$$Type, "resourceManager"?: $ResourceManager$$Type}) | ([registryAccess?: $RegistryAccess$$Type, structureTemplateManager?: $StructureTemplateManager$$Type, resourceManager?: $ResourceManager$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructurePieceSerializationContext$$Original = $StructurePieceSerializationContext;}
declare module "net.minecraft.world.level.block.entity.SculkShriekerBlockEntity" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$VibrationSystem$Data} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$Data"
import {$GameEventListener$Provider$$Interface} from "net.minecraft.world.level.gameevent.GameEventListener$Provider"
import {$VibrationSystem$Listener} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$Listener"
import {$Level} from "net.minecraft.world.level.Level"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$VibrationSystem$User} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$User"
import {$GameEvent, $GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$VibrationSystem$$Interface} from "net.minecraft.world.level.gameevent.vibrations.VibrationSystem"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SculkShriekerBlockEntity extends $BlockEntity implements $GameEventListener$Provider$$Interface<($VibrationSystem$Listener)>, $VibrationSystem$$Interface {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getVibrationUser"(): $VibrationSystem$User
public "getVibrationData"(): $VibrationSystem$Data
public static "tryGetPlayer"(arg0: $Entity$$Type): $ServerPlayer
public "getListener"(): $VibrationSystem$Listener
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "tryShriek"(arg0: $ServerLevel$$Type, arg1: $ServerPlayer$$Type): void
public "tryRespond"(arg0: $ServerLevel$$Type): void
public static "getResonanceEventByFrequency"(arg0: integer): $ResourceKey<($GameEvent)>
public static "getRedstoneStrengthForDistance"(arg0: float, arg1: integer): integer
public static "getGameEventFrequency"(arg0: $ResourceKey$$Type<($GameEvent)>): integer
public static "getGameEventFrequency"(arg0: $Holder$$Type<($GameEvent)>): integer
get "vibrationUser"(): $VibrationSystem$User
get "vibrationData"(): $VibrationSystem$Data
get "listener"(): $VibrationSystem$Listener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SculkShriekerBlockEntity$$Type = ($SculkShriekerBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SculkShriekerBlockEntity$$Original = $SculkShriekerBlockEntity;}
declare module "net.minecraft.world.level.levelgen.WorldDimensions" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Optional} from "java.util.Optional"
import {$ImmutableSet} from "com.google.common.collect.ImmutableSet"
import {$Level} from "net.minecraft.world.level.Level"
import {$WorldDimensions$Complete} from "net.minecraft.world.level.levelgen.WorldDimensions$Complete"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$LevelStem, $LevelStem$$Type} from "net.minecraft.world.level.dimension.LevelStem"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$ChunkGenerator, $ChunkGenerator$$Type} from "net.minecraft.world.level.chunk.ChunkGenerator"
import {$Lifecycle} from "com.mojang.serialization.Lifecycle"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Stream, $Stream$$Type} from "java.util.stream.Stream"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$RegistryAccess$$Type} from "net.minecraft.core.RegistryAccess"
import {$DimensionType$$Type} from "net.minecraft.world.level.dimension.DimensionType"
import {$Record} from "java.lang.Record"

export class $WorldDimensions extends $Record {
static readonly "CODEC": $MapCodec<($WorldDimensions)>

constructor(dimensions: $Map$$Type<($ResourceKey$$Type<($LevelStem$$Type)>), ($LevelStem$$Type)>)
constructor(arg0: $Registry$$Type<($LevelStem$$Type)>)

public "get"(arg0: $ResourceKey$$Type<($LevelStem)>): $Optional<($LevelStem)>
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "dimensions"(): $Map<($ResourceKey<($LevelStem)>), ($LevelStem)>
public "isDebug"(): boolean
public "levels"(): $ImmutableSet<($ResourceKey<($Level)>)>
public "bake"(arg0: $Registry$$Type<($LevelStem$$Type)>): $WorldDimensions$Complete
public "overworld"(): $ChunkGenerator
public "replaceOverworldGenerator"(arg0: $RegistryAccess$$Type, arg1: $ChunkGenerator$$Type): $WorldDimensions
public static "keysInOrder"(arg0: $Stream$$Type<($ResourceKey$$Type<($LevelStem$$Type)>)>): $Stream<($ResourceKey<($LevelStem)>)>
public static "withOverworld"(arg0: $Registry$$Type<($DimensionType$$Type)>, arg1: $Map$$Type<($ResourceKey$$Type<($LevelStem$$Type)>), ($LevelStem$$Type)>, arg2: $ChunkGenerator$$Type): $Map<($ResourceKey<($LevelStem)>), ($LevelStem)>
public static "withOverworld"(arg0: $Map$$Type<($ResourceKey$$Type<($LevelStem$$Type)>), ($LevelStem$$Type)>, arg1: $Holder$$Type<($DimensionType)>, arg2: $ChunkGenerator$$Type): $Map<($ResourceKey<($LevelStem)>), ($LevelStem)>
public static "checkStability"(arg0: $ResourceKey$$Type<($LevelStem)>, arg1: $LevelStem$$Type): $Lifecycle
get "debug"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldDimensions$$Type = ({"dimensions"?: $Map$$Type<($ResourceKey$$Type<($LevelStem$$Type)>), ($LevelStem$$Type)>}) | ([dimensions?: $Map$$Type<($ResourceKey$$Type<($LevelStem$$Type)>), ($LevelStem$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldDimensions$$Original = $WorldDimensions;}
declare module "net.minecraft.world.level.storage.LevelData" {
import {$GameRules} from "net.minecraft.world.level.GameRules"
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Difficulty} from "net.minecraft.world.Difficulty"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$CrashReportCategory$$Type} from "net.minecraft.CrashReportCategory"

export interface $LevelData$$Interface {
set "raining"(value: boolean)
get "difficultyLocked"(): boolean
get "raining"(): boolean
get "hardcore"(): boolean
get "gameTime"(): long
get "spawnPos"(): $BlockPos
get "spawnAngle"(): float
get "thundering"(): boolean
get "dayTime"(): long
get "difficulty"(): $Difficulty
get "gameRules"(): $GameRules
}

export class $LevelData implements $LevelData$$Interface {
 "setRaining"(arg0: boolean): void
 "isDifficultyLocked"(): boolean
 "isRaining"(): boolean
 "isHardcore"(): boolean
 "fillCrashReportCategory"(arg0: $CrashReportCategory$$Type, arg1: $LevelHeightAccessor$$Type): void
 "getGameTime"(): long
 "getSpawnPos"(): $BlockPos
 "getSpawnAngle"(): float
 "isThundering"(): boolean
 "getDayTime"(): long
 "getDifficulty"(): $Difficulty
 "getGameRules"(): $GameRules
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelData$$Type = ($LevelData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelData$$Original = $LevelData;}
declare module "net.minecraft.world.level.block.entity.BlockEntity" {
import {$Iterable} from "java.lang.Iterable"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IBlockEntityExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IBlockEntityExtension"
import {$CallbackInfo$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfo"
import {$EMFEntity$$Interface} from "traben.entity_model_features.utils.EMFEntity"
import {$DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$AttachmentType$$Type as $AttachmentType$0$$Type} from "net.fabricmc.fabric.api.attachment.v1.AttachmentType"
import {$RenderAttachmentBlockEntity$$Interface} from "net.fabricmc.fabric.api.rendering.data.v1.RenderAttachmentBlockEntity"
import {$BlockEntityAccessor$$Interface} from "com.copycatsplus.copycats.mixin.foundation.copycat.BlockEntityAccessor"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$EntityType} from "net.minecraft.world.entity.EntityType"
import {$SupportCache$$Interface} from "net.caffeinemc.mods.lithium.common.world.blockentity.SupportCache"
import {$Cullable$$Interface} from "dev.tr7zw.entityculling.versionless.access.Cullable"
import {$DynamicLightSource$$Interface} from "toni.sodiumdynamiclights.DynamicLightSource"
import {$AttachmentChange$$Type} from "net.fabricmc.fabric.impl.attachment.sync.AttachmentChange"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$AccessorBlockEntity$$Interface} from "com.railwayteam.railways.mixin.AccessorBlockEntity"
import {$BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$ComparatorTracker$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.inventory_comparator_tracking.ComparatorTracker"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$Object2FloatOpenHashMap} from "it.unimi.dsi.fastutil.objects.Object2FloatOpenHashMap"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$CrashReportCategory$$Type} from "net.minecraft.CrashReportCategory"
import {$AttachmentTargetInfo} from "net.fabricmc.fabric.impl.attachment.sync.AttachmentTargetInfo"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"
import {$AttachmentTargetImpl$$Interface} from "net.fabricmc.fabric.impl.attachment.AttachmentTargetImpl"
import {$UUID} from "java.util.UUID"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component} from "net.minecraft.network.chat.Component"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Pose} from "net.minecraft.world.entity.Pose"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType, $BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$RenderDataBlockEntity$$Interface} from "net.fabricmc.fabric.api.blockview.v2.RenderDataBlockEntity"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ETFEntity$$Interface} from "traben.entity_texture_features.utils.ETFEntity"
import {$AttachmentSyncPayloadS2C$$Type} from "net.fabricmc.fabric.impl.attachment.sync.s2c.AttachmentSyncPayloadS2C"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$AttachmentType$$Type} from "net.neoforged.neoforge.attachment.AttachmentType"
import {$LevelRenderer$$Type} from "net.minecraft.client.renderer.LevelRenderer"
import {$SetChangedHandlingBlockEntity$$Interface} from "net.caffeinemc.mods.lithium.common.block.entity.SetChangedHandlingBlockEntity"
import {$AttachmentHolder} from "net.neoforged.neoforge.attachment.AttachmentHolder"
import {$ClientGamePacketListener} from "net.minecraft.network.protocol.game.ClientGamePacketListener"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Team} from "net.minecraft.world.scores.Team"
import {$ClientboundBlockEntityDataPacket$$Type} from "net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket"
import {$Connection$$Type} from "net.minecraft.network.Connection"

export class $BlockEntity extends $AttachmentHolder implements $IBlockEntityExtension$$Interface, $RenderDataBlockEntity$$Interface, $RenderAttachmentBlockEntity$$Interface, $SupportCache$$Interface, $ComparatorTracker$$Interface, $SetChangedHandlingBlockEntity$$Interface, $Cullable$$Interface, $AttachmentTargetImpl$$Interface, $AccessorBlockEntity$$Interface, $DynamicLightSource$$Interface, $EMFEntity$$Interface, $ETFEntity$$Interface, $BlockEntityAccessor$$Interface {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockEntityType$$Type<(never)>, arg1: $BlockPos$$Type, arg2: $BlockState$$Type)

public "getType"(): $BlockEntityType<(never)>
public "getLevel"(): $Level
public "setLevel"(arg0: $Level$$Type): void
public static "getPosFromTag"(arg0: $CompoundTag$$Type): $BlockPos
public "isValidBlockState"(arg0: $BlockState$$Type): boolean
public "loadCustomOnly"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "clearRemoved"(): void
public "callSaveMetadata"(arg0: $CompoundTag$$Type): void
public "setWorldPosition"(arg0: $BlockPos$$Type): void
public "setTimeout"(): void
public "handler$efj000$collective$setLevel"(arg0: $Level$$Type, arg1: $CallbackInfo$$Type): void
public "lithium$hasAnyComparatorNearby"(): boolean
public "applyComponentsFromItemStack"(arg0: $ItemStack$$Type): void
public "saveCustomOnly"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "removeData"<T>(arg0: $AttachmentType$$Type<(T)>): T
public "fillCrashReportCategory"(arg0: $CrashReportCategory$$Type): void
public "emf$isTouchingWater"(): boolean
public "acknowledgeSyncedEntry"(arg0: $AttachmentType$0$$Type, arg1: $AttachmentChange$$Type): void
public "fabric_getSyncTargetInfo"(): $AttachmentTargetInfo
public "etf$getScoreboardTeam"(): $Team
public "etf$getItemsEquipped"(): $Iterable
public "fabric_shouldTryToSync"(): boolean
public "sdl$dynamicLightTick"(): void
public "sdl$getDynamicLightY"(): double
public "sdl$getDynamicLightLevel"(): $Level
public "sdl$resetDynamicLight"(): void
public "sdl$getDynamicLightX"(): double
public "sdl$getDynamicLightZ"(): double
public "applyComponents"(arg0: $DataComponentMap$$Type, arg1: $DataComponentPatch$$Type): void
public "collectComponents"(): $DataComponentMap
public "fabric_syncChange"(arg0: $AttachmentType$0$$Type, arg1: $AttachmentSyncPayloadS2C$$Type): void
public "setOutOfCamera"(value: boolean): void
public "isForcedVisible"(): boolean
public "isOutOfCamera"(): boolean
public "onlyOpCanSetNbt"(): boolean
public "emf$isAlive"(): boolean
public "etf$getType"(): $EntityType
public "etf$getHandItems"(): $Iterable
public "emf$isOnGround"(): boolean
public "emf$isGlowing"(): boolean
public "emf$isOnFire"(): boolean
public "emf$isSneaking"(): boolean
public "emf$hasPassengers"(): boolean
public "emf$getPitch"(): float
public "emf$isSprinting"(): boolean
public "emf$hasVehicle"(): boolean
public "etf$hasCustomName"(): boolean
public "etf$getCustomName"(): $Component
public "emf$getVariableMap"(): $Object2FloatOpenHashMap
public "etf$getPose"(): $Pose
public "emf$isInvisible"(): boolean
public "emf$getVelocity"(): $Vec3
public "emf$getTypeString"(): StringJS
public "emf$prevPitch"(): float
public "etf$distanceTo"(entity: $Entity$$Type): float
public "emf$isInLava"(): boolean
public "etf$getVelocity"(): $Vec3
public "etf$getUuid"(): $UUID
public "etf$getOptifineId"(): integer
public "etf$getArmorItems"(): $Iterable
public "etf$canBeBright"(): boolean
public "etf$isBlockEntity"(): boolean
public "etf$getBlockY"(): integer
/**
 * 
 * @deprecated
 */
public "setBlockState"(arg0: $BlockState$$Type): void
public "triggerEvent"(arg0: integer, arg1: integer): boolean
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "hasLevel"(): boolean
public "setRemoved"(): void
public "getBlockState"(): $BlockState
public "components"(): $DataComponentMap
public "setData"<T>(arg0: $AttachmentType$$Type<(T)>, arg1: T): T
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getBlockPos"(): $BlockPos
public "handler$efj000$collective$setRemoved"(arg0: $CallbackInfo$$Type): void
public "loadWithComponents"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getRenderData"(): any
public "syncData"(arg0: $AttachmentType$$Type<(never)>): void
public "emf$prevX"(): double
public "emf$getY"(): double
public "emf$getX"(): double
public "emf$prevZ"(): double
public "emf$age"(): float
public "etf$getNbt"(): $CompoundTag
public "setCulled"(value: boolean): void
public "emf$getYaw"(): float
public "emf$prevY"(): double
public "emf$isWet"(): boolean
public "isCulled"(): boolean
public "emf$getZ"(): double
public static "setChanged"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "setChanged"(): void
public "saveCustomAndMetadata"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
/**
 * 
 * @deprecated
 */
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "setComponents"(arg0: $DataComponentMap$$Type): void
public "fabric_computeInitialSyncChanges"(arg0: $ServerPlayer$$Type, arg1: $Consumer$$Type): void
public "fabric_getDynamicRegistryManager"(): $RegistryAccess
public "sdl$shouldUpdateDynamicLight"(): boolean
public "saveWithId"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public static "loadStatic"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $CompoundTag$$Type, arg3: $HolderLookup$Provider$$Type): $BlockEntity
public static "addEntityType"(arg0: $CompoundTag$$Type, arg1: $BlockEntityType$$Type<(never)>): void
public "isRemoved"(): boolean
public "etf$getBlockPos"(): $BlockPos
public "etf$getEntityKey"(): StringJS
public "etf$getWorld"(): $Level
public "saveToItem"(arg0: $ItemStack$$Type, arg1: $HolderLookup$Provider$$Type): void
public "sdl$getLuminance"(): integer
public "getPersistentData"(): $CompoundTag
public "collectImplicitComponents"(arg0: $DataComponentMap$Builder$$Type): void
public "lithium$onComparatorAdded"(arg0: $Direction$$Type, arg1: integer): void
public "getRenderAttachmentData"(): any
public static "parseCustomNameSafe"(arg0: StringJS, arg1: $HolderLookup$Provider$$Type): $Component
public "lithium$isSupported"(): boolean
public "applyImplicitComponents"(arg0: $BlockEntity$DataComponentInput$$Type): void
public "saveWithFullMetadata"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "saveWithoutMetadata"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "sodiumdynamiclights$updateDynamicLight"(renderer: $LevelRenderer$$Type): boolean
public "sodiumdynamiclights$scheduleTrackedChunksRebuild"(renderer: $LevelRenderer$$Type): void
public "onChunkUnloaded"(): void
public "handleUpdateTag"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "onDataPacket"(arg0: $Connection$$Type, arg1: $ClientboundBlockEntityDataPacket$$Type, arg2: $HolderLookup$Provider$$Type): void
public "hasCustomOutlineRendering"(arg0: $Player$$Type): boolean
public "invalidateCapabilities"(): void
public "onLoad"(): void
public "getModelData"(): $ModelData
public "requestModelDataUpdate"(): void
public "lithium$handleSetChanged"(): void
public "sdl$isDynamicLightEnabled"(): boolean
public "sdl$setDynamicLightEnabled"(enabled: boolean): void
get "type"(): $BlockEntityType<(never)>
get "timeout"(): void
set "outOfCamera"(value: boolean)
get "forcedVisible"(): boolean
get "outOfCamera"(): boolean
set "blockState"(value: $BlockState$$Type)
get "removed"(): void
get "blockState"(): $BlockState
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
get "blockPos"(): $BlockPos
get "renderData"(): any
set "culled"(value: boolean)
get "culled"(): boolean
get "changed"(): void
get "removed"(): boolean
get "persistentData"(): $CompoundTag
get "renderAttachmentData"(): any
get "modelData"(): $ModelData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntity$$Type = ($BlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntity$$Original = $BlockEntity;}
declare module "net.minecraft.world.level.chunk.PalettedContainer$Data" {
import {$PalettedContainer$Configuration, $PalettedContainer$Configuration$$Type} from "net.minecraft.world.level.chunk.PalettedContainer$Configuration"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$Palette, $Palette$$Type} from "net.minecraft.world.level.chunk.Palette"
import {$BitStorage, $BitStorage$$Type} from "net.minecraft.util.BitStorage"
import {$Record} from "java.lang.Record"

export class $PalettedContainer$Data<T> extends $Record {
constructor(configuration: $PalettedContainer$Configuration$$Type<(T)>, storage: $BitStorage$$Type, palette: $Palette$$Type<(T)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "write"(arg0: $FriendlyByteBuf$$Type): void
public "configuration"(): $PalettedContainer$Configuration<(T)>
public "copy"(): $PalettedContainer$Data<(T)>
public "copyFrom"(arg0: $Palette$$Type<(T)>, arg1: $BitStorage$$Type): void
public "storage"(): $BitStorage
public "getSerializedSize"(): integer
public "palette"(): $Palette<(T)>
get "serializedSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PalettedContainer$Data$$Type<T> = ({"palette"?: $Palette$$Type<(T)>, "configuration"?: $PalettedContainer$Configuration$$Type<(T)>, "storage"?: $BitStorage$$Type}) | ([palette?: $Palette$$Type<(T)>, configuration?: $PalettedContainer$Configuration$$Type<(T)>, storage?: $BitStorage$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PalettedContainer$Data$$Original<T> = $PalettedContainer$Data<(T)>;}
declare module "net.minecraft.world.level.DataPackConfig" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$List, $List$$Type} from "java.util.List"

export class $DataPackConfig {
static readonly "CODEC": $Codec<($DataPackConfig)>
static readonly "DEFAULT": $DataPackConfig

constructor(arg0: $List$$Type<(StringJS)>, arg1: $List$$Type<(StringJS)>)

public "getEnabled"(): $List<(StringJS)>
public "getDisabled"(): $List<(StringJS)>
public "addModPacks"(arg0: $List$$Type<(StringJS)>): void
get "enabled"(): $List<(StringJS)>
get "disabled"(): $List<(StringJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataPackConfig$$Type = ($DataPackConfig);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataPackConfig$$Original = $DataPackConfig;}
declare module "net.minecraft.world.level.block.state.properties.StairsShape" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $StairsShape extends $Enum<($StairsShape)> implements $StringRepresentable$$Interface {
static readonly "INNER_LEFT": $StairsShape
static readonly "INNER_RIGHT": $StairsShape
static readonly "OUTER_LEFT": $StairsShape
static readonly "OUTER_RIGHT": $StairsShape
static readonly "STRAIGHT": $StairsShape

public "toString"(): StringJS
public static "values"(): ($StairsShape)[]
public static "valueOf"(arg0: StringJS): $StairsShape
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StairsShape$$Type = (("straight") | ("inner_left") | ("inner_right") | ("outer_left") | ("outer_right"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StairsShape$$Original = $StairsShape;}
declare module "net.minecraft.world.level.levelgen.feature.stateproviders.NoiseThresholdProvider" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$List$$Type} from "java.util.List"
import {$BlockStateProviderType} from "net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProviderType"
import {$NormalNoise} from "net.minecraft.world.level.levelgen.synth.NormalNoise"
import {$NoiseBasedStateProvider} from "net.minecraft.world.level.levelgen.feature.stateproviders.NoiseBasedStateProvider"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$NormalNoise$NoiseParameters, $NormalNoise$NoiseParameters$$Type} from "net.minecraft.world.level.levelgen.synth.NormalNoise$NoiseParameters"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $NoiseThresholdProvider extends $NoiseBasedStateProvider {
static readonly "CODEC": $MapCodec<($NoiseThresholdProvider)>
readonly "seed": long
readonly "noise": $NormalNoise
readonly "scale": float
readonly "parameters": $NormalNoise$NoiseParameters

constructor(arg0: long, arg1: $NormalNoise$NoiseParameters$$Type, arg2: float, arg3: float, arg4: float, arg5: $BlockState$$Type, arg6: $List$$Type<($BlockState$$Type)>, arg7: $List$$Type<($BlockState$$Type)>)

public "type"(): $BlockStateProviderType<(never)>
public "getState"(arg0: $RandomSource$$Type, arg1: $BlockPos$$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoiseThresholdProvider$$Type = ($NoiseThresholdProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NoiseThresholdProvider$$Original = $NoiseThresholdProvider;}
declare module "net.minecraft.world.level.LevelWriter" {
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $LevelWriter$$Interface {
}

export class $LevelWriter implements $LevelWriter$$Interface {
 "removeBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "addFreshEntity"(arg0: $Entity$$Type): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type, arg3: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelWriter$$Type = ($LevelWriter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelWriter$$Original = $LevelWriter;}
declare module "net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator$Context" {
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$BooleanProperty$$Type} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$Set$$Type} from "java.util.Set"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ObjectArrayList} from "it.unimi.dsi.fastutil.objects.ObjectArrayList"
import {$LevelSimulatedReader, $LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $TreeDecorator$Context {
constructor(arg0: $LevelSimulatedReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: $Set$$Type<($BlockPos$$Type)>, arg4: $Set$$Type<($BlockPos$$Type)>, arg5: $Set$$Type<($BlockPos$$Type)>)

public "roots"(): $ObjectArrayList<($BlockPos)>
public "random"(): $RandomSource
public "level"(): $LevelSimulatedReader
public "isAir"(arg0: $BlockPos$$Type): boolean
public "placeVine"(arg0: $BlockPos$$Type, arg1: $BooleanProperty$$Type): void
public "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type): void
public "logs"(): $ObjectArrayList<($BlockPos)>
public "leaves"(): $ObjectArrayList<($BlockPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TreeDecorator$Context$$Type = ($TreeDecorator$Context);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TreeDecorator$Context$$Original = $TreeDecorator$Context;}
declare module "net.minecraft.world.level.levelgen.structure.structures.ShipwreckStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $ShipwreckStructure extends $Structure {
static readonly "CODEC": $MapCodec<($ShipwreckStructure)>
readonly "isBeached": boolean
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type, arg1: boolean)

public "type"(): $StructureType<(never)>
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShipwreckStructure$$Type = ($ShipwreckStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShipwreckStructure$$Original = $ShipwreckStructure;}
declare module "net.minecraft.world.level.BaseCommandBlock" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionResult} from "net.minecraft.world.InteractionResult"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ServerLevel} from "net.minecraft.server.level.ServerLevel"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$CommandSource$$Interface} from "net.minecraft.commands.CommandSource"
import {$CommandSourceStack} from "net.minecraft.commands.CommandSourceStack"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"

export class $BaseCommandBlock implements $CommandSource$$Interface {
constructor()

public "getPosition"(): $Vec3
public "getName"(): $Component
public "load"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "save"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): $CompoundTag
public "isValid"(): boolean
public "getLevel"(): $ServerLevel
public "createCommandSourceStack"(): $CommandSourceStack
public "getCustomName"(): $Component
public "setCustomName"(arg0: $Component$$Type): void
public "shouldInformAdmins"(): boolean
public "acceptsFailure"(): boolean
public "acceptsSuccess"(): boolean
public "setCommand"(arg0: StringJS): void
public "onUpdated"(): void
public "usedBy"(arg0: $Player$$Type): $InteractionResult
public "getCommand"(): StringJS
public "setLastOutput"(arg0: $Component$$Type): void
public "isTrackOutput"(): boolean
public "getLastOutput"(): $Component
public "getSuccessCount"(): integer
public "setTrackOutput"(arg0: boolean): void
public "setSuccessCount"(arg0: integer): void
public "performCommand"(arg0: $Level$$Type): boolean
public "sendSystemMessage"(arg0: $Component$$Type): void
public "alwaysAccepts"(): boolean
get "position"(): $Vec3
get "name"(): $Component
get "valid"(): boolean
get "level"(): $ServerLevel
get "customName"(): $Component
set "customName"(value: $Component$$Type)
set "command"(value: StringJS)
get "command"(): StringJS
set "lastOutput"(value: $Component$$Type)
get "trackOutput"(): boolean
get "lastOutput"(): $Component
get "successCount"(): integer
set "trackOutput"(value: boolean)
set "successCount"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseCommandBlock$$Type = ($BaseCommandBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BaseCommandBlock$$Original = $BaseCommandBlock;}
declare module "net.minecraft.world.level.material.MapColor$Brightness" {
import {$Enum} from "java.lang.Enum"

export class $MapColor$Brightness extends $Enum<($MapColor$Brightness)> {
static readonly "LOWEST": $MapColor$Brightness
static readonly "HIGH": $MapColor$Brightness
static readonly "LOW": $MapColor$Brightness
readonly "modifier": integer
readonly "id": integer
static readonly "NORMAL": $MapColor$Brightness

public static "values"(): ($MapColor$Brightness)[]
public static "valueOf"(arg0: StringJS): $MapColor$Brightness
public static "byIdUnsafe"(arg0: integer): $MapColor$Brightness
public static "byId"(arg0: integer): $MapColor$Brightness
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapColor$Brightness$$Type = (("low") | ("normal") | ("high") | ("lowest"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapColor$Brightness$$Original = $MapColor$Brightness;}
declare module "net.minecraft.world.level.storage.LevelDataAndDimensions" {
import {$WorldData, $WorldData$$Type} from "net.minecraft.world.level.storage.WorldData"
import {$WorldDimensions$Complete, $WorldDimensions$Complete$$Type} from "net.minecraft.world.level.levelgen.WorldDimensions$Complete"
import {$Record} from "java.lang.Record"

export class $LevelDataAndDimensions extends $Record {
constructor(arg0: $WorldData$$Type, arg1: $WorldDimensions$Complete$$Type)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "dimensions"(): $WorldDimensions$Complete
public "worldData"(): $WorldData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelDataAndDimensions$$Type = ({"dimensions"?: $WorldDimensions$Complete$$Type, "worldData"?: $WorldData$$Type}) | ([dimensions?: $WorldDimensions$Complete$$Type, worldData?: $WorldData$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelDataAndDimensions$$Original = $LevelDataAndDimensions;}
declare module "net.minecraft.world.level.block.entity.BedBlockEntity" {
import {$DyeColor, $DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Level} from "net.minecraft.world.level.Level"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BedBlockEntity extends $BlockEntity {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)
constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: $DyeColor$$Type)

public "setColor"(arg0: $DyeColor$$Type): void
public "getUpdatePacket"(): $Packet
public "getColor"(): $DyeColor
set "color"(value: $DyeColor$$Type)
get "updatePacket"(): $Packet
get "color"(): $DyeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BedBlockEntity$$Type = ($BedBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BedBlockEntity$$Original = $BedBlockEntity;}
declare module "net.minecraft.world.level.saveddata.SavedData$Factory" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$DataFixTypes, $DataFixTypes$$Type} from "net.minecraft.util.datafix.DataFixTypes"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$SavedData} from "net.minecraft.world.level.saveddata.SavedData"
import {$HolderLookup$Provider, $HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$Record} from "java.lang.Record"

export class $SavedData$Factory<T extends $SavedData> extends $Record {
constructor(arg0: $Supplier$$Type<(T)>, arg1: $BiFunction$$Type<($CompoundTag), ($HolderLookup$Provider), (T)>)
constructor(arg0: $Supplier$$Type<(T)>, deserializer: $BiFunction$$Type<($CompoundTag), ($HolderLookup$Provider), (T)>, type: $DataFixTypes$$Type)

public "type"(): $DataFixTypes
public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "constructor"(): $Supplier<(T)>
public "deserializer"(): $BiFunction<($CompoundTag), ($HolderLookup$Provider), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SavedData$Factory$$Type<T> = ({"constructor"?: $Supplier$$Type<(T)>, "deserializer"?: $BiFunction$$Type<($CompoundTag$$Type), ($HolderLookup$Provider$$Type), (T)>, "type"?: $DataFixTypes$$Type}) | ([arg?: $Supplier$$Type<(T)>, deserializer?: $BiFunction$$Type<($CompoundTag$$Type), ($HolderLookup$Provider$$Type), (T)>, type?: $DataFixTypes$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SavedData$Factory$$Original<T> = $SavedData$Factory<(T)>;}
declare module "net.minecraft.world.level.block.state.properties.DripstoneThickness" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $DripstoneThickness extends $Enum<($DripstoneThickness)> implements $StringRepresentable$$Interface {
static readonly "TIP_MERGE": $DripstoneThickness
static readonly "FRUSTUM": $DripstoneThickness
static readonly "TIP": $DripstoneThickness
static readonly "MIDDLE": $DripstoneThickness
static readonly "BASE": $DripstoneThickness

public "toString"(): StringJS
public static "values"(): ($DripstoneThickness)[]
public static "valueOf"(arg0: StringJS): $DripstoneThickness
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DripstoneThickness$$Type = (("tip_merge") | ("tip") | ("frustum") | ("middle") | ("base"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DripstoneThickness$$Original = $DripstoneThickness;}
declare module "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Pair, $Pair$$Type} from "com.mojang.datafixers.util.Pair"
import {$StructureTemplatePool$Projection$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool$Projection"
import {$Function$$Type} from "java.util.function.Function"
import {$List, $List$$Type} from "java.util.List"
import {$StructurePoolElement, $StructurePoolElement$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElement"
import {$StructureTemplateManager$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ObjectArrayList} from "it.unimi.dsi.fastutil.objects.ObjectArrayList"

export class $StructureTemplatePool {
static readonly "CODEC": $Codec<($Holder<($StructureTemplatePool)>)>
 "rawTemplates": $List<($Pair<($StructurePoolElement), (integer)>)>
readonly "templates": $ObjectArrayList<($StructurePoolElement)>
static readonly "DIRECT_CODEC": $Codec<($StructureTemplatePool)>

constructor(arg0: $Holder$$Type<($StructureTemplatePool)>, arg1: $List$$Type<($Pair$$Type<($StructurePoolElement$$Type), (integer)>)>)
constructor(arg0: $Holder$$Type<($StructureTemplatePool)>, arg1: $List$$Type<($Pair$$Type<($Function$$Type<($StructureTemplatePool$Projection$$Type), ($StructurePoolElement$$Type)>), (integer)>)>, arg2: $StructureTemplatePool$Projection$$Type)

public "size"(): integer
public "getShuffledTemplates"(arg0: $RandomSource$$Type): $List<($StructurePoolElement)>
public "getMaxSize"(arg0: $StructureTemplateManager$$Type): integer
public "getFallback"(): $Holder<($StructureTemplatePool)>
public "getRandomTemplate"(arg0: $RandomSource$$Type): $StructurePoolElement
get "fallback"(): $Holder<($StructureTemplatePool)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.WorldgenTemplatePool
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.WorldgenTemplatePoolTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureTemplatePool$$Type = (Special.WorldgenTemplatePool);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureTemplatePool$$Original = $StructureTemplatePool;}
declare module "net.minecraft.world.level.entity.EntityTickList" {
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $EntityTickList {
constructor()

public "remove"(arg0: $Entity$$Type): void
public "add"(arg0: $Entity$$Type): void
public "contains"(arg0: $Entity$$Type): boolean
public "forEach"(arg0: $Consumer$$Type<($Entity)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityTickList$$Type = ($EntityTickList);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityTickList$$Original = $EntityTickList;}
declare module "net.minecraft.world.level.storage.LevelSummary$BackupStatus" {
import {$Enum} from "java.lang.Enum"

export class $LevelSummary$BackupStatus extends $Enum<($LevelSummary$BackupStatus)> {
static readonly "UPGRADE_TO_SNAPSHOT": $LevelSummary$BackupStatus
static readonly "DOWNGRADE": $LevelSummary$BackupStatus
static readonly "NONE": $LevelSummary$BackupStatus

public static "values"(): ($LevelSummary$BackupStatus)[]
public static "valueOf"(arg0: StringJS): $LevelSummary$BackupStatus
public "isSevere"(): boolean
public "shouldBackup"(): boolean
public "getTranslationKey"(): StringJS
get "severe"(): boolean
get "translationKey"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelSummary$BackupStatus$$Type = (("none") | ("downgrade") | ("upgrade_to_snapshot"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelSummary$BackupStatus$$Original = $LevelSummary$BackupStatus;}
declare module "net.minecraft.world.level.levelgen.structure.TerrainAdjustment" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $TerrainAdjustment extends $Enum<($TerrainAdjustment)> implements $StringRepresentable$$Interface {
static readonly "ENCAPSULATE": $TerrainAdjustment
static readonly "CODEC": $Codec<($TerrainAdjustment)>
static readonly "BURY": $TerrainAdjustment
static readonly "NONE": $TerrainAdjustment
static readonly "BEARD_BOX": $TerrainAdjustment
static readonly "BEARD_THIN": $TerrainAdjustment

public static "values"(): ($TerrainAdjustment)[]
public static "valueOf"(arg0: StringJS): $TerrainAdjustment
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TerrainAdjustment$$Type = (("none") | ("bury") | ("beard_thin") | ("beard_box") | ("encapsulate"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TerrainAdjustment$$Original = $TerrainAdjustment;}
declare module "net.minecraft.world.level.levelgen.placement.PlacementModifier" {
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$PlacementModifierType} from "net.minecraft.world.level.levelgen.placement.PlacementModifierType"
import {$Codec} from "com.mojang.serialization.Codec"
import {$PlacementContext$$Type} from "net.minecraft.world.level.levelgen.placement.PlacementContext"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"

export class $PlacementModifier {
static readonly "CODEC": $Codec<($PlacementModifier)>

constructor()

public "type"(): $PlacementModifierType<(never)>
public "getPositions"(arg0: $PlacementContext$$Type, arg1: $RandomSource$$Type, arg2: $BlockPos$$Type): $Stream<($BlockPos)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlacementModifier$$Type = ($PlacementModifier);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlacementModifier$$Original = $PlacementModifier;}
declare module "net.minecraft.world.level.border.WorldBorder" {
import {$List} from "java.util.List"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$WorldBorder$Settings, $WorldBorder$Settings$$Type} from "net.minecraft.world.level.border.WorldBorder$Settings"
import {$Operation$$Type} from "com.llamalad7.mixinextras.injector.wrapoperation.Operation"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BorderStatus} from "net.minecraft.world.level.border.BorderStatus"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$WorldBorder$BorderExtent, $WorldBorder$BorderExtent$$Type} from "net.minecraft.world.level.border.WorldBorder$BorderExtent"
import {$BorderChangeListener, $BorderChangeListener$$Type} from "net.minecraft.world.level.border.BorderChangeListener"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"

export class $WorldBorder {
 "absoluteMaxSize": integer
static readonly "DEFAULT_SETTINGS": $WorldBorder$Settings
static readonly "MAX_SIZE": double
static readonly "MAX_CENTER_COORDINATE": double

constructor()

public "setCenter"(arg0: double, arg1: double): void
public "getMaxX"(): double
public "getMaxZ"(): double
public "getMinX"(): double
public "getMinZ"(): double
public "getSize"(): double
public "tick"(): void
public "setSize"(arg0: double): void
public "getLerpRemainingTime"(): long
public "getCenterZ"(): double
public "getCenterX"(): double
public "isInsideCloseToBorder"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
public "getCollisionShape"(): $VoxelShape
public "setAbsoluteMaxSize"(arg0: integer): void
public "getDistanceToBorder"(arg0: $Entity$$Type): double
public "getDistanceToBorder"(arg0: double, arg1: double): double
public "getDamagePerBlock"(): double
public "getDamageSafeZone"(): double
public "getStatus"(): $BorderStatus
public "setDamageSafeZone"(arg0: double): void
public "getLerpTarget"(): double
public "createSettings"(): $WorldBorder$Settings
public "setDamagePerBlock"(arg0: double): void
public "applySettings"(arg0: $WorldBorder$Settings$$Type): void
public "getLerpSpeed"(): double
public "setWarningBlocks"(arg0: integer): void
public "lerpSizeBetween"(arg0: double, arg1: double, arg2: long): void
public "getWarningTime"(): integer
public "setWarningTime"(arg0: integer): void
public "getWarningBlocks"(): integer
public "getAbsoluteMaxSize"(): integer
public "removeListener"(arg0: $BorderChangeListener$$Type): void
public "getListeners"(): $List<($BorderChangeListener)>
public "addListener"(arg0: $BorderChangeListener$$Type): void
public "isWithinBounds"(arg0: $Vec3$$Type): boolean
public "isWithinBounds"(arg0: $BlockPos$$Type): boolean
public "isWithinBounds"(arg0: double, arg1: double, arg2: double): boolean
public "isWithinBounds"(arg0: double, arg1: double): boolean
public "isWithinBounds"(arg0: $AABB$$Type): boolean
public "isWithinBounds"(arg0: $ChunkPos$$Type): boolean
public "wrapOperation$cad000$lithium$getUpdatedArea"(arg0: $WorldBorder$BorderExtent$$Type, arg1: $Operation$$Type): $WorldBorder$BorderExtent
public "clampToBounds"(arg0: double, arg1: double, arg2: double): $BlockPos
public "clampToBounds"(arg0: $Vec3$$Type): $BlockPos
public "clampToBounds"(arg0: $BlockPos$$Type): $BlockPos
get "maxX"(): double
get "maxZ"(): double
get "minX"(): double
get "minZ"(): double
get "size"(): double
set "size"(value: double)
get "lerpRemainingTime"(): long
get "centerZ"(): double
get "centerX"(): double
get "collisionShape"(): $VoxelShape
get "damagePerBlock"(): double
get "damageSafeZone"(): double
get "status"(): $BorderStatus
set "damageSafeZone"(value: double)
get "lerpTarget"(): double
set "damagePerBlock"(value: double)
get "lerpSpeed"(): double
set "warningBlocks"(value: integer)
get "warningTime"(): integer
set "warningTime"(value: integer)
get "warningBlocks"(): integer
get "listeners"(): $List<($BorderChangeListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldBorder$$Type = ($WorldBorder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WorldBorder$$Original = $WorldBorder;}
declare module "net.minecraft.world.level.block.entity.trialspawner.TrialSpawner" {
import {$TrialSpawnerState, $TrialSpawnerState$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerState"
import {$Optional} from "java.util.Optional"
import {$UUID} from "java.util.UUID"
import {$TrialSpawnerData, $TrialSpawnerData$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerData"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$TrialSpawner$StateAccessor$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawner$StateAccessor"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$IOwnedSpawner$$Interface} from "net.neoforged.neoforge.common.extensions.IOwnedSpawner"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$Codec} from "com.mojang.serialization.Codec"
import {$PlayerDetector, $PlayerDetector$$Type} from "net.minecraft.world.level.block.entity.trialspawner.PlayerDetector"
import {$Either} from "com.mojang.datafixers.util.Either"
import {$SimpleParticleType$$Type} from "net.minecraft.core.particles.SimpleParticleType"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$TrialSpawnerConfig, $TrialSpawnerConfig$$Type} from "net.minecraft.world.level.block.entity.trialspawner.TrialSpawnerConfig"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$PlayerDetector$EntitySelector, $PlayerDetector$EntitySelector$$Type} from "net.minecraft.world.level.block.entity.trialspawner.PlayerDetector$EntitySelector"

export class $TrialSpawner implements $IOwnedSpawner$$Interface {
static readonly "DETECT_PLAYER_SPAWN_BUFFER": integer
static readonly "NORMAL_CONFIG_TAG_NAME": StringJS
static readonly "OMINOUS_CONFIG_TAG_NAME": StringJS

constructor(arg0: $TrialSpawnerConfig$$Type, arg1: $TrialSpawnerConfig$$Type, arg2: $TrialSpawnerData$$Type, arg3: integer, arg4: integer, arg5: $TrialSpawner$StateAccessor$$Type, arg6: $PlayerDetector$$Type, arg7: $PlayerDetector$EntitySelector$$Type)
constructor(arg0: $TrialSpawner$StateAccessor$$Type, arg1: $PlayerDetector$$Type, arg2: $PlayerDetector$EntitySelector$$Type)

public "getState"(): $TrialSpawnerState
public "setState"(arg0: $Level$$Type, arg1: $TrialSpawnerState$$Type): void
public "getOwner"(): $Either<($BlockEntity), ($Entity)>
public "getData"(): $TrialSpawnerData
public "getNormalConfig"(): $TrialSpawnerConfig
public "getPlayerDetector"(): $PlayerDetector
/**
 * 
 * @deprecated
 */
public "setPlayerDetector"(arg0: $PlayerDetector$$Type): void
public static "addSpawnParticles"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type, arg3: $SimpleParticleType$$Type): void
public "markUpdated"(): void
public "applyOminous"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type): void
public "getEntitySelector"(): $PlayerDetector$EntitySelector
public "isOminous"(): boolean
public "spawnMob"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type): $Optional<($UUID)>
public "tickServer"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: boolean): void
public "tickClient"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: boolean): void
public "getConfig"(): $TrialSpawnerConfig
public "getRequiredPlayerRange"(): integer
public "getTargetCooldownLength"(): integer
public static "addBecomeOminousParticles"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type): void
public static "addEjectItemParticles"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type): void
public static "addDetectPlayerParticles"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $RandomSource$$Type, arg3: integer, arg4: $ParticleOptions$$Type): void
public "codec"(): $Codec<($TrialSpawner)>
public "removeOminous"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type): void
public "getOminousConfig"(): $TrialSpawnerConfig
public "ejectReward"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $ResourceKey$$Type<($LootTable)>): void
public "canSpawnInLevel"(arg0: $Level$$Type): boolean
/**
 * 
 * @deprecated
 */
public "overridePeacefulAndMobSpawnRule"(): void
get "state"(): $TrialSpawnerState
get "owner"(): $Either<($BlockEntity), ($Entity)>
get "data"(): $TrialSpawnerData
get "normalConfig"(): $TrialSpawnerConfig
get "playerDetector"(): $PlayerDetector
set "playerDetector"(value: $PlayerDetector$$Type)
get "entitySelector"(): $PlayerDetector$EntitySelector
get "ominous"(): boolean
get "config"(): $TrialSpawnerConfig
get "requiredPlayerRange"(): integer
get "targetCooldownLength"(): integer
get "ominousConfig"(): $TrialSpawnerConfig
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrialSpawner$$Type = ($TrialSpawner);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrialSpawner$$Original = $TrialSpawner;}
declare module "net.minecraft.world.level.storage.CommandStorage" {
import {$DimensionDataStorage$$Type} from "net.minecraft.world.level.storage.DimensionDataStorage"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Stream} from "java.util.stream.Stream"

export class $CommandStorage {
constructor(arg0: $DimensionDataStorage$$Type)

public "get"(arg0: $ResourceLocation$$Type): $CompoundTag
public "set"(arg0: $ResourceLocation$$Type, arg1: $CompoundTag$$Type): void
public "keys"(): $Stream<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandStorage$$Type = ($CommandStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CommandStorage$$Original = $CommandStorage;}
declare module "net.minecraft.world.level.entity.LevelEntityGetter" {
import {$Iterable} from "java.lang.Iterable"
import {$EntityAccess} from "net.minecraft.world.level.entity.EntityAccess"
import {$UUID$$Type} from "java.util.UUID"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$AbortableIterationConsumer$$Type} from "net.minecraft.util.AbortableIterationConsumer"
import {$Consumer$$Type} from "java.util.function.Consumer"

export interface $LevelEntityGetter$$Interface<T extends $EntityAccess> {
get "all"(): $Iterable<(T)>
}

export class $LevelEntityGetter<T extends $EntityAccess> implements $LevelEntityGetter$$Interface {
 "get"<U extends $EntityAccess>(arg0: $EntityTypeTest$$Type<(T), (U)>, arg1: $AABB$$Type, arg2: $AbortableIterationConsumer$$Type<(U)>): void
 "get"(arg0: $AABB$$Type, arg1: $Consumer$$Type<(T)>): void
 "get"<U extends $EntityAccess>(arg0: $EntityTypeTest$$Type<(T), (U)>, arg1: $AbortableIterationConsumer$$Type<(U)>): void
 "get"(arg0: $UUID$$Type): T
 "get"(arg0: integer): T
 "getAll"(): $Iterable<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelEntityGetter$$Type<T> = ($LevelEntityGetter<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelEntityGetter$$Original<T> = $LevelEntityGetter<(T)>;}
declare module "net.minecraft.world.level.storage.loot.providers.number.LootNumberProviderType" {
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$NumberProvider, $NumberProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.number.NumberProvider"
import {$Record} from "java.lang.Record"

export class $LootNumberProviderType extends $Record {
constructor(arg0: $MapCodec$$Type<($NumberProvider$$Type)>)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "codec"(): $MapCodec<($NumberProvider)>
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.LootNumberProviderType
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.LootNumberProviderTypeTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootNumberProviderType$$Type = (Special.LootNumberProviderType) | ({"codec"?: $MapCodec$$Type<($NumberProvider$$Type)>}) | ([codec?: $MapCodec$$Type<($NumberProvider$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootNumberProviderType$$Original = $LootNumberProviderType;}
declare module "net.minecraft.world.level.ClipBlockStateContext" {
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ClipBlockStateContext {
constructor(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $Predicate$$Type<($BlockState)>)

public "getFrom"(): $Vec3
public "getTo"(): $Vec3
public "isTargetBlock"(): $Predicate<($BlockState)>
get "from"(): $Vec3
get "to"(): $Vec3
get "targetBlock"(): $Predicate<($BlockState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClipBlockStateContext$$Type = ($ClipBlockStateContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClipBlockStateContext$$Original = $ClipBlockStateContext;}
declare module "net.minecraft.world.level.EntityGetter" {
import {$Iterable} from "java.lang.Iterable"
import {$UUID$$Type} from "java.util.UUID"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$List, $List$$Type} from "java.util.List"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$Class$$Type} from "java.lang.Class"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$TargetingConditions$$Type} from "net.minecraft.world.entity.ai.targeting.TargetingConditions"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntityGetterKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityGetterKJS"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

export interface $EntityGetter$$Interface extends $EntityGetterKJS$$Interface {
get "mcEntities"(): $Iterable<($Entity)>
get "players"(): $EntityArrayList
get "mcPlayers"(): $List<($Player)>
get "entities"(): $EntityArrayList
}

export class $EntityGetter implements $EntityGetter$$Interface {
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($Entity)>
 "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type, arg2: $Predicate$$Type<($Entity)>): $List<($Entity)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type): $List<(T)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "hasNearbyAlivePlayer"(arg0: double, arg1: double, arg2: double, arg3: double): boolean
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: double, arg2: double, arg3: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: double, arg3: double, arg4: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: $Predicate$$Type<($Entity)>): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): $Player
 "getNearestPlayer"(arg0: $Entity$$Type, arg1: double): $Player
 "getNearestEntity"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double, arg6: $AABB$$Type): T
 "getNearestEntity"<T extends $LivingEntity>(arg0: $List$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double): T
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "getNearbyPlayers"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: $AABB$$Type): $List<($Player)>
 "getNearbyEntities"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: $AABB$$Type): $List<(T)>
 "getPlayerByUUID"(arg0: $UUID$$Type): $Player
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getPlayers"(): $EntityArrayList
 "getMcPlayers"(): $List<($Player)>
 "self"(): $EntityGetter
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntities"(): $EntityArrayList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityGetter$$Type = ($EntityGetter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityGetter$$Original = $EntityGetter;}
declare module "net.minecraft.world.level.levelgen.structure.pools.LegacySinglePoolElement" {
import {$BoundingBox$$Type} from "net.minecraft.world.level.levelgen.structure.BoundingBox"
import {$StructurePoolElementType} from "net.minecraft.world.level.levelgen.structure.pools.StructurePoolElementType"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$LiquidSettings, $LiquidSettings$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSettings"
import {$SinglePoolElement} from "net.minecraft.world.level.levelgen.structure.pools.SinglePoolElement"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$StructureTemplate, $StructureTemplate$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate"
import {$StructurePlaceSettings} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings"
import {$StructureProcessorList, $StructureProcessorList$$Type} from "net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessorList"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$StructureTemplatePool$Projection$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool$Projection"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Either, $Either$$Type} from "com.mojang.datafixers.util.Either"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $LegacySinglePoolElement extends $SinglePoolElement {
readonly "template": $Either<($ResourceLocation), ($StructureTemplate)>
static readonly "CODEC": $MapCodec<($LegacySinglePoolElement)>
readonly "overrideLiquidSettings": $Optional<($LiquidSettings)>
readonly "processors": $Holder<($StructureProcessorList)>

constructor(arg0: $Either$$Type<($ResourceLocation$$Type), ($StructureTemplate$$Type)>, arg1: $Holder$$Type<($StructureProcessorList)>, arg2: $StructureTemplatePool$Projection$$Type, arg3: ($LiquidSettings$$Type)?)

public "toString"(): StringJS
public "getType"(): $StructurePoolElementType<(never)>
public "getSettings"(arg0: $Rotation$$Type, arg1: $BoundingBox$$Type, arg2: $LiquidSettings$$Type, arg3: boolean): $StructurePlaceSettings
get "type"(): $StructurePoolElementType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LegacySinglePoolElement$$Type = ($LegacySinglePoolElement);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LegacySinglePoolElement$$Original = $LegacySinglePoolElement;}
declare module "net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$ConfiguredFeature} from "net.minecraft.world.level.levelgen.feature.ConfiguredFeature"
import {$GeodeLayerSettings, $GeodeLayerSettings$$Type} from "net.minecraft.world.level.levelgen.GeodeLayerSettings"
import {$GeodeCrackSettings, $GeodeCrackSettings$$Type} from "net.minecraft.world.level.levelgen.GeodeCrackSettings"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$GeodeBlockSettings, $GeodeBlockSettings$$Type} from "net.minecraft.world.level.levelgen.GeodeBlockSettings"
import {$Stream} from "java.util.stream.Stream"
import {$FeatureConfiguration$$Interface} from "net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration"

export class $GeodeConfiguration implements $FeatureConfiguration$$Interface {
static readonly "CODEC": $Codec<($GeodeConfiguration)>
readonly "geodeLayerSettings": $GeodeLayerSettings
readonly "useAlternateLayer0Chance": double
readonly "pointOffset": $IntProvider
readonly "minGenOffset": integer
readonly "noiseMultiplier": double
readonly "maxGenOffset": integer
readonly "usePotentialPlacementsChance": double
readonly "geodeBlockSettings": $GeodeBlockSettings
readonly "geodeCrackSettings": $GeodeCrackSettings
readonly "invalidBlocksThreshold": integer
readonly "placementsRequireLayer0Alternate": boolean
static readonly "CHANCE_RANGE": $Codec<(double)>
readonly "distributionPoints": $IntProvider
readonly "outerWallDistance": $IntProvider

constructor(arg0: $GeodeBlockSettings$$Type, arg1: $GeodeLayerSettings$$Type, arg2: $GeodeCrackSettings$$Type, arg3: double, arg4: double, arg5: boolean, arg6: $IntProvider$$Type, arg7: $IntProvider$$Type, arg8: $IntProvider$$Type, arg9: integer, arg10: integer, arg11: double, arg12: integer)

public "getFeatures"(): $Stream<($ConfiguredFeature<(never), (never)>)>
get "features"(): $Stream<($ConfiguredFeature<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeodeConfiguration$$Type = ($GeodeConfiguration);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeodeConfiguration$$Original = $GeodeConfiguration;}
declare module "net.minecraft.world.level.block.state.BlockState" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Optional} from "java.util.Optional"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Mob$$Type} from "net.minecraft.world.entity.Mob"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$ServerPlayer$RespawnPosAngle} from "net.minecraft.server.level.ServerPlayer$RespawnPosAngle"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockBehaviour$BlockStateBase$Cache} from "net.minecraft.world.level.block.state.BlockBehaviour$BlockStateBase$Cache"
import {$ItemAbility$$Type} from "net.neoforged.neoforge.common.ItemAbility"
import {$Map$Entry} from "java.util.Map$Entry"
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function} from "java.util.function.Function"
import {$PathType, $PathType$$Type} from "net.minecraft.world.level.pathfinder.PathType"
import {$UseOnContext$$Type} from "net.minecraft.world.item.context.UseOnContext"
import {$BlockBehaviour$BlockStateBase} from "net.minecraft.world.level.block.state.BlockBehaviour$BlockStateBase"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BubbleColumnDirection} from "net.neoforged.neoforge.common.enums.BubbleColumnDirection"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$TriState} from "net.neoforged.neoforge.common.util.TriState"
import {$SoundType} from "net.minecraft.world.level.block.SoundType"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Reference2ObjectArrayMap$$Type} from "it.unimi.dsi.fastutil.objects.Reference2ObjectArrayMap"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$CallbackInfoReturnable$$Type} from "org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$SignalGetter$$Type} from "net.minecraft.world.level.SignalGetter"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BiConsumer$$Type} from "java.util.function.BiConsumer"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$IBlockStateExtension$$Interface} from "net.neoforged.neoforge.common.extensions.IBlockStateExtension"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $BlockState extends $BlockBehaviour$BlockStateBase implements $IBlockStateExtension$$Interface {
static readonly "PROPERTIES_TAG": StringJS
readonly "owner": O
 "cache": $BlockBehaviour$BlockStateBase$Cache
static readonly "CODEC": $Codec<($BlockState)>
static readonly "PROPERTY_ENTRY_TO_STRING_FUNCTION": $Function<($Map$Entry<($Property<(never)>), ($Comparable<(never)>)>), (StringJS)>
static readonly "NAME_TAG": StringJS
readonly "propertiesCodec": $MapCodec<(S)>

constructor(arg0: $Block$$Type, arg1: $Reference2ObjectArrayMap$$Type<($Property$$Type<(never)>), ($Comparable$$Type<(never)>)>, arg2: $MapCodec$$Type<($BlockState$$Type)>)

public "asState"(): $BlockState
public "isEmpty"(): boolean
public "rotate"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $Rotation$$Type): $BlockState
public "collisionExtendsVertically"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): boolean
public "getCloneItemStack"(arg0: $HitResult$$Type, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: $Player$$Type): $ItemStack
public "canRedstoneConnectTo"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "addRunningEffects"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): boolean
public "onBlockStateChange"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type): void
public "getLightEmission"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): integer
public "addLandingEffects"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $LivingEntity$$Type, arg4: integer): boolean
public "onNeighborChange"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type): void
public "getWeakChanges"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): boolean
public "shouldHideAdjacentFluidFace"(arg0: $Direction$$Type, arg1: $FluidState$$Type): boolean
public "isBed"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $LivingEntity$$Type): boolean
public "shouldCheckWeakPower"(arg0: $SignalGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "hidesNeighborFace"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: $Direction$$Type): boolean
public "getFireSpreadSpeed"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): integer
public "canSustainPlant"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: $BlockState$$Type): $TriState
public "isSlimeBlock"(): boolean
public "getRespawnPosition"(arg0: $EntityType$$Type<(never)>, arg1: $LevelReader$$Type, arg2: $BlockPos$$Type, arg3: float): $Optional<($ServerPlayer$RespawnPosAngle)>
public "isFireSource"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "onBlockExploded"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Explosion$$Type): void
public "canEntityDestroy"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): boolean
public "isFlammable"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "isConduitFrame"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type): boolean
public "ignitedByLava"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): boolean
public "isPortalFrame"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "getFlammability"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type): integer
public "canHarvestBlock"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Player$$Type): boolean
public "isStickyBlock"(): boolean
public "onCaughtFire"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: $LivingEntity$$Type): void
public "getBlockPathType"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Mob$$Type): $PathType
public "canStickTo"(arg0: $BlockState$$Type): boolean
public "isLadder"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $LivingEntity$$Type): boolean
public "getExpDrop"(arg0: $LevelAccessor$$Type, arg1: $BlockPos$$Type, arg2: $BlockEntity$$Type, arg3: $Entity$$Type, arg4: $ItemStack$$Type): integer
public "isBurning"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "isFertile"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type): boolean
public "onTreeGrow"(arg0: $LevelReader$$Type, arg1: $BiConsumer$$Type<($BlockPos), ($BlockState)>, arg2: $RandomSource$$Type, arg3: $BlockPos$$Type, arg4: $TreeConfiguration$$Type): boolean
public "canBeHydrated"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type, arg3: $BlockPos$$Type): boolean
public "getAppearance"(arg0: $BlockAndTintGetter$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: $BlockState$$Type, arg4: $BlockPos$$Type): $BlockState
public "getToolModifiedState"(arg0: $UseOnContext$$Type, arg1: $ItemAbility$$Type, arg2: boolean): $BlockState
public "getStateAtViewpoint"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Vec3$$Type): $BlockState
public "onDestroyedByPushReaction"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Direction$$Type, arg3: $FluidState$$Type): void
public "getEnchantPowerBonus"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): float
public "getBeaconColorMultiplier"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $BlockPos$$Type): integer
public "hasDynamicLightEmission"(): boolean
public "onDestroyedByPlayer"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $Player$$Type, arg3: boolean, arg4: $FluidState$$Type): boolean
public "shouldDisplayFluidOverlay"(arg0: $BlockAndTintGetter$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type): boolean
public "getBubbleColumnDirection"(): $BubbleColumnDirection
public "canDropFromExplosion"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Explosion$$Type): boolean
public "supportsExternalFaceHiding"(): boolean
public "getExplosionResistance"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Explosion$$Type): float
public "getSoundType"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): $SoundType
public "getFriction"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type, arg2: $Entity$$Type): float
public "isScaffolding"(arg0: $LivingEntity$$Type): boolean
public "setBedOccupied"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $LivingEntity$$Type, arg3: boolean): void
public "getBedDirection"(arg0: $LevelReader$$Type, arg1: $BlockPos$$Type): $Direction
public "handler$zdl000$fabric_rendering_fluids_v1$shouldDisplayFluidOverlay"(arg0: $BlockAndTintGetter$$Type, arg1: $BlockPos$$Type, arg2: $FluidState$$Type, arg3: $CallbackInfoReturnable$$Type): void
public "getAdjacentBlockPathType"(arg0: $BlockGetter$$Type, arg1: $BlockPos$$Type, arg2: $Mob$$Type, arg3: $PathType$$Type): $PathType
public static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
get "empty"(): boolean
get "slimeBlock"(): boolean
get "stickyBlock"(): boolean
get "bubbleColumnDirection"(): $BubbleColumnDirection
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockState$$Type = ($Block$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockState$$Original = $BlockState;}
declare module "net.minecraft.world.level.gameevent.vibrations.VibrationSystem$User" {
import {$PositionSource} from "net.minecraft.world.level.gameevent.PositionSource"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$GameEvent, $GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export interface $VibrationSystem$User$$Interface {
get "positionSource"(): $PositionSource
get "listenableEvents"(): $TagKey<($GameEvent)>
get "listenerRadius"(): integer
}

export class $VibrationSystem$User implements $VibrationSystem$User$$Interface {
 "getPositionSource"(): $PositionSource
 "requiresAdjacentChunksToBeTicking"(): boolean
 "canReceiveVibration"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $Holder$$Type<($GameEvent)>, arg3: $GameEvent$Context$$Type): boolean
 "getListenableEvents"(): $TagKey<($GameEvent)>
 "calculateTravelTimeInTicks"(arg0: float): integer
 "canTriggerAvoidVibration"(): boolean
 "getListenerRadius"(): integer
 "isValidVibration"(arg0: $Holder$$Type<($GameEvent)>, arg1: $GameEvent$Context$$Type): boolean
 "onDataChanged"(): void
 "onReceiveVibration"(arg0: $ServerLevel$$Type, arg1: $BlockPos$$Type, arg2: $Holder$$Type<($GameEvent)>, arg3: $Entity$$Type, arg4: $Entity$$Type, arg5: float): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VibrationSystem$User$$Type = ($VibrationSystem$User);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VibrationSystem$User$$Original = $VibrationSystem$User;}
declare module "net.minecraft.world.level.redstone.NeighborUpdater" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $NeighborUpdater$$Interface {
}

export class $NeighborUpdater implements $NeighborUpdater$$Interface {
static readonly "UPDATE_ORDER": ($Direction)[]

 "neighborChanged"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $Block$$Type, arg3: $BlockPos$$Type, arg4: boolean): void
 "neighborChanged"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: $BlockPos$$Type): void
 "shapeUpdate"(arg0: $Direction$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type, arg4: integer, arg5: integer): void
 "updateNeighborsAtExceptFromFacing"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: $Direction$$Type): void
static "executeUpdate"(arg0: $Level$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $Block$$Type, arg4: $BlockPos$$Type, arg5: boolean): void
static "executeShapeUpdate"(arg0: $LevelAccessor$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $BlockPos$$Type, arg4: $BlockPos$$Type, arg5: integer, arg6: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NeighborUpdater$$Type = ($NeighborUpdater);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NeighborUpdater$$Original = $NeighborUpdater;}
declare module "net.minecraft.world.level.block.entity.BannerPattern" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Holder} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $BannerPattern extends $Record {
static readonly "CODEC": $Codec<($Holder<($BannerPattern)>)>
static readonly "DIRECT_CODEC": $Codec<($BannerPattern)>
static readonly "DIRECT_STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($BannerPattern)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($Holder<($BannerPattern)>)>

constructor(arg0: $ResourceLocation$$Type, arg1: StringJS)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "translationKey"(): StringJS
public "assetId"(): $ResourceLocation
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Literal": Special.BannerPattern
/**
 * This field is a type stub generated by ProbeJS and shall not be used in any sense.
 */
 "probejsInternal$$Tag": Special.BannerPatternTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BannerPattern$$Type = (Special.BannerPattern) | ({"assetId"?: $ResourceLocation$$Type, "translationKey"?: StringJS}) | ([assetId?: $ResourceLocation$$Type, translationKey?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BannerPattern$$Original = $BannerPattern;}
declare module "net.minecraft.world.level.block.entity.JigsawBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Level} from "net.minecraft.world.level.Level"
import {$JigsawBlockEntity$JointType, $JigsawBlockEntity$JointType$$Type} from "net.minecraft.world.level.block.entity.JigsawBlockEntity$JointType"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$StructureTemplatePool, $StructureTemplatePool$$Type} from "net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $JigsawBlockEntity extends $BlockEntity {
static readonly "TARGET": StringJS
 "worldPosition": $BlockPos
 "level": $Level
static readonly "FINAL_STATE": StringJS
static readonly "SELECTION_PRIORITY": StringJS
static readonly "POOL": StringJS
static readonly "PLACEMENT_PRIORITY": StringJS
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
static readonly "JOINT": StringJS
 "remove": boolean
static readonly "NAME": StringJS

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "getName"(): $ResourceLocation
public "setName"(arg0: $ResourceLocation$$Type): void
public "getPool"(): $ResourceKey<($StructureTemplatePool)>
public "getTarget"(): $ResourceLocation
public "setTarget"(arg0: $ResourceLocation$$Type): void
public "generate"(arg0: $ServerLevel$$Type, arg1: integer, arg2: boolean): void
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getUpdateTag"(arg0: $HolderLookup$Provider$$Type): $CompoundTag
public "getFinalState"(): StringJS
public "setFinalState"(arg0: StringJS): void
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "getJoint"(): $JigsawBlockEntity$JointType
public "setPool"(arg0: $ResourceKey$$Type<($StructureTemplatePool)>): void
public "setJoint"(arg0: $JigsawBlockEntity$JointType$$Type): void
public "getUpdatePacket"(): $Packet
public "setPlacementPriority"(arg0: integer): void
public "getSelectionPriority"(): integer
public "setSelectionPriority"(arg0: integer): void
public "getPlacementPriority"(): integer
get "name"(): $ResourceLocation
set "name"(value: $ResourceLocation$$Type)
get "pool"(): $ResourceKey<($StructureTemplatePool)>
get "target"(): $ResourceLocation
set "target"(value: $ResourceLocation$$Type)
get "finalState"(): StringJS
set "finalState"(value: StringJS)
get "joint"(): $JigsawBlockEntity$JointType
set "pool"(value: $ResourceKey$$Type<($StructureTemplatePool)>)
set "joint"(value: $JigsawBlockEntity$JointType$$Type)
get "updatePacket"(): $Packet
set "placementPriority"(value: integer)
get "selectionPriority"(): integer
set "selectionPriority"(value: integer)
get "placementPriority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JigsawBlockEntity$$Type = ($JigsawBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JigsawBlockEntity$$Original = $JigsawBlockEntity;}
declare module "net.minecraft.world.level.lighting.ChunkSkyLightSources" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$LevelHeightAccessor$$Type} from "net.minecraft.world.level.LevelHeightAccessor"
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"

export class $ChunkSkyLightSources {
static readonly "NEGATIVE_INFINITY": integer

constructor(arg0: $LevelHeightAccessor$$Type)

public "update"(arg0: $BlockGetter$$Type, arg1: integer, arg2: integer, arg3: integer): boolean
public "fillFrom"(arg0: $ChunkAccess$$Type): void
public "getHighestLowestSourceY"(): integer
public "getLowestSourceY"(arg0: integer, arg1: integer): integer
get "highestLowestSourceY"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkSkyLightSources$$Type = ($ChunkSkyLightSources);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkSkyLightSources$$Original = $ChunkSkyLightSources;}
declare module "net.minecraft.world.level.chunk.UpgradeData$BlockFixer" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor, $LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $UpgradeData$BlockFixer$$Interface {

(arg0: $BlockState, arg1: $Direction, arg2: $BlockState, arg3: $LevelAccessor, arg4: $BlockPos, arg5: $BlockPos): $BlockState$$Type
}

export class $UpgradeData$BlockFixer implements $UpgradeData$BlockFixer$$Interface {
 "processChunk"(arg0: $LevelAccessor$$Type): void
 "updateShape"(arg0: $BlockState$$Type, arg1: $Direction$$Type, arg2: $BlockState$$Type, arg3: $LevelAccessor$$Type, arg4: $BlockPos$$Type, arg5: $BlockPos$$Type): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UpgradeData$BlockFixer$$Type = ((arg0: $BlockState, arg1: $Direction, arg2: $BlockState, arg3: $LevelAccessor, arg4: $BlockPos, arg5: $BlockPos) => $BlockState$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UpgradeData$BlockFixer$$Original = $UpgradeData$BlockFixer;}
declare module "net.minecraft.world.level.levelgen.GeodeCrackSettings" {
import {$Codec} from "com.mojang.serialization.Codec"

export class $GeodeCrackSettings {
static readonly "CODEC": $Codec<($GeodeCrackSettings)>
readonly "generateCrackChance": double
readonly "crackPointOffset": integer
readonly "baseCrackSize": double

constructor(arg0: double, arg1: double, arg2: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeodeCrackSettings$$Type = ($GeodeCrackSettings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeodeCrackSettings$$Original = $GeodeCrackSettings;}
declare module "net.minecraft.world.level.levelgen.DensityFunction$ContextProvider" {
import {$DensityFunction$FunctionContext} from "net.minecraft.world.level.levelgen.DensityFunction$FunctionContext"
import {$DensityFunction$$Type} from "net.minecraft.world.level.levelgen.DensityFunction"

export interface $DensityFunction$ContextProvider$$Interface {
}

export class $DensityFunction$ContextProvider implements $DensityFunction$ContextProvider$$Interface {
 "forIndex"(arg0: integer): $DensityFunction$FunctionContext
 "fillAllDirectly"(arg0: (double)[], arg1: $DensityFunction$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DensityFunction$ContextProvider$$Type = ($DensityFunction$ContextProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DensityFunction$ContextProvider$$Original = $DensityFunction$ContextProvider;}
declare module "net.minecraft.world.level.block.entity.trialspawner.PlayerDetector" {
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$PlayerDetector$EntitySelector, $PlayerDetector$EntitySelector$$Type} from "net.minecraft.world.level.block.entity.trialspawner.PlayerDetector$EntitySelector"

export interface $PlayerDetector$$Interface {

(arg0: $ServerLevel, arg1: $PlayerDetector$EntitySelector, arg2: $BlockPos, arg3: double, arg4: boolean): $List$$Type<($UUID$$Type)>
}

export class $PlayerDetector implements $PlayerDetector$$Interface {
static readonly "INCLUDING_CREATIVE_PLAYERS": $PlayerDetector
static readonly "NO_CREATIVE_PLAYERS": $PlayerDetector
static readonly "SHEEP": $PlayerDetector

 "detect"(arg0: $ServerLevel$$Type, arg1: $PlayerDetector$EntitySelector$$Type, arg2: $BlockPos$$Type, arg3: double, arg4: boolean): $List<($UUID)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerDetector$$Type = ((arg0: $ServerLevel, arg1: $PlayerDetector$EntitySelector, arg2: $BlockPos, arg3: double, arg4: boolean) => $List$$Type<($UUID$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerDetector$$Original = $PlayerDetector;}
declare module "net.minecraft.world.level.saveddata.maps.MapId" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$Record} from "java.lang.Record"

export class $MapId extends $Record {
static readonly "CODEC": $Codec<($MapId)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($MapId)>

constructor(arg0: integer)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): integer
public "key"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapId$$Type = ({"id"?: integer}) | ([id?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MapId$$Original = $MapId;}
declare module "net.minecraft.world.level.block.entity.CommandBlockEntity" {
import {$BlockEntity$DataComponentInput$$Type} from "net.minecraft.world.level.block.entity.BlockEntity$DataComponentInput"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BaseCommandBlock} from "net.minecraft.world.level.BaseCommandBlock"
import {$Level} from "net.minecraft.world.level.Level"
import {$CommandBlockEntity$Mode} from "net.minecraft.world.level.block.entity.CommandBlockEntity$Mode"
import {$DataComponentMap$Builder$$Type} from "net.minecraft.core.component.DataComponentMap$Builder"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CommandBlockEntity extends $BlockEntity {
 "worldPosition": $BlockPos
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "hasComparators": byte
 "remove": boolean

constructor(arg0: $BlockPos$$Type, arg1: $BlockState$$Type)

public "isAutomatic"(): boolean
public "saveAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "onlyOpCanSetNbt"(): boolean
public "getMode"(): $CommandBlockEntity$Mode
public "loadAdditional"(arg0: $CompoundTag$$Type, arg1: $HolderLookup$Provider$$Type): void
public "onModeSwitch"(): void
public "removeComponentsFromTag"(arg0: $CompoundTag$$Type): void
public "isPowered"(): boolean
public "setPowered"(arg0: boolean): void
public "getCommandBlock"(): $BaseCommandBlock
public "isConditional"(): boolean
public "wasConditionMet"(): boolean
public "setAutomatic"(arg0: boolean): void
public "markConditionMet"(): boolean
public "collectImplicitComponents"(arg0: $DataComponentMap$Builder$$Type): void
public "applyImplicitComponents"(arg0: $BlockEntity$DataComponentInput$$Type): void
get "automatic"(): boolean
get "mode"(): $CommandBlockEntity$Mode
get "powered"(): boolean
set "powered"(value: boolean)
get "commandBlock"(): $BaseCommandBlock
get "conditional"(): boolean
set "automatic"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandBlockEntity$$Type = ($CommandBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CommandBlockEntity$$Original = $CommandBlockEntity;}
declare module "net.minecraft.world.level.levelgen.feature.foliageplacers.MegaPineFoliagePlacer" {
import {$FoliagePlacerType} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacerType"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$FoliagePlacer$FoliageSetter$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageSetter"
import {$FoliagePlacer} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer"
import {$IntProvider, $IntProvider$$Type} from "net.minecraft.util.valueproviders.IntProvider"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$LevelSimulatedReader$$Type} from "net.minecraft.world.level.LevelSimulatedReader"
import {$FoliagePlacer$FoliageAttachment$$Type} from "net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer$FoliageAttachment"
import {$TreeConfiguration$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration"

export class $MegaPineFoliagePlacer extends $FoliagePlacer {
static readonly "CODEC": $MapCodec<($MegaPineFoliagePlacer)>
readonly "offset": $IntProvider
readonly "radius": $IntProvider

constructor(arg0: $IntProvider$$Type, arg1: $IntProvider$$Type, arg2: $IntProvider$$Type)

public "type"(): $FoliagePlacerType<(never)>
public "createFoliage"(arg0: $LevelSimulatedReader$$Type, arg1: $FoliagePlacer$FoliageSetter$$Type, arg2: $RandomSource$$Type, arg3: $TreeConfiguration$$Type, arg4: integer, arg5: $FoliagePlacer$FoliageAttachment$$Type, arg6: integer, arg7: integer, arg8: integer): void
public "shouldSkipLocation"(arg0: $RandomSource$$Type, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: boolean): boolean
public "foliageHeight"(arg0: $RandomSource$$Type, arg1: integer, arg2: $TreeConfiguration$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MegaPineFoliagePlacer$$Type = ($MegaPineFoliagePlacer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MegaPineFoliagePlacer$$Original = $MegaPineFoliagePlacer;}
declare module "net.minecraft.world.level.block.state.properties.BedPart" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $BedPart extends $Enum<($BedPart)> implements $StringRepresentable$$Interface {
static readonly "HEAD": $BedPart
static readonly "FOOT": $BedPart

public "toString"(): StringJS
public static "values"(): ($BedPart)[]
public static "valueOf"(arg0: StringJS): $BedPart
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BedPart$$Type = (("head") | ("foot"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BedPart$$Original = $BedPart;}
declare module "net.minecraft.world.level.levelgen.structure.StructureSet$StructureSelectionEntry" {
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure, $Structure$$Type} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$Record} from "java.lang.Record"

export class $StructureSet$StructureSelectionEntry extends $Record {
static readonly "CODEC": $Codec<($StructureSet$StructureSelectionEntry)>

constructor(arg0: $Holder$$Type<($Structure)>, arg1: integer)

public "equals"(arg0: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "weight"(): integer
public "structure"(): $Holder<($Structure)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructureSet$StructureSelectionEntry$$Type = ({"weight"?: integer, "structure"?: $Holder$$Type<($Structure)>}) | ([weight?: integer, structure?: $Holder$$Type<($Structure)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StructureSet$StructureSelectionEntry$$Original = $StructureSet$StructureSelectionEntry;}
declare module "net.minecraft.world.level.SignalGetter" {
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Holder} from "net.minecraft.core.Holder"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Stream} from "java.util.stream.Stream"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter$$Interface} from "net.minecraft.world.level.BlockGetter"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"

export interface $SignalGetter$$Interface extends $BlockGetter$$Interface {
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "maxSection"(): integer
get "minSection"(): integer
get "sectionsCount"(): integer
get "height"(): integer
get "minBuildHeight"(): integer
}

export class $SignalGetter implements $SignalGetter$$Interface {
static readonly "DIRECTIONS": ($Direction)[]

 "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
 "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
 "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
 "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
 "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
 "getMaxLightLevel"(): integer
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getMaxBuildHeight"(): integer
 "getSectionIndex"(arg0: integer): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionsCount"(): integer
 "getHeight"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getMinBuildHeight"(): integer
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
 "getBlockEntityRenderData"(arg0: $BlockPos$$Type): any
 "hasBiomes"(): boolean
 "getBiomeFabric"(arg0: $BlockPos$$Type): $Holder<($Biome)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignalGetter$$Type = ($SignalGetter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SignalGetter$$Original = $SignalGetter;}
declare module "net.minecraft.world.level.ClipContext$Block" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Enum} from "java.lang.Enum"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$ClipContext$ShapeGetter$$Interface} from "net.minecraft.world.level.ClipContext$ShapeGetter"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $ClipContext$Block extends $Enum<($ClipContext$Block)> implements $ClipContext$ShapeGetter$$Interface {
static readonly "COLLIDER": $ClipContext$Block
static readonly "FALLDAMAGE_RESETTING": $ClipContext$Block
static readonly "OUTLINE": $ClipContext$Block
static readonly "VISUAL": $ClipContext$Block

public "get"(arg0: $BlockState$$Type, arg1: $BlockGetter$$Type, arg2: $BlockPos$$Type, arg3: $CollisionContext$$Type): $VoxelShape
public static "values"(): ($ClipContext$Block)[]
public static "valueOf"(arg0: StringJS): $ClipContext$Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClipContext$Block$$Type = (("collider") | ("outline") | ("visual") | ("falldamage_resetting"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClipContext$Block$$Original = $ClipContext$Block;}
declare module "net.minecraft.world.level.block.Portal" {
import {$DimensionTransition, $DimensionTransition$$Type} from "net.minecraft.world.level.portal.DimensionTransition"
import {$Portal$Transition} from "net.minecraft.world.level.block.Portal$Transition"
import {$ServerLevel, $ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"

export interface $Portal$$Interface {

(arg0: $ServerLevel, arg1: $Entity, arg2: $BlockPos): $DimensionTransition$$Type
get "localTransition"(): $Portal$Transition
}

export class $Portal implements $Portal$$Interface {
 "getPortalDestination"(arg0: $ServerLevel$$Type, arg1: $Entity$$Type, arg2: $BlockPos$$Type): $DimensionTransition
 "getPortalTransitionTime"(arg0: $ServerLevel$$Type, arg1: $Entity$$Type): integer
 "getLocalTransition"(): $Portal$Transition
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Portal$$Type = ((arg0: $ServerLevel, arg1: $Entity, arg2: $BlockPos) => $DimensionTransition$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Portal$$Original = $Portal;}
declare module "net.minecraft.world.level.block.entity.BlockEntityTicker" {
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity, $BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockEntityTicker$$Interface<T extends $BlockEntity> {

(arg0: $Level, arg1: $BlockPos, arg2: $BlockState, arg3: T): void
}

export class $BlockEntityTicker<T extends $BlockEntity> implements $BlockEntityTicker$$Interface {
 "tick"(arg0: $Level$$Type, arg1: $BlockPos$$Type, arg2: $BlockState$$Type, arg3: T): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityTicker$$Type<T> = ((arg0: $Level, arg1: $BlockPos, arg2: $BlockState, arg3: T) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityTicker$$Original<T> = $BlockEntityTicker<(T)>;}
declare module "net.minecraft.world.level.chunk.ChunkSource" {
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$AutoCloseable$$Interface} from "java.lang.AutoCloseable"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$LightChunkGetter$$Interface} from "net.minecraft.world.level.chunk.LightChunkGetter"
import {$BooleanSupplier$$Type} from "java.util.function.BooleanSupplier"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$LightChunk} from "net.minecraft.world.level.chunk.LightChunk"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$SectionPos$$Type} from "net.minecraft.core.SectionPos"
import {$LevelChunk} from "net.minecraft.world.level.chunk.LevelChunk"

export class $ChunkSource implements $LightChunkGetter$$Interface, $AutoCloseable$$Interface {
constructor()

public "close"(): void
public "tick"(arg0: $BooleanSupplier$$Type, arg1: boolean): void
public "getChunkNow"(arg0: integer, arg1: integer): $LevelChunk
public "updateChunkForced"(arg0: $ChunkPos$$Type, arg1: boolean): void
public "getLightEngine"(): $LevelLightEngine
public "setSpawnSettings"(arg0: boolean, arg1: boolean): void
public "gatherStats"(): StringJS
public "getChunkForLighting"(arg0: integer, arg1: integer): $LightChunk
public "getChunk"(arg0: integer, arg1: integer, arg2: boolean): $LevelChunk
public "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
public "getLoadedChunksCount"(): integer
public "hasChunk"(arg0: integer, arg1: integer): boolean
public "getLevel"(): $BlockGetter
public "onLightUpdate"(arg0: $LightLayer$$Type, arg1: $SectionPos$$Type): void
get "lightEngine"(): $LevelLightEngine
get "loadedChunksCount"(): integer
get "level"(): $BlockGetter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkSource$$Type = ($ChunkSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChunkSource$$Original = $ChunkSource;}
declare module "net.minecraft.world.level.entity.TransientEntitySectionManager" {
import {$EntitySectionStorage} from "net.minecraft.world.level.entity.EntitySectionStorage"
import {$TransientEntitySectionManagerAccessor$$Interface} from "net.caffeinemc.mods.lithium.mixin.util.accessors.TransientEntitySectionManagerAccessor"
import {$EntityAccess, $EntityAccess$$Type} from "net.minecraft.world.level.entity.EntityAccess"
import {$EntitySection$$Type} from "net.minecraft.world.level.entity.EntitySection"
import {$Class$$Type} from "java.lang.Class"
import {$EntityLookup} from "net.minecraft.world.level.entity.EntityLookup"
import {$LevelEntityGetter} from "net.minecraft.world.level.entity.LevelEntityGetter"
import {$LevelCallback, $LevelCallback$$Type} from "net.minecraft.world.level.entity.LevelCallback"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Logger} from "org.slf4j.Logger"

export class $TransientEntitySectionManager<T extends $EntityAccess> implements $TransientEntitySectionManagerAccessor$$Interface {
readonly "entityStorage": $EntityLookup<(T)>
readonly "callbacks": $LevelCallback<(T)>
static readonly "LOGGER": $Logger
readonly "sectionStorage": $EntitySectionStorage<(T)>

constructor(arg0: $Class$$Type<(T)>, arg1: $LevelCallback$$Type<(T)>)

public "count"(): integer
public "getCache"(): $EntitySectionStorage
public "gatherStats"(): StringJS
public "addEntity"(arg0: T): void
public "stopTicking"(arg0: $ChunkPos$$Type): void
public "startTicking"(arg0: $ChunkPos$$Type): void
public "getEntityGetter"(): $LevelEntityGetter<(T)>
public "removeSectionIfEmpty"(arg0: long, arg1: $EntitySection$$Type<(T)>): void
get "cache"(): $EntitySectionStorage
get "entityGetter"(): $LevelEntityGetter<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TransientEntitySectionManager$$Type<T> = ($TransientEntitySectionManager<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TransientEntitySectionManager$$Original<T> = $TransientEntitySectionManager<(T)>;}
declare module "net.minecraft.world.level.storage.loot.parameters.LootContextParam" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"

export class $LootContextParam<T> {
constructor(arg0: $ResourceLocation$$Type)

public "getName"(): $ResourceLocation
public "toString"(): StringJS
get "name"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootContextParam$$Type<T> = ($LootContextParam<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootContextParam$$Original<T> = $LootContextParam<(T)>;}
declare module "net.minecraft.world.level.storage.loot.ValidationContext" {
import {$HolderGetter$Provider, $HolderGetter$Provider$$Type} from "net.minecraft.core.HolderGetter$Provider"
import {$ProblemReporter, $ProblemReporter$$Type} from "net.minecraft.util.ProblemReporter"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$LootContextUser$$Type} from "net.minecraft.world.level.storage.loot.LootContextUser"
import {$LootContextParamSet$$Type} from "net.minecraft.world.level.storage.loot.parameters.LootContextParamSet"

export class $ValidationContext {
constructor(arg0: $ProblemReporter$$Type, arg1: $LootContextParamSet$$Type)
constructor(arg0: $ProblemReporter$$Type, arg1: $LootContextParamSet$$Type, arg2: $HolderGetter$Provider$$Type)

public "resolver"(): $HolderGetter$Provider
public "reporter"(): $ProblemReporter
public "reportProblem"(arg0: StringJS): void
public "allowsReferences"(): boolean
public "hasVisitedElement"(arg0: $ResourceKey$$Type<(never)>): boolean
public "setParams"(arg0: $LootContextParamSet$$Type): $ValidationContext
public "validateUser"(arg0: $LootContextUser$$Type): void
public "enterElement"(arg0: StringJS, arg1: $ResourceKey$$Type<(never)>): $ValidationContext
public "forChild"(arg0: StringJS): $ValidationContext
set "params"(value: $LootContextParamSet$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ValidationContext$$Type = ($ValidationContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ValidationContext$$Original = $ValidationContext;}
declare module "net.minecraft.world.level.GameRules$VisitorCaller" {
import {$GameRules$Value} from "net.minecraft.world.level.GameRules$Value"
import {$GameRules$Type, $GameRules$Type$$Type} from "net.minecraft.world.level.GameRules$Type"
import {$GameRules$GameRuleTypeVisitor, $GameRules$GameRuleTypeVisitor$$Type} from "net.minecraft.world.level.GameRules$GameRuleTypeVisitor"
import {$GameRules$Key, $GameRules$Key$$Type} from "net.minecraft.world.level.GameRules$Key"

export interface $GameRules$VisitorCaller$$Interface<T extends $GameRules$Value<(object)>> {

(arg0: $GameRules$GameRuleTypeVisitor, arg1: $GameRules$Key<(T)>, arg2: $GameRules$Type<(T)>): void
}

export class $GameRules$VisitorCaller<T extends $GameRules$Value<(object)>> implements $GameRules$VisitorCaller$$Interface {
 "call"(arg0: $GameRules$GameRuleTypeVisitor$$Type, arg1: $GameRules$Key$$Type<(T)>, arg2: $GameRules$Type$$Type<(T)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRules$VisitorCaller$$Type<T> = ((arg0: $GameRules$GameRuleTypeVisitor, arg1: $GameRules$Key<(T)>, arg2: $GameRules$Type<(T)>) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRules$VisitorCaller$$Original<T> = $GameRules$VisitorCaller<(T)>;}
declare module "net.minecraft.world.level.gameevent.EntityPositionSource" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$PositionSource$$Interface} from "net.minecraft.world.level.gameevent.PositionSource"
import {$Optional} from "java.util.Optional"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$PositionSourceType} from "net.minecraft.world.level.gameevent.PositionSourceType"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $EntityPositionSource implements $PositionSource$$Interface {
static readonly "CODEC": $MapCodec<($EntityPositionSource)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($EntityPositionSource)>

constructor(arg0: $Entity$$Type, arg1: float)

public "getPosition"(arg0: $Level$$Type): $Optional<($Vec3)>
public "getType"(): $PositionSourceType<($EntityPositionSource)>
get "type"(): $PositionSourceType<($EntityPositionSource)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityPositionSource$$Type = ($EntityPositionSource);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityPositionSource$$Original = $EntityPositionSource;}
declare module "net.minecraft.world.level.ServerLevelAccessor" {
import {$Iterable} from "java.lang.Iterable"
import {$LevelLightEngine} from "net.minecraft.world.level.lighting.LevelLightEngine"
import {$BlockHitResult} from "net.minecraft.world.phys.BlockHitResult"
import {$LevelHeightAccessor} from "net.minecraft.world.level.LevelHeightAccessor"
import {$Optional} from "java.util.Optional"
import {$ChunkAccess} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ColorResolver$$Type} from "net.minecraft.world.level.ColorResolver"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$SoundSource$$Type} from "net.minecraft.sounds.SoundSource"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$CollisionContext$$Type} from "net.minecraft.world.phys.shapes.CollisionContext"
import {$EntityTypeTest$$Type} from "net.minecraft.world.level.entity.EntityTypeTest"
import {$Biome} from "net.minecraft.world.level.biome.Biome"
import {$Stream} from "java.util.stream.Stream"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BiomeManager} from "net.minecraft.world.level.biome.BiomeManager"
import {$AuxiliaryLightManager} from "net.neoforged.neoforge.common.world.AuxiliaryLightManager"
import {$Difficulty} from "net.minecraft.world.Difficulty"
import {$ChunkStatus$$Type} from "net.minecraft.world.level.chunk.status.ChunkStatus"
import {$LevelData} from "net.minecraft.world.level.storage.LevelData"
import {$BiFunction$$Type} from "java.util.function.BiFunction"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$VoxelShape, $VoxelShape$$Type} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$Holder$Reference} from "net.minecraft.core.Holder$Reference"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$ClipContext$$Type} from "net.minecraft.world.level.ClipContext"
import {$FluidState, $FluidState$$Type} from "net.minecraft.world.level.material.FluidState"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$LevelAccessor$$Interface} from "net.minecraft.world.level.LevelAccessor"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"
import {$FeatureFlagSet} from "net.minecraft.world.flag.FeatureFlagSet"
import {$UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$ChunkSource} from "net.minecraft.world.level.chunk.ChunkSource"
import {$WorldBorder} from "net.minecraft.world.level.border.WorldBorder"
import {$TickPriority$$Type} from "net.minecraft.world.ticks.TickPriority"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$Function$$Type} from "java.util.function.Function"
import {$Class$$Type} from "java.lang.Class"
import {$TargetingConditions$$Type} from "net.minecraft.world.entity.ai.targeting.TargetingConditions"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ModelData} from "net.neoforged.neoforge.client.model.data.ModelData"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$ClipBlockStateContext$$Type} from "net.minecraft.world.level.ClipBlockStateContext"
import {$HolderLookup} from "net.minecraft.core.HolderLookup"
import {$LightLayer$$Type} from "net.minecraft.world.level.LightLayer"
import {$GameEvent$Context$$Type} from "net.minecraft.world.level.gameevent.GameEvent$Context"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$BlockGetter} from "net.minecraft.world.level.BlockGetter"
import {$LevelTickAccess} from "net.minecraft.world.ticks.LevelTickAccess"
import {$Heightmap$Types$$Type} from "net.minecraft.world.level.levelgen.Heightmap$Types"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$DifficultyInstance} from "net.minecraft.world.DifficultyInstance"
import {$ServerLevel} from "net.minecraft.server.level.ServerLevel"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$DimensionType} from "net.minecraft.world.level.dimension.DimensionType"

export interface $ServerLevelAccessor$$Interface extends $LevelAccessor$$Interface {
get "level"(): $ServerLevel
get "chunkSource"(): $ChunkSource
get "random"(): $RandomSource
get "levelData"(): $LevelData
get "blockTicks"(): $LevelTickAccess<($Block)>
get "fluidTicks"(): $LevelTickAccess<($Fluid)>
get "server"(): $MinecraftServer
get "difficulty"(): $Difficulty
get "moonBrightness"(): float
get "moonPhase"(): integer
get "seaLevel"(): integer
get "clientSide"(): boolean
get "skyDarken"(): integer
get "biomeManager"(): $BiomeManager
get "height"(): integer
get "minBuildHeight"(): integer
get "mcEntities"(): $Iterable<($Entity)>
get "players"(): $EntityArrayList
get "mcPlayers"(): $List<($Player)>
get "lightEngine"(): $LevelLightEngine
get "worldBorder"(): $WorldBorder
get "entities"(): $EntityArrayList
get "maxLightLevel"(): integer
get "maxBuildHeight"(): integer
get "maxSection"(): integer
get "minSection"(): integer
get "sectionsCount"(): integer
}

export class $ServerLevelAccessor implements $ServerLevelAccessor$$Interface {
 "getLevel"(): $ServerLevel
 "addFreshEntityWithPassengers"(arg0: $Entity$$Type): void
 "getChunkSource"(): $ChunkSource
 "neighborShapeChanged"(arg0: $Direction$$Type, arg1: $BlockState$$Type, arg2: $BlockPos$$Type, arg3: $BlockPos$$Type, arg4: integer, arg5: integer): void
 "blockUpdated"(arg0: $BlockPos$$Type, arg1: $Block$$Type): void
 "addParticle"(arg0: $ParticleOptions$$Type, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): void
 "nextSubTickCount"(): long
 "getRandom"(): $RandomSource
 "levelEvent"(arg0: $Player$$Type, arg1: integer, arg2: $BlockPos$$Type, arg3: integer): void
 "levelEvent"(arg0: integer, arg1: $BlockPos$$Type, arg2: integer): void
 "dayTime"(): long
 "getLevelData"(): $LevelData
 "getBlockTicks"(): $LevelTickAccess<($Block)>
 "getFluidTicks"(): $LevelTickAccess<($Fluid)>
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Block$$Type, arg2: integer, arg3: $TickPriority$$Type): void
 "scheduleTick"(arg0: $BlockPos$$Type, arg1: $Fluid$$Type, arg2: integer, arg3: $TickPriority$$Type): void
 "getCurrentDifficultyAt"(arg0: $BlockPos$$Type): $DifficultyInstance
 "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $Vec3$$Type): void
 "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $Vec3$$Type, arg2: $GameEvent$Context$$Type): void
 "gameEvent"(arg0: $Entity$$Type, arg1: $Holder$$Type<($GameEvent)>, arg2: $BlockPos$$Type): void
 "gameEvent"(arg0: $Holder$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
 "gameEvent"(arg0: $ResourceKey$$Type<($GameEvent)>, arg1: $BlockPos$$Type, arg2: $GameEvent$Context$$Type): void
 "getServer"(): $MinecraftServer
 "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type, arg4: float, arg5: float): void
 "playSound"(arg0: $Player$$Type, arg1: $BlockPos$$Type, arg2: $SoundEvent$$Type, arg3: $SoundSource$$Type): void
 "getDifficulty"(): $Difficulty
 "hasChunk"(arg0: integer, arg1: integer): boolean
 "getBlockEntity"<T extends $BlockEntity>(arg0: $BlockPos$$Type, arg1: $BlockEntityType$$Type<(T)>): $Optional<(T)>
 "getHeightmapPos"(arg0: $Heightmap$Types$$Type, arg1: $BlockPos$$Type): $BlockPos
 "isUnobstructed"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type): boolean
 "getEntityCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($VoxelShape)>
 "getTimeOfDay"(arg0: float): float
 "getMoonBrightness"(): float
 "getMoonPhase"(): integer
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type): $List<($Entity)>
 "getEntities"<T extends $Entity>(arg0: $EntityTypeTest$$Type<($Entity$$Type), (T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "getEntities"(arg0: $Entity$$Type, arg1: $AABB$$Type, arg2: $Predicate$$Type<($Entity)>): $List<($Entity)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type): $List<(T)>
 "getEntitiesOfClass"<T extends $Entity>(arg0: $Class$$Type<(T)>, arg1: $AABB$$Type, arg2: $Predicate$$Type<(T)>): $List<(T)>
 "hasNearbyAlivePlayer"(arg0: double, arg1: double, arg2: double, arg3: double): boolean
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: double, arg2: double, arg3: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: double, arg3: double, arg4: double): $Player
 "getNearestPlayer"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: $Predicate$$Type<($Entity)>): $Player
 "getNearestPlayer"(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): $Player
 "getNearestPlayer"(arg0: $Entity$$Type, arg1: double): $Player
 "getNearestEntity"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double, arg6: $AABB$$Type): T
 "getNearestEntity"<T extends $LivingEntity>(arg0: $List$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: double, arg4: double, arg5: double): T
 "getNearbyPlayers"(arg0: $TargetingConditions$$Type, arg1: $LivingEntity$$Type, arg2: $AABB$$Type): $List<($Player)>
 "getNearbyEntities"<T extends $LivingEntity>(arg0: $Class$$Type<(T)>, arg1: $TargetingConditions$$Type, arg2: $LivingEntity$$Type, arg3: $AABB$$Type): $List<(T)>
 "getPlayerByUUID"(arg0: $UUID$$Type): $Player
 "getBiome"(arg0: $BlockPos$$Type): $Holder<($Biome)>
 "getBlockStatesIfLoaded"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "registryAccess"(): $RegistryAccess
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: $BlockPos$$Type, arg1: $BlockPos$$Type): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunksAt"(arg0: integer, arg1: integer, arg2: integer, arg3: integer): boolean
 "dimensionType"(): $DimensionType
/**
 * 
 * @deprecated
 */
 "getSeaLevel"(): integer
 "isClientSide"(): boolean
 "getSkyDarken"(): integer
 "lithium$getLoadedChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunkForCollisions"(arg0: integer, arg1: integer): $BlockGetter
 "getUncachedNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "canSeeSkyFromBelowWater"(arg0: $BlockPos$$Type): boolean
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "getMaxLocalRawBrightness"(arg0: $BlockPos$$Type): integer
 "isWaterAt"(arg0: $BlockPos$$Type): boolean
 "hasBiomes"(): boolean
 "enabledFeatures"(): $FeatureFlagSet
 "getPathfindingCostFromLightLevels"(arg0: $BlockPos$$Type): float
 "getBiomeManager"(): $BiomeManager
 "isEmptyBlock"(arg0: $BlockPos$$Type): boolean
 "holderLookup"<T>(arg0: $ResourceKey$$Type<($Registry<(T)>)>): $HolderLookup<(T)>
 "getBlockTint"(arg0: $BlockPos$$Type, arg1: $ColorResolver$$Type): integer
 "getNoiseBiome"(arg0: integer, arg1: integer, arg2: integer): $Holder<($Biome)>
 "getBiomeFabric"(arg0: $BlockPos$$Type): $Holder
 "getChunk"(arg0: $BlockPos$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type): $ChunkAccess
 "getChunk"(arg0: integer, arg1: integer, arg2: $ChunkStatus$$Type, arg3: boolean): $ChunkAccess
 "getHeight"(): integer
 "getHeight"(arg0: $Heightmap$Types$$Type, arg1: integer, arg2: integer): integer
/**
 * 
 * @deprecated
 */
 "getLightLevelDependentMagicValue"(arg0: $BlockPos$$Type): float
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "hasChunkAt"(arg0: $BlockPos$$Type): boolean
 "getMinBuildHeight"(): integer
 "containsAnyLiquid"(arg0: $AABB$$Type): boolean
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getPlayers"(): $EntityArrayList
 "getMcPlayers"(): $List<($Player)>
 "self"(): $EntityGetter
 "getLightEngine"(): $LevelLightEngine
 "canSeeSky"(arg0: $BlockPos$$Type): boolean
 "getShade"(arg0: $Direction$$Type, arg1: boolean): float
 "getBrightness"(arg0: $LightLayer$$Type, arg1: $BlockPos$$Type): integer
 "getRawBrightness"(arg0: $BlockPos$$Type, arg1: integer): integer
 "collidesWithSuffocatingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "findSupportingBlock"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Optional<($BlockPos)>
 "getBlockCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "findFreePosition"(arg0: $Entity$$Type, arg1: $VoxelShape$$Type, arg2: $Vec3$$Type, arg3: double, arg4: double, arg5: double): $Optional<($Vec3)>
 "getWorldBorder"(): $WorldBorder
 "isUnobstructed"(arg0: $BlockState$$Type, arg1: $BlockPos$$Type, arg2: $CollisionContext$$Type): boolean
 "isUnobstructed"(arg0: $Entity$$Type): boolean
 "getCollisions"(arg0: $Entity$$Type, arg1: $AABB$$Type): $Iterable<($VoxelShape)>
 "noCollision"(arg0: $Entity$$Type): boolean
 "noCollision"(arg0: $AABB$$Type): boolean
 "noCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "noBlockCollision"(arg0: $Entity$$Type, arg1: $AABB$$Type): boolean
 "getBestNeighborSignal"(arg0: $BlockPos$$Type): integer
 "getControlInputSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type, arg2: boolean): integer
 "getSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "hasSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): boolean
 "getDirectSignal"(arg0: $BlockPos$$Type, arg1: $Direction$$Type): integer
 "hasNeighborSignal"(arg0: $BlockPos$$Type): boolean
 "getDirectSignalTo"(arg0: $BlockPos$$Type): integer
 "holder"<T>(arg0: $ResourceKey$$Type<(T)>): $Optional<($Holder$Reference<(T)>)>
 "isAreaLoaded"(arg0: $BlockPos$$Type, arg1: integer): boolean
 "holderOrThrow"<T>(arg0: $ResourceKey$$Type<(T)>): $Holder<(T)>
/**
 * 
 * @deprecated
 */
 "getBlockEntityRenderAttachment"(arg0: $BlockPos$$Type): any
 "isStateAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($BlockState)>): boolean
 "isFluidAtPosition"(arg0: $BlockPos$$Type, arg1: $Predicate$$Type<($FluidState)>): boolean
 "removeBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "addFreshEntity"(arg0: $Entity$$Type): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: integer): boolean
 "setBlock"(arg0: $BlockPos$$Type, arg1: $BlockState$$Type, arg2: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type, arg3: integer): boolean
 "destroyBlock"(arg0: $BlockPos$$Type, arg1: boolean, arg2: $Entity$$Type): boolean
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntities"(): $EntityArrayList
 "clipWithInteractionOverride"(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: $BlockPos$$Type, arg3: $VoxelShape$$Type, arg4: $BlockState$$Type): $BlockHitResult
 "getFluidState"(arg0: $BlockPos$$Type): $FluidState
 "getBlockEntity"(arg0: $BlockPos$$Type): $BlockEntity
 "getLightEmission"(arg0: $BlockPos$$Type): integer
 "clip"(arg0: $ClipContext$$Type): $BlockHitResult
 "getBlockState"(arg0: $BlockPos$$Type): $BlockState
 "getBlockFloorHeight"(arg0: $BlockPos$$Type): double
 "getBlockFloorHeight"(arg0: $VoxelShape$$Type, arg1: $Supplier$$Type<($VoxelShape$$Type)>): double
 "getBlockStates"(arg0: $AABB$$Type): $Stream<($BlockState)>
 "isBlockInLine"(arg0: $ClipBlockStateContext$$Type): $BlockHitResult
 "getMaxLightLevel"(): integer
static "traverseBlocks"<T, C>(arg0: $Vec3$$Type, arg1: $Vec3$$Type, arg2: C, arg3: $BiFunction$$Type<(C), ($BlockPos), (T)>, arg4: $Function$$Type<(C), (T)>): T
 "getShade"(arg0: float, arg1: float, arg2: float, arg3: boolean): float
static "create"(arg0: integer, arg1: integer): $LevelHeightAccessor
 "getSectionYFromSectionIndex"(arg0: integer): integer
 "getSectionIndexFromSectionY"(arg0: integer): integer
 "getMaxBuildHeight"(): integer
 "getSectionIndex"(arg0: integer): integer
 "getMaxSection"(): integer
 "getMinSection"(): integer
 "getSectionsCount"(): integer
 "isOutsideBuildHeight"(arg0: $BlockPos$$Type): boolean
 "isOutsideBuildHeight"(arg0: integer): boolean
 "getAuxLightManager"(arg0: $BlockPos$$Type): $AuxiliaryLightManager
 "getAuxLightManager"(arg0: $ChunkPos$$Type): $AuxiliaryLightManager
 "getModelData"(arg0: $BlockPos$$Type): $ModelData
 "getBlockEntityRenderData"(arg0: $BlockPos$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerLevelAccessor$$Type = ($ServerLevelAccessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerLevelAccessor$$Original = $ServerLevelAccessor;}
declare module "net.minecraft.world.level.storage.loot.LootPool$Builder" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$Collection$$Type} from "java.util.Collection"
import {$LootItemFunction$$Type} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction"
import {$LootPoolEntryContainer$$Type} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer"
import {$LootPool, $LootPool$$Type} from "net.minecraft.world.level.storage.loot.LootPool"
import {$LootItemFunction$Builder$$Type} from "net.minecraft.world.level.storage.loot.functions.LootItemFunction$Builder"
import {$NumberProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.number.NumberProvider"
import {$FunctionUserBuilder$$Interface} from "net.minecraft.world.level.storage.loot.functions.FunctionUserBuilder"
import {$FabricLootPoolBuilder$$Interface as $FabricLootPoolBuilder$0$$Interface} from "net.fabricmc.fabric.api.loot.v2.FabricLootPoolBuilder"
import {$FabricLootPoolBuilder$$Interface} from "net.fabricmc.fabric.api.loot.v3.FabricLootPoolBuilder"
import {$LootItemCondition$Builder$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition$Builder"
import {$Function$$Type} from "java.util.function.Function"
import {$LootPoolEntryContainer$Builder$$Type} from "net.minecraft.world.level.storage.loot.entries.LootPoolEntryContainer$Builder"
import {$ConditionUserBuilder$$Interface} from "net.minecraft.world.level.storage.loot.predicates.ConditionUserBuilder"
import {$LootItemCondition$$Type} from "net.minecraft.world.level.storage.loot.predicates.LootItemCondition"

export class $LootPool$Builder implements $FunctionUserBuilder$$Interface<($LootPool$Builder)>, $ConditionUserBuilder$$Interface<($LootPool$Builder)>, $FabricLootPoolBuilder$0$$Interface, $FabricLootPoolBuilder$$Interface {
constructor()

public "name"(arg0: StringJS): $LootPool$Builder
public "add"(arg0: $LootPoolEntryContainer$Builder$$Type<(never)>): $LootPool$Builder
public "apply"(arg0: $LootItemFunction$Builder$$Type): $LootPool$Builder
public "apply"(arg0: $LootItemFunction$$Type): $LootPool$Builder
public "apply"(arg0: $Collection$$Type): $LootPool$Builder
public "with"(arg0: $LootPoolEntryContainer$$Type): $LootPool$Builder
public "with"(arg0: $Collection$$Type): $LootPool$Builder
public "unwrap"(): $LootPool$Builder
public "build"(): $LootPool
public "when"(arg0: $LootItemCondition$Builder$$Type): $LootPool$Builder
public "setBonusRolls"(arg0: $NumberProvider$$Type): $LootPool$Builder
public "setRolls"(arg0: $NumberProvider$$Type): $LootPool$Builder
public "conditionally"(arg0: $LootItemCondition$$Type): $LootPool$Builder
public "conditionally"(arg0: $Collection$$Type): $LootPool$Builder
public "apply"<E>(arg0: (E)[], arg1: $Function$$Type<(E), ($LootItemFunction$Builder$$Type)>): $LootPool$Builder
public "apply"<E>(arg0: $Iterable$$Type<(E)>, arg1: $Function$$Type<(E), ($LootItemFunction$Builder$$Type)>): $LootPool$Builder
public "when"<E>(arg0: $Iterable$$Type<(E)>, arg1: $Function$$Type<(E), ($LootItemCondition$Builder$$Type)>): $LootPool$Builder
/**
 * 
 * @deprecated
 */
public static "copyOf"(arg0: $LootPool$$Type): $LootPool$Builder
set "bonusRolls"(value: $NumberProvider$$Type)
set "rolls"(value: $NumberProvider$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootPool$Builder$$Type = ($LootPool$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LootPool$Builder$$Original = $LootPool$Builder;}
declare module "net.minecraft.world.level.levelgen.blending.BlendingData$HeightConsumer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $BlendingData$HeightConsumer$$Interface {
}

export class $BlendingData$HeightConsumer implements $BlendingData$HeightConsumer$$Interface {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlendingData$HeightConsumer$$Type = ($BlendingData$HeightConsumer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlendingData$HeightConsumer$$Original = $BlendingData$HeightConsumer;}
declare module "net.minecraft.world.level.levelgen.SurfaceSystem" {
import {$BiomeManager$$Type} from "net.minecraft.world.level.biome.BiomeManager"
import {$NoiseChunk$$Type} from "net.minecraft.world.level.levelgen.NoiseChunk"
import {$Optional} from "java.util.Optional"
import {$RandomState$$Type} from "net.minecraft.world.level.levelgen.RandomState"
import {$ChunkAccess$$Type} from "net.minecraft.world.level.chunk.ChunkAccess"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$CarvingContext$$Type} from "net.minecraft.world.level.levelgen.carver.CarvingContext"
import {$SurfaceRules$RuleSource$$Type} from "net.minecraft.world.level.levelgen.SurfaceRules$RuleSource"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$Function$$Type} from "java.util.function.Function"
import {$WorldGenerationContext$$Type} from "net.minecraft.world.level.levelgen.WorldGenerationContext"
import {$PositionalRandomFactory$$Type} from "net.minecraft.world.level.levelgen.PositionalRandomFactory"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $SurfaceSystem {
constructor(arg0: $RandomState$$Type, arg1: $BlockState$$Type, arg2: integer, arg3: $PositionalRandomFactory$$Type)

/**
 * 
 * @deprecated
 */
public "topMaterial"(arg0: $SurfaceRules$RuleSource$$Type, arg1: $CarvingContext$$Type, arg2: $Function$$Type<($BlockPos), ($Holder$$Type<($Biome$$Type)>)>, arg3: $ChunkAccess$$Type, arg4: $NoiseChunk$$Type, arg5: $BlockPos$$Type, arg6: boolean): $Optional<($BlockState)>
public "getBand"(arg0: integer, arg1: integer, arg2: integer): $BlockState
public "buildSurface"(arg0: $RandomState$$Type, arg1: $BiomeManager$$Type, arg2: $Registry$$Type<($Biome$$Type)>, arg3: boolean, arg4: $WorldGenerationContext$$Type, arg5: $ChunkAccess$$Type, arg6: $NoiseChunk$$Type, arg7: $SurfaceRules$RuleSource$$Type): void
public "getSurfaceSecondary"(arg0: integer, arg1: integer): double
public "getSurfaceDepth"(arg0: integer, arg1: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SurfaceSystem$$Type = ($SurfaceSystem);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SurfaceSystem$$Original = $SurfaceSystem;}
declare module "net.minecraft.world.level.levelgen.structure.structures.SwampHutStructure" {
import {$Structure$GenerationContext$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationContext"
import {$Structure$GenerationStub} from "net.minecraft.world.level.levelgen.structure.Structure$GenerationStub"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Structure} from "net.minecraft.world.level.levelgen.structure.Structure"
import {$Optional} from "java.util.Optional"
import {$StructureType} from "net.minecraft.world.level.levelgen.structure.StructureType"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Structure$StructureSettings$$Type} from "net.minecraft.world.level.levelgen.structure.Structure$StructureSettings"

export class $SwampHutStructure extends $Structure {
static readonly "CODEC": $MapCodec<($SwampHutStructure)>
static readonly "DIRECT_CODEC": $Codec<($Structure)>

constructor(arg0: $Structure$StructureSettings$$Type)

public "type"(): $StructureType<(never)>
public "findGenerationPoint"(arg0: $Structure$GenerationContext$$Type): $Optional<($Structure$GenerationStub)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SwampHutStructure$$Type = ($SwampHutStructure);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SwampHutStructure$$Original = $SwampHutStructure;}
declare module "net.minecraft.world.level.storage.PlayerDataStorage" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$LevelStorageSource$LevelStorageAccess$$Type} from "net.minecraft.world.level.storage.LevelStorageSource$LevelStorageAccess"
import {$File} from "java.io.File"
import {$Optional} from "java.util.Optional"
import {$DataFixer, $DataFixer$$Type} from "com.mojang.datafixers.DataFixer"

export class $PlayerDataStorage {
readonly "fixerUpper": $DataFixer

constructor(arg0: $LevelStorageSource$LevelStorageAccess$$Type, arg1: $DataFixer$$Type)

public "load"(arg0: $Player$$Type): $Optional<($CompoundTag)>
public "save"(arg0: $Player$$Type): void
public "getPlayerDir"(): $File
get "playerDir"(): $File
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerDataStorage$$Type = ($PlayerDataStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerDataStorage$$Original = $PlayerDataStorage;}

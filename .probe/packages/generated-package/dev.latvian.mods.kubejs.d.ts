declare module "dev.latvian.mods.kubejs.recipe.RecipeKey" {
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$ComponentRole, $ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$SequencedSet} from "java.util.SequencedSet"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RecipeOptional$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $RecipeKey<T> {
 "excluded": boolean
readonly "codec": $Codec<(T)>
readonly "component": $RecipeComponent<(T)>
readonly "typeInfo": $TypeInfo
readonly "role": $ComponentRole
readonly "names": $SequencedSet<(StringJS)>
readonly "name": StringJS

constructor(component: $RecipeComponent$$Type<(T)>, name: StringJS, role: $ComponentRole$$Type)

public "toString"(): StringJS
public "hashCode"(): integer
public "optional"(): boolean
public "optional"(value: $RecipeOptional$$Type<(T)>): $RecipeKey<(T)>
public "optional"(value: T): $RecipeKey<(T)>
public "alwaysWrite"(): $RecipeKey<(T)>
public "noFunctions"(): $RecipeKey<(T)>
public "defaultOptional"(): $RecipeKey<(T)>
public "toJson"(storage: $RecipeSchemaStorage$$Type, type: $RecipeSchemaType$$Type, ops: $DynamicOps$$Type<($JsonElement$$Type)>): $JsonObject
public "alt"(...names: (StringJS)[]): $RecipeKey<(T)>
public "alt"(name: StringJS): $RecipeKey<(T)>
public "exclude"(): $RecipeKey<(T)>
public "getValidFunctionNames"(): $List<(StringJS)>
public "getPrimaryFunctionName"(): StringJS
public "functionNames"(...names: (StringJS)[]): $RecipeKey<(T)>
public "functionNames"(names: $List$$Type<(StringJS)>): $RecipeKey<(T)>
get "validFunctionNames"(): $List<(StringJS)>
get "primaryFunctionName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeKey$$Type<T> = ($RecipeKey<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeKey$$Original<T> = $RecipeKey<(T)>;}
declare module "dev.latvian.mods.kubejs.event.KubeStartupEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $KubeStartupEvent$$Interface extends $KubeEvent$$Interface {
}

export class $KubeStartupEvent implements $KubeStartupEvent$$Interface {
static readonly "BASIC": $KubeStartupEvent

/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeStartupEvent$$Type = ($KubeStartupEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeStartupEvent$$Original = $KubeStartupEvent;}
declare module "dev.latvian.mods.kubejs.core.SizedIngredientKJS" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$ItemMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ItemMatch"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$IngredientSupplierKJS$$Interface} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$SizedIngredient} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $SizedIngredientKJS$$Interface extends $Replaceable$$Interface, $IngredientSupplierKJS$$Interface, $ItemMatch$$Interface {
}

export class $SizedIngredientKJS implements $SizedIngredientKJS$$Interface {
 "matches"(cx: $RecipeMatchContext$$Type, item: $ItemStack$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $Ingredient$$Type, exact: boolean): boolean
 "kjs$self"(): $SizedIngredient
 "kjs$asIngredient"(): $Ingredient
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "kjs$toFlatJson"(): $JsonElement
 "kjs$toNestedJson"(): $JsonElement
 "matches"(cx: $RecipeMatchContext$$Type, itemLike: $ItemLike$$Type, exact: boolean): boolean
 "matchesAny"(cx: $RecipeMatchContext$$Type, itemLikes: $Iterable$$Type<($ItemLike$$Type)>, exact: boolean): boolean
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SizedIngredientKJS$$Type = ($SizedIngredientKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SizedIngredientKJS$$Original = $SizedIngredientKJS;}
declare module "dev.latvian.mods.kubejs.util.Lazy" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Supplier$$Type, $Supplier$$Interface} from "java.util.function.Supplier"
import {$Class$$Type} from "java.lang.Class"
import {$Duration$$Type} from "java.time.Duration"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $Lazy<T> implements $Supplier$$Interface<(T)> {
public "get"(): T
public static "map"<K, V>(supplier: $Consumer$$Type<($Map<(K), (V)>)>): $Lazy<($Map<(K), (V)>)>
public static "of"<T>(supplier: $Supplier$$Type<(T)>): $Lazy<(T)>
public static "of"<T>(supplier: $Supplier$$Type<(T)>, expires: $Duration$$Type): $Lazy<(T)>
public static "serviceLoader"<T>(type: $Class$$Type<(T)>): $Lazy<(T)>
public static "identityMap"<K, V>(supplier: $Consumer$$Type<($Map<(K), (V)>)>): $Lazy<($Map<(K), (V)>)>
public "forget"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Lazy$$Type<T> = ($Lazy<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Lazy$$Original<T> = $Lazy<(T)>;}
declare module "dev.latvian.mods.kubejs.util.JsonSerializable" {
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"

export interface $JsonSerializable$$Interface {

(): $JsonElement$$Type
}

export class $JsonSerializable implements $JsonSerializable$$Interface {
 "toJson"(): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonSerializable$$Type = (() => $JsonElement$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JsonSerializable$$Original = $JsonSerializable;}
declare module "dev.latvian.mods.kubejs.client.KubeJSKeybinds$TickingKeyEvent" {
import {$LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$KubeJSKeybinds$KubeKey$$Type} from "dev.latvian.mods.kubejs.client.KubeJSKeybinds$KubeKey"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$KubeJSKeybinds$KeyEvent} from "dev.latvian.mods.kubejs.client.KubeJSKeybinds$KeyEvent"

export class $KubeJSKeybinds$TickingKeyEvent extends $KubeJSKeybinds$KeyEvent {
constructor(player: $LocalPlayer$$Type, key: $KubeJSKeybinds$KubeKey$$Type)

public "getTicks"(): integer
public "getEntity"(): $Entity
get "ticks"(): integer
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSKeybinds$TickingKeyEvent$$Type = ($KubeJSKeybinds$TickingKeyEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSKeybinds$TickingKeyEvent$$Original = $KubeJSKeybinds$TickingKeyEvent;}
declare module "dev.latvian.mods.kubejs.core.MinecraftEnvironmentKJS" {
import {$ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScheduledEvents, $ScheduledEvents$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents"
import {$TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$MessageSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"
import {$ScheduledEvents$ScheduledEvent} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $MinecraftEnvironmentKJS$$Interface extends $MessageSenderKJS$$Interface {

(): $ScheduledEvents$$Type
get "scheduledEvents"(): $ScheduledEvents
get "name"(): $Component
get "displayName"(): $Component
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $MinecraftEnvironmentKJS implements $MinecraftEnvironmentKJS$$Interface {
 "schedule"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeating"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getScheduledEvents"(): $ScheduledEvents
 "scheduleInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeatingInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "tell"(message: $Component$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftEnvironmentKJS$$Type = (() => $ScheduledEvents$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MinecraftEnvironmentKJS$$Original = $MinecraftEnvironmentKJS;}
declare module "dev.latvian.mods.kubejs.stages.StageCreationEvent" {
import {$ICancellableEvent$$Interface} from "net.neoforged.bus.api.ICancellableEvent"
import {$PlayerEvent} from "net.neoforged.neoforge.event.entity.player.PlayerEvent"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$Stages, $Stages$$Type} from "dev.latvian.mods.kubejs.stages.Stages"

export class $StageCreationEvent extends $PlayerEvent implements $ICancellableEvent$$Interface {
public "getPlayerStages"(): $Stages
public "setPlayerStages"(s: $Stages$$Type): void
public "isCanceled"(): boolean
public "setCanceled"(arg0: boolean): void
public "getEntity"(): $Entity
get "playerStages"(): $Stages
set "playerStages"(value: $Stages$$Type)
get "canceled"(): boolean
set "canceled"(value: boolean)
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StageCreationEvent$$Type = ($StageCreationEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StageCreationEvent$$Original = $StageCreationEvent;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RegisterSubtypesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$List$$Type} from "java.util.List"
import {$SubtypeInterpreter$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.SubtypeInterpreter"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"

export interface $RegisterSubtypesKubeEvent$$Interface<E, F> extends $KubeEvent$$Interface {
}

export class $RegisterSubtypesKubeEvent<E, F> implements $RegisterSubtypesKubeEvent$$Interface {
 "register"(filter: F, interpreter: $SubtypeInterpreter$$Type): void
 "useComponents"(filter: F): void
 "useComponents"(filter: F, components: $List$$Type<($DataComponentType$$Type<(never)>)>): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterSubtypesKubeEvent$$Type<E, F> = ($RegisterSubtypesKubeEvent<(E), (F)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegisterSubtypesKubeEvent$$Original<E, F> = $RegisterSubtypesKubeEvent<(E), (F)>;}
declare module "dev.latvian.mods.kubejs.script.ConsoleLine" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Collection} from "java.util.Collection"
import {$FriendlyByteBuf} from "net.minecraft.network.FriendlyByteBuf"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Supplier$$Interface} from "java.util.function.Supplier"
import {$List} from "java.util.List"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$ConsoleJS, $ConsoleJS$$Type} from "dev.latvian.mods.kubejs.script.ConsoleJS"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$LogType} from "dev.latvian.mods.kubejs.util.LogType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ConsoleLine implements $Supplier$$Interface<($JsonElement)> {
readonly "console": $ConsoleJS
static readonly "EMPTY_ARRAY": ($ConsoleLine)[]
 "sourceLines": $Collection<($SourceLine)>
 "externalFile": $Path
 "stackTrace": $List<(StringJS)>
 "message": StringJS
 "type": $LogType
static readonly "STREAM_CODEC": $StreamCodec<($FriendlyByteBuf), ($ConsoleLine)>
readonly "timestamp": long
 "group": StringJS

constructor(console: $ConsoleJS$$Type, timestamp: long, message: StringJS)

public "get"(): $JsonElement
public "toString"(): StringJS
public "getText"(): StringJS
public "toJson"(): $JsonObject
public "customData"(key: StringJS, data: $JsonElement$$Type, override: boolean): $ConsoleLine
public "withExternalFile"(path: $Path$$Type): $ConsoleLine
public "withSourceLine"(source: StringJS, line: integer): $ConsoleLine
public "withSourceLine"(sourceLine: $SourceLine$$Type): $ConsoleLine
get "text"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConsoleLine$$Type = ($ConsoleLine);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConsoleLine$$Original = $ConsoleLine;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Group" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Record} from "java.lang.Record"

export class $FluidData$Group extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData$Group)>

constructor(filter: $FluidIngredient$$Type, groupId: $ResourceLocation$$Type, description: $Component$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $FluidIngredient
public "description"(): $Component
public "groupId"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$Group$$Type = ({"description"?: $Component$$Type, "groupId"?: $ResourceLocation$$Type, "filter"?: $FluidIngredient$$Type}) | ([description?: $Component$$Type, groupId?: $ResourceLocation$$Type, filter?: $FluidIngredient$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidData$Group$$Original = $FluidData$Group;}
declare module "dev.latvian.mods.kubejs.item.ArmorMaterialBuilder" {
import {$ArmorMaterial} from "net.minecraft.world.item.ArmorMaterial"
import {$Map$$Type} from "java.util.Map"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$ArmorMaterial$Layer$$Type} from "net.minecraft.world.item.ArmorMaterial$Layer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $ArmorMaterialBuilder extends $BuilderBase<($ArmorMaterial)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "defense"(v: $Map$$Type<($ArmorItem$Type$$Type), (integer)>): this
public "layers"(v: ($ArmorMaterial$Layer$$Type)[]): this
public "knockbackResistance"(v: float): this
public "enchantmentValue"(v: integer): this
public "repairIngredient"(v: $Supplier$$Type<($Ingredient$$Type)>): this
public "toughness"(v: float): this
public "equipSound"(sound: $Holder$$Type<($SoundEvent)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorMaterialBuilder$$Type = ($ArmorMaterialBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorMaterialBuilder$$Original = $ArmorMaterialBuilder;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.JavaWrapper" {
import {$TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Map$$Type} from "java.util.Map"
import {$BaseFunction$$Type} from "dev.latvian.mods.rhino.BaseFunction"
import {$Class$$Type} from "java.lang.Class"
import {$ConsoleJS} from "dev.latvian.mods.kubejs.script.ConsoleJS"
import {$Record, $Record$$Type} from "java.lang.Record"

/**
 * Methods for working with Java classes. Reflection my beloved â™¥
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $JavaWrapper$$Interface {
}

export class $JavaWrapper implements $JavaWrapper$$Interface {
/**
 * Loads the specified class, and throws error if class it not found or allowed.
 * The returned object can have public static methods and fields accessed directly from it.
 * Constructors can be used with the new keyword.
 */
static "loadClass"(className: StringJS): any
/**
 * Cast the object to a target type, use if Rhino can't determine the parameter type due to type erasure.
 */
static "cast"<T>(targetClass: $Class$$Type<(T)>, object: any): T
/**
 * Loads the specified class, and returns null if class is not found or allowed.
 * The returned object can have public static methods and fields accessed directly from it.
 * Constructors can be used with the new keyword.
 */
static "tryLoadClass"(className: StringJS): any
/**
 * Creates a custom ConsoleJS instance for you to use to, well, log stuff
 */
static "createConsole"(name: StringJS): $ConsoleJS
static "makeFunctionProxy"<T>(targetClass: $TypeInfo$$Type, arg1: $BaseFunction$$Type): T
static "mergeRecord"<R extends $Record>(original: R, merge: $Map$$Type<(StringJS), (never)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaWrapper$$Type = ($JavaWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JavaWrapper$$Original = $JavaWrapper;}
declare module "dev.latvian.mods.kubejs.script.KubeJSContextFactory" {
import {$ContextFactory} from "dev.latvian.mods.rhino.ContextFactory"
import {$ScriptManager, $ScriptManager$$Type} from "dev.latvian.mods.kubejs.script.ScriptManager"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $KubeJSContextFactory extends $ContextFactory {
readonly "manager": $ScriptManager

constructor(manager: $ScriptManager$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSContextFactory$$Type = ($KubeJSContextFactory);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSContextFactory$$Original = $KubeJSContextFactory;}
declare module "dev.latvian.mods.kubejs.player.PlayerChatReceivedKubeEvent" {
import {$ServerChatEvent$$Type} from "net.neoforged.neoforge.event.ServerChatEvent"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $PlayerChatReceivedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(event: $ServerChatEvent$$Type)

public "getMessage"(): StringJS
public "getUsername"(): StringJS
public "setComponent"(component: $Component$$Type): void
public "getEntity"(): $LivingEntity
public "getComponent"(): $Component
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "message"(): StringJS
get "username"(): StringJS
set "component"(value: $Component$$Type)
get "entity"(): $LivingEntity
get "component"(): $Component
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerChatReceivedKubeEvent$$Type = ($PlayerChatReceivedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerChatReceivedKubeEvent$$Original = $PlayerChatReceivedKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.GameRulesKJS" {
import {$GameRules$Value} from "net.minecraft.world.level.GameRules$Value"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $GameRulesKJS$$Interface {
}

export class $GameRulesKJS implements $GameRulesKJS$$Interface {
 "kjs$get"(rule: StringJS): $GameRules$Value<(never)>
 "kjs$set"(rule: StringJS, value: StringJS): void
 "kjs$getBoolean"(rule: StringJS): boolean
 "kjs$getString"(rule: StringJS): StringJS
 "kjs$getInt"(rule: StringJS): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRulesKJS$$Type = ($GameRulesKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRulesKJS$$Original = $GameRulesKJS;}
declare module "dev.latvian.mods.kubejs.item.ItemSmeltedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an item is smelted by a player.
 */
export class $ItemSmeltedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, smelted: $ItemStack$$Type)

/**
 * The item that was smelted.
 */
public "getItem"(): $ItemStack
/**
 * The player that smelted the item.
 */
public "getEntity"(): $Player
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "item"(): $ItemStack
get "entity"(): $Player
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemSmeltedKubeEvent$$Type = ($ItemSmeltedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemSmeltedKubeEvent$$Original = $ItemSmeltedKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.BlockDropsKubeEvent" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Level} from "net.minecraft.world.level.Level"
import {$ItemEntity} from "net.minecraft.world.entity.item.ItemEntity"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockDropsEvent$$Type} from "net.neoforged.neoforge.event.level.BlockDropsEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Modify dropped items and xp from block.
 */
export class $BlockDropsKubeEvent implements $KubeEntityEvent$$Interface {
constructor(event: $BlockDropsEvent$$Type)

public "getLevel"(): $Level
public "addItem"(item: $ItemStack$$Type): $ItemEntity
/**
 * The experience dropped by the block.
 */
public "getXp"(): integer
/**
 * The tool used when breaking this block. May be null.
 */
public "getTool"(): $ItemStack
/**
 * Sets the experience dropped by the block.
 */
public "setXp"(xp: integer): void
/**
 * The block that was broken.
 */
public "getBlock"(): $LevelBlock
/**
 * Dropped items. Immutable.
 */
public "getItems"(): $List<($ItemStack)>
public "getEntity"(): $Entity
public "removeItem"(item: $ItemPredicate$$Type): void
/**
 * Dropped item entities.
 */
public "getItemEntities"(): $List<($ItemEntity)>
public "containsItem"(item: $ItemPredicate$$Type): boolean
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "xp"(): integer
get "tool"(): $ItemStack
set "xp"(value: integer)
get "block"(): $LevelBlock
get "items"(): $List<($ItemStack)>
get "entity"(): $Entity
get "itemEntities"(): $List<($ItemEntity)>
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockDropsKubeEvent$$Type = ($BlockDropsKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockDropsKubeEvent$$Original = $BlockDropsKubeEvent;}
declare module "dev.latvian.mods.kubejs.util.SlotFilter" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Record} from "java.lang.Record"

export class $SlotFilter extends $Record {
static readonly "CODEC": $Codec<($SlotFilter)>
static readonly "TYPE_INFO": $TypeInfo
static readonly "EMPTY": $SlotFilter
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($SlotFilter)>

constructor(item: $Ingredient$$Type, index: integer)

public "index"(): integer
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "wrap"(o: any, target: $TypeInfo$$Type): $SlotFilter
public static "of"(ingredient: $Ingredient$$Type, index: integer): $SlotFilter
public "item"(): $Ingredient
public "checkFilter"(index: integer, stack: $ItemStack$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotFilter$$Type = ({"item"?: $Ingredient$$Type, "index"?: integer}) | ([item?: $Ingredient$$Type, index?: integer]) | ((integer) | ($Ingredient$$Type) | ({"item"?: $Ingredient$$Type, "index"?: integer}) | ([item?: $Ingredient$$Type, index?: integer]));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SlotFilter$$Original = $SlotFilter;}
declare module "dev.latvian.mods.kubejs.event.TargetedEventHandler" {
import {$EventHandler} from "dev.latvian.mods.kubejs.event.EventHandler"
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$EventGroup} from "dev.latvian.mods.kubejs.event.EventGroup"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$Supplier} from "java.util.function.Supplier"
import {$ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$ScriptTypePredicate} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"
import {$ScriptTypeHolder$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$Set} from "java.util.Set"
import {$Class} from "java.lang.Class"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$EventHandlerContainer$$Type} from "dev.latvian.mods.kubejs.event.EventHandlerContainer"
import {$EventResult} from "dev.latvian.mods.kubejs.event.EventResult"

export class $TargetedEventHandler<E> extends $EventHandler {
static readonly "DONTENUM": integer
readonly "eventType": $Supplier<($Class<($KubeEvent)>)>
readonly "scriptTypePredicate": $ScriptTypePredicate
static readonly "CONST": integer
readonly "name": StringJS
static readonly "UNINITIALIZED_CONST": integer
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "PERMANENT": integer
readonly "group": $EventGroup

public "hasListeners"(): boolean
public "hasListeners"(extraId: E): boolean
public "post"(event: $KubeEvent$$Type, extraId: E): $EventResult
public "post"(type: $ScriptTypeHolder$$Type, extraId: E, event: $KubeEvent$$Type): $EventResult
public "hasResult"(): $EventHandler
public "forEachListener"(type: $ScriptType$$Type, callback: $Consumer$$Type<($EventHandlerContainer)>): void
public "findUniqueExtraIds"(type: $ScriptType$$Type): $Set<(E)>
public "get"(arg1: integer, arg2: $Scriptable$$Type): any
public "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
public "delete"(arg1: integer): void
public "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
public "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
public "setParentScope"(arg0: $Scriptable$$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(): (any)[]
public "getPrototype"(): $Scriptable
public "setPrototype"(arg0: $Scriptable$$Type): void
public "getIds"(): (any)[]
set "parentScope"(value: $Scriptable$$Type)
get "parentScope"(): $Scriptable
get "allIds"(): (any)[]
get "prototype"(): $Scriptable
set "prototype"(value: $Scriptable$$Type)
get "ids"(): (any)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TargetedEventHandler$$Type<E> = ($TargetedEventHandler<(E)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TargetedEventHandler$$Original<E> = $TargetedEventHandler<(E)>;}
declare module "dev.latvian.mods.kubejs.block.BlockBrokenKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$BlockEvent$BreakEvent$$Type} from "net.neoforged.neoforge.event.level.BlockEvent$BreakEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a block is destroyed by a player.
 */
export class $BlockBrokenKubeEvent implements $KubePlayerEvent$$Interface {
constructor(event: $BlockEvent$BreakEvent$$Type)

/**
 * The block that was broken.
 */
public "getBlock"(): $LevelBlock
/**
 * The player that broke the block.
 */
public "getEntity"(): $Player
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "block"(): $LevelBlock
get "entity"(): $Player
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBrokenKubeEvent$$Type = ($BlockBrokenKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBrokenKubeEvent$$Original = $BlockBrokenKubeEvent;}
declare module "dev.latvian.mods.kubejs.misc.VillagerTypeBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$VillagerType} from "net.minecraft.world.entity.npc.VillagerType"

export class $VillagerTypeBuilder extends $BuilderBase<($VillagerType)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VillagerTypeBuilder$$Type = ($VillagerTypeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VillagerTypeBuilder$$Original = $VillagerTypeBuilder;}
declare module "dev.latvian.mods.kubejs.item.ItemDroppedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player drops an item.
 */
export class $ItemDroppedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, entity: $ItemEntity$$Type)

/**
 * The item that was dropped.
 */
public "getItem"(): $ItemStack
/**
 * The player that dropped the item.
 */
public "getEntity"(): $Entity
/**
 * The item entity that was spawned when dropping.
 */
public "getItemEntity"(): $ItemEntity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "item"(): $ItemStack
get "entity"(): $Entity
get "itemEntity"(): $ItemEntity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDroppedKubeEvent$$Type = ($ItemDroppedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemDroppedKubeEvent$$Original = $ItemDroppedKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.BlockPickedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when player middle-clicks on a block.
 */
export class $BlockPickedKubeEvent implements $KubePlayerEvent$$Interface {
readonly "level": $Level
readonly "block": $LevelBlock
readonly "player": $Player

constructor(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, player: $Player$$Type, hitResult: $HitResult$$Type)

public "getTarget"(): $KubeRayTraceResult
public "getLevel"(): $Level
public "getEntity"(): $LivingEntity
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "target"(): $KubeRayTraceResult
get "entity"(): $LivingEntity
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPickedKubeEvent$$Type = ($BlockPickedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPickedKubeEvent$$Original = $BlockPickedKubeEvent;}
declare module "dev.latvian.mods.kubejs.util.ID" {
import {$UnaryOperator} from "java.util.function.UnaryOperator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$DataResult} from "com.mojang.serialization.DataResult"

export interface $ID$$Interface {
}

export class $ID implements $ID$$Interface {
static readonly "ITEM": $UnaryOperator<(StringJS)>
static readonly "PNG_TEXTURE_MCMETA": $UnaryOperator<(StringJS)>
static readonly "PARTICLE": $UnaryOperator<(StringJS)>
static readonly "BLOCK_MODEL": $UnaryOperator<(StringJS)>
static readonly "BLOCKSTATE": $UnaryOperator<(StringJS)>
static readonly "BLOCK": $UnaryOperator<(StringJS)>
static readonly "ITEM_MODEL": $UnaryOperator<(StringJS)>
static readonly "PNG_TEXTURE": $UnaryOperator<(StringJS)>
static readonly "AIR": $ResourceLocation
static readonly "BLOCK_LOOT_TABLE": $UnaryOperator<(StringJS)>
static readonly "UNKNOWN": $ResourceLocation
static readonly "MODEL": $UnaryOperator<(StringJS)>

static "of"(o: any, preferKJS: boolean): $ResourceLocation
static "url"(id: $ResourceLocation$$Type): StringJS
static "read"(reader: $StringReader$$Type): $DataResult<($ResourceLocation)>
static "mc"(o: any): $ResourceLocation
static "path"(s: StringJS): StringJS
static "reduce"(id: $ResourceLocation$$Type): StringJS
static "string"(id: StringJS): StringJS
static "isKey"(from: any): boolean
static "namespace"(s: StringJS): StringJS
static "resourcePath"(id: $ResourceLocation$$Type): StringJS
static "kjs"(o: any): $ResourceLocation
static "kjsString"(id: StringJS): StringJS
static "reduceKjs"(id: $ResourceLocation$$Type): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ID$$Type = ($ID);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ID$$Original = $ID;}
declare module "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Model" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $VariantBlockStateGenerator$Model {
constructor()

public "x"(x: integer): $VariantBlockStateGenerator$Model
public "y"(y: integer): $VariantBlockStateGenerator$Model
public "model"(s: $ResourceLocation$$Type): $VariantBlockStateGenerator$Model
public "uvlock"(): $VariantBlockStateGenerator$Model
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateGenerator$Model$$Type = ($VariantBlockStateGenerator$Model);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VariantBlockStateGenerator$Model$$Original = $VariantBlockStateGenerator$Model;}
declare module "dev.latvian.mods.kubejs.util.ErrorStack" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ErrorStack {
static readonly "NONE": $ErrorStack

constructor()

public "toString"(): StringJS
public "push"(parent: any): void
public "pop"(): void
public "setKey"(key: any): void
public "setKey"(index: integer): void
public "stringAt"(): StringJS
public "atString"(): StringJS
set "key"(value: any)
set "key"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ErrorStack$$Type = ($ErrorStack);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ErrorStack$$Original = $ErrorStack;}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Hoe" {
import {$BiFunction} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DiggerItemBuilder} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$Item$Properties} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Hoe extends $DiggerItemBuilder {
 "sourceLine": $SourceLine
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
static readonly "HOE_TAGS": ($ResourceLocation)[]
readonly "id": $ResourceLocation
static readonly "HOE_MODEL": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Hoe$$Type = ($DiggerItemBuilder$Hoe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemBuilder$Hoe$$Original = $DiggerItemBuilder$Hoe;}
declare module "dev.latvian.mods.kubejs.fluid.FluidLike" {
import {$ReplacementMatch, $ReplacementMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"

export interface $FluidLike$$Interface extends $ReplacementMatch$$Interface {
get "empty"(): boolean
get "amount"(): integer
get "fluid"(): $Fluid
}

export class $FluidLike implements $FluidLike$$Interface {
 "isEmpty"(): boolean
 "copy"(amount: integer): $FluidLike
 "getAmount"(): integer
 "getFluid"(): $Fluid
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidLike$$Type = ($FluidLike);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidLike$$Original = $FluidLike;}
declare module "dev.latvian.mods.kubejs.recipe.special.SpecialRecipeSerializerManager" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"

export class $SpecialRecipeSerializerManager implements $KubeEvent$$Interface {
static readonly "INSTANCE": $SpecialRecipeSerializerManager

constructor()

public "reset"(): void
public "ignoreSpecialFlag"(id: $ResourceLocation$$Type): void
public "addSpecialMod"(modid: StringJS): void
public "ignoreSpecialMod"(modid: StringJS): void
public "addSpecialFlag"(id: $ResourceLocation$$Type): void
public "isSpecial"(recipe: $Recipe$$Type<(never)>): boolean
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpecialRecipeSerializerManager$$Type = ($SpecialRecipeSerializerManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpecialRecipeSerializerManager$$Original = $SpecialRecipeSerializerManager;}
declare module "dev.latvian.mods.kubejs.level.ExplosionProperties" {
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$Level$ExplosionInteraction, $Level$ExplosionInteraction$$Type} from "net.minecraft.world.level.Level$ExplosionInteraction"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ExplosionDamageCalculator, $ExplosionDamageCalculator$$Type} from "net.minecraft.world.level.ExplosionDamageCalculator"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$Record} from "java.lang.Record"

export class $ExplosionProperties extends $Record {
constructor(source: $Entity$$Type, damageSource: $DamageSource$$Type, damageCalculator: $ExplosionDamageCalculator$$Type, strength: (float)?, causesFire: (boolean)?, mode: $Level$ExplosionInteraction$$Type, particles: (boolean)?, smallParticles: $ParticleOptions$$Type, largeParticles: $ParticleOptions$$Type, explosionSound: $Holder$$Type<($SoundEvent)>)

public "mode"(): $Level$ExplosionInteraction
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "source"(): $Entity
public "explode"(level: $Level$$Type, x: double, y: double, z: double): $Explosion
public "particles"(): $Optional<(boolean)>
public "strength"(): $Optional<(float)>
public "damageCalculator"(): $ExplosionDamageCalculator
public "explosionSound"(): $Holder<($SoundEvent)>
public "damageSource"(): $DamageSource
public "smallParticles"(): $ParticleOptions
public "largeParticles"(): $ParticleOptions
public "causesFire"(): $Optional<(boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionProperties$$Type = ({"causesFire"?: (boolean)?, "particles"?: (boolean)?, "damageSource"?: $DamageSource$$Type, "explosionSound"?: $Holder$$Type<($SoundEvent)>, "largeParticles"?: $ParticleOptions$$Type, "damageCalculator"?: $ExplosionDamageCalculator$$Type, "smallParticles"?: $ParticleOptions$$Type, "strength"?: (float)?, "source"?: $Entity$$Type, "mode"?: $Level$ExplosionInteraction$$Type}) | ([causesFire?: (boolean)?, particles?: (boolean)?, damageSource?: $DamageSource$$Type, explosionSound?: $Holder$$Type<($SoundEvent)>, largeParticles?: $ParticleOptions$$Type, damageCalculator?: $ExplosionDamageCalculator$$Type, smallParticles?: $ParticleOptions$$Type, strength?: (float)?, source?: $Entity$$Type, mode?: $Level$ExplosionInteraction$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExplosionProperties$$Original = $ExplosionProperties;}
declare module "dev.latvian.mods.kubejs.script.data.VirtualDataMapFile" {
import {$VirtualDataPack$$Type} from "dev.latvian.mods.kubejs.script.data.VirtualDataPack"
import {$KubeDataGenerator} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$DataMapType$$Type} from "net.neoforged.neoforge.registries.datamaps.DataMapType"
import {$BiConsumer, $BiConsumer$$Type, $BiConsumer$$Interface} from "java.util.function.BiConsumer"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Holder$$Type} from "net.minecraft.core.Holder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $VirtualDataMapFile<RT, DT> implements $BiConsumer$$Interface<($ResourceLocation), (DT)> {
readonly "registryAccess": $RegistryAccessContainer
readonly "registry": $Registry<(RT)>
readonly "pack": $KubeDataGenerator

constructor(type: $DataMapType$$Type<(RT), (DT)>, pack: $VirtualDataPack$$Type)

public "remove"(holders: $HolderSet$$Type<(RT)>): void
public "remove"(holder: $Holder$$Type<(RT)>): void
public "remove"(holder: RT): void
public "clear"(): void
public "replaceAll"(): void
public "add"(holders: $HolderSet$$Type<(RT)>, value: DT, replace: boolean): void
public "add"(holder: RT, value: DT, replace: boolean): void
public "add"(holder: RT, value: DT): void
public "add"(holder: $Holder$$Type<(RT)>, value: DT): void
public "add"(holder: $Holder$$Type<(RT)>, value: DT, replace: boolean): void
public "add"(holders: $HolderSet$$Type<(RT)>, value: DT): void
public "addTag"(tag: $TagKey$$Type<(RT)>, value: DT, replace: boolean): void
public "addTag"(tag: $TagKey$$Type<(RT)>, value: DT): void
public "removeTag"(tag: $TagKey$$Type<(RT)>): void
public "andThen"(arg0: $BiConsumer$$Type<($ResourceLocation), (DT)>): $BiConsumer<($ResourceLocation), (DT)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualDataMapFile$$Type<RT, DT> = ($VirtualDataMapFile<(RT), (DT)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VirtualDataMapFile$$Original<RT, DT> = $VirtualDataMapFile<(RT), (DT)>;}
declare module "dev.latvian.mods.kubejs.item.FoodBuilder" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$FoodEatenKubeEvent$$Type} from "dev.latvian.mods.kubejs.item.FoodEatenKubeEvent"
import {$MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$FoodProperties, $FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"

export class $FoodBuilder {
constructor()
constructor(properties: $FoodProperties$$Type)

/**
 * Sets seconds it takes to eat the food.
 */
public "eatSeconds"(seconds: float): $FoodBuilder
public "build"(): $FoodProperties
public "usingConvertsTo"(stack: $ItemStack$$Type): $FoodBuilder
/**
 * Sets the food is always edible.
 */
public "alwaysEdible"(): $FoodBuilder
/**
 * Sets whether the food is always edible.
 */
public "alwaysEdible"(flag: boolean): $FoodBuilder
/**
 * Sets the hunger restored.
 */
public "nutrition"(h: integer): $FoodBuilder
/**
 * Sets a callback that is called when the food is eaten.
 * 
 * Note: This is currently not having effect in `ItemEvents.modification`,
 * as firing this callback requires an `ItemBuilder` instance in the `Item`.
 */
public "eaten"(e: $Consumer$$Type<($FoodEatenKubeEvent)>): $FoodBuilder
/**
 * Sets the saturation modifier. Note that the saturation restored is hunger * saturation.
 */
public "saturation"(s: float): $FoodBuilder
/**
 * Adds an effect to the food. Note that the effect duration is in ticks (20 ticks = 1 second).
 * 
 * @param mobEffectId - The id of the effect. Can be either a string or a ResourceLocation.
 * @param duration - The duration of the effect in ticks.
 * @param amplifier - The amplifier of the effect. 0 means level 1, 1 means level 2, etc.
 * @param probability - The probability of the effect being applied. 1 = 100%.
 */
public "effect"(mobEffectId: $ResourceLocation$$Type, duration: integer, amplifier: integer, probability: float): $FoodBuilder
/**
 * Removes an effect from the food.
 */
public "removeEffect"(mobEffect: $MobEffect$$Type): $FoodBuilder
/**
 * Sets the food is fast to eat (having half of the eating time).
 */
public "fastToEat"(): $FoodBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoodBuilder$$Type = ($FoodBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FoodBuilder$$Original = $FoodBuilder;}
declare module "dev.latvian.mods.kubejs.client.icon.KubeIconType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$KubeIcon} from "dev.latvian.mods.kubejs.client.icon.KubeIcon"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $KubeIconType<T extends $KubeIcon> extends $Record {
static readonly "TYPES": $Lazy<($Map<($ResourceLocation), ($KubeIconType<(never)>)>)>
static readonly "CODEC": $Codec<($KubeIconType<(never)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($KubeIconType<(never)>)>

constructor(id: $ResourceLocation$$Type, codec: $MapCodec$$Type<(T)>)
constructor(id: $ResourceLocation$$Type, codec: $MapCodec$$Type<(T)>, streamCodec: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): $ResourceLocation
public "codec"(): $MapCodec<(T)>
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeIconType$$Type<T> = ({"id"?: $ResourceLocation$$Type, "codec"?: $MapCodec$$Type<(T)>, "streamCodec"?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>}) | ([id?: $ResourceLocation$$Type, codec?: $MapCodec$$Type<(T)>, streamCodec?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeIconType$$Original<T> = $KubeIconType<(T)>;}
declare module "dev.latvian.mods.kubejs.player.InventoryChangedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player's inventory changes.
 */
export class $InventoryChangedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(p: $Player$$Type, is: $ItemStack$$Type, s: integer)

/**
 * Gets the slot that was changed.
 */
public "getSlot"(): integer
/**
 * Gets the item that was changed.
 */
public "getItem"(): $ItemStack
/**
 * Gets the player that changed their inventory.
 */
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "slot"(): integer
get "item"(): $ItemStack
get "entity"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryChangedKubeEvent$$Type = ($InventoryChangedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InventoryChangedKubeEvent$$Original = $InventoryChangedKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType$Unit" {
import {$RecipeTypeRegistryContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext"
import {$RecipeComponentType} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$RecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $RecipeComponentType$Unit<T> extends $RecipeComponentType<(T)> {
public "instance"(): $RecipeComponent<(T)>
public "isUnit"(): boolean
public "mapCodec"(ctx: $RecipeTypeRegistryContext$$Type): $MapCodec<($RecipeComponent<(never)>)>
get "unit"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentType$Unit$$Type<T> = ($RecipeComponentType$Unit<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponentType$Unit$$Original<T> = $RecipeComponentType$Unit<(T)>;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Info" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Record} from "java.lang.Record"

export class $FluidData$Info extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData$Info)>

constructor(filter: $FluidIngredient$$Type, info: $List$$Type<($Component$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $FluidIngredient
public "info"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$Info$$Type = ({"filter"?: $FluidIngredient$$Type, "info"?: $List$$Type<($Component$$Type)>}) | ([filter?: $FluidIngredient$$Type, info?: $List$$Type<($Component$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidData$Info$$Original = $FluidData$Info;}
declare module "dev.latvian.mods.kubejs.component.MutableDataComponentHolderFunctions" {
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ComponentFunctions, $ComponentFunctions$$Interface} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map$$Type} from "java.util.Map"
import {$MutableDataComponentHolder} from "net.neoforged.neoforge.common.MutableDataComponentHolder"
import {$UUID$$Type} from "java.util.UUID"
import {$List$$Type} from "java.util.List"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$Unit$$Type} from "net.minecraft.util.Unit"

export interface $MutableDataComponentHolderFunctions$$Interface extends $ComponentFunctions$$Interface {
get "componentMap"(): $DataComponentMap
get "componentHolder"(): $MutableDataComponentHolder
set "lore"(value: $List$$Type<($Component$$Type)>)
set "customData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "dyedColor"(value: $KubeColor$$Type)
set "customName"(value: $Component$$Type)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
get "customName"(): $Component
get "customData"(): $CompoundTag
set "lockCode"(value: StringJS)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
get "additionalTooltipHidden"(): void
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
get "componentString"(): StringJS
get "tooltipHidden"(): void
set "customModelData"(value: integer)
set "glintOverride"(value: boolean)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
}

export class $MutableDataComponentHolderFunctions implements $MutableDataComponentHolderFunctions$$Interface {
 "patch"(components: $DataComponentPatch$$Type): $ComponentFunctions
 "set"(components: $DataComponentMap$$Type): this
 "getComponentMap"(): $DataComponentMap
 "getComponentHolder"(): $MutableDataComponentHolder
 "remove"(type: $DataComponentType$$Type<(never)>): $ComponentFunctions
 "get"<T>(type: $DataComponentType$$Type<(T)>): T
 "set"(component: $DataComponentType$$Type<(never)>, value: any): $ComponentFunctions
 "setLore"(lines: $List$$Type<($Component$$Type)>): void
 "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
 "setCustomData"(tag: $CompoundTag$$Type): void
 "setRarity"(rarity: $Rarity$$Type): void
 "setDyedColor"(color: $KubeColor$$Type): void
 "setCustomName"(name: $Component$$Type): void
 "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "getCustomName"(): $Component
 "getCustomData"(): $CompoundTag
 "setLockCode"(lock: StringJS): void
 "setProfile"(name: StringJS, uuid: $UUID$$Type): void
 "setProfile"(profile: $GameProfile$$Type): void
 "setBaseColor"(color: $DyeColor$$Type): void
 "setPotionId"(potion: $Holder$$Type<($Potion)>): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "setAdditionalTooltipHidden"(): void
 "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
 "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
 "setPotionContents"(contents: $PotionContents$$Type): void
 "getComponentString"(): StringJS
 "resetComponents"(): $ComponentFunctions
 "setTooltipHidden"(): void
 "setCustomModelData"(data: integer): void
 "setGlintOverride"(override: boolean): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableDataComponentHolderFunctions$$Type = ($MutableDataComponentHolderFunctions);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MutableDataComponentHolderFunctions$$Original = $MutableDataComponentHolderFunctions;}
declare module "dev.latvian.mods.kubejs.client.LangKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Pattern} from "java.util.regex.Pattern"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$LangKubeEvent$Key, $LangKubeEvent$Key$$Type} from "dev.latvian.mods.kubejs.client.LangKubeEvent$Key"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Record} from "java.lang.Record"

export class $LangKubeEvent extends $Record implements $KubeEvent$$Interface {
static readonly "PATTERN": $Pattern

constructor(lang: StringJS, map: $Map$$Type<($LangKubeEvent$Key$$Type), (StringJS)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "add"(namespace: StringJS, key: StringJS, value: StringJS): void
public "add"(key: StringJS, value: StringJS): void
public "map"(): $Map<($LangKubeEvent$Key), (StringJS)>
public "addAll"(map: $Map$$Type<(StringJS), (StringJS)>): void
public "addAll"(namespace: StringJS, map: $Map$$Type<(StringJS), (StringJS)>): void
public "lang"(): StringJS
public "renameBlock"(block: $Block$$Type, name: StringJS): void
public "painting"(paintingId: $ResourceLocation$$Type, title: StringJS, author: StringJS): void
public "renameBiome"(id: $ResourceLocation$$Type, name: StringJS): void
public "renameEntity"(id: $ResourceLocation$$Type, name: StringJS): void
public "renameItem"(item: $ItemStack$$Type, name: StringJS): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LangKubeEvent$$Type = ({"map"?: $Map$$Type<($LangKubeEvent$Key$$Type), (StringJS)>, "lang"?: StringJS}) | ([map?: $Map$$Type<($LangKubeEvent$Key$$Type), (StringJS)>, lang?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LangKubeEvent$$Original = $LangKubeEvent;}
declare module "dev.latvian.mods.kubejs.misc.VillagerProfessionBuilder" {
import {$VillagerProfession} from "net.minecraft.world.entity.npc.VillagerProfession"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $VillagerProfessionBuilder extends $BuilderBase<($VillagerProfession)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "secondaryPoi"(t: ($Block$$Type)[]): this
public "requestedItems"(t: ($Item$$Type)[]): this
public "workSound"(t: $SoundEvent$$Type): this
public "poiType"(t: $ResourceLocation$$Type): this
public "poiTypeTag"(t: $ResourceLocation$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VillagerProfessionBuilder$$Type = ($VillagerProfessionBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VillagerProfessionBuilder$$Original = $VillagerProfessionBuilder;}
declare module "dev.latvian.mods.kubejs.script.ConsoleJS" {
import {$ContextFactory} from "dev.latvian.mods.rhino.ContextFactory"
import {$KJSWSSession} from "dev.latvian.mods.kubejs.web.KJSWSSession"
import {$Pattern, $Pattern$$Type} from "java.util.regex.Pattern"
import {$Component} from "net.minecraft.network.chat.Component"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$LogType$$Type} from "dev.latvian.mods.kubejs.util.LogType"
import {$HTTPResponse} from "dev.latvian.apps.tinyserver.http.response.HTTPResponse"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Class$$Type} from "java.lang.Class"
import {$Throwable$$Type} from "java.lang.Throwable"
import {$WSHandler} from "dev.latvian.apps.tinyserver.ws.WSHandler"
import {$KJSHTTPRequest, $KJSHTTPRequest$$Type} from "dev.latvian.mods.kubejs.web.KJSHTTPRequest"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ConsoleLine, $ConsoleLine$$Type} from "dev.latvian.mods.kubejs.script.ConsoleLine"
import {$Logger, $Logger$$Type} from "org.slf4j.Logger"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ConsoleJS {
static "SERVER": $ConsoleJS
readonly "scriptType": $ScriptType
static "STARTUP": $ConsoleJS
 "wsBroadcaster": $WSHandler<($KJSHTTPRequest), ($KJSWSSession)>
static "CLIENT": $ConsoleJS
 "contextFactory": $WeakReference<($ContextFactory)>

constructor(m: $ScriptType$$Type, log: $Logger$$Type)

public "group"(): void
public "log"(...message: (any)[]): void
public "flush"(sync: boolean): void
public "info"(message: any): $ConsoleLine
public "getLogger"(): $Logger
public "trace"(): void
public "debug"(message: any): $ConsoleLine
public "error"(message: StringJS, sourceLine: $SourceLine$$Type, error: $Throwable$$Type, exitPattern: $Pattern$$Type): $ConsoleLine
public "error"(message: StringJS, throwable: $Throwable$$Type): $ConsoleLine
public "error"(message: any): $ConsoleLine
public "error"(message: StringJS, error: $Throwable$$Type, exitPattern: $Pattern$$Type): $ConsoleLine
public "warn"(message: StringJS, error: $Throwable$$Type, exitPattern: $Pattern$$Type): $ConsoleLine
public "warn"(message: any): $ConsoleLine
public "warn"(message: StringJS, sourceLine: $SourceLine$$Type, error: $Throwable$$Type, exitPattern: $Pattern$$Type): $ConsoleLine
public "warn"(message: StringJS, error: $Throwable$$Type): $ConsoleLine
public "groupEnd"(): void
public "writeToFile"(type: $LogType$$Type, timestamp: long, line: StringJS): void
public "writeToFile"(type: $LogType$$Type, line: StringJS): void
public "getWarningsResponse"(ctx: $KJSHTTPRequest$$Type): $HTTPResponse
public "handleError"(line: $ConsoleLine$$Type, error: $Throwable$$Type, exitPattern: $Pattern$$Type, print: boolean): void
public "printObject"(o: any): void
public "printObject"(o: any, tree: boolean): void
public "setDebugEnabled"(m: boolean): void
public "stopCapturingErrors"(): void
public "startCapturingErrors"(): void
public "printClass"(className: StringJS): void
public "printClass"(className: StringJS, tree: boolean): void
public "errorf"(message: StringJS, ...args: (any)[]): $ConsoleLine
public "setMuted"(m: boolean): void
public "infof"(message: StringJS, ...args: (any)[]): $ConsoleLine
public "getMuted"(): boolean
public static "getCurrent"(): $ConsoleJS
public "debugf"(message: StringJS, ...args: (any)[]): $ConsoleLine
public "warnf"(message: StringJS, ...args: (any)[]): $ConsoleLine
public "resetFile"(): void
public "shouldPrintDebug"(): boolean
public static "methodPattern"(c: $Class$$Type<(never)>, method: StringJS): $Pattern
public "errorsComponent"(command: StringJS): $Component
public "getDebugEnabled"(): boolean
public "getScriptLine"(): integer
public "getWriteToFile"(): boolean
public "getErrorsResponse"(ctx: $KJSHTTPRequest$$Type): $HTTPResponse
public "setWriteToFile"(m: boolean): void
get "logger"(): $Logger
set "debugEnabled"(value: boolean)
set "muted"(value: boolean)
get "muted"(): boolean
get "current"(): $ConsoleJS
get "debugEnabled"(): boolean
get "scriptLine"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConsoleJS$$Type = ($ConsoleJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConsoleJS$$Original = $ConsoleJS;}
declare module "dev.latvian.mods.kubejs.fluid.FluidWrapper" {
import {$DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$DataResult} from "com.mojang.serialization.DataResult"
import {$List} from "java.util.List"
import {$SizedFluidIngredient, $SizedFluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.SizedFluidIngredient"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$FluidWrapper$ReadFn$$Type} from "dev.latvian.mods.kubejs.fluid.FluidWrapper$ReadFn"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Tag$$Type} from "net.minecraft.nbt.Tag"

export interface $FluidWrapper$$Interface {
get "empty"(): $FluidStack
get "types"(): $List<(StringJS)>
}

export class $FluidWrapper implements $FluidWrapper$$Interface {
static readonly "FLUID_TYPE_INFO": $TypeInfo
static readonly "EMPTY_STACK_RESULT": $DataResult<($FluidStack)>
static readonly "EMPTY_SIZED_RESULT": $DataResult<($SizedFluidIngredient)>
static readonly "TYPE_INFO": $TypeInfo
static readonly "EMPTY_SIZED": $SizedFluidIngredient
static readonly "INGREDIENT_TYPE_INFO": $TypeInfo
static readonly "SIZED_INGREDIENT_TYPE_INFO": $TypeInfo
static readonly "EMPTY_INGREDIENT_RESULT": $DataResult<($FluidIngredient)>

/**
 * Returns a FluidStack of the input, with the specified amount and data components
 */
static "of"(o: $FluidStack$$Type, amount: integer, components: $DataComponentMap$$Type): $FluidStack
/**
 * Returns a FluidStack of the input, with the specified data components
 */
static "of"(o: $FluidStack$$Type, components: $DataComponentMap$$Type): $FluidStack
/**
 * Returns a FluidStack of the input
 */
static "of"(o: $FluidStack$$Type): $FluidStack
/**
 * Returns a FluidStack of the input, with the specified amount
 */
static "of"(o: $FluidStack$$Type, amount: integer): $FluidStack
static "read"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, reader: $StringReader$$Type): $DataResult<($FluidStack)>
static "getId"(fluid: $Fluid$$Type): $ResourceLocation
static "getType"(id: $ResourceLocation$$Type): $Fluid
static "exists"(id: $ResourceLocation$$Type): boolean
static "water"(): $FluidStack
static "water"(amount: integer): $FluidStack
static "getEmpty"(): $FluidStack
static "parseString"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, s: StringJS): $DataResult<($FluidStack)>
static "lava"(amount: integer): $FluidStack
static "lava"(): $FluidStack
static "getTypes"(): $List<(StringJS)>
/**
 * Returns an ingredient that accepts the given set of fluids under the given component filter.
 */
static "ingredientOf"(base: $HolderSet$$Type<($Fluid)>, data: $DataComponentMap$$Type): $FluidIngredient
static "ingredientOf"(of: $FluidIngredient$$Type): $FluidIngredient
/**
 * Returns an ingredient that accepts the given set of items under the given (optionally strict) component filter.
 */
static "ingredientOf"(base: $HolderSet$$Type<($Fluid)>, data: $DataComponentMap$$Type, strict: boolean): $FluidIngredient
static "sizedIngredientOf"(arg0: $FluidIngredient$$Type, amount: integer): $SizedFluidIngredient
static "sizedIngredientOf"(of: $SizedFluidIngredient$$Type): $SizedFluidIngredient
static "ingredientOfString"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, s: StringJS): $DataResult<($FluidIngredient)>
static "readWithContext"<T>(registryOps: $DynamicOps$$Type<($Tag$$Type)>, s: StringJS, fn: $FluidWrapper$ReadFn$$Type<(T)>, name: StringJS): $DataResult<(T)>
static "sizedIngredientOfString"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, s: StringJS): $DataResult<($SizedFluidIngredient)>
static "readSizedIngredient"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, reader: $StringReader$$Type): $DataResult<($SizedFluidIngredient)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidWrapper$$Type = ($FluidWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidWrapper$$Original = $FluidWrapper;}
declare module "dev.latvian.mods.kubejs.core.SizedFluidIngredientKJS" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$FluidMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.FluidMatch"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$SizedFluidIngredient} from "net.neoforged.neoforge.fluids.crafting.SizedFluidIngredient"
import {$FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $SizedFluidIngredientKJS$$Interface extends $Replaceable$$Interface, $FluidMatch$$Interface {
}

export class $SizedFluidIngredientKJS implements $SizedFluidIngredientKJS$$Interface {
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $FluidIngredient$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, s: $FluidStack$$Type, exact: boolean): boolean
 "self"(): $SizedFluidIngredient
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "toFlatJson"(): $JsonElement
 "toNestedJson"(): $JsonElement
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SizedFluidIngredientKJS$$Type = ($SizedFluidIngredientKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SizedFluidIngredientKJS$$Original = $SizedFluidIngredientKJS;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent" {
import {$ChestMenuSlot, $ChestMenuSlot$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuSlot"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"

export class $ChestMenuClickEvent {
readonly "button": integer
readonly "slot": $ChestMenuSlot
readonly "type": $ClickType

constructor(slot: $ChestMenuSlot$$Type, type: $ClickType$$Type, button: integer)

public "setHandled"(): void
get "handled"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuClickEvent$$Type = ($ChestMenuClickEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuClickEvent$$Original = $ChestMenuClickEvent;}
declare module "dev.latvian.mods.kubejs.recipe.schema.function.ResolvedRecipeSchemaFunction" {
import {$RecipeScriptContext, $RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"

export interface $ResolvedRecipeSchemaFunction$$Interface {

(cx: $RecipeScriptContext, args: $List<(any)>): void
}

export class $ResolvedRecipeSchemaFunction implements $ResolvedRecipeSchemaFunction$$Interface {
 "execute"(cx: $RecipeScriptContext$$Type, args: $List$$Type<(any)>): void
 "arguments"(): $List<($RecipeComponent<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResolvedRecipeSchemaFunction$$Type = ((cx: $RecipeScriptContext, args: $List<(any)>) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ResolvedRecipeSchemaFunction$$Original = $ResolvedRecipeSchemaFunction;}
declare module "dev.latvian.mods.kubejs.core.EntityCollectionKJS" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $EntityCollectionKJS$$Interface {

(): $Iterable$$Type<($Entity$$Type)>
get "mcEntities"(): $Iterable<($Entity)>
get "entities"(): $EntityArrayList
get "players"(): $EntityArrayList
get "mcPlayers"(): $List<($Player)>
}

export class $EntityCollectionKJS implements $EntityCollectionKJS$$Interface {
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getEntities"(): $EntityArrayList
 "getPlayers"(): $EntityArrayList
 "getMcPlayers"(): $List<($Player)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityCollectionKJS$$Type = (() => $Iterable$$Type<($Entity$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityCollectionKJS$$Original = $EntityCollectionKJS;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.NativeEventWrapper" {
import {$EventPriority$$Type} from "net.neoforged.bus.api.EventPriority"
import {$Event, $Event$$Type} from "net.neoforged.bus.api.Event"
import {$Class$$Type} from "java.lang.Class"
import {$Consumer$$Type} from "java.util.function.Consumer"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $NativeEventWrapper$$Interface {
}

export class $NativeEventWrapper implements $NativeEventWrapper$$Interface {
static "onEvent"<T extends typeof $Event<(unknown)>>(eventClass: T, consumer: (event: InstanceType<(T)>) => void): void
static "onEvent"<T extends typeof $Event<(unknown)>>(priority: $EventPriority$$Type, eventClass: T, consumer: (event: InstanceType<(T)>) => void): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeEventWrapper$$Type = ($NativeEventWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NativeEventWrapper$$Original = $NativeEventWrapper;}
declare module "dev.latvian.mods.kubejs.client.icon.KubeIcon" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Optional} from "java.util.Optional"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$KubeIconType, $KubeIconType$$Type} from "dev.latvian.mods.kubejs.client.icon.KubeIconType"

export interface $KubeIcon$$Interface {

(): $KubeIconType$$Type<(never)>
get "type"(): $KubeIconType<(never)>
}

export class $KubeIcon implements $KubeIcon$$Interface {
static readonly "CODEC": $Codec<($KubeIcon)>
static readonly "OPTIONAL_STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($Optional<($KubeIcon)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($KubeIcon)>

 "getType"(): $KubeIconType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeIcon$$Type = (() => $KubeIconType$$Type<(never)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeIcon$$Original = $KubeIcon;}
declare module "dev.latvian.mods.kubejs.util.NBTSerializable" {
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"

export interface $NBTSerializable$$Interface {

(): $Tag$$Type
}

export class $NBTSerializable implements $NBTSerializable$$Interface {
 "toNBT"(): $Tag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTSerializable$$Type = (() => $Tag$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NBTSerializable$$Original = $NBTSerializable;}
declare module "dev.latvian.mods.kubejs.script.data.GeneratedData" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$IoSupplier, $IoSupplier$$Interface} from "net.minecraft.server.packs.resources.IoSupplier"
import {$Path$$Type} from "java.nio.file.Path"
import {$InputStream} from "java.io.InputStream"
import {$ZipFile$$Type} from "java.util.zip.ZipFile"
import {$ZipEntry$$Type} from "java.util.zip.ZipEntry"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $GeneratedData extends $Record implements $IoSupplier$$Interface<($InputStream)> {
static readonly "PACK_META": $GeneratedData
static readonly "INTERNAL_RELOAD": $GeneratedData
static readonly "PACK_ICON": $GeneratedData

constructor(id: $ResourceLocation$$Type, data: $Supplier$$Type<((byte)[])>)

public "get"(): any
public "equals"(obj: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "data"(): $Supplier<((byte)[])>
public "id"(): $ResourceLocation
public static "json"(id: $ResourceLocation$$Type, json: $Supplier$$Type<($JsonElement$$Type)>): $GeneratedData
public static "create"(arg0: $Path$$Type): $IoSupplier<($InputStream)>
public static "create"(arg0: $ZipFile$$Type, arg1: $ZipEntry$$Type): $IoSupplier<($InputStream)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedData$$Type = ({"id"?: $ResourceLocation$$Type, "data"?: $Supplier$$Type<((byte)[])>}) | ([id?: $ResourceLocation$$Type, data?: $Supplier$$Type<((byte)[])>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeneratedData$$Original = $GeneratedData;}
declare module "dev.latvian.mods.kubejs.util.LogType" {
import {$Enum} from "java.lang.Enum"
import {$BiConsumer} from "java.util.function.BiConsumer"
import {$Logger} from "org.slf4j.Logger"

export class $LogType extends $Enum<($LogType)> {
static readonly "INIT": $LogType
readonly "callback": $BiConsumer<($Logger), (StringJS)>
static readonly "ERROR": $LogType
static readonly "VALUES": ($LogType)[]
readonly "id": StringJS
static readonly "INFO": $LogType
static readonly "DEBUG": $LogType
static readonly "WARN": $LogType

public static "values"(): ($LogType)[]
public static "valueOf"(name: StringJS): $LogType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogType$$Type = (("init") | ("debug") | ("info") | ("warn") | ("error"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LogType$$Original = $LogType;}
declare module "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext" {
import {$RecipePostProcessor} from "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessor"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeSchemaStorage, $RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Record} from "java.lang.Record"

export class $RecipeTypeRegistryContext extends $Record {
constructor(registries: $RegistryAccessContainer$$Type, storage: $RecipeSchemaStorage$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "storage"(): $RecipeSchemaStorage
public "registries"(): $RegistryAccessContainer
public "recipeComponentCodec"(): $Codec<($RecipeComponent<(never)>)>
public "recipePostProcessorCodec"(): $Codec<($RecipePostProcessor)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeTypeRegistryContext$$Type = ({"storage"?: $RecipeSchemaStorage$$Type, "registries"?: $RegistryAccessContainer$$Type}) | ([storage?: $RecipeSchemaStorage$$Type, registries?: $RegistryAccessContainer$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeTypeRegistryContext$$Original = $RecipeTypeRegistryContext;}
declare module "dev.latvian.mods.kubejs.core.FireworkRocketEntityKJS" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $FireworkRocketEntityKJS$$Interface {

(lifetime: integer): void
set "lifetimeKJS"(value: integer)
}

export class $FireworkRocketEntityKJS implements $FireworkRocketEntityKJS$$Interface {
 "setLifetimeKJS"(lifetime: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FireworkRocketEntityKJS$$Type = ((lifetime: integer) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FireworkRocketEntityKJS$$Original = $FireworkRocketEntityKJS;}
declare module "dev.latvian.mods.kubejs.block.BlockLeftClickedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Direction} from "net.minecraft.core.Direction"
import {$PlayerInteractEvent$LeftClickBlock$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerInteractEvent$LeftClickBlock"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player left clicks on a block.
 */
export class $BlockLeftClickedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(event: $PlayerInteractEvent$LeftClickBlock$$Type)

/**
 * The item that was used to left click the block.
 */
public "getItem"(): $ItemStack
/**
 * The block that was left clicked.
 */
public "getBlock"(): $LevelBlock
/**
 * The player that left clicked the block.
 */
public "getEntity"(): $LivingEntity
/**
 * The face of the block that was left clicked.
 */
public "getFacing"(): $Direction
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "item"(): $ItemStack
get "block"(): $LevelBlock
get "entity"(): $LivingEntity
get "facing"(): $Direction
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockLeftClickedKubeEvent$$Type = ($BlockLeftClickedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockLeftClickedKubeEvent$$Original = $BlockLeftClickedKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator$Part" {
import {$VariantBlockStateGenerator$Model} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Model"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $MultipartBlockStateGenerator$Part {
constructor()

public "model"(s: $ResourceLocation$$Type): $VariantBlockStateGenerator$Model
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultipartBlockStateGenerator$Part$$Type = ($MultipartBlockStateGenerator$Part);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultipartBlockStateGenerator$Part$$Original = $MultipartBlockStateGenerator$Part;}
declare module "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$FlowingFluid} from "net.minecraft.world.level.material.FlowingFluid"
import {$FluidBuilder, $FluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $FlowingFluidBuilder extends $BuilderBase<($FlowingFluid)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "fluidBuilder": $FluidBuilder
readonly "id": $ResourceLocation

constructor(b: $FluidBuilder$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlowingFluidBuilder$$Type = ($FlowingFluidBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlowingFluidBuilder$$Original = $FlowingFluidBuilder;}
declare module "dev.latvian.mods.kubejs.event.EventHandler" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$EventGroup} from "dev.latvian.mods.kubejs.event.EventGroup"
import {$BaseFunction} from "dev.latvian.mods.rhino.BaseFunction"
import {$IEventHandler$$Type} from "dev.latvian.mods.kubejs.event.IEventHandler"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$TargetedEventHandler} from "dev.latvian.mods.kubejs.event.TargetedEventHandler"
import {$Supplier} from "java.util.function.Supplier"
import {$ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$ScriptTypePredicate} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"
import {$ScriptTypeHolder$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$Class} from "java.lang.Class"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$EventTargetType$$Type} from "dev.latvian.mods.kubejs.event.EventTargetType"
import {$EventHandlerContainer$$Type} from "dev.latvian.mods.kubejs.event.EventHandlerContainer"
import {$EventResult} from "dev.latvian.mods.kubejs.event.EventResult"

export class $EventHandler extends $BaseFunction {
static readonly "DONTENUM": integer
readonly "eventType": $Supplier<($Class<($KubeEvent)>)>
readonly "scriptTypePredicate": $ScriptTypePredicate
static readonly "CONST": integer
readonly "name": StringJS
static readonly "UNINITIALIZED_CONST": integer
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "PERMANENT": integer
readonly "group": $EventGroup

public "hasListeners"(): boolean
public "toString"(): StringJS
public "listen"(type: $ScriptType$$Type, extraId: any, handler: $IEventHandler$$Type): void
public "call"(scope: $Scriptable$$Type, thisObj: $Scriptable$$Type, args: (any)[]): any
public "post"(scriptType: $ScriptTypeHolder$$Type, event: $KubeEvent$$Type): $EventResult
public "post"(event: $KubeEvent$$Type): $EventResult
public "hasResult"(): $EventHandler
public "requiredTarget"<E>(type: $EventTargetType$$Type<(E)>): $TargetedEventHandler<(E)>
public "supportsTarget"<E>(type: $EventTargetType$$Type<(E)>): $TargetedEventHandler<(E)>
public "forEachListener"(type: $ScriptType$$Type, callback: $Consumer$$Type<($EventHandlerContainer)>): void
public "get"(arg1: integer, arg2: $Scriptable$$Type): any
public "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
public "delete"(arg1: integer): void
public "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
public "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
public "setParentScope"(arg0: $Scriptable$$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(): (any)[]
public "getPrototype"(): $Scriptable
public "setPrototype"(arg0: $Scriptable$$Type): void
public "getIds"(): (any)[]
set "parentScope"(value: $Scriptable$$Type)
get "parentScope"(): $Scriptable
get "allIds"(): (any)[]
get "prototype"(): $Scriptable
set "prototype"(value: $Scriptable$$Type)
get "ids"(): (any)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventHandler$$Type = ($EventHandler);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventHandler$$Original = $EventHandler;}
declare module "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionHolder" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$SlotFilter, $SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"
import {$IngredientAction, $IngredientAction$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction"
import {$Record} from "java.lang.Record"

export class $IngredientActionHolder extends $Record {
static readonly "LIST_STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($List<($IngredientActionHolder)>)>
static readonly "CODEC": $Codec<($IngredientActionHolder)>
static readonly "LIST_CODEC": $Codec<($List<($IngredientActionHolder)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IngredientActionHolder)>

constructor(action: $IngredientAction$$Type, filter: $SlotFilter$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $SlotFilter
public "action"(): $IngredientAction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientActionHolder$$Type = ({"filter"?: $SlotFilter$$Type, "action"?: $IngredientAction$$Type}) | ([filter?: $SlotFilter$$Type, action?: $IngredientAction$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientActionHolder$$Original = $IngredientActionHolder;}
declare module "dev.latvian.mods.kubejs.block.BlockStoppedFallingKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$FallingBlockEntity$$Type} from "net.minecraft.world.entity.item.FallingBlockEntity"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a falling block finishes falling.
 */
export class $BlockStoppedFallingKubeEvent implements $KubeEntityEvent$$Interface {
readonly "fallSpeed": double
readonly "replacedBlock": $LevelBlock
readonly "block": $LevelBlock

constructor(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, entity: $FallingBlockEntity$$Type, fallSpeed: double, replacedState: $BlockState$$Type)

public "getLevel"(): $Level
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStoppedFallingKubeEvent$$Type = ($BlockStoppedFallingKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStoppedFallingKubeEvent$$Original = $BlockStoppedFallingKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext" {
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$ErrorStack, $ErrorStack$$Type} from "dev.latvian.mods.kubejs.util.ErrorStack"
import {$RecipeMatchContext$$Interface} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$RecipeLikeKJS} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$KubeRecipeContext$$Interface} from "dev.latvian.mods.kubejs.recipe.KubeRecipeContext"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RecipeValidationContext$$Interface extends $KubeRecipeContext$$Interface, $RecipeMatchContext$$Interface {

(): $ErrorStack$$Type
}

export class $RecipeValidationContext implements $RecipeValidationContext$$Interface {
 "errors"(): $ErrorStack
 "ops"(): $RegistryOpsContainer
 "recipe"(): $RecipeLikeKJS
 "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeValidationContext$$Type = (() => $ErrorStack$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeValidationContext$$Original = $RecipeValidationContext;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RemoveRecipesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"

export interface $RemoveRecipesKubeEvent$$Interface extends $KubeEvent$$Interface {

(category: $ResourceLocation, recipesToRemove: ($ResourceLocation)[]): void
}

export class $RemoveRecipesKubeEvent implements $RemoveRecipesKubeEvent$$Interface {
 "remove"(recipesToRemove: (Special.RecipeId)[]): void
 "removeFromCategory"(category: $ResourceLocation$$Type, recipesToRemove: ($ResourceLocation$$Type)[]): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveRecipesKubeEvent$$Type = ((category: $ResourceLocation, recipesToRemove: ($ResourceLocation)[]) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RemoveRecipesKubeEvent$$Original = $RemoveRecipesKubeEvent;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.TextIcons" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Style} from "net.minecraft.network.chat.Style"
import {$MutableComponent, $MutableComponent$$Type} from "net.minecraft.network.chat.MutableComponent"
import {$Component} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $TextIcons$$Interface {
}

export class $TextIcons implements $TextIcons$$Interface {
static readonly "STYLE": $Style
static readonly "FONT": $ResourceLocation
static readonly "NAME": $Component
static readonly "ALL_ICONS": StringJS

static "info"(): $MutableComponent
static "id"(): $MutableComponent
static "copy"(): $MutableComponent
static "error"(): $MutableComponent
static "warn"(): $MutableComponent
static "minus"(): $MutableComponent
static "tag"(): $MutableComponent
static "plus"(): $MutableComponent
static "no"(): $MutableComponent
static "itemTag"(): $MutableComponent
static "yes"(): $MutableComponent
static "yes"(yes: boolean): $MutableComponent
static "camera"(): $MutableComponent
static "tilde"(): $MutableComponent
static "smallSpace"(): $MutableComponent
static "fluidTag"(): $MutableComponent
static "logo"(): $MutableComponent
static "icons"(characters: StringJS): $MutableComponent
static "icon"(character: $MutableComponent$$Type): $MutableComponent
static "vscode"(): $MutableComponent
static "crafting"(): $MutableComponent
static "prototypeComponent"(): $MutableComponent
static "patchedComponent"(): $MutableComponent
static "blockTagIcon"(): $MutableComponent
static "entityTypeTag"(): $MutableComponent
static "fire"(): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextIcons$$Type = ($TextIcons);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TextIcons$$Original = $TextIcons;}
declare module "dev.latvian.mods.kubejs.block.custom.ButtonOrPressurePlateBuilder" {
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"

export interface $ButtonOrPressurePlateBuilder$$Interface {
}

export class $ButtonOrPressurePlateBuilder implements $ButtonOrPressurePlateBuilder$$Interface {
 "ticksToStayPressed"(ticks: $TickDuration$$Type): this
 "behaviour"(behaviour: $BlockSetType$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ButtonOrPressurePlateBuilder$$Type = ($ButtonOrPressurePlateBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ButtonOrPressurePlateBuilder$$Original = $ButtonOrPressurePlateBuilder;}
declare module "dev.latvian.mods.kubejs.recipe.component.ComponentRole" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $ComponentRole extends $Enum<($ComponentRole)> implements $StringRepresentable$$Interface {
static readonly "OTHER": $ComponentRole
static readonly "INPUT": $ComponentRole
static readonly "CODEC": $Codec<($ComponentRole)>
static readonly "OUTPUT": $ComponentRole

public static "values"(): ($ComponentRole)[]
public static "valueOf"(name: StringJS): $ComponentRole
public "isOther"(): boolean
public "isInput"(): boolean
public "getSerializedName"(): StringJS
public "isOutput"(): boolean
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "other"(): boolean
get "input"(): boolean
get "serializedName"(): StringJS
get "output"(): boolean
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentRole$$Type = (("input") | ("output") | ("other"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComponentRole$$Original = $ComponentRole;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeSchemaType} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$LinkedHashMap} from "java.util.LinkedHashMap"
import {$RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$RecipeSchemaStorage, $RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RegistryAwareSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RegistryAwareSchema"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"

export class $RecipeNamespace extends $LinkedHashMap<(StringJS), ($RecipeSchemaType)> {
readonly "name": StringJS
readonly "storage": $RecipeSchemaStorage

constructor(storage: $RecipeSchemaStorage$$Type, name: StringJS)

public "toString"(): StringJS
public "register"(id: StringJS, type: $RegistryAwareSchema$$Type): $RecipeNamespace
public "register"(id: StringJS, type: $RecipeSchema$$Type): $RecipeNamespace
public "registerBasic"(id: StringJS, ...keys: ($RecipeKey$$Type<(never)>)[]): $RecipeNamespace
public "shaped"(id: StringJS): $RecipeNamespace
public "withExistingParent"(id: StringJS, parent: $ResourceLocation$$Type): $RecipeNamespace
public "special"(id: StringJS): $RecipeNamespace
public "shapeless"(id: StringJS): $RecipeNamespace
public "getRegisteredOrThrow"(id: StringJS): $RecipeSchemaType
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeNamespace$$Type = ($RecipeNamespace);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeNamespace$$Original = $RecipeNamespace;}
declare module "dev.latvian.mods.kubejs.item.custom.ShearsItemBuilder" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ItemBuilder} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ShearsItemBuilder extends $ItemBuilder {
 "sourceLine": $SourceLine
static readonly "SHEAR_TAGS": ($ResourceLocation)[]
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "speedBaseline"(f: float): this
public static "isCustomShears"(stack: $ItemStack$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShearsItemBuilder$$Type = ($ShearsItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShearsItemBuilder$$Original = $ShearsItemBuilder;}
declare module "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessor" {
import {$KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipePostProcessorType} from "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessorType"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"

export interface $RecipePostProcessor$$Interface {
}

export class $RecipePostProcessor implements $RecipePostProcessor$$Interface {
 "type"(): $RecipePostProcessorType<(never)>
 "process"(ctx: $RecipeValidationContext$$Type, recipe: $KubeRecipe$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipePostProcessor$$Type = ($RecipePostProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipePostProcessor$$Original = $RecipePostProcessor;}
declare module "dev.latvian.mods.kubejs.block.custom.ButtonBlockBuilder" {
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$Consumer} from "java.util.function.Consumer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ButtonOrPressurePlateBuilder$$Interface} from "dev.latvian.mods.kubejs.block.custom.ButtonOrPressurePlateBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"

export class $ButtonBlockBuilder extends $ShapedBlockBuilder implements $ButtonOrPressurePlateBuilder$$Interface {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "BUTTON_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "ticksToStayPressed"(ticks: $TickDuration$$Type): $BlockBuilder
public "behaviour"(behaviour: $BlockSetType$$Type): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ButtonBlockBuilder$$Type = ($ButtonBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ButtonBlockBuilder$$Original = $ButtonBlockBuilder;}
declare module "dev.latvian.mods.kubejs.core.RecipeInputKJS" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$RecipeInput} from "net.minecraft.world.item.crafting.RecipeInput"
import {$List} from "java.util.List"
import {$SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RecipeInputKJS$$Interface {
}

export class $RecipeInputKJS implements $RecipeInputKJS$$Interface {
 "find"(filter: $SlotFilter$$Type): $ItemStack
 "find"(filter: $SlotFilter$$Type, skip: integer): $ItemStack
 "findAll"(): $List<($ItemStack)>
 "findAll"(filter: $SlotFilter$$Type): $List<($ItemStack)>
 "self"(): $RecipeInput
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeInputKJS$$Type = ($RecipeInputKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeInputKJS$$Original = $RecipeInputKJS;}
declare module "dev.latvian.mods.kubejs.core.PlayerSelector" {
import {$UUID$$Type} from "java.util.UUID"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $PlayerSelector$$Interface {

(server: $MinecraftServer): $ServerPlayer$$Type
}

export class $PlayerSelector implements $PlayerSelector$$Interface {
static "name"(name: StringJS): $PlayerSelector
static "wrap"(o: any): $PlayerSelector
static "identity"(player: $ServerPlayer$$Type): $PlayerSelector
 "or"(fallback: $PlayerSelector$$Type): $PlayerSelector
 "getPlayer"(server: $MinecraftServer$$Type): $ServerPlayer
static "uuid"(uuid: $UUID$$Type): $PlayerSelector
static "fuzzyName"(name: StringJS): $PlayerSelector
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerSelector$$Type = (StringJS) | ((server: $MinecraftServer) => $ServerPlayer$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerSelector$$Original = $PlayerSelector;}
declare module "dev.latvian.mods.kubejs.core.IngredientKJS" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$ItemStackSet} from "dev.latvian.mods.kubejs.item.ItemStackSet"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$WithCodec$$Interface} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$ItemMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ItemMatch"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ItemPredicate, $ItemPredicate$$Interface} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Set} from "java.util.Set"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$Stream} from "java.util.stream.Stream"
import {$SizedIngredient} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IngredientKJS$$Interface extends $ItemPredicate$$Interface, $Replaceable$$Interface, $WithCodec$$Interface, $ItemMatch$$Interface {

(itemStack: $ItemStack): boolean
get "stackArray"(): ($ItemStack)[]
get "tagKey"(): $TagKey<($Item)>
get "codec"(): $Codec<(never)>
get "wildcard"(): boolean
get "itemIds"(): $Set<(StringJS)>
get "first"(): $ItemStack
get "itemTypes"(): $Set<($Item)>
get "itemStream"(): $Stream<($Item)>
get "displayStacks"(): $ItemStackSet
get "stacks"(): $ItemStackSet
}

export class $IngredientKJS implements $IngredientKJS$$Interface {
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $Ingredient$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, item: $ItemStack$$Type, exact: boolean): boolean
 "containsAnyTag"(): boolean
 "getStackArray"(): ($ItemStack)[]
 "asStack"(): $SizedIngredient
 "getTagKey"(): $TagKey<($Item)>
 "withCount"(count: integer): $SizedIngredient
 "getCodec"(): $Codec<(never)>
 "isWildcard"(): boolean
 "self"(): $Ingredient
 "toIngredientString"(ops: $DynamicOps$$Type<($Tag$$Type)>): StringJS
 "asIngredient"(): $Ingredient
 "except"(subtracted: $Ingredient$$Type): $Ingredient
 "and"(ingredient: $Ingredient$$Type): $Ingredient
 "or"(ingredient: $Ingredient$$Type): $Ingredient
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "test"(itemStack: any): boolean
 "test"(itemStack: $ItemStack$$Type): boolean
static "wrap"(from: any): $ItemPredicate
 "testItem"(item: $Item$$Type): boolean
 "getItemIds"(): $Set<(StringJS)>
 "getFirst"(): $ItemStack
 "getItemTypes"(): $Set<($Item)>
 "getItemStream"(): $Stream<($Item)>
 "canBeUsedForMatching"(): boolean
 "getDisplayStacks"(): $ItemStackSet
 "getStacks"(): $ItemStackSet
 "toNBT"(): $Tag
 "toJson"(): $JsonElement
 "matches"(cx: $RecipeMatchContext$$Type, itemLike: $ItemLike$$Type, exact: boolean): boolean
 "matchesAny"(cx: $RecipeMatchContext$$Type, itemLikes: $Iterable$$Type<($ItemLike$$Type)>, exact: boolean): boolean
 "or"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "not"<T>(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "isEqual"<T>(arg0: any): $Predicate<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientKJS$$Type = ((itemStack: $ItemStack) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientKJS$$Original = $IngredientKJS;}
declare module "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder" {
import {$BlockRenderType$$Type} from "dev.latvian.mods.kubejs.block.BlockRenderType"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$PathType$$Type} from "net.minecraft.world.level.pathfinder.PathType"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$FluidType} from "net.neoforged.neoforge.fluids.FluidType"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$SoundAction$$Type} from "net.neoforged.neoforge.common.SoundAction"

export class $FluidTypeBuilder extends $BuilderBase<($FluidType)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

public "tint"(tint: $KubeColor$$Type): this
public "descriptionId"(descriptionId: StringJS): this
public "renderType"(renderType: $BlockRenderType$$Type): this
public "temperature"(temperature: integer): this
public "sound"(action: $SoundAction$$Type, sound: $SoundEvent$$Type): this
public "canHydrate"(canHydrate: boolean): this
public "canSwim"(canSwim: boolean): this
public "rarity"(rarity: $Rarity$$Type): this
public "addDripstoneDripping"(chance: float, dripParticle: $ParticleOptions$$Type, cauldron: $Block$$Type, fillSound: $SoundEvent$$Type): this
public "density"(density: integer): this
public "supportsBoating"(supportsBoating: boolean): this
public "canConvertToSource"(canConvertToSource: boolean): this
public "adjacentPathType"(adjacentPathType: $PathType$$Type): this
public "canDrown"(canDrown: boolean): this
public "pathType"(pathType: $PathType$$Type): this
public "lightLevel"(lightLevel: integer): this
public "viscosity"(viscosity: integer): this
public "flowingTexture"(flowingTexture: $ResourceLocation$$Type): this
public "stillTexture"(stillTexture: $ResourceLocation$$Type): this
public "motionScale"(motionScale: double): this
public "canExtinguish"(canExtinguish: boolean): this
public "canPushEntity"(canPushEntity: boolean): this
public "fallDistanceModifier"(fallDistanceModifier: float): this
public "screenOverlayTexture"(screenOverlayTexture: $ResourceLocation$$Type): this
public "blockOverlayTexture"(blockOverlayTexture: $ResourceLocation$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTypeBuilder$$Type = ($FluidTypeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidTypeBuilder$$Original = $FluidTypeBuilder;}
declare module "dev.latvian.mods.kubejs.registry.CustomBuilderObject" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $CustomBuilderObject extends $BuilderBase {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type, object: $Supplier$$Type<(any)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomBuilderObject$$Type = ($CustomBuilderObject);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomBuilderObject$$Original = $CustomBuilderObject;}
declare module "dev.latvian.mods.kubejs.script.WithScriptContext" {
import {$Context, $Context$$Type} from "dev.latvian.mods.rhino.Context"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $WithScriptContext$$Interface {

(): $Context$$Type
}

export class $WithScriptContext implements $WithScriptContext$$Interface {
 "cx"(): $Context
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithScriptContext$$Type = (() => $Context$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WithScriptContext$$Original = $WithScriptContext;}
declare module "dev.latvian.mods.kubejs.net.KubeServerData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$ItemTooltipData, $ItemTooltipData$$Type} from "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData"
import {$RecipeViewerData, $RecipeViewerData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.RecipeViewerData"
import {$Record} from "java.lang.Record"

export class $KubeServerData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($KubeServerData)>

constructor(recipeViewerData: ($RecipeViewerData$$Type)?, itemTooltipData: $List$$Type<($ItemTooltipData$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "collect"(): $KubeServerData
public "recipeViewerData"(): $Optional<($RecipeViewerData)>
public "itemTooltipData"(): $List<($ItemTooltipData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeServerData$$Type = ({"recipeViewerData"?: ($RecipeViewerData$$Type)?, "itemTooltipData"?: $List$$Type<($ItemTooltipData$$Type)>}) | ([recipeViewerData?: ($RecipeViewerData$$Type)?, itemTooltipData?: $List$$Type<($ItemTooltipData$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeServerData$$Original = $KubeServerData;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaRegistry" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeNamespace} from "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace"
import {$RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RegistryAwareSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RegistryAwareSchema"

export class $RecipeSchemaRegistry implements $KubeEvent$$Interface {
constructor(storage: $RecipeSchemaStorage$$Type)

public "register"(id: $ResourceLocation$$Type, schema: $RegistryAwareSchema$$Type): void
public "register"(id: $ResourceLocation$$Type, schema: $RecipeSchema$$Type): void
public "namespace"(namespace: StringJS): $RecipeNamespace
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchemaRegistry$$Type = ($RecipeSchemaRegistry);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeSchemaRegistry$$Original = $RecipeSchemaRegistry;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.RecipeViewerData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemData, $ItemData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData"
import {$CategoryData, $CategoryData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.CategoryData"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$FluidData, $FluidData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData"
import {$Record} from "java.lang.Record"

export class $RecipeViewerData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($RecipeViewerData)>

constructor(removedCategories: $List$$Type<($ResourceLocation$$Type)>, removedGlobalRecipes: $List$$Type<($ResourceLocation$$Type)>, categoryData: $List$$Type<($CategoryData$$Type)>, itemData: $ItemData$$Type, fluidData: $FluidData$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public static "collect"(): $RecipeViewerData
public "fluidData"(): $FluidData
public "itemData"(): $ItemData
public "removedCategories"(): $List<($ResourceLocation)>
public "removedGlobalRecipes"(): $List<($ResourceLocation)>
public "categoryData"(): $List<($CategoryData)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeViewerData$$Type = ({"categoryData"?: $List$$Type<($CategoryData$$Type)>, "removedCategories"?: $List$$Type<($ResourceLocation$$Type)>, "removedGlobalRecipes"?: $List$$Type<($ResourceLocation$$Type)>, "fluidData"?: $FluidData$$Type, "itemData"?: $ItemData$$Type}) | ([categoryData?: $List$$Type<($CategoryData$$Type)>, removedCategories?: $List$$Type<($ResourceLocation$$Type)>, removedGlobalRecipes?: $List$$Type<($ResourceLocation$$Type)>, fluidData?: $FluidData$$Type, itemData?: $ItemData$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeViewerData$$Original = $RecipeViewerData;}
declare module "dev.latvian.mods.kubejs.core.ItemEntityKJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$EntityKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityKJS"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ItemEntityKJS$$Interface extends $EntityKJS$$Interface {
get "infinitePickUpDelay"(): void
set "ticksUntilDespawn"(value: integer)
get "noPickUpDelay"(): void
get "defaultPickUpDelay"(): void
get "ticksUntilDespawn"(): integer
get "noDespawn"(): void
set "lifespan"(value: integer)
get "lifespan"(): integer
get "item"(): $ItemStack
get "peacefulCreature"(): boolean
get "waterCreature"(): boolean
get "ambientCreature"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "nbt"(): $CompoundTag
set "x"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "z"(value: double)
get "living"(): boolean
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "block"(): $LevelBlock
get "server"(): $MinecraftServer
get "motionX"(): double
set "motionY"(value: double)
get "facing"(): $Direction
get "profile"(): $GameProfile
get "frame"(): boolean
get "passengers"(): $EntityArrayList
get "player"(): boolean
get "motionZ"(): double
get "type"(): StringJS
set "motionZ"(value: double)
get "animal"(): boolean
get "monster"(): boolean
get "teamId"(): StringJS
get "motionY"(): double
set "motionX"(value: double)
get "scriptType"(): $ScriptType
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $ItemEntityKJS implements $ItemEntityKJS$$Interface {
 "setInfinitePickUpDelay"(): void
 "setTicksUntilDespawn"(ticks: integer): void
 "setNoPickUpDelay"(): void
 "setDefaultPickUpDelay"(): void
 "getTicksUntilDespawn"(): integer
 "setNoDespawn"(): void
 "setLifespan"(lifespan: integer): void
 "getLifespan"(): integer
 "self"(): $Entity
 "getItem"(): $ItemStack
 "isPeacefulCreature"(): boolean
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isAmbientCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "getNbt"(): $CompoundTag
 "setX"(x: double): void
 "attack"(hp: float): void
 "spawn"(): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "runCommandSilent"(command: StringJS): void
 "tell"(message: $Component$$Type): void
 "isLiving"(): boolean
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "playSound"(id: $SoundEvent$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "getServer"(): $MinecraftServer
 "getMotionX"(): double
 "setMotionY"(y: double): void
 "getFacing"(): $Direction
 "getProfile"(): $GameProfile
 "isFrame"(): boolean
 "getPassengers"(): $EntityArrayList
 "isPlayer"(): boolean
 "setRotation"(yaw: float, pitch: float): void
 "getMotionZ"(): double
 "getType"(): StringJS
 "setMotionZ"(z: double): void
 "isAnimal"(): boolean
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "isMonster"(): boolean
 "getTeamId"(): StringJS
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getMotionY"(): double
 "setMotionX"(x: double): void
 "getScriptType"(): $ScriptType
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$$Type): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEntityKJS$$Type = ($ItemEntityKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemEntityKJS$$Original = $ItemEntityKJS;}
declare module "dev.latvian.mods.kubejs.core.LazyComponentKJS" {
import {$Supplier$$Interface} from "java.util.function.Supplier"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $LazyComponentKJS$$Interface extends $Supplier$$Interface<($Component)> {

(): $Component$$Type
}

export class $LazyComponentKJS implements $LazyComponentKJS$$Interface {
 "get"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LazyComponentKJS$$Type = (() => $Component$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LazyComponentKJS$$Original = $LazyComponentKJS;}
declare module "dev.latvian.mods.kubejs.script.KubeJSFileWatcherThread" {
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Thread} from "java.lang.Thread"
import {$Runnable, $Runnable$$Type} from "java.lang.Runnable"
import {$ScriptFile, $ScriptFile$$Type} from "dev.latvian.mods.kubejs.script.ScriptFile"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $KubeJSFileWatcherThread extends $Thread {
readonly "reload": $Runnable
readonly "scriptType": $ScriptType
static readonly "MIN_PRIORITY": integer
readonly "files": ($ScriptFile)[]
static readonly "MAX_PRIORITY": integer
static readonly "NORM_PRIORITY": integer

constructor(scriptType: $ScriptType$$Type, files: ($ScriptFile$$Type)[], reload: $Runnable$$Type)

public "run"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSFileWatcherThread$$Type = ($KubeJSFileWatcherThread);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSFileWatcherThread$$Original = $KubeJSFileWatcherThread;}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate" {
import {$BlockIDPredicate$PropertyObject} from "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate$PropertyObject"
import {$LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$BlockPredicate$$Interface} from "dev.latvian.mods.kubejs.block.predicate.BlockPredicate"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$List} from "java.util.List"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockIDPredicate implements $BlockPredicate$$Interface {
constructor(i: $ResourceLocation$$Type)

public "toString"(): StringJS
public "with"(key: StringJS, value: StringJS): $BlockIDPredicate
public "check"(b: $LevelBlock$$Type): boolean
public "checkState"(state: $BlockState$$Type): boolean
public "getBlockState"(): $BlockState
public "getBlockProperties"(): $List<($BlockIDPredicate$PropertyObject)>
get "blockState"(): $BlockState
get "blockProperties"(): $List<($BlockIDPredicate$PropertyObject)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockIDPredicate$$Type = ($BlockIDPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockIDPredicate$$Original = $BlockIDPredicate;}
declare module "dev.latvian.mods.kubejs.player.StageChangedEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$Stages, $Stages$$Type} from "dev.latvian.mods.kubejs.stages.Stages"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $StageChangedEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, stages: $Stages$$Type, stage: StringJS)

public "getEntity"(): $LivingEntity
public "getPlayer"(): $Player
public "getStage"(): StringJS
public "getPlayerStages"(): $Stages
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "entity"(): $LivingEntity
get "player"(): $Player
get "stage"(): StringJS
get "playerStages"(): $Stages
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StageChangedEvent$$Type = ($StageChangedEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StageChangedEvent$$Original = $StageChangedEvent;}
declare module "dev.latvian.mods.kubejs.block.BlockStartedFallingKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$FallingBlockEntity$$Type} from "net.minecraft.world.entity.item.FallingBlockEntity"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a falling block starts to fall.
 */
export class $BlockStartedFallingKubeEvent implements $KubeEntityEvent$$Interface {
constructor(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, entity: $FallingBlockEntity$$Type)

public "getLevel"(): $Level
public "getBlock"(): $LevelBlock
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "block"(): $LevelBlock
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStartedFallingKubeEvent$$Type = ($BlockStartedFallingKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStartedFallingKubeEvent$$Original = $BlockStartedFallingKubeEvent;}
declare module "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export interface $KubeLivingEntityEvent$$Interface extends $KubeEntityEvent$$Interface {

(): $LivingEntity$$Type
get "entity"(): $LivingEntity
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}

export class $KubeLivingEntityEvent implements $KubeLivingEntityEvent$$Interface {
 "getEntity"(): $LivingEntity
 "getLevel"(): $Level
 "getPlayer"(): $Player
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeLivingEntityEvent$$Type = (() => $LivingEntity$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeLivingEntityEvent$$Original = $KubeLivingEntityEvent;}
declare module "dev.latvian.mods.kubejs.block.custom.FallingBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $FallingBlockBuilder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "dustColor"(color: $KubeColor$$Type): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FallingBlockBuilder$$Type = ($FallingBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FallingBlockBuilder$$Original = $FallingBlockBuilder;}
declare module "dev.latvian.mods.kubejs.player.KubeJSInventoryListener" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ContainerListener$$Interface} from "net.minecraft.world.inventory.ContainerListener"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"

export class $KubeJSInventoryListener implements $ContainerListener$$Interface {
readonly "player": $Player

constructor(p: $Player$$Type)

public "slotChanged"(container: $AbstractContainerMenu$$Type, index: integer, stack: $ItemStack$$Type): void
public "dataChanged"(container: $AbstractContainerMenu$$Type, id: integer, value: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSInventoryListener$$Type = ($KubeJSInventoryListener);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSInventoryListener$$Original = $KubeJSInventoryListener;}
declare module "dev.latvian.mods.kubejs.entity.CheckLivingEntitySpawnKubeEvent" {
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$MobSpawnType, $MobSpawnType$$Type} from "net.minecraft.world.entity.MobSpawnType"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Either$$Type} from "com.mojang.datafixers.util.Either"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$WrappedSpawner} from "dev.latvian.mods.kubejs.level.WrappedSpawner"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked before an entity is spawned into the world.
 * 
 * Only entities from a `BaseSpawner` or world generation will trigger this event.
 */
export class $CheckLivingEntitySpawnKubeEvent implements $KubeLivingEntityEvent$$Interface {
readonly "x": double
readonly "y": double
readonly "z": double

constructor(entity: $LivingEntity$$Type, level: $Level$$Type, x: double, y: double, z: double, type: $MobSpawnType$$Type, spawnerEither: $Either$$Type<($BlockEntity$$Type), ($Entity$$Type)>)

/**
 * The type of spawn.
 */
public "getType"(): $MobSpawnType
/**
 * The level the entity is being spawned into.
 */
public "getLevel"(): $Level
/**
 * The block the entity is being spawned on.
 */
public "getBlock"(): $LevelBlock
/**
 * The spawner that spawned the entity.
 */
public "getSpawner"(): $WrappedSpawner
/**
 * The entity being spawned.
 */
public "getEntity"(): $LivingEntity
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "type"(): $MobSpawnType
get "level"(): $Level
get "block"(): $LevelBlock
get "spawner"(): $WrappedSpawner
get "entity"(): $LivingEntity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CheckLivingEntitySpawnKubeEvent$$Type = ($CheckLivingEntitySpawnKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CheckLivingEntitySpawnKubeEvent$$Original = $CheckLivingEntitySpawnKubeEvent;}
declare module "dev.latvian.mods.kubejs.item.JukeboxSongBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$JukeboxSong} from "net.minecraft.world.item.JukeboxSong"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export class $JukeboxSongBuilder extends $BuilderBase<($JukeboxSong)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

public "song"(sound: $Holder$$Type<($SoundEvent)>, length: float): this
public "description"(description: $Component$$Type): this
public "comparatorOutput"(comparatorOutput: integer): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JukeboxSongBuilder$$Type = ($JukeboxSongBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JukeboxSongBuilder$$Original = $JukeboxSongBuilder;}
declare module "dev.latvian.mods.kubejs.core.ContainerKJS" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Container} from "net.minecraft.world.Container"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$InventoryKJS$$Interface} from "dev.latvian.mods.kubejs.core.InventoryKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ContainerKJS$$Interface extends $InventoryKJS$$Interface {
get "width"(): integer
get "height"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "changed"(): void
get "empty"(): boolean
get "allItems"(): $List<($ItemStack)>
}

export class $ContainerKJS implements $ContainerKJS$$Interface {
 "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
 "getWidth"(): integer
 "getHeight"(): integer
 "isMutable"(): boolean
 "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
 "getSlots"(): integer
 "getSlotLimit"(slot: integer): integer
 "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
 "setChanged"(): void
 "getStackInSlot"(slot: integer): $ItemStack
 "asContainer"(): $Container
 "clear"(): void
 "self"(): $Container
 "getBlock"(level: $Level$$Type): $LevelBlock
 "isEmpty"(): boolean
 "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "countNonEmpty"(): integer
 "countNonEmpty"(match: $ItemPredicate$$Type): integer
 "getAllItems"(): $List<($ItemStack)>
 "clear"(match: $ItemPredicate$$Type): void
 "find"(): integer
 "find"(match: $ItemPredicate$$Type): integer
 "count"(): integer
 "count"(match: $ItemPredicate$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerKJS$$Type = ($ContainerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ContainerKJS$$Original = $ContainerKJS;}
declare module "dev.latvian.mods.kubejs.core.AdvancementNodeKJS" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$DisplayInfo} from "net.minecraft.advancements.DisplayInfo"
import {$AdvancementNode, $AdvancementNode$$Type} from "net.minecraft.advancements.AdvancementNode"
import {$Set} from "java.util.Set"
import {$Component} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $AdvancementNodeKJS$$Interface {
get "title"(): $Component
get "id"(): $ResourceLocation
get "parent"(): $AdvancementNode
get "children"(): $Set<($AdvancementNode)>
get "description"(): $Component
get "display"(): $DisplayInfo
get "displayText"(): $Component
}

export class $AdvancementNodeKJS implements $AdvancementNodeKJS$$Interface {
 "getTitle"(): $Component
 "getId"(): $ResourceLocation
 "self"(): $AdvancementNode
 "getParent"(): $AdvancementNode
 "getChildren"(): $Set<($AdvancementNode)>
 "addChild"(a: $AdvancementNode$$Type): void
 "hasDisplay"(): boolean
 "getDescription"(): $Component
 "getDisplay"(): $DisplayInfo
 "getDisplayText"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdvancementNodeKJS$$Type = ($AdvancementNodeKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AdvancementNodeKJS$$Original = $AdvancementNodeKJS;}
declare module "dev.latvian.mods.kubejs.client.BlockEntityRendererRegistryKubeEvent" {
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityRendererProvider$$Type} from "net.minecraft.client.renderer.blockentity.BlockEntityRendererProvider"
import {$EntityRenderersEvent$RegisterRenderers$$Type} from "net.neoforged.neoforge.client.event.EntityRenderersEvent$RegisterRenderers"
import {$Minecraft} from "net.minecraft.client.Minecraft"

export class $BlockEntityRendererRegistryKubeEvent implements $ClientKubeEvent$$Interface {
constructor(event: $EntityRenderersEvent$RegisterRenderers$$Type)

public "register"(type: $BlockEntityType$$Type<(never)>, renderer: $BlockEntityRendererProvider$$Type): void
public "getClient"(): $Minecraft
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityRendererRegistryKubeEvent$$Type = ($BlockEntityRendererRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityRendererRegistryKubeEvent$$Original = $BlockEntityRendererRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.drop.BlockDropSupplier" {
import {$BlockDrops, $BlockDrops$$Type} from "dev.latvian.mods.kubejs.block.drop.BlockDrops"

export interface $BlockDropSupplier$$Interface {

(): $BlockDrops$$Type
}

export class $BlockDropSupplier implements $BlockDropSupplier$$Interface {
static readonly "NO_DROPS": $BlockDropSupplier

 "get"(): $BlockDrops
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockDropSupplier$$Type = (() => $BlockDrops$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockDropSupplier$$Original = $BlockDropSupplier;}
declare module "dev.latvian.mods.kubejs.item.ItemModificationKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemModificationKubeEvent$ItemModifications$$Type} from "dev.latvian.mods.kubejs.item.ItemModificationKubeEvent$ItemModifications"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Consumer$$Type} from "java.util.function.Consumer"

/**
 * Invoked after all items are registered to modify them.
 */
export class $ItemModificationKubeEvent implements $KubeEvent$$Interface {
constructor()

/**
 * Modifies items matching the given ingredient.
 * 
 * **NOTE**: tag ingredients are not supported at this time.
 */
public "modify"(arg0: $ItemPredicate$$Type, c: $Consumer$$Type<($ItemModificationKubeEvent$ItemModifications)>): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModificationKubeEvent$$Type = ($ItemModificationKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemModificationKubeEvent$$Original = $ItemModificationKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Value" {
import {$CustomObjectRecipeComponent$Key, $CustomObjectRecipeComponent$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key"
import {$Comparable, $Comparable$$Interface} from "java.lang.Comparable"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$Map$Entry, $Map$Entry$$Type, $Map$Entry$$Interface} from "java.util.Map$Entry"
import {$Record} from "java.lang.Record"

export class $CustomObjectRecipeComponent$Value extends $Record implements $Map$Entry$$Interface<($CustomObjectRecipeComponent$Key), (any)>, $Comparable$$Interface<($CustomObjectRecipeComponent$Value)> {
constructor(key: $CustomObjectRecipeComponent$Key$$Type, index: integer, value: any)

public "index"(): integer
public "value"(): any
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "compareTo"(value: any): integer
public "compareTo"(value: $CustomObjectRecipeComponent$Value$$Type): integer
public "getValue"(): any
public "getKey"(): any
public "key"(): $CustomObjectRecipeComponent$Key
public "setValue"(object: any): any
public static "copyOf"<K, V>(arg0: $Map$Entry$$Type<($CustomObjectRecipeComponent$Key$$Type), (any)>): $Map$Entry<($CustomObjectRecipeComponent$Key), (any)>
public static "comparingByKey"<K, V>(arg0: $Comparator$$Type<($CustomObjectRecipeComponent$Key)>): $Comparator<($Map$Entry<($CustomObjectRecipeComponent$Key), (any)>)>
public static "comparingByKey"<K extends $Comparable<(object)>, V>(): $Comparator<($Map$Entry<($CustomObjectRecipeComponent$Key), (any)>)>
public static "comparingByValue"<K, V extends $Comparable<(object)>>(): $Comparator<($Map$Entry<($CustomObjectRecipeComponent$Key), (any)>)>
public static "comparingByValue"<K, V>(arg0: $Comparator$$Type<(any)>): $Comparator<($Map$Entry<($CustomObjectRecipeComponent$Key), (any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomObjectRecipeComponent$Value$$Type = ({"index"?: integer, "value"?: any, "key"?: $CustomObjectRecipeComponent$Key$$Type}) | ([index?: integer, value?: any, key?: $CustomObjectRecipeComponent$Key$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomObjectRecipeComponent$Value$$Original = $CustomObjectRecipeComponent$Value;}
declare module "dev.latvian.mods.kubejs.block.BlockRightClickedKubeEvent" {
import {$BlockHitResult, $BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player right clicks on a block.
 */
export class $BlockRightClickedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(item: $ItemStack$$Type, player: $Player$$Type, hand: $InteractionHand$$Type, pos: $BlockPos$$Type, direction: $Direction$$Type, hitResult: $BlockHitResult$$Type)

/**
 * The position of the block that was right clicked.
 */
public "getItem"(): $ItemStack
/**
 * The block that was right clicked.
 */
public "getBlock"(): $LevelBlock
/**
 * The player that right clicked the block.
 */
public "getEntity"(): $LivingEntity
/**
 * The hand that was used to right click the block.
 */
public "getHand"(): $InteractionHand
public "getHitResult"(): $BlockHitResult
/**
 * The face of the block being right clicked.
 */
public "getFacing"(): $Direction
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "item"(): $ItemStack
get "block"(): $LevelBlock
get "entity"(): $LivingEntity
get "hand"(): $InteractionHand
get "hitResult"(): $BlockHitResult
get "facing"(): $Direction
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRightClickedKubeEvent$$Type = ($BlockRightClickedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockRightClickedKubeEvent$$Original = $BlockRightClickedKubeEvent;}
declare module "dev.latvian.mods.kubejs.item.custom.SmithingTemplateItemBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$ItemBuilder} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $SmithingTemplateItemBuilder extends $ItemBuilder {
 "ingredientsText": $Component
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "appliesToText": $Component
readonly "ingredientsSlotEmptyIcons": $List<($ResourceLocation)>
 "appliesToSlotDescriptionText": $Component
readonly "appliesToEmptyIcons": $List<($ResourceLocation)>
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "ingredientSlotDescriptionText": $Component

constructor(i: $ResourceLocation$$Type)

/**
 * Sets the name for this smithing template.
 * Note that the normal display name for all smithing templates is the same and cannot be changed, this instead sets the name in the tooltip (see vanilla smithing templates for what this looks like).
 * 
 * This will be overridden by a lang file if it exists.
 */
public "displayName"(name: $Component$$Type): this
/**
 * Sets the description text that shows in the item tooltip to describe what ingredients can be added.
 * Using 'Ingots & Crystals' or 'Netherite Ingot' will use the vanilla language keys so it is translated into other languages automatically.
 * THIS IS PURELY VISUAL
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `ingredientsText` field.
 */
public "ingredients"(text: StringJS): this
/**
 * Sets the description text that shows in the item tooltip to describe what it can be applied to.
 * Using 'Armor' or 'Diamond Equipment' will use the vanilla language keys so it is translated into other languages automatically.
 * THIS IS PURELY VISUAL
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `ingredientsText` field.
 */
public "appliesTo"(text: StringJS): this
/**
 * Adds a sword to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "swordIcon"(): this
/**
 * Adds a quartz to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "quartzIcon"(): this
/**
 * Adds a axe to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "axeIcon"(): this
/**
 * Adds a hoe to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "hoeIcon"(): this
/**
 * Adds an ingot to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "ingotIcon"(): this
/**
 * Adds a shovel to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "shovelIcon"(): this
/**
 * Adds a dust to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "dustIcon"(): this
/**
 * Adds boots to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "bootsIcon"(): this
/**
 * Adds all armor icons to the list of base slot icons that the smithing table cycles through when this smithing template is put in
 */
public "armorIcons"(): this
/**
 * Adds all basic tool icons to the list of base slot icons that the smithing table cycles through when this smithing template is put in
 */
public "toolIcons"(): this
/**
 * Adds a helmet to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "helmetIcon"(): this
/**
 * Adds a lapis lazuli to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "lapisIcon"(): this
/**
 * Adds an amethyst shard to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "shardIcon"(): this
/**
 * Adds the specified texture location to the list of base slot icons that the smithing table cycles through when this smithing template is put in.
 */
public "addAppliesToSlotIcon"(location: $ResourceLocation$$Type): this
/**
 * Adds the specified texture location to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "addIngredientsSlotIcon"(location: $ResourceLocation$$Type): this
/**
 * Adds an ingot, dust, diamond, emerald, quartz, lapis lazuli and amethyst shard icons to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "ingotAndCrystalIcons"(): this
/**
 * Sets the description text that shows when you hover over the ingredient slot when this item is put in smithing table as a template.
 * Using 'Add ingot or crystal' or 'Add Netherite Ingot' will use the vanilla language keys so it is translated into other languages automatically.
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `ingredientSlotDescriptionText` field.
 */
public "ingredientsSlotDescription"(text: StringJS): this
/**
 * Sets the description text that shows when you hover over the base item slot when this item is put in smithing table as a template.
 * Using 'Add a piece of armor' or 'Add diamond armor, weapon, or tool' will use the vanilla language keys so it is translated into other languages automatically.
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `appliesToSlotDescriptionText` field.
 */
public "appliesToSlotDescription"(text: StringJS): this
/**
 * Adds a diamond to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "diamondIcon"(): this
/**
 * Adds leggings to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "leggingsIcon"(): this
/**
 * Adds a pickaxe to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "pickaxeIcon"(): this
/**
 * Adds a chestplate to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "chestplateIcon"(): this
/**
 * Adds all armor and basic tool icons to the list of base slot icons that the smithing table cycles through when this smithing template is put in
 */
public "equipmentIcons"(): this
/**
 * Adds an emerald to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "emeraldIcon"(): this
/**
 * Adds a dust, diamond, emerald, quartz, lapis lazuli and amethyst shard icons to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "crystalIcons"(): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmithingTemplateItemBuilder$$Type = ($SmithingTemplateItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SmithingTemplateItemBuilder$$Original = $SmithingTemplateItemBuilder;}
declare module "dev.latvian.mods.kubejs.item.DynamicItemTooltipsKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"

export class $DynamicItemTooltipsKubeEvent implements $KubeEvent$$Interface {
readonly "item": $ItemStack
readonly "advanced": boolean
readonly "ctrl": boolean
readonly "startup": boolean
readonly "shift": boolean
readonly "alt": boolean
readonly "lines": $List<($Component)>
readonly "creative": boolean

constructor(item: $ItemStack$$Type, flags: $TooltipFlag$$Type, lines: $List$$Type<($Component$$Type)>, startup: boolean)

public "add"(text: $List$$Type<($Component$$Type)>): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicItemTooltipsKubeEvent$$Type = ($DynamicItemTooltipsKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DynamicItemTooltipsKubeEvent$$Original = $DynamicItemTooltipsKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Variant" {
import {$VariantBlockStateGenerator$Model} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Model"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonElement} from "com.google.gson.JsonElement"

export class $VariantBlockStateGenerator$Variant {
constructor()

public "model"(s: $ResourceLocation$$Type): $VariantBlockStateGenerator$Model
public "toJson"(): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateGenerator$Variant$$Type = ($VariantBlockStateGenerator$Variant);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VariantBlockStateGenerator$Variant$$Original = $VariantBlockStateGenerator$Variant;}
declare module "dev.latvian.mods.kubejs.client.ModelGenerator$Override" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $ModelGenerator$Override {
constructor(model: $ResourceLocation$$Type)

public "predicate"(property: $ResourceLocation$$Type, value: float): void
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$Override$$Type = ($ModelGenerator$Override);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModelGenerator$Override$$Original = $ModelGenerator$Override;}
declare module "dev.latvian.mods.kubejs.item.ItemPickedUpKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player picks up an item. Cancelling (in `ItemEvents.canPickUp`) will prevent the item from being picked up.
 */
export class $ItemPickedUpKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, entity: $ItemEntity$$Type, stack: $ItemStack$$Type)

/**
 * The item that was picked up.
 */
public "getItem"(): $ItemStack
/**
 * The player that picked up the item.
 */
public "getEntity"(): $Entity
/**
 * The item entity that was picked up.
 */
public "getItemEntity"(): $ItemEntity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "item"(): $ItemStack
get "entity"(): $Entity
get "itemEntity"(): $ItemEntity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPickedUpKubeEvent$$Type = ($ItemPickedUpKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemPickedUpKubeEvent$$Original = $ItemPickedUpKubeEvent;}
declare module "dev.latvian.mods.kubejs.text.action.TextAction" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Map} from "java.util.Map"
import {$TooltipActionType} from "dev.latvian.mods.kubejs.text.action.TooltipActionType"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"

export interface $TextAction$$Interface {
}

export class $TextAction implements $TextAction$$Interface {
static readonly "MAP": $Map<(integer), ($TooltipActionType<(never)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($TextAction)>

 "type"(): $TooltipActionType<(never)>
 "apply"(lines: $List$$Type<($Component$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextAction$$Type = ($TextAction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TextAction$$Original = $TextAction;}
declare module "dev.latvian.mods.kubejs.level.ExplosionKubeEvent$Before" {
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ExplosionKubeEvent} from "dev.latvian.mods.kubejs.level.ExplosionKubeEvent"

/**
 * Invoked right before an explosion happens.
 */
export class $ExplosionKubeEvent$Before extends $ExplosionKubeEvent {
constructor(level: $Level$$Type, explosion: $Explosion$$Type)

/**
 * Returns the size of the explosion.
 */
public "getSize"(): float
/**
 * Sets the size of the explosion.
 */
public "setSize"(s: float): void
get "size"(): float
set "size"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionKubeEvent$Before$$Type = ($ExplosionKubeEvent$Before);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExplosionKubeEvent$Before$$Original = $ExplosionKubeEvent$Before;}
declare module "dev.latvian.mods.kubejs.server.ServerKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export class $ServerKubeEvent implements $KubeEvent$$Interface {
readonly "server": $MinecraftServer

constructor(s: $MinecraftServer$$Type)

public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerKubeEvent$$Type = ($ServerKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerKubeEvent$$Original = $ServerKubeEvent;}
declare module "dev.latvian.mods.kubejs.fluid.FluidBuilder" {
import {$BlockRenderType$$Type} from "dev.latvian.mods.kubejs.block.BlockRenderType"
import {$FluidBucketItemBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder"
import {$FlowingFluid} from "net.minecraft.world.level.material.FlowingFluid"
import {$FluidBlockBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder"
import {$FluidTypeBuilder, $FluidTypeBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$FlowingFluidBuilder} from "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BaseFlowingFluid$Properties} from "net.neoforged.neoforge.fluids.BaseFlowingFluid$Properties"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $FluidBuilder extends $BuilderBase<($FlowingFluid)> {
static readonly "WATER_COLOR": $KubeColor
 "bucketItem": $FluidBucketItemBuilder
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "flowingFluid": $FlowingFluidBuilder
 "sourceLine": $SourceLine
 "fluidType": $FluidTypeBuilder
 "block": $FluidBlockBuilder
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "type"(builder: $Consumer$$Type<($FluidTypeBuilder)>): this
public "createProperties"(): $BaseFlowingFluid$Properties
public "displayName"(name: $Component$$Type): $BuilderBase<($FlowingFluid)>
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase<($FlowingFluid)>
public "tint"(c: $KubeColor$$Type): this
public "renderType"(l: $BlockRenderType$$Type): this
public "levelDecreasePerBlock"(levelDecreasePerBlock: integer): this
public "translucent"(): this
public "noBucket"(): this
public "noBlock"(): this
public "tickRate"(tickRate: integer): this
public "slopeFindDistance"(slopeFindDistance: integer): this
public "flowingTexture"(id: $ResourceLocation$$Type): this
public "stillTexture"(id: $ResourceLocation$$Type): this
public "explosionResistance"(explosionResistance: float): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBuilder$$Type = ($FluidBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidBuilder$$Original = $FluidBuilder;}
declare module "dev.latvian.mods.kubejs.script.PlatformWrapper$ModInfo" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $PlatformWrapper$ModInfo {
constructor(i: StringJS)

public "getName"(): StringJS
public "setName"(n: StringJS): void
public "getId"(): StringJS
public "getVersion"(): StringJS
public "getCustomName"(): StringJS
get "name"(): StringJS
set "name"(value: StringJS)
get "id"(): StringJS
get "version"(): StringJS
get "customName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformWrapper$ModInfo$$Type = ($PlatformWrapper$ModInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlatformWrapper$ModInfo$$Original = $PlatformWrapper$ModInfo;}
declare module "dev.latvian.mods.kubejs.player.ChestKubeEvent" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Container} from "net.minecraft.world.Container"
import {$AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$InventoryKubeEvent} from "dev.latvian.mods.kubejs.player.InventoryKubeEvent"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"

/**
 * Invoked when a player opens a chest.
 * 
 * Same as `PlayerEvents.inventoryOpened`, but only for chests.
 */
export class $ChestKubeEvent extends $InventoryKubeEvent {
constructor(player: $Player$$Type, menu: $AbstractContainerMenu$$Type)

/**
 * Gets the chest inventory.
 */
public "getInventory"(): $Container
/**
 * Gets the chest block.
 */
public "getBlock"(): $LevelBlock
/**
 * Gets the player that opened or closed the container.
 */
public "getEntity"(): $LivingEntity
get "inventory"(): $Container
get "block"(): $LevelBlock
get "entity"(): $LivingEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestKubeEvent$$Type = ($ChestKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestKubeEvent$$Original = $ChestKubeEvent;}
declare module "dev.latvian.mods.kubejs.fluid.ThickFluidBuilder" {
import {$FlowingFluidBuilder} from "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder"
import {$FluidBucketItemBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$FluidBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$KubeColor} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$FluidBlockBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder"
import {$FluidTypeBuilder} from "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ThickFluidBuilder extends $FluidBuilder {
static readonly "WATER_COLOR": $KubeColor
 "bucketItem": $FluidBucketItemBuilder
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "flowingFluid": $FlowingFluidBuilder
 "sourceLine": $SourceLine
 "fluidType": $FluidTypeBuilder
 "block": $FluidBlockBuilder
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThickFluidBuilder$$Type = ($ThickFluidBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ThickFluidBuilder$$Original = $ThickFluidBuilder;}
declare module "dev.latvian.mods.kubejs.util.JsonIO" {
import {$Map} from "java.util.Map"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$DataOutputStream$$Type} from "java.io.DataOutputStream"
import {$Path$$Type} from "java.nio.file.Path"
import {$JsonArray} from "com.google.gson.JsonArray"

export class $JsonIO {
constructor()

public static "toString"(json: $JsonElement$$Type): StringJS
public static "toArray"(element: $JsonElement$$Type): $JsonArray
public static "write"(path: $Path$$Type, json: $JsonElement$$Type): void
public static "read"(path: $Path$$Type): $Map<(never), (never)>
public static "parse"(string: StringJS): any
public static "readString"(path: $Path$$Type): StringJS
public static "readJson"(path: $Path$$Type): $JsonElement
public static "toObject"(json: $JsonElement$$Type): any
public static "toPrimitive"(element: $JsonElement$$Type): any
public static "parseRaw"(string: StringJS): $JsonElement
public static "toPrettyString"(json: $JsonElement$$Type): StringJS
public static "getJsonHashString"(json: $JsonElement$$Type): StringJS
public static "writeJsonHash"(stream: $DataOutputStream$$Type, element: $JsonElement$$Type): void
public static "getJsonHashBytes"(json: $JsonElement$$Type): (byte)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonIO$$Type = ($JsonIO);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JsonIO$$Original = $JsonIO;}
declare module "dev.latvian.mods.kubejs.client.LoadedTexture" {
import {$BufferedImage$$Type} from "java.awt.image.BufferedImage"
import {$Map$$Type} from "java.util.Map"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"

export class $LoadedTexture {
readonly "pixels": (integer)[]
readonly "width": integer
static readonly "EMPTY": $LoadedTexture
readonly "mcmeta": (byte)[]
readonly "height": integer

constructor(img: $BufferedImage$$Type, mcmeta: (byte)[])
constructor(width: integer, height: integer, pixels: (integer)[], mcmeta: (byte)[])

public "toBytes"(): (byte)[]
public static "load"(id: $ResourceLocation$$Type): $LoadedTexture
public "copy"(): $LoadedTexture
public "resize"(newWidth: integer, newHeight: integer): $LoadedTexture
public "tint"(tint: $KubeColor$$Type): $LoadedTexture
public "remap"(remap: $Map$$Type<($KubeColor$$Type), ($KubeColor$$Type)>): $LoadedTexture
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LoadedTexture$$Type = ($LoadedTexture);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LoadedTexture$$Original = $LoadedTexture;}
declare module "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$IngredientAction} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $IngredientActionType<T extends $IngredientAction> extends $Record {
static readonly "TYPES": $Lazy<($Map<($ResourceLocation), ($IngredientActionType<(never)>)>)>
static readonly "CODEC": $Codec<($IngredientActionType<(never)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IngredientActionType<(never)>)>

constructor(id: $ResourceLocation$$Type, codec: $MapCodec$$Type<(T)>)
constructor(id: $ResourceLocation$$Type, codec: $MapCodec$$Type<(T)>, streamCodec: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): $ResourceLocation
public "codec"(): $MapCodec<(T)>
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientActionType$$Type<T> = ({"id"?: $ResourceLocation$$Type, "codec"?: $MapCodec$$Type<(T)>, "streamCodec"?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>}) | ([id?: $ResourceLocation$$Type, codec?: $MapCodec$$Type<(T)>, streamCodec?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientActionType$$Original<T> = $IngredientActionType<(T)>;}
declare module "dev.latvian.mods.kubejs.core.RegistryObjectKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$List} from "java.util.List"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SpecialEquality$$Interface} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$Holder} from "net.minecraft.core.Holder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RegistryObjectKJS$$Interface<T> extends $SpecialEquality$$Interface {
get "id"(): StringJS
get "key"(): $ResourceKey<(T)>
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<(T)>)>
get "registry"(): $Registry<(T)>
get "tags"(): $List<($ResourceLocation)>
get "registryId"(): $ResourceKey<($Registry<(T)>)>
}

export class $RegistryObjectKJS<T> implements $RegistryObjectKJS$$Interface {
 "specialEquals"(o: any, shallow: boolean): boolean
 "getId"(): StringJS
 "getKey"(): $ResourceKey<(T)>
 "getMod"(): StringJS
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getIdLocation"(): $ResourceLocation
 "asHolder"(): $Holder<(T)>
 "getTagKeys"(): $List<($TagKey<(T)>)>
 "getRegistry"(): $Registry<(T)>
 "getTags"(): $List<($ResourceLocation)>
 "getRegistryId"(): $ResourceKey<($Registry<(T)>)>
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryObjectKJS$$Type<T> = ($RegistryObjectKJS<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryObjectKJS$$Original<T> = $RegistryObjectKJS<(T)>;}
declare module "dev.latvian.mods.kubejs.block.callback.BlockStateModifyPlacementCallback" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$InteractionHand} from "net.minecraft.world.InteractionHand"
import {$Direction} from "net.minecraft.core.Direction"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level} from "net.minecraft.world.level.Level"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext, $BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$BlockStateModifyCallback} from "dev.latvian.mods.kubejs.block.callback.BlockStateModifyCallback"

export class $BlockStateModifyPlacementCallback extends $BlockStateModifyCallback {
readonly "minecraftBlock": $Block
readonly "context": $BlockPlaceContext
 "block": $LevelBlock

constructor(context: $BlockPlaceContext$$Type, block: $Block$$Type)

/**
 * Gets the level
 */
public "getLevel"(): $Level
/**
 * Gets the item being placed
 */
public "getItem"(): $ItemStack
/**
 * Returns if the player is using the 'secondary' function of this item. Basically checks if they are holding shift
 */
public "isSecondaryUseActive"(): boolean
/**
 * Gets an array of all directions, ordered by which the player is looking closest to
 */
public "getNearestLookingDirections"(): ($Direction)[]
/**
 * Returns if the block being placed is replacing the block clicked
 */
public "replacingClickedOnBlock"(): boolean
/**
 * Gets the direction closes to where the player is currently looking
 */
public "getNearestLookingDirection"(): $Direction
/**
 * Gets the nearest horizontal direction to where the player is looking. NORTH if there is no player
 */
public "getHorizontalDirection"(): $Direction
/**
 * Gets the hand that is placing the block
 */
public "getHand"(): $InteractionHand
/**
 * Gets the player placing the block, if available
 */
public "getPlayer"(): $Player
/**
 * Gets the vertical direction (UP/DOWN) closest to where the player is currently looking
 */
public "getNearestLookingVerticalDirection"(): $Direction
/**
 * Gets the clicked position in world
 */
public "getClickedPos"(): $BlockPos
/**
 * Gets the facing direction of the clicked block face
 */
public "getClickedFace"(): $Direction
/**
 * Returns if the block being placed thinks it can be placed here. This is used for replacement checks, like placing blocks in water or tall grass
 */
public "canPlace"(): boolean
/**
 * Returns if the hit posiiton in the block-space is inside the 1x1x1 cube of the block
 */
public "isInside"(): boolean
/**
 * Set if this block is waterlogged or not
 */
public "waterlogged"(waterlogged: boolean): $BlockStateModifyPlacementCallback
/**
 * Set this block as waterlogged if it is in water
 */
public "waterlogged"(): $BlockStateModifyPlacementCallback
/**
 * Gets the position in the block-space of where it was clicked
 */
public "getClickLocation"(): $Vec3
/**
 * Get the horizontal rotation of the player
 */
public "getRotation"(): float
/**
 * Checks if this block is in water
 */
public "isInWater"(): boolean
/**
 * Gets the FluidSate at the clicked position
 */
public "getFluidStateAtClickedPos"(): $FluidState
/**
 * Checks if the position clicked has a specified fluid there
 */
public "isClickedPosIn"(fluid: $Fluid$$Type): boolean
/**
 * Checks if the block currently occupying the position this is being placed in is the same block type.
 * Used for things like candles, where multiple can be in the same block-space.
 */
public "isReplacingSelf"(): boolean
/**
 * Gets the clicked block
 */
public "getClickedBlock"(): $LevelBlock
get "level"(): $Level
get "item"(): $ItemStack
get "secondaryUseActive"(): boolean
get "nearestLookingDirections"(): ($Direction)[]
get "nearestLookingDirection"(): $Direction
get "horizontalDirection"(): $Direction
get "hand"(): $InteractionHand
get "player"(): $Player
get "nearestLookingVerticalDirection"(): $Direction
get "clickedPos"(): $BlockPos
get "clickedFace"(): $Direction
get "inside"(): boolean
get "clickLocation"(): $Vec3
get "rotation"(): float
get "inWater"(): boolean
get "fluidStateAtClickedPos"(): $FluidState
get "replacingSelf"(): boolean
get "clickedBlock"(): $LevelBlock
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateModifyPlacementCallback$$Type = ($BlockStateModifyPlacementCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateModifyPlacementCallback$$Original = $BlockStateModifyPlacementCallback;}
declare module "dev.latvian.mods.kubejs.client.KubeSessionData" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$List} from "java.util.List"
import {$KubeServerData$$Type} from "dev.latvian.mods.kubejs.net.KubeServerData"
import {$ClientPacketListener$$Type} from "net.minecraft.client.multiplayer.ClientPacketListener"
import {$Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$ItemTooltipData} from "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData"
import {$RecipeViewerData} from "dev.latvian.mods.kubejs.recipe.viewer.server.RecipeViewerData"

export class $KubeSessionData {
 "activePostShader": $ResourceLocation
 "itemTooltips": $List<($ItemTooltipData)>
 "recipeViewerData": $RecipeViewerData

constructor()

public static "of"(mc: $Minecraft$$Type): $KubeSessionData
public static "of"(listener: $ClientPacketListener$$Type): $KubeSessionData
public "sync"(data: $KubeServerData$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeSessionData$$Type = ($KubeSessionData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeSessionData$$Original = $KubeSessionData;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$DataComponentSubtypes" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Record} from "java.lang.Record"

export class $FluidData$DataComponentSubtypes extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData$DataComponentSubtypes)>

constructor(filter: $FluidIngredient$$Type, components: $List$$Type<($DataComponentType$$Type<(never)>)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $FluidIngredient
public "components"(): $List<($DataComponentType<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$DataComponentSubtypes$$Type = ({"filter"?: $FluidIngredient$$Type, "components"?: $List$$Type<($DataComponentType$$Type<(never)>)>}) | ([filter?: $FluidIngredient$$Type, components?: $List$$Type<($DataComponentType$$Type<(never)>)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidData$DataComponentSubtypes$$Original = $FluidData$DataComponentSubtypes;}
declare module "dev.latvian.mods.kubejs.recipe.KubeRecipe" {
import {$CustomJavaToJsWrapper$$Interface} from "dev.latvian.mods.rhino.util.CustomJavaToJsWrapper"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RecipeSchema} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$List} from "java.util.List"
import {$RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$RecipeLikeKJS$$Interface} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$RecipeComponentValue} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeTypeFunction} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$ErrorStack$$Type} from "dev.latvian.mods.kubejs.util.ErrorStack"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$IngredientAction$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Recipe} from "net.minecraft.world.item.crafting.Recipe"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $KubeRecipe implements $RecipeLikeKJS$$Interface, $CustomJavaToJsWrapper$$Interface {
 "newRecipe": boolean
 "sourceLine": $SourceLine
 "originalJson": $JsonObject
 "removed": boolean
 "creationError": boolean
static readonly "TYPE_INFO": $TypeInfo
 "json": $JsonObject
static readonly "CHANGED_MARKER": StringJS
 "type": $RecipeTypeFunction
 "changed": boolean

constructor()

public "group"(g: StringJS): $KubeRecipe
public "remove"(): void
public "get"(key: StringJS): any
public "toString"(): StringJS
public "getValue"<T>(key: $RecipeKey$$Type<(T)>): T
public "validate"(cx: $RecipeValidationContext$$Type): void
public "merge"(j: $JsonObject$$Type): $KubeRecipe
public "id"(id: $ResourceLocation$$Type): $KubeRecipe
public "set"(key: StringJS, value: any): $KubeRecipe
public "getId"(): StringJS
public "save"(): void
public "setValue"<T>(key: $RecipeKey$$Type<(T)>, value: T): $KubeRecipe
public "getPath"(): StringJS
public "stage"(s: StringJS): $KubeRecipe
public "getOriginalRecipe"(): $Recipe<(never)>
public "afterLoaded"(stack: $ErrorStack$$Type): void
public "afterLoaded"(cx: $RecipeValidationContext$$Type): void
public "serializeChanges"(): $KubeRecipe
public "ingredientAction"(filter: $SlotFilter$$Type, action: $IngredientAction$$Type): $KubeRecipe
public "inputValues"(): ($RecipeComponentValue<(never)>)[]
public "getFromToString"(): StringJS
public "outputValues"(): ($RecipeComponentValue<(never)>)[]
public "consumeIngredient"(filter: $SlotFilter$$Type): $KubeRecipe
public "keepIngredient"(filter: $SlotFilter$$Type): $KubeRecipe
public "replaceIngredient"(filter: $SlotFilter$$Type, item: $ItemStack$$Type): $KubeRecipe
public "damageIngredient"(filter: $SlotFilter$$Type): $KubeRecipe
public "damageIngredient"(filter: $SlotFilter$$Type, damage: integer): $KubeRecipe
public "getOriginalRecipeIngredients"(): $List<($Ingredient)>
public "getSerializationTypeFunction"(): $RecipeTypeFunction
public "serialize"(): void
public "deserialize"(merge: boolean): void
public "replaceOutput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "getSerializer"(): $RecipeSerializer<(never)>
public "replaceInput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "getTypeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
/**
 * 
 * @deprecated
 */
public "getSchema"(): $RecipeSchema
/**
 * 
 * @deprecated
 */
public "getOrCreateId"(): $ResourceLocation
/**
 * 
 * @deprecated
 */
public "getGroup"(): StringJS
public "convertJavaToJs"(scope: $Scriptable$$Type, staticType: $TypeInfo$$Type): $Scriptable
public "hasOutput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
public "hasInput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
public "getOriginalRecipeResult"(): $ItemStack
public "customIngredientAction"(filter: $SlotFilter$$Type, id: StringJS): $KubeRecipe
public "hasChanged"(): boolean
public "initValues"(save: boolean): void
public "modifyResult"(id: StringJS): $KubeRecipe
public "getMod"(): StringJS
public "getType"(): $ResourceLocation
get "path"(): StringJS
get "originalRecipe"(): $Recipe<(never)>
get "fromToString"(): StringJS
get "originalRecipeIngredients"(): $List<($Ingredient)>
get "serializationTypeFunction"(): $RecipeTypeFunction
get "serializer"(): $RecipeSerializer<(never)>
get "typeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
get "schema"(): $RecipeSchema
get "orCreateId"(): $ResourceLocation
get "originalRecipeResult"(): $ItemStack
get "mod"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeRecipe$$Type = ($KubeRecipe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeRecipe$$Original = $KubeRecipe;}
declare module "dev.latvian.mods.kubejs.block.callback.BlockStateModifyCallback" {
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Optional} from "java.util.Optional"
import {$Enum} from "java.lang.Enum"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$IntegerProperty$$Type} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty$$Type} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty$$Type} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStateModifyCallback {
constructor(state: $BlockState$$Type)

/**
 * Gets the value of the pased in property
 */
public "get"<T extends $Comparable<(object)>>(property: $Property$$Type<(T)>): T
public "toString"(): StringJS
/**
 * Gets the value of the passed in property
 */
public "getValue"<T extends $Comparable<(object)>>(property: $Property$$Type<(T)>): T
/**
 * Sets the value of the specified boolean property
 */
public "set"(property: $BooleanProperty$$Type, value: boolean): $BlockStateModifyCallback
/**
 * Sets the value of the specified integer property
 */
public "set"(property: $IntegerProperty$$Type, value: integer): $BlockStateModifyCallback
/**
 * Sets the value of the specified enum property
 */
public "set"<T extends $Enum<(object)>>(property: $EnumProperty$$Type<(T)>, value: StringJS): $BlockStateModifyCallback
/**
 * Get the properties this block has that can be changed
 */
public "getProperties"(): $Collection<($Property<(never)>)>
/**
 * Gets the state. If it has been modified, gets the new state
 */
public "getState"(): $BlockState
/**
 * Sets the value of the specified property
 */
public "setValue"<T extends $Comparable<(object)>, V extends $Comparable<(object)>>(property: $Property$$Type<(T)>, comparable: V): $BlockStateModifyCallback
/**
 * Rotate the block using the specified Rotation
 */
public "rotate"(rotation: $Rotation$$Type): $BlockStateModifyCallback
/**
 * Mirror the block using the specified Mirror
 */
public "mirror"(mirror: $Mirror$$Type): $BlockStateModifyCallback
/**
 * Get a map of this blocks properties to it's value
 */
public "getValues"(): $Map<($Property<(never)>), ($Comparable<(never)>)>
/**
 * Gets the value of the passed in property as an Optional. If the property does not exist in this block the Optional will be empty
 */
public "getOptionalValue"<T extends $Comparable<(object)>>(property: $Property$$Type<(T)>): $Optional<(T)>
public "populateNeighbours"(map: $Map$$Type<($Map$$Type<($Property$$Type<(never)>), ($Comparable$$Type<(never)>)>), ($BlockState$$Type)>): $BlockStateModifyCallback
/**
 * Checks if this block has the specified property
 */
public "hasProperty"<T extends $Comparable<(object)>>(property: $Property$$Type<(T)>): boolean
/**
 * Cycles the property
 */
public "cycle"<T extends $Comparable<(object)>>(property: $Property$$Type<(T)>): $BlockStateModifyCallback
/**
 * Updates the shape of this block. Mostly used in waterloggable blocks to update the water flow
 */
public "updateShape"(direction: $Direction$$Type, blockState: $BlockState$$Type, levelAccessor: $LevelAccessor$$Type, blockPos: $BlockPos$$Type, blockPos2: $BlockPos$$Type): $BlockStateModifyCallback
get "properties"(): $Collection<($Property<(never)>)>
get "state"(): $BlockState
get "values"(): $Map<($Property<(never)>), ($Comparable<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateModifyCallback$$Type = ($BlockStateModifyCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateModifyCallback$$Original = $BlockStateModifyCallback;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback" {
import {$ChestMenuClickEvent, $ChestMenuClickEvent$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent"

export interface $ChestMenuClickEvent$Callback$$Interface {

(event: $ChestMenuClickEvent): void
}

export class $ChestMenuClickEvent$Callback implements $ChestMenuClickEvent$Callback$$Interface {
 "onClick"(event: $ChestMenuClickEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuClickEvent$Callback$$Type = ((event: $ChestMenuClickEvent) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuClickEvent$Callback$$Original = $ChestMenuClickEvent$Callback;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.BuildingMaterialProperties$Blocks" {
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $BuildingMaterialProperties$Blocks extends $Record {
constructor(slab: (boolean)?, stairs: (boolean)?, fence: (boolean)?, fenceGate: (boolean)?, wall: (boolean)?, pressurePlate: (boolean)?, button: (boolean)?, trapdoor: (boolean)?, door: (boolean)?)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "fence"(): $Optional<(boolean)>
public "wall"(): $Optional<(boolean)>
public "button"(): $Optional<(boolean)>
public "pressurePlate"(): $Optional<(boolean)>
public "stairs"(): $Optional<(boolean)>
public "fenceGate"(): $Optional<(boolean)>
public "door"(): $Optional<(boolean)>
public "slab"(): $Optional<(boolean)>
public "trapdoor"(): $Optional<(boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuildingMaterialProperties$Blocks$$Type = ({"trapdoor"?: (boolean)?, "wall"?: (boolean)?, "stairs"?: (boolean)?, "fenceGate"?: (boolean)?, "door"?: (boolean)?, "button"?: (boolean)?, "fence"?: (boolean)?, "pressurePlate"?: (boolean)?, "slab"?: (boolean)?}) | ([trapdoor?: (boolean)?, wall?: (boolean)?, stairs?: (boolean)?, fenceGate?: (boolean)?, door?: (boolean)?, button?: (boolean)?, fence?: (boolean)?, pressurePlate?: (boolean)?, slab?: (boolean)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BuildingMaterialProperties$Blocks$$Original = $BuildingMaterialProperties$Blocks;}
declare module "dev.latvian.mods.kubejs.net.SyncServerDataPayload" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$PacketFlow$$Type} from "net.minecraft.network.protocol.PacketFlow"
import {$FriendlyByteBuf} from "net.minecraft.network.FriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$KubeServerData, $KubeServerData$$Type} from "dev.latvian.mods.kubejs.net.KubeServerData"
import {$CustomPacketPayload$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$Type"
import {$StreamDecoder$$Type} from "net.minecraft.network.codec.StreamDecoder"
import {$IPayloadContext$$Type} from "net.neoforged.neoforge.network.handling.IPayloadContext"
import {$CustomPacketPayload, $CustomPacketPayload$$Interface} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload"
import {$StreamMemberEncoder$$Type} from "net.minecraft.network.codec.StreamMemberEncoder"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$ServerboundCustomPayloadPacket} from "net.minecraft.network.protocol.common.ServerboundCustomPayloadPacket"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$ClientboundCustomPayloadPacket} from "net.minecraft.network.protocol.common.ClientboundCustomPayloadPacket"
import {$ConnectionProtocol$$Type} from "net.minecraft.network.ConnectionProtocol"
import {$CustomPacketPayload$TypeAndCodec$$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$TypeAndCodec"
import {$CustomPacketPayload$FallbackProvider$$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$FallbackProvider"
import {$Record} from "java.lang.Record"

export class $SyncServerDataPayload extends $Record implements $CustomPacketPayload$$Interface {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($SyncServerDataPayload)>

constructor(data: $KubeServerData$$Type)

public "type"(): $CustomPacketPayload$Type<(never)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "data"(): $KubeServerData
public "handle"(ctx: $IPayloadContext$$Type): void
public "toVanillaServerbound"(): $ServerboundCustomPayloadPacket
public "toVanillaClientbound"(): $ClientboundCustomPayloadPacket
public static "codec"<B extends $FriendlyByteBuf>(arg0: $CustomPacketPayload$FallbackProvider$$Type<(B)>, arg1: $List$$Type<($CustomPacketPayload$TypeAndCodec$$Type<(B), (never)>)>, arg2: $ConnectionProtocol$$Type, arg3: $PacketFlow$$Type): $StreamCodec<(B), ($CustomPacketPayload)>
public static "codec"<B extends $ByteBuf, T extends $CustomPacketPayload>(arg0: $StreamMemberEncoder$$Type<(B), (T)>, arg1: $StreamDecoder$$Type<(B), (T)>): $StreamCodec<(B), (T)>
public static "createType"<T extends $CustomPacketPayload>(arg0: StringJS): $CustomPacketPayload$Type<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SyncServerDataPayload$$Type = ({"data"?: $KubeServerData$$Type}) | ([data?: $KubeServerData$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SyncServerDataPayload$$Original = $SyncServerDataPayload;}
declare module "dev.latvian.mods.kubejs.generator.KubeDataGenerator" {
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$KubeResourceGenerator$$Interface} from "dev.latvian.mods.kubejs.generator.KubeResourceGenerator"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$VillagerProfession$$Type} from "net.minecraft.world.entity.npc.VillagerProfession"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$VirtualDataMapFile$$Type} from "dev.latvian.mods.kubejs.script.data.VirtualDataMapFile"
import {$DataMapType$$Type} from "net.neoforged.neoforge.registries.datamaps.DataMapType"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$VillagerType$$Type} from "net.minecraft.world.entity.npc.VillagerType"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export interface $KubeDataGenerator$$Interface extends $KubeResourceGenerator$$Interface {
get "registries"(): $RegistryAccessContainer
}

export class $KubeDataGenerator implements $KubeDataGenerator$$Interface {
 "dataMap"<R, T>(type: $DataMapType$$Type<(R), (T)>, consumer: $Consumer$$Type<($VirtualDataMapFile<(R), (T)>)>): void
 "setWaxable"(from: $Block$$Type, to: $Block$$Type): void
 "setVillagerType"(biome: $ResourceKey$$Type<($Biome)>, villagerType: $VillagerType$$Type): void
 "setCompostable"(items: $ItemPredicate$$Type, chance: float, canVillagerCompost: boolean): void
 "removeFurnaceFuel"(items: $ItemPredicate$$Type): void
 "setParrotImitation"(type: $EntityType$$Type<(never)>, sound: $SoundEvent$$Type): void
 "setMonsterRoomMobs"(entityType: $EntityType$$Type<(never)>, weight: integer): void
 "setRaidHeroGifts"(profession: $VillagerProfession$$Type, lootTable: $ResourceKey$$Type<($LootTable)>): void
 "removeCompostable"(items: $ItemPredicate$$Type): void
 "setFurnaceFuel"(items: $ItemPredicate$$Type, ticks: $TickDuration$$Type): void
 "setOxidizable"(from: $Block$$Type, to: $Block$$Type): void
 "setVibrationFrequency"(gameEvent: $GameEvent$$Type, frequency: integer): void
 "flush"(): void
 "add"(data: $GeneratedData$$Type): void
 "text"(id: $ResourceLocation$$Type, content: StringJS): void
 "getGenerated"(id: $ResourceLocation$$Type): $GeneratedData
 "getRegistries"(): $RegistryAccessContainer
 "json"(id: $ResourceLocation$$Type, json: $JsonElement$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeDataGenerator$$Type = ($KubeDataGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeDataGenerator$$Original = $KubeDataGenerator;}
declare module "dev.latvian.mods.kubejs.misc.PoiTypeBuilder" {
import {$PoiType} from "net.minecraft.world.entity.ai.village.poi.PoiType"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PoiTypeBuilder extends $BuilderBase<($PoiType)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "block"(r: $Block$$Type): this
public "blocks"(r: ($BlockState$$Type)[]): this
public "validRange"(i: integer): this
public "maxTickets"(i: integer): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PoiTypeBuilder$$Type = ($PoiTypeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PoiTypeBuilder$$Original = $PoiTypeBuilder;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.TextWrapper" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ItemLore} from "net.minecraft.world.item.component.ItemLore"
import {$List$$Type} from "java.util.List"
import {$MutableComponent, $MutableComponent$$Type} from "net.minecraft.network.chat.MutableComponent"
import {$Tag$$Type} from "net.minecraft.nbt.Tag"
import {$ClickEvent, $ClickEvent$$Type} from "net.minecraft.network.chat.ClickEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

/**
 * The hub for all things text components. Format text to your hearts content!
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $TextWrapper$$Interface {
}

export class $TextWrapper implements $TextWrapper$$Interface {
static readonly "TYPE_INFO": $TypeInfo

/**
 * Checks if the passed in component, and all its children are empty
 */
static "isEmpty"(component: $Component$$Type): boolean
/**
 * Joins all components in the list with the separator component
 */
static "join"(separator: $MutableComponent$$Type, texts: $Iterable$$Type<($Component$$Type)>): $MutableComponent
/**
 * Joins all components
 */
static "join"(...texts: ($Component$$Type)[]): $MutableComponent
/**
 * Returns a Component of the input
 */
static "of"(component: $MutableComponent$$Type): $MutableComponent
/**
 * Returns an empty component
 */
static "empty"(): $MutableComponent
static "info"(text: $Component$$Type): $MutableComponent
/**
 * Returns a component of the input, colored red
 */
static "red"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a plain component of the passed in string, even if empty
 */
static "string"(text: StringJS): $MutableComponent
/**
 * Returns a plain component of the input
 */
static "literal"(text: StringJS): $MutableComponent
static "warn"(text: $Component$$Type): $MutableComponent
/**
 * Returns a component displaying all entities matching the input selector
 */
static "selector"(selector: StringJS): $MutableComponent
/**
 * Returns a component displaying all entities matching the input selector, with a custom separator
 */
static "selector"(selector: StringJS, separator: $Component$$Type): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects
 */
static "translatable"(key: Special.LangKey, ...objects: (any)[]): $MutableComponent
/**
 * Returns a translatable component of the input key
 */
static "translatable"(key: Special.LangKey): $MutableComponent
/**
 * Returns a component of the input, colored green
 */
static "green"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored black
 */
static "black"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored blue
 */
static "blue"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects and a fallback translation in case the client does not have one
 */
static "translatableWithFallback"(key: StringJS, fallback: StringJS, ...objects: (any)[]): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects and a fallback translation in case the client does not have one
 */
static "translatableWithFallback"(key: StringJS, fallback: StringJS): $MutableComponent
/**
 * Returns a plain component of the string, or empty if it is an empty string
 */
static "ofString"(s: StringJS): $MutableComponent
/**
 * Returns a score component of the input objective, for the provided selector
 */
static "score"(selector: StringJS, objective: StringJS): $MutableComponent
static "lore"(lore: $List$$Type<($Component$$Type)>): $ItemLore
/**
 * Returns a component of the input, colored gold
 */
static "gold"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored white
 */
static "white"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored yellow
 */
static "yellow"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a keybinding component of the input keybinding descriptor
 */
static "keybind"(keybind: StringJS): $MutableComponent
/**
 * Returns a component of the input, colored gray
 */
static "gray"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark purple
 */
static "darkPurple"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark red
 */
static "darkRed"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored aqua
 */
static "aqua"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark gray
 */
static "darkGray"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark blue
 */
static "darkBlue"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark green
 */
static "darkGreen"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark aqua
 */
static "darkAqua"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a translatable component of the input key
 */
static "translate"(key: Special.LangKey): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects
 */
static "translate"(key: Special.LangKey, ...objects: (any)[]): $MutableComponent
/**
 * Returns a component of the input, colored light purple
 */
static "lightPurple"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a colorful representation of the input nbt. Useful for displaying NBT to the player
 */
static "prettyPrintNbt"(tag: $Tag$$Type): $Component
/**
 * Returns a ClickEvent of the input
 */
static "clickEventOf"(event: $ClickEvent$$Type): $ClickEvent
static "ofTag"(tag: $Tag$$Type): $Component
/**
 * Returns a translatable component of the input key, with args of the objects and a fallback translation in case the client does not have one
 */
static "translateWithFallback"(key: StringJS, fallback: StringJS, ...objects: (any)[]): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects and a fallback translation in case the client does not have one
 */
static "translateWithFallback"(key: StringJS, fallback: StringJS): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextWrapper$$Type = ($TextWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TextWrapper$$Original = $TextWrapper;}
declare module "dev.latvian.mods.kubejs.event.KubeEvent" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $KubeEvent$$Interface {
}

export class $KubeEvent implements $KubeEvent$$Interface {
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeEvent$$Type = ($KubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeEvent$$Original = $KubeEvent;}
declare module "dev.latvian.mods.kubejs.server.ServerScriptManager" {
import {$VirtualDataPack} from "dev.latvian.mods.kubejs.script.data.VirtualDataPack"
import {$Map} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$GeneratedDataStage} from "dev.latvian.mods.kubejs.script.data.GeneratedDataStage"
import {$PackResources, $PackResources$$Type} from "net.minecraft.server.packs.PackResources"
import {$PreTagKubeEvent} from "dev.latvian.mods.kubejs.server.tag.PreTagKubeEvent"
import {$RecipeSchemaStorage} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$KubeJSContextFactory} from "dev.latvian.mods.kubejs.script.KubeJSContextFactory"
import {$SyncServerDataPayload} from "dev.latvian.mods.kubejs.net.SyncServerDataPayload"
import {$ScriptPack} from "dev.latvian.mods.kubejs.script.ScriptPack"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$ScriptManager} from "dev.latvian.mods.kubejs.script.ScriptManager"

export class $ServerScriptManager extends $ScriptManager {
readonly "virtualPacks": $Map<($GeneratedDataStage), ($VirtualDataPack)>
readonly "scriptType": $ScriptType
readonly "registriesDataPack": $VirtualDataPack
readonly "internalDataPack": $VirtualDataPack
 "canListenEvents": boolean
readonly "recipeSchemaStorage": $RecipeSchemaStorage
 "firstLoad": boolean
readonly "packs": $Map<(StringJS), ($ScriptPack)>
readonly "preTagEvents": $Map<($ResourceKey<(never)>), ($PreTagKubeEvent)>
 "serverData": $SyncServerDataPayload
 "contextFactory": $KubeJSContextFactory

public static "release"(): $ServerScriptManager
public "reload"(): void
public "loadFromDirectory"(): void
public "loadAdditional"(): void
public static "createPackResources"(original: $List$$Type<($PackResources$$Type)>): $List<($PackResources)>
public "reloadAndCapture"(): void
public static "createForDataGen"(): $ServerScriptManager
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerScriptManager$$Type = ($ServerScriptManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerScriptManager$$Original = $ServerScriptManager;}
declare module "dev.latvian.mods.kubejs.client.ModelGenerator$Element" {
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$ModelGenerator$Face$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator$Face"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ModelGenerator$Element {
constructor()

public "size"(b: $AABB$$Type): $ModelGenerator$Element
public "toJson"(): $JsonObject
public "faces"(sides: ($Direction$$Type)[], face: $Consumer$$Type<($ModelGenerator$Face)>): void
public "allFaces"(face: $Consumer$$Type<($ModelGenerator$Face)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$Element$$Type = ($ModelGenerator$Element);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModelGenerator$Element$$Original = $ModelGenerator$Element;}
declare module "dev.latvian.mods.kubejs.fluid.ThinFluidBuilder" {
import {$FlowingFluidBuilder} from "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder"
import {$FluidBucketItemBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$FluidBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$KubeColor} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$FluidBlockBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder"
import {$FluidTypeBuilder} from "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ThinFluidBuilder extends $FluidBuilder {
static readonly "WATER_COLOR": $KubeColor
 "bucketItem": $FluidBucketItemBuilder
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "flowingFluid": $FlowingFluidBuilder
 "sourceLine": $SourceLine
 "fluidType": $FluidTypeBuilder
 "block": $FluidBlockBuilder
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThinFluidBuilder$$Type = ($ThinFluidBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ThinFluidBuilder$$Original = $ThinFluidBuilder;}
declare module "dev.latvian.mods.kubejs.plugin.ClassFilter" {
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Class$$Type} from "java.lang.Class"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ClassFilter {
readonly "scriptType": $ScriptType

constructor(scriptType: $ScriptType$$Type)

public "allow"(c: $Class$$Type<(never)>): void
public "allow"(s: StringJS): void
public "isAllowed"(s: StringJS): boolean
public "deny"(s: StringJS): void
public "deny"(c: $Class$$Type<(never)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassFilter$$Type = ($ClassFilter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClassFilter$$Original = $ClassFilter;}
declare module "dev.latvian.mods.kubejs.util.NBTIOWrapper" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Path$$Type} from "java.nio.file.Path"

export interface $NBTIOWrapper$$Interface {
}

export class $NBTIOWrapper implements $NBTIOWrapper$$Interface {
static "write"(path: $Path$$Type, nbt: $CompoundTag$$Type): void
static "read"(path: $Path$$Type): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTIOWrapper$$Type = ($NBTIOWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NBTIOWrapper$$Original = $NBTIOWrapper;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$HurtEnemyContext" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Record} from "java.lang.Record"

export class $ItemBuilder$HurtEnemyContext extends $Record {
constructor(getItem: $ItemStack$$Type, getTarget: $LivingEntity$$Type, getAttacker: $LivingEntity$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getTarget"(): $LivingEntity
public "getItem"(): $ItemStack
public "getAttacker"(): $LivingEntity
get "target"(): $LivingEntity
get "item"(): $ItemStack
get "attacker"(): $LivingEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$HurtEnemyContext$$Type = ({"getItem"?: $ItemStack$$Type, "getAttacker"?: $LivingEntity$$Type, "getTarget"?: $LivingEntity$$Type}) | ([getItem?: $ItemStack$$Type, getAttacker?: $LivingEntity$$Type, getTarget?: $LivingEntity$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$HurtEnemyContext$$Original = $ItemBuilder$HurtEnemyContext;}
declare module "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction" {
import {$Pattern} from "java.util.regex.Pattern"
import {$BaseFunction} from "dev.latvian.mods.rhino.BaseFunction"
import {$RecipeSchemaType, $RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$WrappedJS$$Interface} from "dev.latvian.mods.kubejs.util.WrappedJS"
import {$KubeRecipe} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$ErrorStack$$Type} from "dev.latvian.mods.kubejs.util.ErrorStack"
import {$RecipesKubeEvent, $RecipesKubeEvent$$Type} from "dev.latvian.mods.kubejs.recipe.RecipesKubeEvent"
import {$DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $RecipeTypeFunction extends $BaseFunction implements $WrappedJS$$Interface {
static readonly "DONTENUM": integer
static readonly "CONST": integer
readonly "idString": StringJS
readonly "schemaType": $RecipeSchemaType
static readonly "UNINITIALIZED_CONST": integer
readonly "serializerKey": $ResourceKey<($RecipeSerializer<(never)>)>
static readonly "SKIP_ERROR": $Pattern
readonly "id": $ResourceLocation
readonly "event": $RecipesKubeEvent
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "PERMANENT": integer

constructor(event: $RecipesKubeEvent$$Type, schemaType: $RecipeSchemaType$$Type)

public "equals"(obj: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "call"(scope: $Scriptable$$Type, thisObj: $Scriptable$$Type, args0: (any)[]): $KubeRecipe
public "createRecipe"(sourceLine: $SourceLine$$Type, stack: $ErrorStack$$Type, args: (any)[]): $KubeRecipe
public "get"(arg1: integer, arg2: $Scriptable$$Type): any
public "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
public "delete"(arg1: integer): void
public "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
public "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
public "setParentScope"(arg0: $Scriptable$$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(): (any)[]
public "getPrototype"(): $Scriptable
public "setPrototype"(arg0: $Scriptable$$Type): void
public "getIds"(): (any)[]
set "parentScope"(value: $Scriptable$$Type)
get "parentScope"(): $Scriptable
get "allIds"(): (any)[]
get "prototype"(): $Scriptable
set "prototype"(value: $Scriptable$$Type)
get "ids"(): (any)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeTypeFunction$$Type = ($RecipeTypeFunction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeTypeFunction$$Original = $RecipeTypeFunction;}
declare module "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer$Mode" {
import {$Enum} from "java.lang.Enum"

export class $HighlightRenderer$Mode extends $Enum<($HighlightRenderer$Mode)> {
static readonly "SCREEN": $HighlightRenderer$Mode
static readonly "NONE": $HighlightRenderer$Mode
static readonly "WORLD": $HighlightRenderer$Mode

public static "values"(): ($HighlightRenderer$Mode)[]
public static "valueOf"(name: StringJS): $HighlightRenderer$Mode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HighlightRenderer$Mode$$Type = (("none") | ("screen") | ("world"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HighlightRenderer$Mode$$Original = $HighlightRenderer$Mode;}
declare module "dev.latvian.mods.kubejs.recipe.filter.RecipeFilterParseEvent" {
import {$Context} from "dev.latvian.mods.rhino.Context"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RecipeFilter, $RecipeFilter$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeFilter"
import {$List, $List$$Type} from "java.util.List"
import {$Event} from "net.neoforged.bus.api.Event"

export class $RecipeFilterParseEvent extends $Event {
readonly "cx": $Context
readonly "filters": $List<($RecipeFilter)>
readonly "map": $Map<(never), (never)>

constructor(filters: $List$$Type<($RecipeFilter$$Type)>, map: $Map$$Type<(never), (never)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeFilterParseEvent$$Type = ($RecipeFilterParseEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeFilterParseEvent$$Original = $RecipeFilterParseEvent;}
declare module "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator" {
import {$VariantBlockStateGenerator$Variant$$Type} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Variant"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $VariantBlockStateGenerator {
constructor()

public "variant"(key: StringJS, consumer: $Consumer$$Type<($VariantBlockStateGenerator$Variant)>): void
public "toJson"(): $JsonObject
public "simpleVariant"(key: StringJS, model: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateGenerator$$Type = ($VariantBlockStateGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VariantBlockStateGenerator$$Original = $VariantBlockStateGenerator;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder" {
import {$ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ItemBuilder} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export class $ArmorItemBuilder extends $ItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

public "material"(material: $Holder$$Type<($ArmorMaterial)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$$Type = ($ArmorItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$$Original = $ArmorItemBuilder;}
declare module "dev.latvian.mods.kubejs.server.tag.TagKubeEvent" {
import {$EventExceptionHandler} from "dev.latvian.mods.kubejs.event.EventExceptionHandler"
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map} from "java.util.Map"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Set} from "java.util.Set"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$TagWrapper} from "dev.latvian.mods.kubejs.server.tag.TagWrapper"

export class $TagKubeEvent implements $KubeEvent$$Interface {
readonly "registryKey": $ResourceKey<(never)>
 "totalRemoved": integer
static readonly "SOURCE": StringJS
readonly "vanillaRegistry": $Registry<(never)>
 "totalAdded": integer
static readonly "TAG_EVENT_HANDLER": $EventExceptionHandler
readonly "tags": $Map<($ResourceLocation), ($TagWrapper)>

constructor(registryKey: $ResourceKey$$Type<(never)>, vr: $Registry$$Type<(never)>)

public "remove"(tag: $ResourceLocation$$Type, ...filters: (any)[]): $TagWrapper
public "get"(id: $ResourceLocation$$Type): $TagWrapper
public "add"(tag: $ResourceLocation$$Type, ...filters: (any)[]): $TagWrapper
public "getType"(): $ResourceLocation
public "removeAll"(tag: $ResourceLocation$$Type): $TagWrapper
public "getElementIds"(): $Set<($ResourceLocation)>
public "removeAllTagsFrom"(...ids: (any)[]): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "type"(): $ResourceLocation
get "elementIds"(): $Set<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagKubeEvent$$Type = ($TagKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TagKubeEvent$$Original = $TagKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.IngredientSupplierKJS" {
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IngredientSupplierKJS$$Interface {
}

export class $IngredientSupplierKJS implements $IngredientSupplierKJS$$Interface {
 "kjs$asIngredient"(): $Ingredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientSupplierKJS$$Type = ($IngredientSupplierKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientSupplierKJS$$Original = $IngredientSupplierKJS;}
declare module "dev.latvian.mods.kubejs.player.PlayerAdvancementKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$AdvancementNode, $AdvancementNode$$Type} from "net.minecraft.advancements.AdvancementNode"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player gets an advancement.
 */
export class $PlayerAdvancementKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $ServerPlayer$$Type, advancementNode: $AdvancementNode$$Type)

/**
 * Returns the advancement that was obtained.
 */
public "getAdvancement"(): $AdvancementNode
/**
 * Returns the player that got the advancement.
 */
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "advancement"(): $AdvancementNode
get "entity"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerAdvancementKubeEvent$$Type = ($PlayerAdvancementKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerAdvancementKubeEvent$$Original = $PlayerAdvancementKubeEvent;}
declare module "dev.latvian.mods.kubejs.command.ArgumentTypeWrappers" {
import {$CommandContext$$Type} from "com.mojang.brigadier.context.CommandContext"
import {$ArgumentType} from "com.mojang.brigadier.arguments.ArgumentType"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$CommandRegistryKubeEvent$$Type} from "dev.latvian.mods.kubejs.command.CommandRegistryKubeEvent"
import {$Enum} from "java.lang.Enum"
import {$ArgumentTypeWrapper, $ArgumentTypeWrapper$$Interface} from "dev.latvian.mods.kubejs.command.ArgumentTypeWrapper"
import {$CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"

export class $ArgumentTypeWrappers extends $Enum<($ArgumentTypeWrappers)> implements $ArgumentTypeWrapper$$Interface {
static readonly "ROTATION": $ArgumentTypeWrappers
static readonly "VEC2_CENTERED": $ArgumentTypeWrappers
static readonly "FLOAT": $ArgumentTypeWrappers
static readonly "PARTICLE": $ArgumentTypeWrappers
static readonly "INT_RANGE": $ArgumentTypeWrappers
static readonly "BLOCK_STATE": $ArgumentTypeWrappers
static readonly "NBT_TAG": $ArgumentTypeWrappers
static readonly "NBT_PATH": $ArgumentTypeWrappers
static readonly "ANGLE": $ArgumentTypeWrappers
static readonly "ITEM_PREDICATE": $ArgumentTypeWrappers
static readonly "BLOCK_POS_LOADED": $ArgumentTypeWrappers
static readonly "BLOCK_POS": $ArgumentTypeWrappers
static readonly "MESSAGE": $ArgumentTypeWrappers
static readonly "ITEM_SLOT": $ArgumentTypeWrappers
static readonly "ENTITY": $ArgumentTypeWrappers
static readonly "BLOCK_PREDICATE": $ArgumentTypeWrappers
static readonly "DIMENSION": $ArgumentTypeWrappers
static readonly "VEC2": $ArgumentTypeWrappers
static readonly "COLOR": $ArgumentTypeWrappers
static readonly "VEC3": $ArgumentTypeWrappers
static readonly "ITEM_STACK": $ArgumentTypeWrappers
static readonly "SWIZZLE": $ArgumentTypeWrappers
static readonly "OBJECTIVE": $ArgumentTypeWrappers
static readonly "DOUBLE": $ArgumentTypeWrappers
static readonly "ENTITIES": $ArgumentTypeWrappers
static readonly "UUID": $ArgumentTypeWrappers
static readonly "INTEGER": $ArgumentTypeWrappers
static readonly "LONG": $ArgumentTypeWrappers
static readonly "WORD": $ArgumentTypeWrappers
static readonly "VEC3_CENTERED": $ArgumentTypeWrappers
static readonly "TIME": $ArgumentTypeWrappers
static readonly "GREEDY_STRING": $ArgumentTypeWrappers
static readonly "NBT_COMPOUND": $ArgumentTypeWrappers
static readonly "BOOLEAN": $ArgumentTypeWrappers
static readonly "PLAYER": $ArgumentTypeWrappers
static readonly "RESOURCE_LOCATION": $ArgumentTypeWrappers
static readonly "FLOAT_RANGE": $ArgumentTypeWrappers
static readonly "PLAYERS": $ArgumentTypeWrappers
static readonly "GAME_PROFILE": $ArgumentTypeWrappers
static readonly "COLUMN_POS": $ArgumentTypeWrappers
static readonly "STRING": $ArgumentTypeWrappers
static readonly "COMPONENT": $ArgumentTypeWrappers
static readonly "ENTITY_ANCHOR": $ArgumentTypeWrappers

public static "values"(): ($ArgumentTypeWrappers)[]
public static "valueOf"(name: StringJS): $ArgumentTypeWrappers
public "time"(minRequired: integer): $ArgumentTypeWrapper
public "create"(event: $CommandRegistryKubeEvent$$Type): $ArgumentType<(never)>
public "getResult"(context: $CommandContext$$Type<($CommandSourceStack$$Type)>, input: StringJS): any
public static "registry"<T>(event: $CommandRegistryKubeEvent$$Type, reg: $ResourceLocation$$Type): $ArgumentTypeWrapper
public static "byName"(name: $ResourceLocation$$Type): typeof never
public static "printAll"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArgumentTypeWrappers$$Type = (("boolean") | ("float") | ("double") | ("integer") | ("long") | ("string") | ("greedy_string") | ("word") | ("entity") | ("entities") | ("player") | ("players") | ("game_profile") | ("block_pos") | ("block_pos_loaded") | ("column_pos") | ("vec3") | ("vec2") | ("vec3_centered") | ("vec2_centered") | ("block_state") | ("block_predicate") | ("item_stack") | ("item_predicate") | ("color") | ("component") | ("message") | ("nbt_compound") | ("nbt_tag") | ("nbt_path") | ("particle") | ("angle") | ("rotation") | ("swizzle") | ("item_slot") | ("resource_location") | ("entity_anchor") | ("int_range") | ("float_range") | ("dimension") | ("time") | ("uuid") | ("objective"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArgumentTypeWrappers$$Original = $ArgumentTypeWrappers;}
declare module "dev.latvian.mods.kubejs.entity.EntitySpawnedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an entity is about to be added to the world.
 * 
 * This event also fires for existing entities when they are loaded from a save.
 */
export class $EntitySpawnedKubeEvent implements $KubeEntityEvent$$Interface {
constructor(entity: $Entity$$Type, level: $Level$$Type)

/**
 * The level the entity is being added to.
 */
public "getLevel"(): $Level
/**
 * The entity being added to the world.
 */
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySpawnedKubeEvent$$Type = ($EntitySpawnedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntitySpawnedKubeEvent$$Original = $EntitySpawnedKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicate" {
import {$LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$BlockPredicate$$Interface} from "dev.latvian.mods.kubejs.block.predicate.BlockPredicate"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$BlockEntityPredicateDataCheck$$Type} from "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicateDataCheck"

export class $BlockEntityPredicate implements $BlockPredicate$$Interface {
constructor(i: $ResourceLocation$$Type)

public "toString"(): StringJS
public "data"(cd: $BlockEntityPredicateDataCheck$$Type): $BlockEntityPredicate
public "check"(block: $LevelBlock$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityPredicate$$Type = ($BlockEntityPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityPredicate$$Original = $BlockEntityPredicate;}
declare module "dev.latvian.mods.kubejs.recipe.filter.RecipeFilter" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Predicate, $Predicate$$Type, $Predicate$$Interface} from "java.util.function.Predicate"
import {$RecipeMatchContext, $RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"

export interface $RecipeFilter$$Interface extends $Predicate$$Interface<($RecipeMatchContext)> {

(cx: $RecipeMatchContext): boolean
}

export class $RecipeFilter implements $RecipeFilter$$Interface {
 "test"(cx: $RecipeMatchContext$$Type): boolean
 "test"(cx: any): boolean
static "wrap"(o: any): $RecipeFilter
 "or"(arg0: $Predicate$$Type<($RecipeMatchContext)>): $Predicate<($RecipeMatchContext)>
 "negate"(): $Predicate<($RecipeMatchContext)>
 "and"(arg0: $Predicate$$Type<($RecipeMatchContext)>): $Predicate<($RecipeMatchContext)>
static "not"<T>(arg0: $Predicate$$Type<($RecipeMatchContext)>): $Predicate<($RecipeMatchContext)>
static "isEqual"<T>(arg0: any): $Predicate<($RecipeMatchContext)>
}
export type RecipeFilterObject = {"or"?: $RecipeFilter$$Type, "not"?: $RecipeFilter$$Type, "id"?: Special.RecipeId, "type"?: Special.RecipeSerializer, "group"?: StringJS, "mod"?: Special.Mod, "input"?: $Ingredient$$Type, "output"?: $ItemStack$$Type};
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeFilter$$Type = (RegExp) | ("*") | ("-") | (($RecipeFilter$$Type)[]) | (RecipeFilterObject) | ((cx: $RecipeMatchContext) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeFilter$$Original = $RecipeFilter;}
declare module "dev.latvian.mods.kubejs.util.TickDuration" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Codec} from "com.mojang.serialization.Codec"
import {$TemporalUnit, $TemporalUnit$$Type} from "java.time.temporal.TemporalUnit"
import {$List} from "java.util.List"
import {$TemporalAmount$$Interface} from "java.time.temporal.TemporalAmount"
import {$Temporal, $Temporal$$Type} from "java.time.temporal.Temporal"
import {$Record} from "java.lang.Record"

export class $TickDuration extends $Record implements $TemporalAmount$$Interface {
static readonly "ZERO": $TickDuration
static readonly "CODEC": $Codec<($TickDuration)>
static readonly "SECONDS_CODEC": $Codec<($TickDuration)>
static readonly "MINUTES_CODEC": $Codec<($TickDuration)>
static readonly "TYPE_INFO": $TypeInfo
static readonly "HOURS_CODEC": $Codec<($TickDuration)>

constructor(ticks: long)

public "get"(unit: $TemporalUnit$$Type): long
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "wrap"(from: any): $TickDuration
public static "of"(ticks: long): $TickDuration
public "getUnits"(): $List<($TemporalUnit)>
public "addTo"(temporal: $Temporal$$Type): $Temporal
public "subtractFrom"(temporal: $Temporal$$Type): $Temporal
public "intTicks"(): integer
public "ticks"(): long
get "units"(): $List<($TemporalUnit)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickDuration$$Type = ({"ticks"?: long}) | ([ticks?: long]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TickDuration$$Original = $TickDuration;}
declare module "dev.latvian.mods.kubejs.recipe.CachedTagLookup" {
import {$Collection} from "java.util.Collection"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List, $List$$Type} from "java.util.List"
import {$Set} from "java.util.Set"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$Holder} from "net.minecraft.core.Holder"

export class $CachedTagLookup<T> {
readonly "registry": $Registry<(T)>
readonly "originalMap": $Map<($ResourceLocation), ($List<($TagLoader$EntryWithSource)>)>

constructor(registry: $Registry$$Type<(T)>, originalMap: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>)

public "values"(key: $TagKey$$Type<(T)>): $Set<(T)>
public "isEmpty"(key: $TagKey$$Type<(T)>): boolean
public "keys"(value: T): $Set<($TagKey<(T)>)>
public "build"(builders: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>): $Map<($ResourceLocation), ($Collection<(T)>)>
public "tagMap"(): $Map<($ResourceLocation), ($Collection<($Holder<(T)>)>)>
public "bindingMap"(): $Map<($TagKey<(T)>), ($List<($Holder<(T)>)>)>
public "keyToValue"(): $Map<($TagKey<(T)>), ($Set<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedTagLookup$$Type<T> = ($CachedTagLookup<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CachedTagLookup$$Original<T> = $CachedTagLookup<(T)>;}
declare module "dev.latvian.mods.kubejs.web.SessionInfo" {
import {$Set, $Set$$Type} from "java.util.Set"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Record} from "java.lang.Record"

export class $SessionInfo extends $Record {
static readonly "NONE": $SessionInfo

constructor(source: StringJS, tags: $Set$$Type<(StringJS)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "source"(): StringJS
public "tags"(): $Set<(StringJS)>
public static "fromJson"(info: $SessionInfo$$Type, json: $JsonObject$$Type): $SessionInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionInfo$$Type = ({"tags"?: $Set$$Type<(StringJS)>, "source"?: StringJS}) | ([tags?: $Set$$Type<(StringJS)>, source?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SessionInfo$$Original = $SessionInfo;}
declare module "dev.latvian.mods.kubejs.block.callback.AfterEntityFallenOnBlockCallback" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$EntitySteppedOnBlockCallback} from "dev.latvian.mods.kubejs.block.callback.EntitySteppedOnBlockCallback"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"

export class $AfterEntityFallenOnBlockCallback extends $EntitySteppedOnBlockCallback {
constructor(blockGetter: $BlockGetter$$Type, entity: $Entity$$Type)

/**
 * Returns the Vec3 of the entity's velocity. Use .x, .y and .z to get the respective components of that
 */
public "getVelocity"(): $Vec3
/**
 * Bounce the entity upwards by bounciness * their fall velocity.
 * Do not make bounciness negative, as that is a recipe for a long and laggy trip to the void
 */
public "bounce"(bounciness: float): void
/**
 * Sets the entity's velocity
 */
public "setVelocity"(x: float, y: float, z: float): void
/**
 * Sets the entity's velocity
 */
public "setVelocity"(vec: $Vec3$$Type): void
get "velocity"(): $Vec3
set "velocity"(value: $Vec3$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterEntityFallenOnBlockCallback$$Type = ($AfterEntityFallenOnBlockCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AfterEntityFallenOnBlockCallback$$Original = $AfterEntityFallenOnBlockCallback;}
declare module "dev.latvian.mods.kubejs.block.custom.BasicKubeBlock$Builder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $BasicKubeBlock$Builder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicKubeBlock$Builder$$Type = ($BasicKubeBlock$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BasicKubeBlock$Builder$$Original = $BasicKubeBlock$Builder;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchema, $RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeNamespace, $RecipeNamespace$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $RecipeSchemaType {
readonly "schema": $RecipeSchema
 "parent": $RecipeSchemaType
readonly "serializerType": StringJS
readonly "namespace": $RecipeNamespace
readonly "serializerKey": $ResourceKey<($RecipeSerializer<(never)>)>
readonly "id": $ResourceLocation

constructor(namespace: $RecipeNamespace$$Type, id: $ResourceLocation$$Type, schema: $RecipeSchema$$Type)

public "toString"(): StringJS
public "getSerializer"(): $RecipeSerializer<(never)>
get "serializer"(): $RecipeSerializer<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchemaType$$Type = ($RecipeSchemaType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeSchemaType$$Original = $RecipeSchemaType;}
declare module "dev.latvian.mods.kubejs.client.ParticleProviderRegistryKubeEvent" {
import {$ParticleProvider$$Type} from "net.minecraft.client.particle.ParticleProvider"
import {$RegisterParticleProvidersEvent$$Type} from "net.neoforged.neoforge.client.event.RegisterParticleProvidersEvent"
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$ParticleType$$Type} from "net.minecraft.core.particles.ParticleType"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$KubeAnimatedParticle$$Type} from "dev.latvian.mods.kubejs.client.KubeAnimatedParticle"
import {$ParticleOptions} from "net.minecraft.core.particles.ParticleOptions"
import {$ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Type} from "dev.latvian.mods.kubejs.client.ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ParticleProviderRegistryKubeEvent implements $ClientKubeEvent$$Interface {
constructor(event: $RegisterParticleProvidersEvent$$Type)

public "register"<T extends $ParticleOptions>(type: $ParticleType$$Type<(T)>): void
public "register"<T extends $ParticleOptions>(type: $ParticleType$$Type<(T)>, particle: $Consumer$$Type<($KubeAnimatedParticle)>): void
public "register"<T extends $ParticleOptions>(type: $ParticleType$$Type<(T)>, spriteProvider: $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Type<(T)>): void
public "registerSpecial"<T extends $ParticleOptions>(type: $ParticleType$$Type<(T)>, provider: $ParticleProvider$$Type<(T)>): void
public "getClient"(): $Minecraft
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleProviderRegistryKubeEvent$$Type = ($ParticleProviderRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ParticleProviderRegistryKubeEvent$$Original = $ParticleProviderRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer" {
import {$HighlightRenderer$Mode} from "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer$Mode"
import {$IntOpenHashSet} from "it.unimi.dsi.fastutil.ints.IntOpenHashSet"
import {$Long2IntMap} from "it.unimi.dsi.fastutil.longs.Long2IntMap"
import {$KeyMapping} from "net.minecraft.client.KeyMapping"
import {$HighlightRenderer$ShaderChain} from "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer$ShaderChain"
import {$Slot} from "net.minecraft.world.inventory.Slot"
import {$AbstractContainerScreen$$Type} from "net.minecraft.client.gui.screens.inventory.AbstractContainerScreen"
import {$GuiGraphics$$Type} from "net.minecraft.client.gui.GuiGraphics"
import {$Reference2IntMap} from "it.unimi.dsi.fastutil.objects.Reference2IntMap"
import {$RenderLevelStageEvent$$Type} from "net.neoforged.neoforge.client.event.RenderLevelStageEvent"
import {$ShaderInstance} from "net.minecraft.client.renderer.ShaderInstance"
import {$Set} from "java.util.Set"
import {$KubeColor} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$Entity} from "net.minecraft.world.entity.Entity"

export class $HighlightRenderer {
readonly "highlightedEntities": $Reference2IntMap<($Entity)>
 "color": $KubeColor
static "INSTANCE": $HighlightRenderer
readonly "hoveredSlots": $Set<($Slot)>
static "keyMapping": $KeyMapping
readonly "uniqueColors": $IntOpenHashSet
 "highlightShader": $ShaderInstance
 "mode": $HighlightRenderer$Mode
 "worldChain": $HighlightRenderer$ShaderChain
 "actualKey": boolean
 "guiChain": $HighlightRenderer$ShaderChain
 "cancelBlockHighlight": boolean
readonly "highlightedBlocks": $Long2IntMap

constructor()

public "screen"(mc: $Minecraft$$Type, graphics: $GuiGraphics$$Type, screen: $AbstractContainerScreen$$Type<(never)>, mx: integer, my: integer, delta: float): void
public "resizePostChains"(width: integer, height: integer): void
public "loadPostChains"(mc: $Minecraft$$Type): void
public "clearBuffers"(mc: $Minecraft$$Type): void
public "hudPostDraw"(mc: $Minecraft$$Type, graphics: $GuiGraphics$$Type, delta: float): void
public "renderAfterLevel"(mc: $Minecraft$$Type, event: $RenderLevelStageEvent$$Type): void
public "renderAfterEntities"(mc: $Minecraft$$Type, event: $RenderLevelStageEvent$$Type): void
public "updateDepth"(mc: $Minecraft$$Type): void
public "tickPre"(mc: $Minecraft$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HighlightRenderer$$Type = ($HighlightRenderer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HighlightRenderer$$Original = $HighlightRenderer;}
declare module "dev.latvian.mods.kubejs.script.ScriptTypePredicate" {
import {$Predicate, $Predicate$$Type, $Predicate$$Interface} from "java.util.function.Predicate"
import {$List} from "java.util.List"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ScriptTypePredicate$$Interface extends $Predicate$$Interface<($ScriptType)> {

(type: $ScriptType): boolean
get "validTypes"(): $List<($ScriptType)>
}

export class $ScriptTypePredicate implements $ScriptTypePredicate$$Interface {
static readonly "ALL": $ScriptTypePredicate
static readonly "STARTUP_OR_CLIENT": $ScriptTypePredicate
static readonly "COMMON": $ScriptTypePredicate
static readonly "STARTUP_OR_SERVER": $ScriptTypePredicate

 "test"(type: $ScriptType$$Type): boolean
 "test"(type: any): boolean
 "getValidTypes"(): $List<($ScriptType)>
 "or"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
 "negate"(): $Predicate<($ScriptType)>
 "and"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
static "not"<T>(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
static "isEqual"<T>(arg0: any): $Predicate<($ScriptType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptTypePredicate$$Type = ((type: $ScriptType) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptTypePredicate$$Original = $ScriptTypePredicate;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.UtilsWrapper" {
import {$Pattern} from "java.util.regex.Pattern"
import {$Collection$$Type} from "java.util.Collection"
import {$Map} from "java.util.Map"
import {$List} from "java.util.List"
import {$Duration$$Type} from "java.time.Duration"
import {$Runnable$$Type} from "java.lang.Runnable"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$Random$$Type} from "java.util.Random"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$CountingMap} from "dev.latvian.mods.kubejs.util.CountingMap"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$CreativeModeTab} from "net.minecraft.world.item.CreativeModeTab"
import {$Stat} from "net.minecraft.stats.Stat"
import {$Supplier$$Type} from "java.util.function.Supplier"

/**
 * A collection of utilities
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $UtilsWrapper$$Interface {
get "random"(): $RandomSource
get "systemTime"(): long
}

export class $UtilsWrapper implements $UtilsWrapper$$Interface {
/**
 * Returns a regex pattern of the input with the specified flags
 */
static "regex"(pattern: StringJS, flags: integer): $Pattern
/**
 * Returns a regex pattern of the input
 */
static "regex"(s: any): $Pattern
/**
 * Get an immutable empty list
 */
static "emptyList"<T>(): $List<(T)>
/**
 * Checks if the passed in object is an instance of WrappedJS
 */
static "isWrapped"(o: any): boolean
/**
 * Returns a new mutable map
 */
static "newMap"(): $Map<(never), (never)>
/**
 * Get an immutable empty map
 */
static "emptyMap"<K, V>(): $Map<(K), (V)>
/**
 * Returns a new mutable list
 */
static "newList"(): $List<(never)>
/**
 * Returns a lazy value with the supplier function as its value factory
 */
static "lazy"<T>(supplier: $Supplier$$Type<(T)>): $Lazy<(T)>
/**
 * Runs the provided runnable function in KubeJS' background thread and returns its CompletableFuture
 */
static "runAsync"(task: $Runnable$$Type): $CompletableFuture<(void)>
/**
 * Returns the creative tab associated with the id
 */
static "findCreativeTab"(id: $ResourceLocation$$Type): $CreativeModeTab
/**
 * Runs the provided supplier function in KubeJS' background thread and returns its CompletableFuture
 */
static "supplyAsync"(task: $Supplier$$Type<(any)>): $CompletableFuture<(any)>
/**
 * Get a Random, for generating random numbers. Note this will always return the same Random instance
 */
static "getRandom"(): $RandomSource
/**
 * Gets a SoundEvent from the id
 */
static "getSound"(id: $ResourceLocation$$Type): $SoundEvent
/**
 * Returns a Stat of the passed in ResourceLocation.
 * Note that this requires the same ResourceLocation to get the same stat, so should not be used unless you want to make your own stat, and are storing an actual ResourceLocation somewhere to access it.
 */
static "getStat"(id: $ResourceLocation$$Type): $Stat<($ResourceLocation)>
/**
 * Get a new random with the specified seed
 */
static "newRandom"(seed: long): $RandomSource
/**
 * Gets a random object from the list using the passed in random
 */
static "randomOf"(random: $Random$$Type, objects: $Collection$$Type<(any)>): any
/**
 * Returns a new counting map
 */
static "newCountingMap"(): $CountingMap
/**
 * Returns a lazy value with the supplier function as its value factory, that will expire after the specified time
 */
static "expiringLazy"<T>(supplier: $Supplier$$Type<(T)>, expires: $Duration$$Type): $Lazy<(T)>
/**
 * Gets the current system time, in milliseconds
 */
static "getSystemTime"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UtilsWrapper$$Type = ($UtilsWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UtilsWrapper$$Original = $UtilsWrapper;}
declare module "dev.latvian.mods.kubejs.item.ItemPredicate" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ItemStackSet} from "dev.latvian.mods.kubejs.item.ItemStackSet"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Predicate, $Predicate$$Type, $Predicate$$Interface} from "java.util.function.Predicate"
import {$IngredientSupplierKJS$$Interface} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Set} from "java.util.Set"
import {$Stream} from "java.util.stream.Stream"

export interface $ItemPredicate$$Interface extends $Predicate$$Interface<($ItemStack)>, $IngredientSupplierKJS$$Interface {

(itemStack: $ItemStack): boolean
get "stackArray"(): ($ItemStack)[]
get "itemIds"(): $Set<(StringJS)>
get "first"(): $ItemStack
get "itemTypes"(): $Set<($Item)>
get "itemStream"(): $Stream<($Item)>
get "wildcard"(): boolean
get "displayStacks"(): $ItemStackSet
get "stacks"(): $ItemStackSet
}

export class $ItemPredicate implements $ItemPredicate$$Interface {
static readonly "ALL": $ItemPredicate
static readonly "TYPE_INFO": $TypeInfo
static readonly "NONE": $ItemPredicate

 "test"(itemStack: any): boolean
 "test"(itemStack: $ItemStack$$Type): boolean
static "wrap"(from: any): $ItemPredicate
 "testItem"(item: $Item$$Type): boolean
 "getStackArray"(): ($ItemStack)[]
 "getItemIds"(): $Set<(StringJS)>
 "getFirst"(): $ItemStack
 "getItemTypes"(): $Set<($Item)>
 "getItemStream"(): $Stream<($Item)>
 "isWildcard"(): boolean
 "canBeUsedForMatching"(): boolean
 "getDisplayStacks"(): $ItemStackSet
 "asIngredient"(): $Ingredient
 "getStacks"(): $ItemStackSet
 "or"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "not"<T>(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "isEqual"<T>(arg0: any): $Predicate<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPredicate$$Type = ($Ingredient$$Type) | ("*") | ("-") | ((item: $ItemStack) => boolean) | ((itemStack: $ItemStack) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemPredicate$$Original = $ItemPredicate;}
declare module "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder" {
import {$ToDoubleFunction$$Type} from "java.util.function.ToDoubleFunction"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$NumberProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.number.NumberProvider"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$CropBlockBuilder$ShapeBuilder$$Type} from "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$ShapeBuilder"
import {$KubeDataGenerator$$Type} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$CropBlockBuilder$SurviveCallback$$Type} from "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$SurviveCallback"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback, $RandomTickCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"

export class $CropBlockBuilder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "CROP_ITEM_TAGS": ($ResourceLocation)[]
static readonly "CROP_BLOCK_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

/**
 * Set the age of the crop and the shape of the crop at that age.
 */
public "age"(age: integer, builder: $Consumer$$Type<($CropBlockBuilder$ShapeBuilder)>): this
/**
 * Set the age of the crop. Note that the box will be the same for all ages (A full block size).
 */
public "age"(age: integer): this
public "randomTick"(randomTickCallback: $Consumer$$Type<($RandomTickCallback)>): $BlockBuilder
/**
 * Add a crop output with exactly one output.
 */
public "crop"(output: $Holder$$Type<($Item)>): this
/**
 * Add a crop output with a specific amount.
 */
public "crop"(output: $Holder$$Type<($Item)>, chance: $NumberProvider$$Type): this
public "bonemeal"(bonemealCallback: $ToIntFunction$$Type<($RandomTickCallback)>): this
/**
 * Remove seed drops from the loot table, does not prevent seed item from creating.
 */
public "noSeeds"(): this
public "survive"(surviveCallback: $CropBlockBuilder$SurviveCallback$$Type): this
public "growTick"(growSpeedCallback: $ToDoubleFunction$$Type<($RandomTickCallback)>): this
public "generateLootTable"(generator: $KubeDataGenerator$$Type): $LootTable
public "farmersCanPlant"(): this
public "noItem"(): $BlockBuilder
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlockBuilder$$Type = ($CropBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CropBlockBuilder$$Original = $CropBlockBuilder;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.ColorWrapper" {
import {$ColorRGBA} from "net.minecraft.util.ColorRGBA"
import {$Map} from "java.util.Map"
import {$DyeColor} from "net.minecraft.world.item.DyeColor"
import {$KubeColor} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$TextColor} from "net.minecraft.network.chat.TextColor"
import {$ChatFormatting} from "net.minecraft.ChatFormatting"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ColorWrapper$$Interface {
}

export class $ColorWrapper implements $ColorWrapper$$Interface {
static readonly "BLUE_DYE": $KubeColor
static readonly "GOLD": $KubeColor
static readonly "GRAY": $KubeColor
static readonly "MAGENTA_DYE": $KubeColor
static readonly "BLUE": $KubeColor
static readonly "DARK_AQUA": $KubeColor
static readonly "TEXT": $Map<(StringJS), ($ChatFormatting)>
static readonly "DYE": $Map<(StringJS), ($DyeColor)>
static readonly "WHITE_DYE": $KubeColor
static readonly "DARK_RED": $KubeColor
static readonly "LIGHT_PURPLE": $KubeColor
static readonly "BROWN_DYE": $KubeColor
static readonly "BLACK": $KubeColor
static readonly "GRAY_DYE": $KubeColor
static readonly "NONE": $KubeColor
static readonly "LIGHT_BLUE_DYE": $KubeColor
static readonly "AQUA": $KubeColor
static readonly "WHITE": $KubeColor
static readonly "LIGHT_GRAY_DYE": $KubeColor
static readonly "BLACK_DYE": $KubeColor
static readonly "RED_DYE": $KubeColor
static readonly "PURPLE_DYE": $KubeColor
static readonly "GREEN_DYE": $KubeColor
static readonly "PINK_DYE": $KubeColor
static readonly "DARK_BLUE": $KubeColor
static readonly "GREEN": $KubeColor
static readonly "CYAN_DYE": $KubeColor
static readonly "RED": $KubeColor
static readonly "DARK_PURPLE": $KubeColor
static readonly "ORANGE_DYE": $KubeColor
static readonly "YELLOW_DYE": $KubeColor
static readonly "DARK_GREEN": $KubeColor
static readonly "YELLOW": $KubeColor
static readonly "LIME_DYE": $KubeColor
static readonly "DARK_GRAY": $KubeColor
static readonly "MAP": $Map<(StringJS), ($KubeColor)>

static "wrap"(o: any): $KubeColor
static "rgba"(r: integer, g: integer, b: integer, a: integer): $KubeColor
static "wrapTextColor"(o: any): $TextColor
static "wrapColorRGBA"(o: any): $ColorRGBA
static "createMapped"(o: any, ...names: (StringJS)[]): $KubeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColorWrapper$$Type = ($ColorWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ColorWrapper$$Original = $ColorWrapper;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.NBTWrapper" {
import {$CollectionTag} from "net.minecraft.nbt.CollectionTag"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$Map$$Type} from "java.util.Map"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$OrderedCompoundTag} from "dev.latvian.mods.kubejs.util.OrderedCompoundTag"
import {$ListTag} from "net.minecraft.nbt.ListTag"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $NBTWrapper$$Interface {
}

export class $NBTWrapper implements $NBTWrapper$$Interface {
static "wrap"(v: any): $Tag
static "i"(v: integer): $Tag
static "b"(v: byte): $Tag
static "ba"(v: (byte)[]): $Tag
static "s"(v: short): $Tag
static "f"(v: float): $Tag
static "l"(v: long): $Tag
static "d"(v: double): $Tag
static "read"(buf: $FriendlyByteBuf$$Type): $OrderedCompoundTag
static "ia"(v: (integer)[]): $Tag
static "compoundTag"(map: $Map$$Type<(never), (never)>): $Tag
static "compoundTag"(): $Tag
static "wrapCollection"(v: any): $CollectionTag<(never)>
static "la"(v: (long)[]): $Tag
static "toJson"(t: $Tag$$Type): $JsonElement
static "stringTag"(v: StringJS): $Tag
static "fromTag"(t: $Tag$$Type): any
static "intTag"(v: integer): $Tag
static "listTag"(list: $List$$Type<(never)>): $Tag
static "listTag"(): $Tag
static "isTagCollection"(o: any): boolean
static "isTagCompound"(o: any): boolean
static "wrapListTag"(list: any): $ListTag
static "wrapCompound"(v: any): $CompoundTag
static "toTag"(tag: $Tag$$Type): $Tag
static "longTag"(v: long): $Tag
static "doubleTag"(v: double): $Tag
static "shortTag"(v: short): $Tag
static "byteTag"(v: byte): $Tag
static "floatTag"(v: float): $Tag
static "longArrayTag"(v: (long)[]): $Tag
static "byteArrayTag"(v: (byte)[]): $Tag
static "intArrayTag"(v: (integer)[]): $Tag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTWrapper$$Type = ($NBTWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NBTWrapper$$Original = $NBTWrapper;}
declare module "dev.latvian.mods.kubejs.core.ServerPlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubeJSInventoryListener} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$PlayerKJS$$Interface} from "dev.latvian.mods.kubejs.core.PlayerKJS"
import {$Stages} from "dev.latvian.mods.kubejs.stages.Stages"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$ChestMenuData$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuData"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS, $InventoryKJS$$Type} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$KubeJSGUI$$Type} from "dev.latvian.mods.kubejs.gui.KubeJSGUI"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Container} from "net.minecraft.world.Container"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$EntityPotionEffectsJS} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ServerPlayerKJS$$Interface extends $PlayerKJS$$Interface {

(): $AttachedData$$Type<($Player$$Type)>
set "selectedSlot"(value: integer)
get "miningBlock"(): boolean
set "mouseItem"(value: $ItemStack$$Type)
get "stats"(): $PlayerStatsJS
set "activePostShader"(value: $ResourceLocation$$Type)
get "op"(): boolean
get "spawnLocation"(): $LevelBlock
set "spawnLocation"(value: $LevelBlock$$Type)
set "creativeMode"(value: boolean)
get "inventoryChangeListener"(): $KubeJSInventoryListener
get "craftingGrid"(): $InventoryKJS
get "openInventory"(): $AbstractContainerMenu
get "selectedSlot"(): integer
get "mouseItem"(): $ItemStack
get "xpLevel"(): integer
set "foodLevel"(value: integer)
set "saturation"(value: float)
set "xpLevel"(value: integer)
get "stages"(): $Stages
get "saturation"(): float
get "inventory"(): $InventoryKJS
get "foodLevel"(): integer
get "fake"(): boolean
get "xp"(): integer
set "xp"(value: integer)
set "statusMessage"(value: $Component$$Type)
get "profile"(): $GameProfile
get "player"(): boolean
get "headArmorItem"(): $ItemStack
get "reachDistance"(): double
set "chestArmorItem"(value: $ItemStack$$Type)
get "legsArmorItem"(): $ItemStack
get "mainHandItem"(): $ItemStack
set "headArmorItem"(value: $ItemStack$$Type)
set "legsArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
get "feetArmorItem"(): $ItemStack
get "totalMovementSpeed"(): double
set "feetArmorItem"(value: $ItemStack$$Type)
set "mainHandItem"(value: $ItemStack$$Type)
get "potionEffects"(): $EntityPotionEffectsJS
get "defaultMovementSpeed"(): double
set "defaultMovementSpeed"(value: double)
set "movementSpeedAddition"(value: double)
set "totalMovementSpeedMultiplier"(value: double)
set "defaultMovementSpeedMultiplier"(value: double)
get "living"(): boolean
get "offHandItem"(): $ItemStack
set "offHandItem"(value: $ItemStack$$Type)
set "maxHealth"(value: float)
get "undead"(): boolean
get "data"(): $AttachedData<($Player)>
get "peacefulCreature"(): boolean
get "waterCreature"(): boolean
get "ambientCreature"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "nbt"(): $CompoundTag
set "x"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "z"(value: double)
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "block"(): $LevelBlock
get "server"(): $MinecraftServer
get "motionX"(): double
set "motionY"(value: double)
get "facing"(): $Direction
get "frame"(): boolean
get "passengers"(): $EntityArrayList
get "item"(): $ItemStack
get "motionZ"(): double
get "type"(): StringJS
set "motionZ"(value: double)
get "animal"(): boolean
get "monster"(): boolean
get "teamId"(): StringJS
get "motionY"(): double
set "motionX"(value: double)
get "scriptType"(): $ScriptType
get "persistentData"(): $CompoundTag
}

export class $ServerPlayerKJS implements $ServerPlayerKJS$$Interface {
 "openChestGUI"(gui: $Consumer$$Type<($KubeJSGUI)>): void
 "openChestGUI"(title: $Component$$Type, rows: integer, gui: $Consumer$$Type<($ChestMenuData)>): void
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "setSelectedSlot"(index: integer): void
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "isMiningBlock"(): boolean
 "setMouseItem"(item: $ItemStack$$Type): void
 "getStats"(): $PlayerStatsJS
 "notify"(builder: $NotificationToastData$$Type): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "self"(): $Player
 "isOp"(): boolean
 "ban"(banner: StringJS, reason: StringJS, expiresInMillis: long): void
 "kick"(): void
 "kick"(reason: $Component$$Type): void
 "heal"(): void
 "unlockAdvancement"(id: $ResourceLocation$$Type): void
 "getSpawnLocation"(): $LevelBlock
 "openInventoryGUI"(inventory: $InventoryKJS$$Type, title: $Component$$Type, columns: integer): void
 "openInventoryGUI"(inventory: $InventoryKJS$$Type, title: $Component$$Type): void
 "openInventoryGUI"(inventory: $InventoryKJS$$Type, title: $Component$$Type, columns: integer, rows: integer): void
 "revokeAdvancement"(id: $ResourceLocation$$Type): void
 "setSpawnLocation"(c: $LevelBlock$$Type): void
 "isAdvancementDone"(id: $ResourceLocation$$Type): boolean
 "captureInventory"(autoRestore: boolean): $Container
 "setCreativeMode"(mode: boolean): void
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "addItemCooldown"(item: $Item$$Type, ticks: integer): void
 "getCraftingGrid"(): $InventoryKJS
 "boostElytraFlight"(): void
 "sendInventoryUpdate"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "getSelectedSlot"(): integer
 "spawn"(): void
 "addXPLevels"(l: integer): void
 "getMouseItem"(): $ItemStack
 "getXpLevel"(): integer
 "setFoodLevel"(foodLevel: integer): void
 "setSaturation"(saturation: float): void
 "addFood"(f: integer, m: float): void
 "setXpLevel"(l: integer): void
 "addExhaustion"(exhaustion: float): void
 "getStages"(): $Stages
 "giveInHand"(item: $ItemStack$$Type): void
 "getSaturation"(): float
 "getInventory"(): $InventoryKJS
 "getFoodLevel"(): integer
 "isFake"(): boolean
 "give"(item: $ItemStack$$Type): void
 "getXp"(): integer
 "notify"(title: $Component$$Type, text: $Component$$Type): void
 "addXP"(xp: integer): void
 "setXp"(xp: integer): void
 "setStatusMessage"(message: $Component$$Type): void
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "getHeadArmorItem"(): $ItemStack
 "getReachDistance"(): double
 "setChestArmorItem"(item: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "getMainHandItem"(): $ItemStack
 "setHeadArmorItem"(item: $ItemStack$$Type): void
 "setLegsArmorItem"(item: $ItemStack$$Type): void
 "getChestArmorItem"(): $ItemStack
 "getFeetArmorItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "getAttributeTotalValue"(attribute: $Holder$$Type<($Attribute)>): double
 "getAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>): double
 "canEntityBeSeen"(entity: $LivingEntity$$Type): boolean
 "setFeetArmorItem"(item: $ItemStack$$Type): void
 "setAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>, value: double): void
 "isHoldingInAnyHand"(i: $ItemPredicate$$Type): boolean
 "modifyAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): void
 "setMainHandItem"(item: $ItemStack$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "getPotionEffects"(): $EntityPotionEffectsJS
 "removeAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): void
 "swing"(hand: $InteractionHand$$Type): void
 "swing"(): void
 "getDefaultMovementSpeed"(): double
 "setDefaultMovementSpeed"(speed: double): void
 "setMovementSpeedAddition"(speed: double): void
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "foodEaten"(is: $ItemStack$$Type, food: $FoodProperties$$Type): void
 "isLiving"(): boolean
 "damageHeldItem"(): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "getOffHandItem"(): $ItemStack
 "setOffHandItem"(item: $ItemStack$$Type): void
 "getHeldItem"(hand: $InteractionHand$$Type): $ItemStack
 "rayTraceEntity"(filter: $Predicate$$Type<($Entity)>): $Entity
 "rayTrace"(): $KubeRayTraceResult
 "setMaxHealth"(hp: float): void
 "getEquipment"(slot: $EquipmentSlot$$Type): $ItemStack
 "isUndead"(): boolean
 "setEquipment"(slot: $EquipmentSlot$$Type, item: $ItemStack$$Type): void
 "setHeldItem"(hand: $InteractionHand$$Type, item: $ItemStack$$Type): void
 "sendData"(channel: StringJS): void
 "getData"(): $AttachedData<($Player)>
 "isPeacefulCreature"(): boolean
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isAmbientCreature"(): boolean
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "getNbt"(): $CompoundTag
 "setX"(x: double): void
 "attack"(hp: float): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "runCommandSilent"(command: StringJS): void
 "tell"(message: $Component$$Type): void
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "playSound"(id: $SoundEvent$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "getServer"(): $MinecraftServer
 "getMotionX"(): double
 "setMotionY"(y: double): void
 "getFacing"(): $Direction
 "isFrame"(): boolean
 "getPassengers"(): $EntityArrayList
 "getItem"(): $ItemStack
 "setRotation"(yaw: float, pitch: float): void
 "getMotionZ"(): double
 "getType"(): StringJS
 "setMotionZ"(z: double): void
 "isAnimal"(): boolean
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "isMonster"(): boolean
 "getTeamId"(): StringJS
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getMotionY"(): double
 "setMotionX"(x: double): void
 "getScriptType"(): $ScriptType
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerPlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerPlayerKJS$$Original = $ServerPlayerKJS;}
declare module "dev.latvian.mods.kubejs.block.callback.CanBeReplacedCallback" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$InteractionHand} from "net.minecraft.world.InteractionHand"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CanBeReplacedCallback {
constructor(blockPlaceContext: $BlockPlaceContext$$Type, state: $BlockState$$Type)

public "getLevel"(): $Level
public "getItem"(): $ItemStack
public "isSecondaryUseActive"(): boolean
public "getNearestLookingDirections"(): ($Direction)[]
public "getNearestLookingDirection"(): $Direction
public "getHorizontalDirection"(): $Direction
public "getHand"(): $InteractionHand
public "getPlayer"(): $Player
public "canBeReplaced"(): boolean
public "getNearestLookingVerticalDirection"(): $Direction
public "getClickedPos"(): $BlockPos
public "getClickedFace"(): $Direction
public "isInside"(): boolean
public "getClickLocation"(): $Vec3
public "getRotation"(): float
public "getFluidStateAtClickedPos"(): $FluidState
public "isClickedPosIn"(fluid: $Fluid$$Type): boolean
public "getClickedBlock"(): $LevelBlock
get "level"(): $Level
get "item"(): $ItemStack
get "secondaryUseActive"(): boolean
get "nearestLookingDirections"(): ($Direction)[]
get "nearestLookingDirection"(): $Direction
get "horizontalDirection"(): $Direction
get "hand"(): $InteractionHand
get "player"(): $Player
get "nearestLookingVerticalDirection"(): $Direction
get "clickedPos"(): $BlockPos
get "clickedFace"(): $Direction
get "inside"(): boolean
get "clickLocation"(): $Vec3
get "rotation"(): float
get "fluidStateAtClickedPos"(): $FluidState
get "clickedBlock"(): $LevelBlock
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CanBeReplacedCallback$$Type = ($CanBeReplacedCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CanBeReplacedCallback$$Original = $CanBeReplacedCallback;}
declare module "dev.latvian.mods.kubejs.entity.AfterLivingEntityHurtKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$DamageSource} from "net.minecraft.world.damagesource.DamageSource"
import {$Level} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$LivingDamageEvent$Post$$Type} from "net.neoforged.neoforge.event.entity.living.LivingDamageEvent$Post"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked after an entity is hurt by a damage source.
 */
export class $AfterLivingEntityHurtKubeEvent implements $KubeLivingEntityEvent$$Interface {
constructor(event: $LivingDamageEvent$Post$$Type)

/**
 * The damage source.
 */
public "getSource"(): $DamageSource
/**
 * The entity that was hurt.
 */
public "getEntity"(): $LivingEntity
/**
 * The amount of damage.
 */
public "getDamage"(): float
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "source"(): $DamageSource
get "entity"(): $LivingEntity
get "damage"(): float
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterLivingEntityHurtKubeEvent$$Type = ($AfterLivingEntityHurtKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AfterLivingEntityHurtKubeEvent$$Original = $AfterLivingEntityHurtKubeEvent;}
declare module "dev.latvian.mods.kubejs.plugin.KubeJSPluginEvent" {
import {$Event} from "net.neoforged.bus.api.Event"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $KubeJSPluginEvent extends $Event {
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSPluginEvent$$Type = ($KubeJSPluginEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSPluginEvent$$Original = $KubeJSPluginEvent;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Chestplate" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ArmorItemBuilder} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $ArmorItemBuilder$Chestplate extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "CHESTPLATE_TAGS": ($ResourceLocation)[]

constructor(id: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Chestplate$$Type = ($ArmorItemBuilder$Chestplate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$Chestplate$$Original = $ArmorItemBuilder$Chestplate;}
declare module "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$TextAction, $TextAction$$Type} from "dev.latvian.mods.kubejs.text.action.TextAction"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$TooltipRequirements, $TooltipRequirements$$Type} from "dev.latvian.mods.kubejs.text.tooltip.TooltipRequirements"
import {$List, $List$$Type} from "java.util.List"
import {$Record} from "java.lang.Record"

export class $ItemTooltipData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemTooltipData)>

constructor(filter: ($Ingredient$$Type)?, requirements: ($TooltipRequirements$$Type)?, actions: $List$$Type<($TextAction$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $Optional<($Ingredient)>
public "actions"(): $List<($TextAction)>
public "requirements"(): $Optional<($TooltipRequirements)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTooltipData$$Type = ({"requirements"?: ($TooltipRequirements$$Type)?, "filter"?: ($Ingredient$$Type)?, "actions"?: $List$$Type<($TextAction$$Type)>}) | ([requirements?: ($TooltipRequirements$$Type)?, filter?: ($Ingredient$$Type)?, actions?: $List$$Type<($TextAction$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemTooltipData$$Original = $ItemTooltipData;}
declare module "dev.latvian.mods.kubejs.client.ParticleGenerator" {
import {$List$$Type} from "java.util.List"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $ParticleGenerator {
constructor()

public "toJson"(): $JsonObject
public "textures"(textures: $List$$Type<(StringJS)>): $ParticleGenerator
public "texture"(texture: StringJS): $ParticleGenerator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleGenerator$$Type = ($ParticleGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ParticleGenerator$$Original = $ParticleGenerator;}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Pickaxe" {
import {$BiFunction} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DiggerItemBuilder} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$Item$Properties} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Pickaxe extends $DiggerItemBuilder {
 "sourceLine": $SourceLine
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
static readonly "PICKAXE_TAGS": ($ResourceLocation)[]
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "PICKAXE_MODEL": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Pickaxe$$Type = ($DiggerItemBuilder$Pickaxe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemBuilder$Pickaxe$$Original = $DiggerItemBuilder$Pickaxe;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Group" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Record} from "java.lang.Record"

export class $ItemData$Group extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData$Group)>

constructor(filter: $Ingredient$$Type, groupId: $ResourceLocation$$Type, description: $Component$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $Ingredient
public "description"(): $Component
public "groupId"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$Group$$Type = ({"description"?: $Component$$Type, "groupId"?: $ResourceLocation$$Type, "filter"?: $Ingredient$$Type}) | ([description?: $Component$$Type, groupId?: $ResourceLocation$$Type, filter?: $Ingredient$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemData$Group$$Original = $ItemData$Group;}
declare module "dev.latvian.mods.kubejs.block.drop.BlockDrops" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$NumberProvider, $NumberProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.number.NumberProvider"
import {$Record} from "java.lang.Record"

export class $BlockDrops extends $Record {
static readonly "EMPTY": $BlockDrops

constructor(items: ($ItemStack$$Type)[], rolls: $NumberProvider$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "items"(): ($ItemStack)[]
public static "createDefault"(item: $ItemStack$$Type): $BlockDrops
public "rolls"(): $NumberProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockDrops$$Type = ({"items"?: ($ItemStack$$Type)[], "rolls"?: $NumberProvider$$Type}) | ([items?: ($ItemStack$$Type)[], rolls?: $NumberProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockDrops$$Original = $BlockDrops;}
declare module "dev.latvian.mods.kubejs.core.LevelKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$WithAttachedData$$Interface} from "dev.latvian.mods.kubejs.core.WithAttachedData"
import {$UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ExplosionProperties$$Type} from "dev.latvian.mods.kubejs.level.ExplosionProperties"
import {$ScriptTypeHolder$$Interface} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityGetterKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityGetterKJS"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $LevelKJS$$Interface extends $WithAttachedData$$Interface<($Level)>, $ScriptTypeHolder$$Interface, $EntityGetterKJS$$Interface {

(): $AttachedData$$Type<($Level$$Type)>
get "name"(): $Component
get "overworld"(): boolean
get "dimension"(): $ResourceLocation
set "time"(value: long)
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "side"(): $ScriptType
get "data"(): $AttachedData<($Level)>
get "mcEntities"(): $Iterable<($Entity)>
get "players"(): $EntityArrayList
get "mcPlayers"(): $List<($Player)>
get "displayName"(): $Component
get "entities"(): $EntityArrayList
}

export class $LevelKJS implements $LevelKJS$$Interface {
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean): void
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean, cause: $ServerPlayer$$Type): void
 "isOverworld"(): boolean
 "explode"(x: double, y: double, z: double, properties: $ExplosionProperties$$Type): $Explosion
 "createEntity"(type: $EntityType$$Type<(never)>): $Entity
 "spawnEntity"(type: $EntityType$$Type<(never)>, callback: $Consumer$$Type<($Entity)>): void
 "spawnFireworks"(x: double, y: double, z: double, fireworks: $Fireworks$$Type, lifetime: integer): void
 "spawnParticles"(options: $ParticleOptions$$Type, overrideLimiter: boolean, x: double, y: double, z: double, vx: double, vy: double, vz: double, count: integer, speed: double): void
 "getDimension"(): $ResourceLocation
 "setTime"(time: long): void
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "self"(): $Level
 "tell"(message: $Component$$Type): void
 "getBlock"(x: integer, y: integer, z: integer): $LevelBlock
 "getBlock"(entity: $BlockEntity$$Type): $LevelBlock
 "getBlock"(pos: $BlockPos$$Type): $LevelBlock
 "getSide"(): $ScriptType
 "getData"(): $AttachedData<($Level)>
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getPlayers"(): $EntityArrayList
 "getMcPlayers"(): $List<($Player)>
 "getDisplayName"(): $Component
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntities"(): $EntityArrayList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelKJS$$Type = (() => $AttachedData$$Type<($Level$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelKJS$$Original = $LevelKJS;}
declare module "dev.latvian.mods.kubejs.util.IntBounds" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$Record} from "java.lang.Record"

export class $IntBounds extends $Record {
static readonly "OPTIONAL": $IntBounds
static readonly "CODEC": $Codec<($IntBounds)>
static readonly "MAP_CODEC": $MapCodec<($IntBounds)>
static readonly "DEFAULT": $IntBounds
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($IntBounds)>

constructor(min: integer, max: integer)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "min"(): integer
public "max"(): integer
public static "of"(min: integer, max: integer): $IntBounds
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntBounds$$Type = ({"max"?: integer, "min"?: integer}) | ([max?: integer, min?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IntBounds$$Original = $IntBounds;}
declare module "dev.latvian.mods.kubejs.entity.KubeEntityEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export interface $KubeEntityEvent$$Interface extends $KubeLevelEvent$$Interface {

(): $Entity$$Type
get "level"(): $Level
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}

export class $KubeEntityEvent implements $KubeEntityEvent$$Interface {
 "getLevel"(): $Level
 "getEntity"(): $Entity
 "getPlayer"(): $Player
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeEntityEvent$$Type = (() => $Entity$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeEntityEvent$$Original = $KubeEntityEvent;}
declare module "dev.latvian.mods.kubejs.item.ItemEntityInteractedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player right clicks on an entity.
 */
export class $ItemEntityInteractedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, entity: $Entity$$Type, hand: $InteractionHand$$Type, item: $ItemStack$$Type)

/**
 * The entity that was interacted with.
 */
public "getTarget"(): $Entity
/**
 * The item that was used to interact with the entity.
 */
public "getItem"(): $ItemStack
/**
 * The player that interacted with the entity.
 */
public "getEntity"(): $Entity
/**
 * The hand that was used to interact with the entity.
 */
public "getHand"(): $InteractionHand
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "target"(): $Entity
get "item"(): $ItemStack
get "entity"(): $Entity
get "hand"(): $InteractionHand
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEntityInteractedKubeEvent$$Type = ($ItemEntityInteractedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemEntityInteractedKubeEvent$$Original = $ItemEntityInteractedKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.FluidKJS" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$List} from "java.util.List"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$FluidLike, $FluidLike$$Interface} from "dev.latvian.mods.kubejs.fluid.FluidLike"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$Holder} from "net.minecraft.core.Holder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $FluidKJS$$Interface extends $RegistryObjectKJS$$Interface<($Fluid)>, $FluidLike$$Interface {
get "empty"(): boolean
get "registry"(): $Registry<($Fluid)>
get "registryId"(): $ResourceKey<($Registry<($Fluid)>)>
get "amount"(): integer
get "fluid"(): $Fluid
get "id"(): StringJS
get "key"(): $ResourceKey<($Fluid)>
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Fluid)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $FluidKJS implements $FluidKJS$$Interface {
 "isEmpty"(): boolean
 "getRegistry"(): $Registry<($Fluid)>
 "getRegistryId"(): $ResourceKey<($Registry<($Fluid)>)>
 "getAmount"(): integer
 "getFluid"(): $Fluid
 "specialEquals"(o: any, shallow: boolean): boolean
 "getId"(): StringJS
 "getKey"(): $ResourceKey<($Fluid)>
 "getMod"(): StringJS
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getIdLocation"(): $ResourceLocation
 "asHolder"(): $Holder<($Fluid)>
 "getTagKeys"(): $List<($TagKey<($Fluid)>)>
 "getTags"(): $List<($ResourceLocation)>
 "copy"(amount: integer): $FluidLike
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidKJS$$Type = ($FluidKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidKJS$$Original = $FluidKJS;}
declare module "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent" {
import {$TinyMap} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeComponent, $RecipeComponent$$Type, $RecipeComponent$$Interface} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeKey} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$RecipeComponentType} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Set$$Type} from "java.util.Set"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"
import {$OpsContainer$$Type} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$EitherRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent"
import {$CustomObjectRecipeComponent$Key, $CustomObjectRecipeComponent$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$CustomObjectRecipeComponent$Value, $CustomObjectRecipeComponent$Value$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Value"
import {$RecipeComponentBuilder} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder"
import {$KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$ListRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.ListRecipeComponent"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $CustomObjectRecipeComponent implements $RecipeComponent$$Interface<($List<($CustomObjectRecipeComponent$Value)>)> {
static readonly "TYPE": $RecipeComponentType<(never)>

constructor(keys: $List$$Type<($CustomObjectRecipeComponent$Key$$Type)>)

public "type"(): $RecipeComponentType<(never)>
public "toString"(): StringJS
public "wrap"(rcx: $RecipeScriptContext$$Type, from: any): $List<($CustomObjectRecipeComponent$Value)>
public "isEmpty"(value: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>): boolean
public "isEmpty"(value: any): boolean
public "replace"(cx: $RecipeScriptContext$$Type, original: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>, match: $ReplacementMatchInfo$$Type, arg3: any): $List<($CustomObjectRecipeComponent$Value)>
public "replace"(cx: $RecipeScriptContext$$Type, original: any, match: $ReplacementMatchInfo$$Type, arg3: any): any
public "matches"(cx: $RecipeMatchContext$$Type, value: any, match: $ReplacementMatchInfo$$Type): boolean
public "matches"(cx: $RecipeMatchContext$$Type, value: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>, match: $ReplacementMatchInfo$$Type): boolean
public "validate"(ctx: $RecipeValidationContext$$Type, value: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>): void
public "validate"(ctx: $RecipeValidationContext$$Type, value: any): void
public "typeInfo"(): $TypeInfo
public "keys"(): $List<($CustomObjectRecipeComponent$Key)>
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, list: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>): void
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, list: any): void
public "mapCodec"(): $MapCodec<($List<($CustomObjectRecipeComponent$Value)>)>
public "codec"(): $Codec<($List<($CustomObjectRecipeComponent$Value)>)>
public "createCopy"(): $CustomObjectRecipeComponent
public "hasPriority"(hasPriority: $Predicate$$Type<($Set<(StringJS)>)>): $CustomObjectRecipeComponent
public "hasPriority"(cx: $RecipeMatchContext$$Type, from: any): boolean
public "toString"(ops: $OpsContainer$$Type, value: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>): StringJS
public static "builder"(keys: $List$$Type<($CustomObjectRecipeComponent$Key$$Type)>): $CustomObjectRecipeComponent
public static "builder"(...keys: ($CustomObjectRecipeComponent$Key$$Type)[]): $CustomObjectRecipeComponent
public "key"(name: StringJS, role: $ComponentRole$$Type): $RecipeKey<($List<($CustomObjectRecipeComponent$Value)>)>
public "asList"(): $ListRecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "spread"(value: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>): $List<(never)>
public "or"<O>(other: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<($List<($CustomObjectRecipeComponent$Value)>), (O)>
public "readFromJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($List$$Type<($CustomObjectRecipeComponent$Value$$Type)>)>, json: $JsonObject$$Type): void
public "asListOrSelf"(): $ListRecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($List<($CustomObjectRecipeComponent$Value)>)>)>
public "asConditionalList"(): $ListRecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "writeToJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($List$$Type<($CustomObjectRecipeComponent$Value$$Type)>)>, json: $JsonObject$$Type): void
public "isIgnored"(): boolean
public "otherKey"(name: StringJS): $RecipeKey<($List<($CustomObjectRecipeComponent$Value)>)>
public "createBuilder"(): $RecipeComponentBuilder
public "inputKey"(name: StringJS): $RecipeKey<($List<($CustomObjectRecipeComponent$Value)>)>
public "asMap"<K>(key: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($List<($CustomObjectRecipeComponent$Value)>)>)>
public "orSelf"(): $RecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "allowEmpty"(): boolean
public "asConditionalListOrSelf"(): $ListRecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "withCodec"(codec: $Codec$$Type<($List$$Type<($CustomObjectRecipeComponent$Value$$Type)>)>): $RecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "outputKey"(name: StringJS): $RecipeKey<($List<($CustomObjectRecipeComponent$Value)>)>
get "ignored"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomObjectRecipeComponent$$Type = ($CustomObjectRecipeComponent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomObjectRecipeComponent$$Original = $CustomObjectRecipeComponent;}
declare module "dev.latvian.mods.kubejs.core.LivingEntityKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$EntityPotionEffectsJS} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$EntityKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityKJS"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $LivingEntityKJS$$Interface extends $EntityKJS$$Interface {
get "headArmorItem"(): $ItemStack
get "reachDistance"(): double
set "chestArmorItem"(value: $ItemStack$$Type)
get "legsArmorItem"(): $ItemStack
get "mainHandItem"(): $ItemStack
set "headArmorItem"(value: $ItemStack$$Type)
set "legsArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
get "feetArmorItem"(): $ItemStack
get "totalMovementSpeed"(): double
set "feetArmorItem"(value: $ItemStack$$Type)
set "mainHandItem"(value: $ItemStack$$Type)
get "potionEffects"(): $EntityPotionEffectsJS
get "defaultMovementSpeed"(): double
set "defaultMovementSpeed"(value: double)
set "movementSpeedAddition"(value: double)
set "totalMovementSpeedMultiplier"(value: double)
set "defaultMovementSpeedMultiplier"(value: double)
get "living"(): boolean
get "offHandItem"(): $ItemStack
set "offHandItem"(value: $ItemStack$$Type)
set "maxHealth"(value: float)
get "undead"(): boolean
get "peacefulCreature"(): boolean
get "waterCreature"(): boolean
get "ambientCreature"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "nbt"(): $CompoundTag
set "x"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "z"(value: double)
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "block"(): $LevelBlock
get "server"(): $MinecraftServer
get "motionX"(): double
set "motionY"(value: double)
get "facing"(): $Direction
get "profile"(): $GameProfile
get "frame"(): boolean
get "passengers"(): $EntityArrayList
get "item"(): $ItemStack
get "player"(): boolean
get "motionZ"(): double
get "type"(): StringJS
set "motionZ"(value: double)
get "animal"(): boolean
get "monster"(): boolean
get "teamId"(): StringJS
get "motionY"(): double
set "motionX"(value: double)
get "scriptType"(): $ScriptType
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $LivingEntityKJS implements $LivingEntityKJS$$Interface {
static readonly "KJS_PLAYER_CUSTOM_SPEED": $ResourceLocation

 "getHeadArmorItem"(): $ItemStack
 "getReachDistance"(): double
 "setChestArmorItem"(item: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "getMainHandItem"(): $ItemStack
 "setHeadArmorItem"(item: $ItemStack$$Type): void
 "setLegsArmorItem"(item: $ItemStack$$Type): void
 "getChestArmorItem"(): $ItemStack
 "getFeetArmorItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "getAttributeTotalValue"(attribute: $Holder$$Type<($Attribute)>): double
 "getAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>): double
 "canEntityBeSeen"(entity: $LivingEntity$$Type): boolean
 "setFeetArmorItem"(item: $ItemStack$$Type): void
 "setAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>, value: double): void
 "isHoldingInAnyHand"(i: $ItemPredicate$$Type): boolean
 "modifyAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): void
 "setMainHandItem"(item: $ItemStack$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "getPotionEffects"(): $EntityPotionEffectsJS
 "removeAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): void
 "swing"(hand: $InteractionHand$$Type): void
 "swing"(): void
 "self"(): $Entity
 "getDefaultMovementSpeed"(): double
 "setDefaultMovementSpeed"(speed: double): void
 "setMovementSpeedAddition"(speed: double): void
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "foodEaten"(is: $ItemStack$$Type, food: $FoodProperties$$Type): void
 "isLiving"(): boolean
 "damageHeldItem"(): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "getOffHandItem"(): $ItemStack
 "setOffHandItem"(item: $ItemStack$$Type): void
 "getHeldItem"(hand: $InteractionHand$$Type): $ItemStack
 "rayTraceEntity"(filter: $Predicate$$Type<($Entity)>): $Entity
 "rayTrace"(): $KubeRayTraceResult
 "setMaxHealth"(hp: float): void
 "getEquipment"(slot: $EquipmentSlot$$Type): $ItemStack
 "isUndead"(): boolean
 "setEquipment"(slot: $EquipmentSlot$$Type, item: $ItemStack$$Type): void
 "setHeldItem"(hand: $InteractionHand$$Type, item: $ItemStack$$Type): void
 "isPeacefulCreature"(): boolean
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isAmbientCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "getNbt"(): $CompoundTag
 "setX"(x: double): void
 "attack"(hp: float): void
 "spawn"(): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "runCommandSilent"(command: StringJS): void
 "tell"(message: $Component$$Type): void
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "playSound"(id: $SoundEvent$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "getServer"(): $MinecraftServer
 "getMotionX"(): double
 "setMotionY"(y: double): void
 "getFacing"(): $Direction
 "getProfile"(): $GameProfile
 "isFrame"(): boolean
 "getPassengers"(): $EntityArrayList
 "getItem"(): $ItemStack
 "isPlayer"(): boolean
 "setRotation"(yaw: float, pitch: float): void
 "getMotionZ"(): double
 "getType"(): StringJS
 "setMotionZ"(z: double): void
 "isAnimal"(): boolean
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "isMonster"(): boolean
 "getTeamId"(): StringJS
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getMotionY"(): double
 "setMotionX"(x: double): void
 "getScriptType"(): $ScriptType
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$$Type): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityKJS$$Type = ($LivingEntityKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LivingEntityKJS$$Original = $LivingEntityKJS;}
declare module "dev.latvian.mods.kubejs.level.SimpleLevelKubeEvent" {
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $SimpleLevelKubeEvent implements $KubeLevelEvent$$Interface {
constructor(l: $Level$$Type)

public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleLevelKubeEvent$$Type = ($SimpleLevelKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleLevelKubeEvent$$Original = $SimpleLevelKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional" {
import {$RecipeSchemaType, $RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"

export interface $RecipeOptional$$Interface<T> {

(type: $RecipeSchemaType): T
get "default"(): boolean
get "informativeValue"(): T
}

export class $RecipeOptional<T> implements $RecipeOptional$$Interface {
static readonly "DEFAULT": $RecipeOptional<(never)>

 "isDefault"(): boolean
 "getDefaultValue"(type: $RecipeSchemaType$$Type): T
static "unit"<T>(value: T): $RecipeOptional<(T)>
 "getInformativeValue"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeOptional$$Type<T> = ((type: $RecipeSchemaType) => T);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeOptional$$Original<T> = $RecipeOptional<(T)>;}
declare module "dev.latvian.mods.kubejs.script.data.GeneratedDataStage" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Map} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$EventTargetType} from "dev.latvian.mods.kubejs.event.EventTargetType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $GeneratedDataStage extends $Enum<($GeneratedDataStage)> implements $StringRepresentable$$Interface {
static readonly "BEFORE_MODS": $GeneratedDataStage
static readonly "TARGET": $EventTargetType<($GeneratedDataStage)>
static readonly "REGISTRIES": $GeneratedDataStage
static readonly "LAST": $GeneratedDataStage
readonly "displayName": StringJS
static readonly "INTERNAL": $GeneratedDataStage
static readonly "AFTER_MODS": $GeneratedDataStage
static readonly "FOR_SCRIPTS": ($GeneratedDataStage)[]

public static "values"(): ($GeneratedDataStage)[]
public static "valueOf"(name: StringJS): $GeneratedDataStage
public "getSerializedName"(): StringJS
public static "forScripts"<T>(factory: $Function$$Type<($GeneratedDataStage), (T)>): $Map<($GeneratedDataStage), (T)>
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedDataStage$$Type = (("internal") | ("registries") | ("before_mods") | ("after_mods") | ("last"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeneratedDataStage$$Original = $GeneratedDataStage;}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Axe" {
import {$BiFunction} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DiggerItemBuilder} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$Item$Properties} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Axe extends $DiggerItemBuilder {
 "sourceLine": $SourceLine
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
readonly "id": $ResourceLocation
static readonly "AXE_MODEL": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "AXE_TAGS": ($ResourceLocation)[]

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Axe$$Type = ($DiggerItemBuilder$Axe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemBuilder$Axe$$Original = $DiggerItemBuilder$Axe;}
declare module "dev.latvian.mods.kubejs.component.ComponentFunctions" {
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map$$Type} from "java.util.Map"
import {$UUID$$Type} from "java.util.UUID"
import {$List$$Type} from "java.util.List"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$Unit$$Type} from "net.minecraft.util.Unit"

export interface $ComponentFunctions$$Interface {
set "lore"(value: $List$$Type<($Component$$Type)>)
set "customData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "dyedColor"(value: $KubeColor$$Type)
set "customName"(value: $Component$$Type)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
get "customName"(): $Component
get "customData"(): $CompoundTag
set "lockCode"(value: StringJS)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
get "additionalTooltipHidden"(): void
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
get "componentString"(): StringJS
get "tooltipHidden"(): void
get "componentMap"(): $DataComponentMap
set "customModelData"(value: integer)
set "glintOverride"(value: boolean)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
}

export class $ComponentFunctions implements $ComponentFunctions$$Interface {
 "remove"(type: $DataComponentType$$Type<(never)>): this
 "get"<T>(type: $DataComponentType$$Type<(T)>): T
 "patch"(components: $DataComponentPatch$$Type): this
 "set"(components: $DataComponentMap$$Type): this
 "set"(component: $DataComponentType$$Type<(never)>, value: any): this
 "setLore"(lines: $List$$Type<($Component$$Type)>): void
 "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
 "setCustomData"(tag: $CompoundTag$$Type): void
 "setRarity"(rarity: $Rarity$$Type): void
 "setDyedColor"(color: $KubeColor$$Type): void
 "setCustomName"(name: $Component$$Type): void
 "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): this
 "getCustomName"(): $Component
 "getCustomData"(): $CompoundTag
 "setLockCode"(lock: StringJS): void
 "setProfile"(name: StringJS, uuid: $UUID$$Type): void
 "setProfile"(profile: $GameProfile$$Type): void
 "setBaseColor"(color: $DyeColor$$Type): void
 "setPotionId"(potion: $Holder$$Type<($Potion)>): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "setAdditionalTooltipHidden"(): void
 "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
 "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
 "setPotionContents"(contents: $PotionContents$$Type): void
 "getComponentString"(): StringJS
 "resetComponents"(): this
 "setTooltipHidden"(): void
 "getComponentMap"(): $DataComponentMap
 "setCustomModelData"(data: integer): void
 "setGlintOverride"(override: boolean): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentFunctions$$Type = ($ComponentFunctions);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComponentFunctions$$Original = $ComponentFunctions;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.RemoteRecipeViewerDataUpdatedEvent" {
import {$Event} from "net.neoforged.bus.api.Event"
import {$RecipeViewerData, $RecipeViewerData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.RecipeViewerData"

export class $RemoteRecipeViewerDataUpdatedEvent extends $Event {
readonly "data": $RecipeViewerData

constructor(data: $RecipeViewerData$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoteRecipeViewerDataUpdatedEvent$$Type = ($RemoteRecipeViewerDataUpdatedEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RemoteRecipeViewerDataUpdatedEvent$$Original = $RemoteRecipeViewerDataUpdatedEvent;}
declare module "dev.latvian.mods.kubejs.core.MenuTypeKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$List} from "java.util.List"
import {$MenuType} from "net.minecraft.world.inventory.MenuType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$Holder} from "net.minecraft.core.Holder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $MenuTypeKJS$$Interface extends $RegistryObjectKJS$$Interface<($MenuType<(never)>)> {
get "registry"(): $Registry<($MenuType<(never)>)>
get "registryId"(): $ResourceKey<($Registry<($MenuType<(never)>)>)>
get "id"(): StringJS
get "key"(): $ResourceKey<($MenuType<(never)>)>
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($MenuType<(never)>)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $MenuTypeKJS implements $MenuTypeKJS$$Interface {
 "getRegistry"(): $Registry<($MenuType<(never)>)>
 "getRegistryId"(): $ResourceKey<($Registry<($MenuType<(never)>)>)>
 "specialEquals"(o: any, shallow: boolean): boolean
 "getId"(): StringJS
 "getKey"(): $ResourceKey<($MenuType<(never)>)>
 "getMod"(): StringJS
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getIdLocation"(): $ResourceLocation
 "asHolder"(): $Holder<($MenuType<(never)>)>
 "getTagKeys"(): $List<($TagKey<($MenuType<(never)>)>)>
 "getTags"(): $List<($ResourceLocation)>
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MenuTypeKJS$$Type = ($MenuTypeKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MenuTypeKJS$$Original = $MenuTypeKJS;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue" {
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$WrappedJS$$Interface} from "dev.latvian.mods.kubejs.util.WrappedJS"
import {$Comparable} from "java.lang.Comparable"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$Map$Entry, $Map$Entry$$Type, $Map$Entry$$Interface} from "java.util.Map$Entry"

export class $RecipeComponentValue<T> implements $WrappedJS$$Interface, $Map$Entry$$Interface<($RecipeKey<(T)>), (T)> {
static readonly "EMPTY_ARRAY": ($RecipeComponentValue<(never)>)[]
readonly "index": integer
 "value": T
readonly "key": $RecipeKey<(T)>

constructor(key: $RecipeKey$$Type<(T)>, index: integer)

public "equals"(obj: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getValue"(): T
public "replace"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "matches"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
public "validate"(ctx: $RecipeValidationContext$$Type, sourceLine: $SourceLine$$Type): void
public "getKey"(): any
public "write"(): void
public "setValue"(newValue: T): T
public "copy"(): $RecipeComponentValue<(T)>
public "getIndex"(): integer
public "shouldWrite"(): boolean
public static "copyOf"<K, V>(arg0: $Map$Entry$$Type<($RecipeKey$$Type<(T)>), (T)>): $Map$Entry<($RecipeKey<(T)>), (T)>
public static "comparingByKey"<K, V>(arg0: $Comparator$$Type<($RecipeKey<(T)>)>): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
public static "comparingByKey"<K extends $Comparable<(object)>, V>(): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
public static "comparingByValue"<K, V extends $Comparable<(object)>>(): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
public static "comparingByValue"<K, V>(arg0: $Comparator$$Type<(T)>): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentValue$$Type<T> = ($RecipeComponentValue<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponentValue$$Original<T> = $RecipeComponentValue<(T)>;}
declare module "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $ShapedBlockBuilder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type, ...suffixes: (StringJS)[])

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedBlockBuilder$$Type = ($ShapedBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShapedBlockBuilder$$Original = $ShapedBlockBuilder;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityEventCallback" {
import {$KubeBlockEntity, $KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"

export interface $BlockEntityEventCallback$$Interface {

(entity: $KubeBlockEntity, data: integer): void
}

export class $BlockEntityEventCallback implements $BlockEntityEventCallback$$Interface {
 "accept"(entity: $KubeBlockEntity$$Type, data: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityEventCallback$$Type = ((entity: $KubeBlockEntity, data: integer) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityEventCallback$$Original = $BlockEntityEventCallback;}
declare module "dev.latvian.mods.kubejs.event.EventExceptionHandler" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Throwable, $Throwable$$Type} from "java.lang.Throwable"
import {$EventHandlerContainer, $EventHandlerContainer$$Type} from "dev.latvian.mods.kubejs.event.EventHandlerContainer"

export interface $EventExceptionHandler$$Interface {

(event: $KubeEvent, container: $EventHandlerContainer, ex: $Throwable): $Throwable$$Type
}

export class $EventExceptionHandler implements $EventExceptionHandler$$Interface {
 "handle"(event: $KubeEvent$$Type, container: $EventHandlerContainer$$Type, ex: $Throwable$$Type): $Throwable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventExceptionHandler$$Type = ((event: $KubeEvent, container: $EventHandlerContainer, ex: $Throwable) => $Throwable$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventExceptionHandler$$Original = $EventExceptionHandler;}
declare module "dev.latvian.mods.kubejs.recipe.ModifyCraftingItemKubeEvent" {
import {$CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"

export class $ModifyCraftingItemKubeEvent implements $KubeEvent$$Interface {
 "item": $ItemStack
readonly "grid": $RecipeInput
readonly "width": integer
readonly "index": integer
readonly "height": integer

constructor(grid: $RecipeInput$$Type, width: integer, height: integer, item: $ItemStack$$Type, index: integer)
constructor(grid: $CraftingInput$$Type, item: $ItemStack$$Type, index: integer)

/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifyCraftingItemKubeEvent$$Type = ($ModifyCraftingItemKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModifyCraftingItemKubeEvent$$Original = $ModifyCraftingItemKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.TagManagerKJS" {
import {$ReloadableServerResourceHolderKJS$$Interface} from "dev.latvian.mods.kubejs.core.ReloadableServerResourceHolderKJS"
import {$ReloadableServerResourcesKJS, $ReloadableServerResourcesKJS$$Type} from "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $TagManagerKJS$$Interface extends $ReloadableServerResourceHolderKJS$$Interface {
}

export class $TagManagerKJS implements $TagManagerKJS$$Interface {
 "kjs$setResources"(resources: $ReloadableServerResourcesKJS$$Type): void
 "kjs$getResources"(): $ReloadableServerResourcesKJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagManagerKJS$$Type = ($TagManagerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TagManagerKJS$$Original = $TagManagerKJS;}
declare module "dev.latvian.mods.kubejs.recipe.KubeRecipeContext" {
import {$RecipeLikeContext$$Interface} from "dev.latvian.mods.kubejs.recipe.RecipeLikeContext"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$RecipeLikeKJS} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $KubeRecipeContext$$Interface extends $RecipeLikeContext$$Interface {
}

export class $KubeRecipeContext implements $KubeRecipeContext$$Interface {
 "ops"(): $RegistryOpsContainer
 "recipe"(): $RecipeLikeKJS
 "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeRecipeContext$$Type = ($KubeRecipeContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeRecipeContext$$Original = $KubeRecipeContext;}
declare module "dev.latvian.mods.kubejs.server.tag.TagWrapper" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$List, $List$$Type} from "java.util.List"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$TagKubeEvent, $TagKubeEvent$$Type} from "dev.latvian.mods.kubejs.server.tag.TagKubeEvent"

export class $TagWrapper {
readonly "entries": $List<($TagLoader$EntryWithSource)>
readonly "id": $ResourceLocation
readonly "event": $TagKubeEvent

constructor(e: $TagKubeEvent$$Type, i: $ResourceLocation$$Type, t: $List$$Type<($TagLoader$EntryWithSource$$Type)>)

public "remove"(...filters: (any)[]): $TagWrapper
public "toString"(): StringJS
public "add"(...filters: (any)[]): $TagWrapper
public "removeAll"(): $TagWrapper
public "getObjectIds"(): $List<($ResourceLocation)>
get "objectIds"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagWrapper$$Type = ($TagWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TagWrapper$$Original = $TagWrapper;}
declare module "dev.latvian.mods.kubejs.recipe.match.FluidMatch" {
import {$ReplacementMatch, $ReplacementMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"

export interface $FluidMatch$$Interface extends $ReplacementMatch$$Interface {
}

export class $FluidMatch implements $FluidMatch$$Interface {
 "matches"(cx: $RecipeMatchContext$$Type, stack: $FluidStack$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, ingredient: $FluidIngredient$$Type, exact: boolean): boolean
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidMatch$$Type = ($FluidMatch);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidMatch$$Original = $FluidMatch;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.BlockWrapper" {
import {$RegistryKubeEvent$$Type} from "dev.latvian.mods.kubejs.registry.RegistryKubeEvent"
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List} from "java.util.List"
import {$Direction} from "net.minecraft.core.Direction"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockEntityPredicate} from "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicate"
import {$BlockIDPredicate} from "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate"
import {$BlockSetType} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$BlockPredicate, $BlockPredicate$$Type} from "dev.latvian.mods.kubejs.block.predicate.BlockPredicate"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$BuildingMaterialProperties$$Type} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.BuildingMaterialProperties"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

/**
 * Various block related helper functions
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $BlockWrapper {
static readonly "TYPE_INFO": $TypeInfo
static readonly "STATE_TYPE_INFO": $TypeInfo

constructor()

public static "id"(id: $ResourceLocation$$Type, properties: $Map$$Type<(StringJS), (any)>): $BlockIDPredicate
public static "id"(id: $ResourceLocation$$Type): $BlockIDPredicate
/**
 * Gets a blocks id from the Block
 */
public static "getId"(block: $Block$$Type): $ResourceLocation
public static "entity"(id: $ResourceLocation$$Type): $BlockEntityPredicate
/**
 * Gets a list of the classname of all registered blocks
 */
public static "getTypeList"(): $List<(StringJS)>
/**
 * Gets a Block from a block id
 */
public static "getBlock"(id: $ResourceLocation$$Type): $Block
public static "withProperties"(state: $BlockState$$Type, properties: $Map$$Type<(never), (never)>): $BlockState
public static "custom"(predicate: $BlockPredicate$$Type): $BlockPredicate
/**
 * Parses a block state from the input string. May throw for invalid inputs!
 */
public static "wrapBlockState"(registries: $RegistryAccessContainer$$Type, o: any): $BlockState
public static "wrapSetType"(from: any, target: $TypeInfo$$Type): $BlockSetType
/**
 * Get a map of direction name to Direction. Functionally identical to Direction.ALL
 */
public static "getFacing"(): $Map<(StringJS), ($Direction)>
/**
 * Gets a list of all blocks with tags
 */
public static "getTaggedIds"(tag: $ResourceLocation$$Type): $List<($ResourceLocation)>
public static "getAllBlockStates"(): $Collection<($BlockState)>
public static "parseBlockState"(registries: $RegistryAccessContainer$$Type, string: StringJS): $BlockState
public static "registerBuildingMaterial"(event: $RegistryKubeEvent$$Type<($Block$$Type)>, id: $ResourceLocation$$Type, properties: $BuildingMaterialProperties$$Type): void
public static "registerBuildingMaterial"(event: $RegistryKubeEvent$$Type<($Block$$Type)>, id: $ResourceLocation$$Type): void
get "typeList"(): $List<(StringJS)>
get "facing"(): $Map<(StringJS), ($Direction)>
get "allBlockStates"(): $Collection<($BlockState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockWrapper$$Type = ($BlockWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockWrapper$$Original = $BlockWrapper;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage" {
import {$RecipePostProcessor} from "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessor"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Map} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RecipeSchemaType} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$ServerScriptManager$$Type} from "dev.latvian.mods.kubejs.server.ServerScriptManager"
import {$RecipeNamespace} from "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace"
import {$RecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$KubeRecipeFactory} from "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory"
import {$RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$ResourceManager$$Type} from "net.minecraft.server.packs.resources.ResourceManager"

export class $RecipeSchemaStorage {
readonly "mappings": $Map<(StringJS), ($ResourceLocation)>
readonly "recipeTypes": $Map<($ResourceLocation), ($KubeRecipeFactory)>
readonly "schemaTypes": $Map<(StringJS), ($RecipeSchemaType)>
 "recipeComponentCodec": $Codec<($RecipeComponent<(never)>)>
 "recipePostProcessorCodec": $Codec<($RecipePostProcessor)>
readonly "namespaces": $Map<(StringJS), ($RecipeNamespace)>

constructor(manager: $ServerScriptManager$$Type)

public "namespace"(namespace: StringJS): $RecipeNamespace
public "fireEvents"(registries: $RegistryAccessContainer$$Type, resourceManager: $ResourceManager$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchemaStorage$$Type = ($RecipeSchemaStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeSchemaStorage$$Original = $RecipeSchemaStorage;}
declare module "dev.latvian.mods.kubejs.item.ItemStackKey" {
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $ItemStackKey {
readonly "patch": $DataComponentPatch
readonly "item": $Item
static "EMPTY": $ItemStackKey

constructor(item: $Item$$Type, patch: $DataComponentPatch$$Type)

public "equals"(obj: any): boolean
public "hashCode"(): integer
public static "of"(stack: $ItemStack$$Type): $ItemStackKey
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackKey$$Type = ($ItemStackKey);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemStackKey$$Original = $ItemStackKey;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RemoveCategoriesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"

export interface $RemoveCategoriesKubeEvent$$Interface extends $KubeEvent$$Interface {

(categories: ($ResourceLocation)[]): void
}

export class $RemoveCategoriesKubeEvent implements $RemoveCategoriesKubeEvent$$Interface {
 "remove"(categories: ($ResourceLocation$$Type)[]): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveCategoriesKubeEvent$$Type = ((categories: ($ResourceLocation)[]) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RemoveCategoriesKubeEvent$$Original = $RemoveCategoriesKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.LocalClientPlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubeJSInventoryListener} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Stages} from "dev.latvian.mods.kubejs.stages.Stages"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$ClientPlayerKJS$$Interface} from "dev.latvian.mods.kubejs.core.ClientPlayerKJS"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$EntityPotionEffectsJS} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $LocalClientPlayerKJS$$Interface extends $ClientPlayerKJS$$Interface {

(): $AttachedData$$Type<($Player$$Type)>
get "minecraft"(): $Minecraft
get "miningBlock"(): boolean
get "stats"(): $PlayerStatsJS
set "activePostShader"(value: $ResourceLocation$$Type)
get "inventoryChangeListener"(): $KubeJSInventoryListener
get "craftingGrid"(): $InventoryKJS
get "openInventory"(): $AbstractContainerMenu
get "selectedSlot"(): integer
set "selectedSlot"(value: integer)
get "mouseItem"(): $ItemStack
get "xpLevel"(): integer
set "foodLevel"(value: integer)
set "saturation"(value: float)
set "xpLevel"(value: integer)
set "mouseItem"(value: $ItemStack$$Type)
get "stages"(): $Stages
get "saturation"(): float
get "inventory"(): $InventoryKJS
get "foodLevel"(): integer
get "fake"(): boolean
get "xp"(): integer
set "xp"(value: integer)
set "statusMessage"(value: $Component$$Type)
get "profile"(): $GameProfile
get "player"(): boolean
get "headArmorItem"(): $ItemStack
get "reachDistance"(): double
set "chestArmorItem"(value: $ItemStack$$Type)
get "legsArmorItem"(): $ItemStack
get "mainHandItem"(): $ItemStack
set "headArmorItem"(value: $ItemStack$$Type)
set "legsArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
get "feetArmorItem"(): $ItemStack
get "totalMovementSpeed"(): double
set "feetArmorItem"(value: $ItemStack$$Type)
set "mainHandItem"(value: $ItemStack$$Type)
get "potionEffects"(): $EntityPotionEffectsJS
get "defaultMovementSpeed"(): double
set "defaultMovementSpeed"(value: double)
set "movementSpeedAddition"(value: double)
set "totalMovementSpeedMultiplier"(value: double)
set "defaultMovementSpeedMultiplier"(value: double)
get "living"(): boolean
get "offHandItem"(): $ItemStack
set "offHandItem"(value: $ItemStack$$Type)
set "maxHealth"(value: float)
get "undead"(): boolean
get "data"(): $AttachedData<($Player)>
get "peacefulCreature"(): boolean
get "waterCreature"(): boolean
get "ambientCreature"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "nbt"(): $CompoundTag
set "x"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "z"(value: double)
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "block"(): $LevelBlock
get "server"(): $MinecraftServer
get "motionX"(): double
set "motionY"(value: double)
get "facing"(): $Direction
get "frame"(): boolean
get "passengers"(): $EntityArrayList
get "item"(): $ItemStack
get "motionZ"(): double
get "type"(): StringJS
set "motionZ"(value: double)
get "animal"(): boolean
get "monster"(): boolean
get "teamId"(): StringJS
get "motionY"(): double
set "motionX"(value: double)
get "scriptType"(): $ScriptType
get "persistentData"(): $CompoundTag
}

export class $LocalClientPlayerKJS implements $LocalClientPlayerKJS$$Interface {
 "runCommand"(command: StringJS): void
 "isSelf"(): boolean
 "getMinecraft"(): $Minecraft
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "isMiningBlock"(): boolean
 "getStats"(): $PlayerStatsJS
 "notify"(notification: $NotificationToastData$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "self"(): $Entity
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "addItemCooldown"(item: $Item$$Type, ticks: integer): void
 "getCraftingGrid"(): $InventoryKJS
 "boostElytraFlight"(): void
 "sendInventoryUpdate"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "getSelectedSlot"(): integer
 "setSelectedSlot"(index: integer): void
 "spawn"(): void
 "addXPLevels"(l: integer): void
 "getMouseItem"(): $ItemStack
 "getXpLevel"(): integer
 "setFoodLevel"(foodLevel: integer): void
 "setSaturation"(saturation: float): void
 "addFood"(f: integer, m: float): void
 "setXpLevel"(l: integer): void
 "addExhaustion"(exhaustion: float): void
 "setMouseItem"(item: $ItemStack$$Type): void
 "getStages"(): $Stages
 "giveInHand"(item: $ItemStack$$Type): void
 "getSaturation"(): float
 "getInventory"(): $InventoryKJS
 "getFoodLevel"(): integer
 "isFake"(): boolean
 "give"(item: $ItemStack$$Type): void
 "getXp"(): integer
 "notify"(title: $Component$$Type, text: $Component$$Type): void
 "addXP"(xp: integer): void
 "setXp"(xp: integer): void
 "setStatusMessage"(message: $Component$$Type): void
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "getHeadArmorItem"(): $ItemStack
 "getReachDistance"(): double
 "setChestArmorItem"(item: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "getMainHandItem"(): $ItemStack
 "setHeadArmorItem"(item: $ItemStack$$Type): void
 "setLegsArmorItem"(item: $ItemStack$$Type): void
 "getChestArmorItem"(): $ItemStack
 "getFeetArmorItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "getAttributeTotalValue"(attribute: $Holder$$Type<($Attribute)>): double
 "getAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>): double
 "canEntityBeSeen"(entity: $LivingEntity$$Type): boolean
 "setFeetArmorItem"(item: $ItemStack$$Type): void
 "setAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>, value: double): void
 "isHoldingInAnyHand"(i: $ItemPredicate$$Type): boolean
 "modifyAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): void
 "setMainHandItem"(item: $ItemStack$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "getPotionEffects"(): $EntityPotionEffectsJS
 "removeAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): void
 "swing"(hand: $InteractionHand$$Type): void
 "swing"(): void
 "getDefaultMovementSpeed"(): double
 "setDefaultMovementSpeed"(speed: double): void
 "setMovementSpeedAddition"(speed: double): void
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "foodEaten"(is: $ItemStack$$Type, food: $FoodProperties$$Type): void
 "isLiving"(): boolean
 "damageHeldItem"(): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "getOffHandItem"(): $ItemStack
 "setOffHandItem"(item: $ItemStack$$Type): void
 "getHeldItem"(hand: $InteractionHand$$Type): $ItemStack
 "rayTraceEntity"(filter: $Predicate$$Type<($Entity)>): $Entity
 "rayTrace"(): $KubeRayTraceResult
 "setMaxHealth"(hp: float): void
 "getEquipment"(slot: $EquipmentSlot$$Type): $ItemStack
 "isUndead"(): boolean
 "setEquipment"(slot: $EquipmentSlot$$Type, item: $ItemStack$$Type): void
 "setHeldItem"(hand: $InteractionHand$$Type, item: $ItemStack$$Type): void
 "sendData"(channel: StringJS): void
 "getData"(): $AttachedData<($Player)>
 "isPeacefulCreature"(): boolean
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isAmbientCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "getNbt"(): $CompoundTag
 "setX"(x: double): void
 "attack"(hp: float): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "tell"(message: $Component$$Type): void
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "playSound"(id: $SoundEvent$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "getServer"(): $MinecraftServer
 "getMotionX"(): double
 "setMotionY"(y: double): void
 "getFacing"(): $Direction
 "isFrame"(): boolean
 "getPassengers"(): $EntityArrayList
 "getItem"(): $ItemStack
 "setRotation"(yaw: float, pitch: float): void
 "getMotionZ"(): double
 "getType"(): StringJS
 "setMotionZ"(z: double): void
 "isAnimal"(): boolean
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "isMonster"(): boolean
 "getTeamId"(): StringJS
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getMotionY"(): double
 "setMotionX"(x: double): void
 "getScriptType"(): $ScriptType
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LocalClientPlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LocalClientPlayerKJS$$Original = $LocalClientPlayerKJS;}
declare module "dev.latvian.mods.kubejs.client.SoundsGenerator" {
import {$JsonObject} from "com.google.gson.JsonObject"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$SoundsGenerator$SoundGen$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundGen"

export class $SoundsGenerator {
constructor()

public "toJson"(): $JsonObject
public "addSound"(path: StringJS, consumer: $Consumer$$Type<($SoundsGenerator$SoundGen)>, overlayExisting: boolean): void
public "addSound"(path: StringJS, consumer: $Consumer$$Type<($SoundsGenerator$SoundGen)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundsGenerator$$Type = ($SoundsGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoundsGenerator$$Original = $SoundsGenerator;}
declare module "dev.latvian.mods.kubejs.core.WithPersistentData" {
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MessageSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $WithPersistentData$$Interface extends $MessageSenderKJS$$Interface {
get "persistentData"(): $CompoundTag
get "name"(): $Component
get "displayName"(): $Component
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $WithPersistentData implements $WithPersistentData$$Interface {
 "getPersistentData"(): $CompoundTag
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "tell"(message: $Component$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithPersistentData$$Type = ($WithPersistentData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WithPersistentData$$Original = $WithPersistentData;}
declare module "dev.latvian.mods.kubejs.entity.KubeRayTraceResult" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Direction} from "net.minecraft.core.Direction"
import {$HitResult$Type} from "net.minecraft.world.phys.HitResult$Type"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"

export class $KubeRayTraceResult {
readonly "hit": $Vec3
readonly "fromEntity": $Entity
readonly "distance": double
readonly "facing": $Direction
readonly "block": $LevelBlock
readonly "type": $HitResult$Type
readonly "entity": $Entity

constructor(from: $Entity$$Type, result: $HitResult$$Type, d: double)
constructor(from: $Entity$$Type, result: $HitResult$$Type)

public "getHitY"(): double
public "getHitZ"(): double
public "getHitX"(): double
get "hitY"(): double
get "hitZ"(): double
get "hitX"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeRayTraceResult$$Type = ($KubeRayTraceResult);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeRayTraceResult$$Original = $KubeRayTraceResult;}
declare module "dev.latvian.mods.kubejs.script.ScriptTypeHolder" {
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ScriptTypeHolder$$Interface {

(): $ScriptType$$Type
}

export class $ScriptTypeHolder implements $ScriptTypeHolder$$Interface {
 "kjs$getScriptType"(): $ScriptType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptTypeHolder$$Type = (() => $ScriptType$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptTypeHolder$$Original = $ScriptTypeHolder;}
declare module "dev.latvian.mods.kubejs.block.BlockModificationKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$BlockModificationKubeEvent$BlockModifications$$Type} from "dev.latvian.mods.kubejs.block.BlockModificationKubeEvent$BlockModifications"
import {$BlockStatePredicate$$Type} from "dev.latvian.mods.kubejs.block.state.BlockStatePredicate"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $BlockModificationKubeEvent implements $KubeEvent$$Interface {
constructor()

/**
 * Modifies blocks that match the given predicate.
 * 
 * **NOTE**: tag predicates are not supported at this time.
 */
public "modify"(predicate: $BlockStatePredicate$$Type, c: $Consumer$$Type<($BlockModificationKubeEvent$BlockModifications)>): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockModificationKubeEvent$$Type = ($BlockModificationKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockModificationKubeEvent$$Original = $BlockModificationKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.KubeJSKeybinds$KeyEvent" {
import {$LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$KubeJSKeybinds$KubeKey$$Type} from "dev.latvian.mods.kubejs.client.KubeJSKeybinds$KubeKey"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$ClientPlayerKubeEvent} from "dev.latvian.mods.kubejs.client.ClientPlayerKubeEvent"

export class $KubeJSKeybinds$KeyEvent extends $ClientPlayerKubeEvent {
constructor(player: $LocalPlayer$$Type, key: $KubeJSKeybinds$KubeKey$$Type)

public "getEntity"(): $Entity
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSKeybinds$KeyEvent$$Type = ($KubeJSKeybinds$KeyEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSKeybinds$KeyEvent$$Original = $KubeJSKeybinds$KeyEvent;}
declare module "dev.latvian.mods.kubejs.client.ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider" {
import {$ClientLevel, $ClientLevel$$Type} from "net.minecraft.client.multiplayer.ClientLevel"
import {$ParticleProvider} from "net.minecraft.client.particle.ParticleProvider"
import {$Particle, $Particle$$Type} from "net.minecraft.client.particle.Particle"
import {$ParticleEngine$SpriteParticleRegistration$$Interface} from "net.minecraft.client.particle.ParticleEngine$SpriteParticleRegistration"
import {$SpriteSet, $SpriteSet$$Type} from "net.minecraft.client.particle.SpriteSet"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

export interface $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Interface<T extends $ParticleOptions> extends $ParticleEngine$SpriteParticleRegistration$$Interface<(T)> {

(type: T, clientLevel: $ClientLevel, x: double, y: double, z: double, sprites: $SpriteSet, xSpeed: double, ySpeed: double, zSpeed: double): $Particle$$Type
}

export class $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider<T extends $ParticleOptions> implements $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Interface {
 "create"(type: T, clientLevel: $ClientLevel$$Type, x: double, y: double, z: double, sprites: $SpriteSet$$Type, xSpeed: double, ySpeed: double, zSpeed: double): $Particle
 "create"(sprites: $SpriteSet$$Type): $ParticleProvider<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Type<T> = ((type: T, clientLevel: $ClientLevel, x: double, y: double, z: double, sprites: $SpriteSet, xSpeed: double, ySpeed: double, zSpeed: double) => $Particle$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Original<T> = $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider<(T)>;}
declare module "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext" {
import {$RecipeLikeContext$$Interface} from "dev.latvian.mods.kubejs.recipe.RecipeLikeContext"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$RecipeLikeKJS} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RecipeMatchContext$$Interface extends $RecipeLikeContext$$Interface {
}

export class $RecipeMatchContext implements $RecipeMatchContext$$Interface {
 "ops"(): $RegistryOpsContainer
 "recipe"(): $RecipeLikeKJS
 "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeMatchContext$$Type = ($RecipeMatchContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeMatchContext$$Original = $RecipeMatchContext;}
declare module "dev.latvian.mods.kubejs.util.KubeResourceLocation" {
import {$UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Record} from "java.lang.Record"

export class $KubeResourceLocation extends $Record {
static readonly "CODEC": $Codec<($ResourceLocation)>

constructor(wrapped: $ResourceLocation$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "wrap"(from: any): $ResourceLocation
public "wrapped"(): $ResourceLocation
public "withPath"(path: StringJS): $ResourceLocation
public "withPath"(path: $UnaryOperator$$Type<(StringJS)>): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeResourceLocation$$Type = ({"wrapped"?: $ResourceLocation$$Type}) | ([wrapped?: $ResourceLocation$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeResourceLocation$$Original = $KubeResourceLocation;}
declare module "dev.latvian.mods.kubejs.block.BlockModificationKubeEvent$BlockModifications" {
import {$SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$RandomTickCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$Record} from "java.lang.Record"

export class $BlockModificationKubeEvent$BlockModifications extends $Record {
constructor(block: $Block$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "block"(): $Block
public "setIsRandomlyTicking"(v: boolean): void
public "setNameKey"(key: StringJS): void
public "setHasCollision"(v: boolean): void
public "setRandomTickCallback"(callback: $Consumer$$Type<($RandomTickCallback)>): void
public "setDestroySpeed"(v: float): void
public "setLightEmission"(v: integer): void
public "setRequiresTool"(v: boolean): void
public "setFriction"(v: float): void
public "setSpeedFactor"(v: float): void
public "setJumpFactor"(v: float): void
public "setSoundType"(v: $SoundType$$Type): void
public "setExplosionResistance"(v: float): void
set "isRandomlyTicking"(value: boolean)
set "nameKey"(value: StringJS)
set "hasCollision"(value: boolean)
set "randomTickCallback"(value: $Consumer$$Type<($RandomTickCallback)>)
set "destroySpeed"(value: float)
set "lightEmission"(value: integer)
set "requiresTool"(value: boolean)
set "friction"(value: float)
set "speedFactor"(value: float)
set "jumpFactor"(value: float)
set "soundType"(value: $SoundType$$Type)
set "explosionResistance"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockModificationKubeEvent$BlockModifications$$Type = ({"block"?: $Block$$Type}) | ([block?: $Block$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockModificationKubeEvent$BlockModifications$$Original = $BlockModificationKubeEvent$BlockModifications;}
declare module "dev.latvian.mods.kubejs.level.ExplosionKubeEvent$After" {
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$List, $List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$ExplosionKubeEvent} from "dev.latvian.mods.kubejs.level.ExplosionKubeEvent"

/**
 * Invoked right after an explosion happens.
 */
export class $ExplosionKubeEvent$After extends $ExplosionKubeEvent {
constructor(level: $Level$$Type, explosion: $Explosion$$Type, affectedEntities: $List$$Type<($Entity$$Type)>)

/**
 * Gets a list of all blocks affected by the explosion.
 */
public "getAffectedBlocks"(): $List<($LevelBlock)>
/**
 * Gets a list of all entities affected by the explosion.
 */
public "getAffectedEntities"(): $EntityArrayList
/**
 * Remove all knockback from all affected *players*.
 */
public "removeKnockback"(): void
/**
 * Remove all blocks from the list of affected blocks.
 */
public "removeAllAffectedBlocks"(): void
/**
 * Remove all entities from the list of affected entities.
 */
public "removeAllAffectedEntities"(): void
/**
 * Remove an entity from the list of affected entities.
 */
public "removeAffectedEntity"(entity: $Entity$$Type): void
/**
 * Remove a block from the list of affected blocks.
 */
public "removeAffectedBlock"(block: $LevelBlock$$Type): void
get "affectedBlocks"(): $List<($LevelBlock)>
get "affectedEntities"(): $EntityArrayList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionKubeEvent$After$$Type = ($ExplosionKubeEvent$After);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExplosionKubeEvent$After$$Original = $ExplosionKubeEvent$After;}
declare module "dev.latvian.mods.kubejs.player.PlayerClonedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player respawns.
 * 
 * The reason of respawn can be either death or returning from the end.
 */
export class $PlayerClonedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $ServerPlayer$$Type, oldPlayer: $ServerPlayer$$Type, keepData: boolean)

/**
 * Gets the player that was before respawn. Note that this entity is already removed from the world.
 */
public "getOldPlayer"(): $ServerPlayer
/**
 * Gets the player that respawned.
 */
public "getEntity"(): $LivingEntity
/**
 * Gets whether the player's data was kept, e.g. when returning from the end.
 */
public "getKeepData"(): boolean
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "oldPlayer"(): $ServerPlayer
get "entity"(): $LivingEntity
get "keepData"(): boolean
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerClonedKubeEvent$$Type = ($PlayerClonedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerClonedKubeEvent$$Original = $PlayerClonedKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.DataSenderKJS" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $DataSenderKJS$$Interface {
}

export class $DataSenderKJS implements $DataSenderKJS$$Interface {
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "sendData"(channel: StringJS): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataSenderKJS$$Type = ($DataSenderKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataSenderKJS$$Original = $DataSenderKJS;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemData$DataComponentSubtypes, $ItemData$DataComponentSubtypes$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$DataComponentSubtypes"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$ItemData$Info, $ItemData$Info$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Info"
import {$ItemData$Group, $ItemData$Group$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Group"
import {$Record} from "java.lang.Record"

export class $ItemData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData)>

constructor(addedEntries: $List$$Type<($ItemStack$$Type)>, removedEntries: $List$$Type<($Ingredient$$Type)>, completelyRemovedEntries: $List$$Type<($Ingredient$$Type)>, groupedEntries: $List$$Type<($ItemData$Group$$Type)>, info: $List$$Type<($ItemData$Info$$Type)>, dataComponentSubtypes: $List$$Type<($ItemData$DataComponentSubtypes$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public static "collect"(): $ItemData
public "info"(): $List<($ItemData$Info)>
public "completelyRemovedEntries"(): $List<($Ingredient)>
public "dataComponentSubtypes"(): $List<($ItemData$DataComponentSubtypes)>
public "addedEntries"(): $List<($ItemStack)>
public "removedEntries"(): $List<($Ingredient)>
public "groupedEntries"(): $List<($ItemData$Group)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$$Type = ({"info"?: $List$$Type<($ItemData$Info$$Type)>, "completelyRemovedEntries"?: $List$$Type<($Ingredient$$Type)>, "groupedEntries"?: $List$$Type<($ItemData$Group$$Type)>, "removedEntries"?: $List$$Type<($Ingredient$$Type)>, "dataComponentSubtypes"?: $List$$Type<($ItemData$DataComponentSubtypes$$Type)>, "addedEntries"?: $List$$Type<($ItemStack$$Type)>}) | ([info?: $List$$Type<($ItemData$Info$$Type)>, completelyRemovedEntries?: $List$$Type<($Ingredient$$Type)>, groupedEntries?: $List$$Type<($ItemData$Group$$Type)>, removedEntries?: $List$$Type<($Ingredient$$Type)>, dataComponentSubtypes?: $List$$Type<($ItemData$DataComponentSubtypes$$Type)>, addedEntries?: $List$$Type<($ItemStack$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemData$$Original = $ItemData;}
declare module "dev.latvian.mods.kubejs.client.KubeJSKeybinds$KubeKey" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $KubeJSKeybinds$KubeKey {
readonly "id": StringJS

constructor(id: StringJS)

public "equals"(obj: any): boolean
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSKeybinds$KubeKey$$Type = ($KubeJSKeybinds$KubeKey);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSKeybinds$KubeKey$$Original = $KubeJSKeybinds$KubeKey;}
declare module "dev.latvian.mods.kubejs.core.ItemFrameEntityKJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$EntityKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityKJS"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ItemFrameEntityKJS$$Interface extends $EntityKJS$$Interface {
get "frame"(): boolean
get "item"(): $ItemStack
get "peacefulCreature"(): boolean
get "waterCreature"(): boolean
get "ambientCreature"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "nbt"(): $CompoundTag
set "x"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "z"(value: double)
get "living"(): boolean
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "block"(): $LevelBlock
get "server"(): $MinecraftServer
get "motionX"(): double
set "motionY"(value: double)
get "facing"(): $Direction
get "profile"(): $GameProfile
get "passengers"(): $EntityArrayList
get "player"(): boolean
get "motionZ"(): double
get "type"(): StringJS
set "motionZ"(value: double)
get "animal"(): boolean
get "monster"(): boolean
get "teamId"(): StringJS
get "motionY"(): double
set "motionX"(value: double)
get "scriptType"(): $ScriptType
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $ItemFrameEntityKJS implements $ItemFrameEntityKJS$$Interface {
 "self"(): $Entity
 "isFrame"(): boolean
 "getItem"(): $ItemStack
 "isPeacefulCreature"(): boolean
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isAmbientCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "getNbt"(): $CompoundTag
 "setX"(x: double): void
 "attack"(hp: float): void
 "spawn"(): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "runCommandSilent"(command: StringJS): void
 "tell"(message: $Component$$Type): void
 "isLiving"(): boolean
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "playSound"(id: $SoundEvent$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "getServer"(): $MinecraftServer
 "getMotionX"(): double
 "setMotionY"(y: double): void
 "getFacing"(): $Direction
 "getProfile"(): $GameProfile
 "getPassengers"(): $EntityArrayList
 "isPlayer"(): boolean
 "setRotation"(yaw: float, pitch: float): void
 "getMotionZ"(): double
 "getType"(): StringJS
 "setMotionZ"(z: double): void
 "isAnimal"(): boolean
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "isMonster"(): boolean
 "getTeamId"(): StringJS
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getMotionY"(): double
 "setMotionX"(x: double): void
 "getScriptType"(): $ScriptType
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$$Type): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFrameEntityKJS$$Type = ($ItemFrameEntityKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemFrameEntityKJS$$Original = $ItemFrameEntityKJS;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$FluidData$Group, $FluidData$Group$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Group"
import {$FluidData$Info, $FluidData$Info$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Info"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$FluidData$DataComponentSubtypes, $FluidData$DataComponentSubtypes$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$DataComponentSubtypes"
import {$Record} from "java.lang.Record"

export class $FluidData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData)>

constructor(addedEntries: $List$$Type<($FluidStack$$Type)>, removedEntries: $List$$Type<($FluidIngredient$$Type)>, completelyRemovedEntries: $List$$Type<($FluidIngredient$$Type)>, groupedEntries: $List$$Type<($FluidData$Group$$Type)>, info: $List$$Type<($FluidData$Info$$Type)>, dataComponentSubtypes: $List$$Type<($FluidData$DataComponentSubtypes$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public static "collect"(): $FluidData
public "info"(): $List<($FluidData$Info)>
public "completelyRemovedEntries"(): $List<($FluidIngredient)>
public "dataComponentSubtypes"(): $List<($FluidData$DataComponentSubtypes)>
public "addedEntries"(): $List<($FluidStack)>
public "removedEntries"(): $List<($FluidIngredient)>
public "groupedEntries"(): $List<($FluidData$Group)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$$Type = ({"info"?: $List$$Type<($FluidData$Info$$Type)>, "completelyRemovedEntries"?: $List$$Type<($FluidIngredient$$Type)>, "groupedEntries"?: $List$$Type<($FluidData$Group$$Type)>, "removedEntries"?: $List$$Type<($FluidIngredient$$Type)>, "dataComponentSubtypes"?: $List$$Type<($FluidData$DataComponentSubtypes$$Type)>, "addedEntries"?: $List$$Type<($FluidStack$$Type)>}) | ([info?: $List$$Type<($FluidData$Info$$Type)>, completelyRemovedEntries?: $List$$Type<($FluidIngredient$$Type)>, groupedEntries?: $List$$Type<($FluidData$Group$$Type)>, removedEntries?: $List$$Type<($FluidIngredient$$Type)>, dataComponentSubtypes?: $List$$Type<($FluidData$DataComponentSubtypes$$Type)>, addedEntries?: $List$$Type<($FluidStack$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidData$$Original = $FluidData;}
declare module "dev.latvian.mods.kubejs.util.RotationAxis" {
import {$Enum} from "java.lang.Enum"
import {$Vector3f} from "org.joml.Vector3f"
import {$Quaternionf} from "org.joml.Quaternionf"

export class $RotationAxis extends $Enum<($RotationAxis)> {
static readonly "ZN": $RotationAxis
static readonly "YN": $RotationAxis
readonly "vec": $Vector3f
static readonly "XN": $RotationAxis
static readonly "ZP": $RotationAxis
static readonly "YP": $RotationAxis
static readonly "XP": $RotationAxis

public "deg"(f: float): $Quaternionf
public static "values"(): ($RotationAxis)[]
public static "valueOf"(name: StringJS): $RotationAxis
public "rad"(f: float): $Quaternionf
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotationAxis$$Type = (("xn") | ("xp") | ("yn") | ("yp") | ("zn") | ("zp"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RotationAxis$$Original = $RotationAxis;}
declare module "dev.latvian.mods.kubejs.core.WindowKJS" {
import {$List, $List$$Type} from "java.util.List"
import {$IoSupplier, $IoSupplier$$Type} from "net.minecraft.server.packs.resources.IoSupplier"
import {$InputStream, $InputStream$$Type} from "java.io.InputStream"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $WindowKJS$$Interface {
}

export class $WindowKJS implements $WindowKJS$$Interface {
 "kjs$loadIcons"(original: $List$$Type<($IoSupplier$$Type<($InputStream$$Type)>)>): $List<($IoSupplier<($InputStream)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WindowKJS$$Type = ($WindowKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WindowKJS$$Original = $WindowKJS;}
declare module "dev.latvian.mods.kubejs.block.callback.BlockStateMirrorCallback" {
import {$Mirror, $Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Rotation} from "net.minecraft.world.level.block.Rotation"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockStateModifyCallback} from "dev.latvian.mods.kubejs.block.callback.BlockStateModifyCallback"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStateMirrorCallback extends $BlockStateModifyCallback {
constructor(state: $BlockState$$Type, mirror: $Mirror$$Type)

/**
 * Mirrors the direction passed in
 */
public "mirror"(dir: $Direction$$Type): $Direction
/**
 * Gets the Mirror
 */
public "getMirror"(): $Mirror
/**
 * Gets the rotation of the direction passed in relative to this mirror
 */
public "getRotation"(dir: $Direction$$Type): $Rotation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateMirrorCallback$$Type = ($BlockStateMirrorCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateMirrorCallback$$Original = $BlockStateMirrorCallback;}
declare module "dev.latvian.mods.kubejs.core.EntityGetterKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$EntityCollectionKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityCollectionKJS"
import {$UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $EntityGetterKJS$$Interface extends $EntityCollectionKJS$$Interface {
get "mcEntities"(): $Iterable<($Entity)>
get "players"(): $EntityArrayList
get "mcPlayers"(): $List<($Player)>
get "entities"(): $EntityArrayList
}

export class $EntityGetterKJS implements $EntityGetterKJS$$Interface {
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getPlayers"(): $EntityArrayList
 "getMcPlayers"(): $List<($Player)>
 "self"(): $EntityGetter
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntities"(): $EntityArrayList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityGetterKJS$$Type = ($EntityGetterKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityGetterKJS$$Original = $EntityGetterKJS;}
declare module "dev.latvian.mods.kubejs.core.FluidStackKJS" {
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ComponentFunctions} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$MutableDataComponentHolder} from "net.neoforged.neoforge.common.MutableDataComponentHolder"
import {$UUID$$Type} from "java.util.UUID"
import {$FluidMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.FluidMatch"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$RelativeURL} from "dev.latvian.mods.kubejs.web.RelativeURL"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$SpecialEquality$$Interface} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$MutableDataComponentHolderFunctions, $MutableDataComponentHolderFunctions$$Interface} from "dev.latvian.mods.kubejs.component.MutableDataComponentHolderFunctions"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$FluidLike, $FluidLike$$Interface} from "dev.latvian.mods.kubejs.fluid.FluidLike"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map$$Type} from "java.util.Map"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$WithCodec$$Interface} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Unit$$Type} from "net.minecraft.util.Unit"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $FluidStackKJS$$Interface extends $Replaceable$$Interface, $SpecialEquality$$Interface, $WithCodec$$Interface, $FluidLike$$Interface, $FluidMatch$$Interface, $MutableDataComponentHolderFunctions$$Interface, $RegistryObjectKJS$$Interface<($Fluid)> {
get "empty"(): boolean
get "id"(): StringJS
get "codec"(): $Codec<(never)>
get "key"(): $ResourceKey<($Fluid)>
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "registry"(): $Registry<($Fluid)>
get "registryId"(): $ResourceKey<($Registry<($Fluid)>)>
get "amount"(): integer
get "fluid"(): $Fluid
get "componentMap"(): $DataComponentMap
get "componentHolder"(): $MutableDataComponentHolder
get "tagKeys"(): $List<($TagKey<($Fluid)>)>
get "tags"(): $List<($ResourceLocation)>
set "lore"(value: $List$$Type<($Component$$Type)>)
set "customData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "dyedColor"(value: $KubeColor$$Type)
set "customName"(value: $Component$$Type)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
get "customName"(): $Component
get "customData"(): $CompoundTag
set "lockCode"(value: StringJS)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
get "additionalTooltipHidden"(): void
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
get "componentString"(): StringJS
get "tooltipHidden"(): void
set "customModelData"(value: integer)
set "glintOverride"(value: boolean)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
}

export class $FluidStackKJS implements $FluidStackKJS$$Interface {
 "matches"(cx: $RecipeMatchContext$$Type, ingredient: $FluidIngredient$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, s: $FluidStack$$Type, exact: boolean): boolean
 "specialEquals"(o: any, shallow: boolean): boolean
 "isEmpty"(): boolean
 "kjs$getWebIconURL"(ops: $DynamicOps$$Type<($Tag$$Type)>, size: integer): $RelativeURL
 "getId"(): StringJS
 "getCodec"(): $Codec<(never)>
 "kjs$self"(): $FluidStack
 "getKey"(): $ResourceKey<($Fluid)>
 "copy"(amount: integer): $FluidLike
 "getMod"(): StringJS
 "getIdLocation"(): $ResourceLocation
 "asHolder"(): $Holder<($Fluid)>
 "getRegistry"(): $Registry<($Fluid)>
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "getRegistryId"(): $ResourceKey<($Registry<($Fluid)>)>
 "getAmount"(): integer
 "getFluid"(): $Fluid
 "kjs$equalsIgnoringCount"(stack: $FluidStack$$Type): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
 "toNBT"(): $Tag
 "toJson"(): $JsonElement
 "patch"(components: $DataComponentPatch$$Type): $ComponentFunctions
 "set"(components: $DataComponentMap$$Type): $MutableDataComponentHolderFunctions
 "getComponentMap"(): $DataComponentMap
 "getComponentHolder"(): $MutableDataComponentHolder
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getTagKeys"(): $List<($TagKey<($Fluid)>)>
 "getTags"(): $List<($ResourceLocation)>
static "wrap"(o: any): $ReplacementMatch
 "remove"(type: $DataComponentType$$Type<(never)>): $ComponentFunctions
 "get"<T>(type: $DataComponentType$$Type<(T)>): T
 "set"(component: $DataComponentType$$Type<(never)>, value: any): $ComponentFunctions
 "setLore"(lines: $List$$Type<($Component$$Type)>): void
 "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
 "setCustomData"(tag: $CompoundTag$$Type): void
 "setRarity"(rarity: $Rarity$$Type): void
 "setDyedColor"(color: $KubeColor$$Type): void
 "setCustomName"(name: $Component$$Type): void
 "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "getCustomName"(): $Component
 "getCustomData"(): $CompoundTag
 "setLockCode"(lock: StringJS): void
 "setProfile"(name: StringJS, uuid: $UUID$$Type): void
 "setProfile"(profile: $GameProfile$$Type): void
 "setBaseColor"(color: $DyeColor$$Type): void
 "setPotionId"(potion: $Holder$$Type<($Potion)>): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "setAdditionalTooltipHidden"(): void
 "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
 "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
 "setPotionContents"(contents: $PotionContents$$Type): void
 "getComponentString"(): StringJS
 "resetComponents"(): $ComponentFunctions
 "setTooltipHidden"(): void
 "setCustomModelData"(data: integer): void
 "setGlintOverride"(override: boolean): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidStackKJS$$Type = ($FluidStackKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidStackKJS$$Original = $FluidStackKJS;}
declare module "dev.latvian.mods.kubejs.core.mixin.RecipeInputMixin" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$RecipeInput} from "net.minecraft.world.item.crafting.RecipeInput"
import {$List} from "java.util.List"
import {$SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"
import {$RecipeInputKJS$$Interface} from "dev.latvian.mods.kubejs.core.RecipeInputKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RecipeInputMixin$$Interface extends $RecipeInputKJS$$Interface {
}

export class $RecipeInputMixin implements $RecipeInputMixin$$Interface {
 "find"(filter: $SlotFilter$$Type): $ItemStack
 "find"(filter: $SlotFilter$$Type, skip: integer): $ItemStack
 "findAll"(): $List<($ItemStack)>
 "findAll"(filter: $SlotFilter$$Type): $List<($ItemStack)>
 "self"(): $RecipeInput
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeInputMixin$$Type = ($RecipeInputMixin);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeInputMixin$$Original = $RecipeInputMixin;}
declare module "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo" {
import {$TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ReplacementMatch, $ReplacementMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RecordTypeInfo} from "dev.latvian.mods.rhino.type.RecordTypeInfo"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$Record} from "java.lang.Record"

export class $ReplacementMatchInfo extends $Record {
static readonly "TYPE_INFO": $RecordTypeInfo
static readonly "NONE": $ReplacementMatchInfo

constructor(match: $ReplacementMatch$$Type, exact: boolean, componentType: ($RecipeComponent$$Type<(never)>)?)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "componentType"(): $Optional<($RecipeComponent<(never)>)>
public static "wrap"(o: any, target: $TypeInfo$$Type): $ReplacementMatchInfo
public "match"(): $ReplacementMatch
public "exact"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplacementMatchInfo$$Type = ({"exact"?: boolean, "componentType"?: ($RecipeComponent$$Type<(never)>)?, "match"?: $ReplacementMatch$$Type}) | ([exact?: boolean, componentType?: ($RecipeComponent$$Type<(never)>)?, match?: $ReplacementMatch$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReplacementMatchInfo$$Original = $ReplacementMatchInfo;}
declare module "dev.latvian.mods.kubejs.recipe.RecipeLikeContext" {
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$RecipeLikeKJS} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RecipeLikeContext$$Interface {
}

export class $RecipeLikeContext implements $RecipeLikeContext$$Interface {
 "ops"(): $RegistryOpsContainer
 "recipe"(): $RecipeLikeKJS
 "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeLikeContext$$Type = ($RecipeLikeContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeLikeContext$$Original = $RecipeLikeContext;}
declare module "dev.latvian.mods.kubejs.player.SimplePlayerKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $SimplePlayerKubeEvent implements $KubePlayerEvent$$Interface {
constructor(p: $Player$$Type)

public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "entity"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimplePlayerKubeEvent$$Type = ($SimplePlayerKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimplePlayerKubeEvent$$Original = $SimplePlayerKubeEvent;}
declare module "dev.latvian.mods.kubejs.registry.ServerRegistryKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$List$$Type} from "java.util.List"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$CustomBuilderObject} from "dev.latvian.mods.kubejs.registry.CustomBuilderObject"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"

export class $ServerRegistryKubeEvent<T> implements $KubeEvent$$Interface {
readonly "registryKey": $ResourceKey<($Registry<(T)>)>
readonly "codec": $Codec<(T)>
readonly "jsonOps": $DynamicOps<($JsonElement)>

constructor(registryKey: $ResourceKey$$Type<($Registry<(T)>)>, jsonOps: $DynamicOps$$Type<($JsonElement$$Type)>, codec: $Codec$$Type<(T)>, builders: $List$$Type<($BuilderBase$$Type<(never)>)>)

public "create"(id: $ResourceLocation$$Type): $BuilderBase<(T)>
public "create"(id: $ResourceLocation$$Type, type: $ResourceLocation$$Type): $BuilderBase<(T)>
public "createCustom"(id: $ResourceLocation$$Type, object: $Supplier$$Type<(any)>): $CustomBuilderObject
public "createFromJson"(id: $ResourceLocation$$Type, json: $JsonElement$$Type): $CustomBuilderObject
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerRegistryKubeEvent$$Type<T> = ($ServerRegistryKubeEvent<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerRegistryKubeEvent$$Original<T> = $ServerRegistryKubeEvent<(T)>;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.ItemWrapper" {
import {$DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$Collection} from "java.util.Collection"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Map} from "java.util.Map"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$UUID$$Type} from "java.util.UUID"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$DataResult} from "com.mojang.serialization.DataResult"
import {$List} from "java.util.List"
import {$ItemAbility} from "net.neoforged.neoforge.common.ItemAbility"
import {$Fireworks, $Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Tag$$Type} from "net.minecraft.nbt.Tag"

/**
 * Various item related helper methods
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ItemWrapper$$Interface {
get "empty"(): $ItemStack
get "typeList"(): $List<(StringJS)>
get "list"(): $List<($ItemStack)>
get "typeToStackMap"(): $Map<($ResourceLocation), ($Collection<($ItemStack)>)>
}

export class $ItemWrapper implements $ItemWrapper$$Interface {
static readonly "ITEM_TYPE_INFO": $TypeInfo
static readonly "EMPTY_ARRAY": ($ItemStack)[]
static readonly "TYPE_INFO": $TypeInfo

/**
 * Returns an ItemStack of the input
 */
static "of"(arg0: $ItemStack$$Type): $ItemStack
/**
 * Returns an ItemStack of the input, with the specified count and data components
 */
static "of"(arg0: $ItemStack$$Type, count: integer, components: $DataComponentMap$$Type): $ItemStack
/**
 * Returns an ItemStack of the input, with the specified count
 */
static "of"(arg0: $ItemStack$$Type, count: integer): $ItemStack
/**
 * Returns an ItemStack of the input, with the specified data components
 */
static "of"(arg0: $ItemStack$$Type, components: $DataComponentMap$$Type): $ItemStack
static "read"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, reader: $StringReader$$Type): $DataResult<($ItemStack)>
/**
 * Gets an items id from the Item
 */
static "getId"(item: $Item$$Type): $ResourceLocation
/**
 * Checks if the provided item id exists in the registry
 */
static "exists"(id: $ResourceLocation$$Type): boolean
static "getVariants"(item: $ItemStack$$Type): $Collection<($ItemStack)>
/**
 * Gets an Item from an item id
 */
static "getItem"(id: $ResourceLocation$$Type): $Item
/**
 * Get the item that represents air/an empty slot
 */
static "getEmpty"(): $ItemStack
static "parseString"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, s: StringJS): $DataResult<($ItemStack)>
/**
 * Get a list of all the item ids in the game
 */
static "getTypeList"(): $List<(StringJS)>
static "playerHead"(name: StringJS): $ItemStack
/**
 * Checks if the passed in object is an ItemStack.
 * Note that this does not mean it will not function as an ItemStack if passed to something that requests one.
 */
static "isItem"(o: any): boolean
static "findItem"(s: StringJS): $DataResult<($Item)>
/**
 * Returns a Firework with the input properties
 */
static "fireworks"(fireworks: $Fireworks$$Type): $Fireworks
/**
 * Get a list of most items in the game. Items not in a creative tab are ignored
 */
static "getList"(): $List<($ItemStack)>
static "wrapItemAbility"(object: any): $ItemAbility
static "playerHeadFromUrl"(url: StringJS): $ItemStack
static "isItemStackLike"(from: any): boolean
static "getTypeToStackMap"(): $Map<($ResourceLocation), ($Collection<($ItemStack)>)>
static "parseJson"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, json: $JsonElement$$Type): $DataResult<($ItemStack)>
static "playerHeadFromBase64"(uuid: $UUID$$Type, textureBase64: StringJS): $ItemStack
static "playerHeadFromSkinHash"(hash: StringJS): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemWrapper$$Type = ($ItemWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemWrapper$$Original = $ItemWrapper;}
declare module "dev.latvian.mods.kubejs.client.EntityRendererRegistryKubeEvent" {
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$EntityRenderersEvent$RegisterRenderers$$Type} from "net.neoforged.neoforge.client.event.EntityRenderersEvent$RegisterRenderers"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$EntityRendererProvider$$Type} from "net.minecraft.client.renderer.entity.EntityRendererProvider"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $EntityRendererRegistryKubeEvent implements $ClientKubeEvent$$Interface {
constructor(event: $EntityRenderersEvent$RegisterRenderers$$Type)

public "register"(type: $EntityType$$Type<(never)>, renderer: $EntityRendererProvider$$Type): void
public "getClient"(): $Minecraft
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityRendererRegistryKubeEvent$$Type = ($EntityRendererRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityRendererRegistryKubeEvent$$Original = $EntityRendererRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.item.ItemModelPropertiesKubeEvent" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$KubeStartupEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeStartupEvent"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$ClampedItemPropertyFunction$$Type} from "net.minecraft.client.renderer.item.ClampedItemPropertyFunction"

export class $ItemModelPropertiesKubeEvent implements $KubeStartupEvent$$Interface {
constructor()

/**
 * Register a model property for an item. Model properties are used to change the appearance of an item in the world.
 * 
 * More about model properties: https://minecraft.wiki/w/Tutorials/Models#Item_predicates
 */
public "register"(ingredient: $Ingredient$$Type, overwriteId: $ResourceLocation$$Type, callback: $ClampedItemPropertyFunction$$Type): void
/**
 * Register a model property for all items.
 */
public "registerAll"(overwriteId: $ResourceLocation$$Type, callback: $ClampedItemPropertyFunction$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModelPropertiesKubeEvent$$Type = ($ItemModelPropertiesKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemModelPropertiesKubeEvent$$Original = $ItemModelPropertiesKubeEvent;}
declare module "dev.latvian.mods.kubejs.script.ScriptType" {
import {$KubeJSFileWatcherThread} from "dev.latvian.mods.kubejs.script.KubeJSFileWatcherThread"
import {$Map} from "java.util.Map"
import {$Enum} from "java.lang.Enum"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$List} from "java.util.List"
import {$NativeEventWrapper$Listeners} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.NativeEventWrapper$Listeners"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$ScriptTypeHolder$$Interface} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$NativeEventWrapper$Listeners$Key} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.NativeEventWrapper$Listeners$Key"
import {$ScriptTypePredicate, $ScriptTypePredicate$$Interface} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"
import {$ConsoleJS} from "dev.latvian.mods.kubejs.script.ConsoleJS"
import {$Path} from "java.nio.file.Path"
import {$ClassFilter} from "dev.latvian.mods.kubejs.plugin.ClassFilter"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptType extends $Enum<($ScriptType)> implements $ScriptTypePredicate$$Interface, $ScriptTypeHolder$$Interface {
readonly "console": $ConsoleJS
readonly "path": $Path
readonly "nativeEventListeners": $Map<($NativeEventWrapper$Listeners$Key), ($NativeEventWrapper$Listeners)>
static readonly "SERVER": $ScriptType
 "fileWatcherThread": $KubeJSFileWatcherThread
static readonly "VALUES": ($ScriptType)[]
static readonly "STARTUP": $ScriptType
readonly "classFilter": $Lazy<($ClassFilter)>
static readonly "CLIENT": $ScriptType
readonly "nameStrip": StringJS

public static "values"(): ($ScriptType)[]
public "test"(type: any): boolean
public "test"(type: $ScriptType$$Type): boolean
public static "valueOf"(name: StringJS): $ScriptType
public "negate"(): $ScriptTypePredicate
public "getValidTypes"(): $List<($ScriptType)>
public "isClient"(): boolean
public "isServer"(): boolean
public "getLogFile"(): $Path
public "isStartup"(): boolean
public "kjs$getScriptType"(): $ScriptType
public "or"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
public "and"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
public static "not"<T>(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
public static "isEqual"<T>(arg0: any): $Predicate<($ScriptType)>
get "validTypes"(): $List<($ScriptType)>
get "client"(): boolean
get "server"(): boolean
get "logFile"(): $Path
get "startup"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptType$$Type = (("startup") | ("server") | ("client"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptType$$Original = $ScriptType;}
declare module "dev.latvian.mods.kubejs.script.SourceLine" {
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $SourceLine extends $Record {
static readonly "UNKNOWN": $SourceLine

constructor(source: StringJS, line: integer)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "of"(): $SourceLine
public static "of"(source: StringJS, line: integer): $SourceLine
public "line"(): integer
public "source"(): StringJS
public static "write"(buf: $FriendlyByteBuf$$Type, sourceLine: $SourceLine$$Type): void
public static "read"(buf: $FriendlyByteBuf$$Type): $SourceLine
public "isUnknown"(): boolean
public static "fromJson"(json: $JsonObject$$Type): $SourceLine
public "toJson"(): $JsonObject
get "unknown"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SourceLine$$Type = ({"line"?: integer, "source"?: StringJS}) | ([line?: integer, source?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SourceLine$$Original = $SourceLine;}
declare module "dev.latvian.mods.kubejs.core.ComponentKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$FormattedText, $FormattedText$$Type} from "net.minecraft.network.chat.FormattedText"
import {$UUID$$Type} from "java.util.UUID"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type, $Component$$Interface} from "net.minecraft.network.chat.Component"
import {$FormattedText$StyledContentConsumer$$Type} from "net.minecraft.network.chat.FormattedText$StyledContentConsumer"
import {$Message$$Type} from "com.mojang.brigadier.Message"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$WrappedJS$$Interface} from "dev.latvian.mods.kubejs.util.WrappedJS"
import {$ComponentContents} from "net.minecraft.network.chat.ComponentContents"
import {$FormattedText$ContentConsumer$$Type} from "net.minecraft.network.chat.FormattedText$ContentConsumer"
import {$WithCodec$$Interface} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$Style, $Style$$Type} from "net.minecraft.network.chat.Style"
import {$ClickEvent$$Type} from "net.minecraft.network.chat.ClickEvent"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$FormattedCharSequence} from "net.minecraft.util.FormattedCharSequence"
import {$URI$$Type} from "java.net.URI"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$Date$$Type} from "java.util.Date"
import {$DataSource$$Type} from "net.minecraft.network.chat.contents.DataSource"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ComponentKJS$$Interface extends $Component$$Interface, $WithCodec$$Interface, $WrappedJS$$Interface {
get "codec"(): $Codec<(never)>
get "string"(): StringJS
get "contents"(): $ComponentContents
get "siblings"(): $List<($Component)>
get "visualOrderText"(): $FormattedCharSequence
get "style"(): $Style
}

export class $ComponentKJS implements $ComponentKJS$$Interface {
 "forEach"(action: $Consumer$$Type<($Component)>): void
 "asIterable"(): $Iterable<($Component)>
 "darkAqua"(): $MutableComponent
 "lightPurple"(): $MutableComponent
 "darkBlue"(): $MutableComponent
/**
 * 
 * @deprecated
 */
 "component"(): $Component
 "clickOpenUrl"(url: StringJS): $MutableComponent
 "obfuscated"(): $MutableComponent
 "obfuscated"(value: boolean): $MutableComponent
 "hasSiblings"(): boolean
 "clickCopy"(text: StringJS): $MutableComponent
 "clickOpenFile"(path: StringJS): $MutableComponent
/**
 * 
 * @deprecated
 */
 "rawCopy"(): $MutableComponent
 "strikethrough"(): $MutableComponent
 "strikethrough"(value: boolean): $MutableComponent
 "hasStyle"(): boolean
 "underlined"(): $MutableComponent
 "underlined"(value: boolean): $MutableComponent
 "darkRed"(): $MutableComponent
 "darkPurple"(): $MutableComponent
 "noColor"(): $MutableComponent
/**
 * 
 * @deprecated
 */
 "rawComponent"(): $MutableComponent
 "darkGray"(): $MutableComponent
 "isEmpty"(): boolean
 "darkGreen"(): $MutableComponent
 "insertion"(s: StringJS): $MutableComponent
 "bold"(value: boolean): $MutableComponent
 "bold"(): $MutableComponent
 "color"(c: $KubeColor$$Type): $MutableComponent
 "italic"(): $MutableComponent
 "italic"(value: boolean): $MutableComponent
 "red"(): $MutableComponent
 "yellow"(): $MutableComponent
 "black"(): $MutableComponent
 "gold"(): $MutableComponent
 "click"(s: $ClickEvent$$Type): $MutableComponent
 "font"(s: $ResourceLocation$$Type): $MutableComponent
 "white"(): $MutableComponent
 "hover"(s: $Component$$Type): $MutableComponent
 "clickChangePage"(page: StringJS): $MutableComponent
 "clickSuggestCommand"(command: StringJS): $MutableComponent
 "clickRunCommand"(command: StringJS): $MutableComponent
 "blue"(): $MutableComponent
 "gray"(): $MutableComponent
 "green"(): $MutableComponent
 "aqua"(): $MutableComponent
 "getCodec"(): $Codec<(never)>
 "self"(): $MutableComponent
 "contains"(arg0: $Component$$Type): boolean
static "empty"(): $MutableComponent
 "copy"(): $MutableComponent
static "literal"(arg0: StringJS): $MutableComponent
 "visit"<T>(arg0: $FormattedText$ContentConsumer$$Type<(T)>): $Optional<(T)>
 "visit"<T>(arg0: $FormattedText$StyledContentConsumer$$Type<(T)>, arg1: $Style$$Type): $Optional<(T)>
 "getString"(arg0: integer): StringJS
 "getString"(): StringJS
 "getContents"(): $ComponentContents
static "selector"(arg0: StringJS, arg1: ($Component$$Type)?): $MutableComponent
static "translatable"(arg0: StringJS, ...arg1: (any)[]): $MutableComponent
static "translatable"(arg0: StringJS): $MutableComponent
static "nullToEmpty"(arg0: StringJS): $Component
static "translatableEscape"(arg0: StringJS, ...arg1: (any)[]): $MutableComponent
static "translationArg"(arg0: $ResourceLocation$$Type): $Component
static "translationArg"(arg0: $UUID$$Type): $Component
static "translationArg"(arg0: $ChunkPos$$Type): $Component
static "translationArg"(arg0: $Message$$Type): $Component
static "translationArg"(arg0: $Date$$Type): $Component
static "translationArg"(arg0: $URI$$Type): $Component
 "getSiblings"(): $List<($Component)>
static "translatableWithFallback"(arg0: StringJS, arg1: StringJS, ...arg2: (any)[]): $MutableComponent
static "translatableWithFallback"(arg0: StringJS, arg1: StringJS): $MutableComponent
 "tryCollapseToString"(): StringJS
 "getVisualOrderText"(): $FormattedCharSequence
static "score"(arg0: StringJS, arg1: StringJS): $MutableComponent
 "toFlatList"(arg0: $Style$$Type): $List<($Component)>
 "toFlatList"(): $List<($Component)>
 "plainCopy"(): $MutableComponent
 "getStyle"(): $Style
static "nbt"(arg0: StringJS, arg1: boolean, arg2: ($Component$$Type)?, arg3: $DataSource$$Type): $MutableComponent
static "keybind"(arg0: StringJS): $MutableComponent
 "toNBT"(): $Tag
 "toJson"(): $JsonElement
static "of"(arg0: StringJS, arg1: $Style$$Type): $FormattedText
static "of"(arg0: StringJS): $FormattedText
static "composite"(arg0: $List$$Type<($FormattedText$$Type)>): $FormattedText
static "composite"(...arg0: ($FormattedText$$Type)[]): $FormattedText
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentKJS$$Type = ($ComponentKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComponentKJS$$Original = $ComponentKJS;}
declare module "dev.latvian.mods.kubejs.item.custom.SwordItemBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$HandheldItemBuilder} from "dev.latvian.mods.kubejs.item.custom.HandheldItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $SwordItemBuilder extends $HandheldItemBuilder {
static readonly "SWORD_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "SWORD_MODEL": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SwordItemBuilder$$Type = ($SwordItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SwordItemBuilder$$Original = $SwordItemBuilder;}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$HandheldItemBuilder} from "dev.latvian.mods.kubejs.item.custom.HandheldItemBuilder"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem, $DiggerItem$$Type} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier, $Tier$$Type} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder extends $HandheldItemBuilder {
 "sourceLine": $SourceLine
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type, d: float, s: float, f: $BiFunction$$Type<($Tier), ($Item$Properties), ($DiggerItem$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$$Type = ($DiggerItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemBuilder$$Original = $DiggerItemBuilder;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.KMath" {
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Vector4f} from "org.joml.Vector4f"
import {$Vector3f} from "org.joml.Vector3f"
import {$Quaternionf} from "org.joml.Quaternionf"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$Matrix4f} from "org.joml.Matrix4f"
import {$Vector3d} from "org.joml.Vector3d"
import {$Matrix3f} from "org.joml.Matrix3f"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $KMath$$Interface {
}

export class $KMath implements $KMath$$Interface {
static readonly "DEGREES_TO_RADIANS": double
static readonly "E": double
static readonly "PI": double
static readonly "RADIANS_TO_DEGREES": double

static "deg"(value: double): double
static "floor"(value: double): long
static "ceil"(value: double): long
static "clamp"(value: double, min: double, max: double): double
static "map"(value: double, min0: double, max0: double, min1: double, max1: double): double
static "v3"(x: double, y: double, z: double): $Vec3
static "block"(x: double, y: double, z: double): $BlockPos
static "approach"(current: double, target: double, speed: double): double
static "isPowerOfTwo"(value: integer): boolean
static "quaternion"(x: float, y: float, z: float, w: float): $Quaternionf
static "rad"(value: double): double
static "degreesDifference"(current: double, target: double): double
static "rotateIfNecessary"(current: double, target: double, max: double): double
static "approachDegrees"(current: double, target: double, speed: double): double
static "clampedLerp"(value: double, min: double, max: double): double
static "lerp"(value: double, min: double, max: double): double
static "wrapDegrees"(d: double): double
static "v3f"(x: float, y: float, z: float): $Vector3f
static "v3d"(x: double, y: double, z: double): $Vector3d
static "m3f"(): $Matrix3f
static "v4f"(x: float, y: float, z: float, w: float): $Vector4f
static "m4f"(): $Matrix4f
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMath$$Type = ($KMath);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KMath$$Original = $KMath;}
declare module "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Class$$Type} from "java.lang.Class"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Record} from "java.lang.Record"

export class $KubeRecipeFactory extends $Record {
static readonly "DEFAULT": $KubeRecipeFactory

constructor(id: $ResourceLocation$$Type, recipeType: $Class$$Type<(never)>, factory: $Supplier$$Type<($KubeRecipe$$Type)>)
constructor(id: $ResourceLocation$$Type, recipeType: $TypeInfo$$Type, factory: $Supplier$$Type<($KubeRecipe$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "factory"(): $Supplier<($KubeRecipe)>
public "id"(): $ResourceLocation
public "create"(type: $RecipeTypeFunction$$Type, sourceLine: $SourceLine$$Type, save: boolean): $KubeRecipe
public "recipeType"(): $TypeInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeRecipeFactory$$Type = ({"id"?: $ResourceLocation$$Type, "factory"?: $Supplier$$Type<($KubeRecipe$$Type)>, "recipeType"?: $TypeInfo$$Type}) | ([id?: $ResourceLocation$$Type, factory?: $Supplier$$Type<($KubeRecipe$$Type)>, recipeType?: $TypeInfo$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeRecipeFactory$$Original = $KubeRecipeFactory;}
declare module "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$FluidBuilder, $FluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $FluidBlockBuilder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
readonly "fluidBuilder": $FluidBuilder
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(b: $FluidBuilder$$Type)

public "item"(i: $Consumer$$Type<($ItemBuilder)>): $BlockBuilder
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBlockBuilder$$Type = ($FluidBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidBlockBuilder$$Original = $FluidBlockBuilder;}
declare module "dev.latvian.mods.kubejs.core.MinecraftClientKJS" {
import {$TextureAtlasSprite} from "net.minecraft.client.renderer.texture.TextureAtlasSprite"
import {$Screen, $Screen$$Type} from "net.minecraft.client.gui.screens.Screen"
import {$ScheduledEvents, $ScheduledEvents$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents"
import {$KeyMapping$$Type} from "net.minecraft.client.KeyMapping"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MinecraftEnvironmentKJS$$Interface} from "dev.latvian.mods.kubejs.core.MinecraftEnvironmentKJS"
import {$ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Function} from "java.util.function.Function"
import {$TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$ScheduledEvents$ScheduledEvent} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $MinecraftClientKJS$$Interface extends $MinecraftEnvironmentKJS$$Interface {

(): $ScheduledEvents$$Type
get "title"(): StringJS
get "name"(): $Component
get "shiftDown"(): boolean
get "ctrlDown"(): boolean
get "altDown"(): boolean
set "title"(value: StringJS)
get "blockTextureAtlas"(): $Function<($ResourceLocation), ($TextureAtlasSprite)>
get "currentScreen"(): $Screen
get "currentWorldName"(): StringJS
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
set "currentScreen"(value: $Screen$$Type)
get "particleTextureAtlas"(): $Function<($ResourceLocation), ($TextureAtlasSprite)>
get "scheduledEvents"(): $ScheduledEvents
get "displayName"(): $Component
}

export class $MinecraftClientKJS implements $MinecraftClientKJS$$Interface {
 "getTitle"(): StringJS
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "isKeyDown"(keyName: StringJS): boolean
 "isKeyDown"(key: integer): boolean
 "isKeyBindDown"(id: StringJS): boolean
 "isShiftDown"(): boolean
 "isCtrlDown"(): boolean
 "isAltDown"(): boolean
 "setTitle"(t: StringJS): void
 "getBlockTextureAtlas"(): $Function<($ResourceLocation), ($TextureAtlasSprite)>
 "getCurrentScreen"(): $Screen
 "getCurrentWorldName"(): StringJS
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "setCurrentScreen"(gui: $Screen$$Type): void
 "getKeyBindPressedTicks"(id: StringJS): integer
 "isKeyMappingDown"(key: $KeyMapping$$Type): boolean
 "self"(): $Minecraft
 "tell"(message: $Component$$Type): void
 "getParticleTextureAtlas"(): $Function<($ResourceLocation), ($TextureAtlasSprite)>
 "schedule"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeating"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getScheduledEvents"(): $ScheduledEvents
 "scheduleInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeatingInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftClientKJS$$Type = (() => $ScheduledEvents$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MinecraftClientKJS$$Original = $MinecraftClientKJS;}
declare module "dev.latvian.mods.kubejs.core.ClientPacketListenerKJS" {
import {$KubeSessionData} from "dev.latvian.mods.kubejs.client.KubeSessionData"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ClientPacketListenerKJS$$Interface {
}

export class $ClientPacketListenerKJS implements $ClientPacketListenerKJS$$Interface {
 "kjs$sessionData"(): $KubeSessionData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPacketListenerKJS$$Type = ($ClientPacketListenerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientPacketListenerKJS$$Original = $ClientPacketListenerKJS;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Boots" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ArmorItemBuilder} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $ArmorItemBuilder$Boots extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "BOOT_TAGS": ($ResourceLocation)[]
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Boots$$Type = ($ArmorItemBuilder$Boots);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$Boots$$Original = $ArmorItemBuilder$Boots;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentType" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map} from "java.util.Map"
import {$Class$$Type} from "java.lang.Class"
import {$Record} from "java.lang.Record"

export class $BlockEntityAttachmentType extends $Record {
static readonly "ALL": $Lazy<($Map<($ResourceLocation), ($BlockEntityAttachmentType)>)>

constructor(id: $ResourceLocation$$Type, type: $Class$$Type<(never)>)
constructor(id: $ResourceLocation$$Type, typeInfo: $TypeInfo$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "typeInfo"(): $TypeInfo
public "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentType$$Type = ({"typeInfo"?: $TypeInfo$$Type, "id"?: $ResourceLocation$$Type}) | ([typeInfo?: $TypeInfo$$Type, id?: $ResourceLocation$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityAttachmentType$$Original = $BlockEntityAttachmentType;}
declare module "dev.latvian.mods.kubejs.block.callback.BlockStateRotateCallback" {
import {$Rotation, $Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockStateModifyCallback} from "dev.latvian.mods.kubejs.block.callback.BlockStateModifyCallback"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStateRotateCallback extends $BlockStateModifyCallback {
constructor(state: $BlockState$$Type, rotation: $Rotation$$Type)

/**
 * Rotates the specified direction
 */
public "rotate"(dir: $Direction$$Type): $Direction
/**
 * Get the Rotation that this block is being rotated by
 */
public "getRotation"(): $Rotation
get "rotation"(): $Rotation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateRotateCallback$$Type = ($BlockStateRotateCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateRotateCallback$$Original = $BlockStateRotateCallback;}
declare module "dev.latvian.mods.kubejs.block.callback.EntityFallenOnBlockCallback" {
import {$DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$EntitySteppedOnBlockCallback} from "dev.latvian.mods.kubejs.block.callback.EntitySteppedOnBlockCallback"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EntityFallenOnBlockCallback extends $EntitySteppedOnBlockCallback {
constructor(level: $Level$$Type, entity: $Entity$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fallHeight: float)

/**
 * Applies fall damage to the entity, multiplier by the multiplier.
 * Note this does not force it, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(multiplier: float): boolean
/**
 * Applies fall damage to the entity as if they had fallen from the provided height, and multiplies it by the provided multiplier.
 * Note this does not force it, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(fallHeight: float, multiplier: float): boolean
/**
 * Damages the entity using the provided damage source, using the fall height and multiplier to calculate the damage amount.
 * Note this does not force the damage, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(fallHeight: float, multiplier: float, damageSource: $DamageSource$$Type): boolean
/**
 * Applies default fall damage to the entity.
 * Note this does not force it, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(): boolean
/**
 * Get the height the entity has fallen
 */
public "getFallHeight"(): float
get "fallHeight"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityFallenOnBlockCallback$$Type = ($EntityFallenOnBlockCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityFallenOnBlockCallback$$Original = $EntityFallenOnBlockCallback;}
declare module "dev.latvian.mods.kubejs.misc.MobEffectBuilder$EffectEntityCallback" {
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export interface $MobEffectBuilder$EffectEntityCallback$$Interface {

(entity: $LivingEntity, level: integer): void
}

export class $MobEffectBuilder$EffectEntityCallback implements $MobEffectBuilder$EffectEntityCallback$$Interface {
 "applyEffectTick"(entity: $LivingEntity$$Type, level: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectBuilder$EffectEntityCallback$$Type = ((entity: $LivingEntity, level: integer) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobEffectBuilder$EffectEntityCallback$$Original = $MobEffectBuilder$EffectEntityCallback;}
declare module "dev.latvian.mods.kubejs.entity.LivingEntityDeathKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$Level} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked before a living entity dies.
 * 
 * **NOTE**: You need to set hp to > 0 besides cancelling the event to prevent the entity from dying.
 */
export class $LivingEntityDeathKubeEvent implements $KubeLivingEntityEvent$$Interface {
constructor(entity: $LivingEntity$$Type, source: $DamageSource$$Type)

/**
 * The damage source that triggers the death.
 */
public "getSource"(): $DamageSource
/**
 * The entity that dies.
 */
public "getEntity"(): $LivingEntity
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "source"(): $DamageSource
get "entity"(): $LivingEntity
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityDeathKubeEvent$$Type = ($LivingEntityDeathKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LivingEntityDeathKubeEvent$$Original = $LivingEntityDeathKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.RecipeLikeKJS" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchema} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RecipeLikeKJS$$Interface {
get "serializer"(): $RecipeSerializer<(never)>
set "group"(value: StringJS)
get "typeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
get "schema"(): $RecipeSchema
get "orCreateId"(): $ResourceLocation
get "group"(): StringJS
get "mod"(): StringJS
get "type"(): $ResourceLocation
}

export class $RecipeLikeKJS implements $RecipeLikeKJS$$Interface {
 "replaceOutput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "getSerializer"(): $RecipeSerializer<(never)>
 "setGroup"(group: StringJS): void
 "replaceInput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "getTypeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
 "getSchema"(): $RecipeSchema
 "getOrCreateId"(): $ResourceLocation
 "getGroup"(): StringJS
 "hasOutput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
 "hasInput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
 "getMod"(): StringJS
 "getType"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeLikeKJS$$Type = ($RecipeLikeKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeLikeKJS$$Original = $RecipeLikeKJS;}
declare module "dev.latvian.mods.kubejs.misc.PaintingVariantBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$PaintingVariant} from "net.minecraft.world.entity.decoration.PaintingVariant"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $PaintingVariantBuilder extends $BuilderBase<($PaintingVariant)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

public "size"(width: integer, height: integer): this
public "assetId"(assetId: $ResourceLocation$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PaintingVariantBuilder$$Type = ($PaintingVariantBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PaintingVariantBuilder$$Original = $PaintingVariantBuilder;}
declare module "dev.latvian.mods.kubejs.stages.Stages" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Collection, $Collection$$Type} from "java.util.Collection"

export interface $Stages$$Interface {
get "all"(): $Collection<(StringJS)>
get "player"(): $Player
}

export class $Stages implements $Stages$$Interface {
 "remove"(stage: StringJS): boolean
 "clear"(): boolean
 "replace"(stages: $Collection$$Type<(StringJS)>): void
 "add"(stage: StringJS): boolean
 "set"(stage: StringJS, enabled: boolean): boolean
 "sync"(): void
 "getAll"(): $Collection<(StringJS)>
 "has"(stage: StringJS): boolean
 "getPlayer"(): $Player
 "toggle"(stage: StringJS): boolean
 "removeNoUpdate"(stage: StringJS): boolean
 "addNoUpdate"(stage: StringJS): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Stages$$Type = ($Stages);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Stages$$Original = $Stages;}
declare module "dev.latvian.mods.kubejs.util.CountingMap" {
import {$Collection} from "java.util.Collection"
import {$Object2LongEntry, $Object2LongEntry$$Type} from "dev.latvian.mods.kubejs.util.Object2LongEntry"
import {$List} from "java.util.List"
import {$Set} from "java.util.Set"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $CountingMap {
constructor()

public "get"(key: any): long
public "clear"(): void
public "add"(key: any, value: long): long
public "set"(key: any, value: long): long
public "forEach"(forEach: $Consumer$$Type<($Object2LongEntry)>): void
public "getSize"(): integer
public "getEntries"(): $List<($Object2LongEntry)>
public "getKeys"(): $Set<(any)>
public "getValues"(): $Collection<(long)>
public "getTotalCount"(): long
get "size"(): integer
get "entries"(): $List<($Object2LongEntry)>
get "keys"(): $Set<(any)>
get "values"(): $Collection<(long)>
get "totalCount"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CountingMap$$Type = ($CountingMap);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CountingMap$$Original = $CountingMap;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$UseCallback" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"

export interface $ItemBuilder$UseCallback$$Interface {

(level: $Level, player: $Player, interactionHand: $InteractionHand): boolean
}

export class $ItemBuilder$UseCallback implements $ItemBuilder$UseCallback$$Interface {
 "use"(level: $Level$$Type, player: $Player$$Type, interactionHand: $InteractionHand$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$UseCallback$$Type = ((level: $Level, player: $Player, interactionHand: $InteractionHand) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$UseCallback$$Original = $ItemBuilder$UseCallback;}
declare module "dev.latvian.mods.kubejs.client.highlight.HighlightKubeEvent" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$HighlightRenderer$$Type} from "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Minecraft, $Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$EntitySelector$$Type} from "net.minecraft.commands.arguments.selector.EntitySelector"
import {$ClientPlayerKubeEvent} from "dev.latvian.mods.kubejs.client.ClientPlayerKubeEvent"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

/**
 * Invoked when block and entity highlight is rendered.
 */
export class $HighlightKubeEvent extends $ClientPlayerKubeEvent {
constructor(mc: $Minecraft$$Type, renderer: $HighlightRenderer$$Type)

public "getClient"(): $Minecraft
public "addBlock"(pos: $BlockPos$$Type, color: $KubeColor$$Type): void
public "addEntity"(entity: $Entity$$Type, color: $KubeColor$$Type): void
public "addTarget"(color: $KubeColor$$Type): void
public "addEntities"(selector: $EntitySelector$$Type, color: $KubeColor$$Type): void
public "getTargetBlock"(): $LevelBlock
public "addBlocks"(from: $BlockPos$$Type, to: $BlockPos$$Type, color: $KubeColor$$Type): void
public "addEntitiesByType"(type: $EntityType$$Type<(never)>, color: $KubeColor$$Type): void
public "addTargetEntity"(color: $KubeColor$$Type): void
public "addTargetBlock"(color: $KubeColor$$Type): void
public "getTargetEntity"(): $Entity
public "getEntity"(): $Entity
get "client"(): $Minecraft
get "targetBlock"(): $LevelBlock
get "targetEntity"(): $Entity
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HighlightKubeEvent$$Type = ($HighlightKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HighlightKubeEvent$$Original = $HighlightKubeEvent;}
declare module "dev.latvian.mods.kubejs.util.ScheduledEvents" {
import {$ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$LinkedList} from "java.util.LinkedList"
import {$AtomicInteger} from "java.util.concurrent.atomic.AtomicInteger"
import {$TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"

export class $ScheduledEvents {
 "currentTick": long
readonly "factory": $Supplier<($ScheduledEvents$ScheduledEvent)>
readonly "nextId": $AtomicInteger
 "currentMillis": long
readonly "events": $LinkedList<($ScheduledEvents$ScheduledEvent)>
readonly "futureEvents": $LinkedList<($ScheduledEvents$ScheduledEvent)>

constructor(factory: $Supplier$$Type<($ScheduledEvents$ScheduledEvent$$Type)>)

public "clear"(id: integer): void
public "schedule"(timer: $TemporalAmount$$Type, repeating: boolean, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
public "schedule"(timer: long, ofTicks: boolean, repeating: boolean, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
public "tickAll"(nowTicks: long): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledEvents$$Type = ($ScheduledEvents);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduledEvents$$Original = $ScheduledEvents;}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabIconSupplier" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"

export interface $CreativeTabIconSupplier$$Interface {

(): $ItemStack$$Type
get "icon"(): $ItemStack
}

export class $CreativeTabIconSupplier implements $CreativeTabIconSupplier$$Interface {
static readonly "DEFAULT": $CreativeTabIconSupplier

 "getIcon"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabIconSupplier$$Type = (() => $ItemStack$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeTabIconSupplier$$Original = $CreativeTabIconSupplier;}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockPredicate" {
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"

export interface $BlockPredicate$$Interface {

(block: $LevelBlock): boolean
}

export class $BlockPredicate implements $BlockPredicate$$Interface {
 "check"(block: $LevelBlock$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPredicate$$Type = ((block: $LevelBlock) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPredicate$$Original = $BlockPredicate;}
declare module "dev.latvian.mods.kubejs.util.OrderedCompoundTag" {
import {$TagType} from "net.minecraft.nbt.TagType"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$DataOutput$$Type} from "java.io.DataOutput"

export class $OrderedCompoundTag extends $CompoundTag {
static readonly "CODEC": $Codec<($CompoundTag)>
readonly "tagMap": $Map<(StringJS), ($Tag)>
static readonly "TYPE": $TagType<($CompoundTag)>
readonly "tags": $Map<(StringJS), ($Tag)>

constructor(map: $Map$$Type<(StringJS), ($Tag$$Type)>)
constructor()

public "write"(dataOutput: $DataOutput$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrderedCompoundTag$$Type = ($OrderedCompoundTag);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OrderedCompoundTag$$Original = $OrderedCompoundTag;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuData" {
import {$Container} from "net.minecraft.world.Container"
import {$ChestMenuSlot, $ChestMenuSlot$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuSlot"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ChestMenuClickEvent$Callback, $ChestMenuClickEvent$Callback$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback"
import {$Runnable} from "java.lang.Runnable"
import {$ClickType$$Type} from "net.minecraft.world.inventory.ClickType"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$ChestMenuInventoryClickEvent$Callback} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent$Callback"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ChestMenuData {
 "capturedInventory": $Container
readonly "slots": ($ChestMenuSlot)[]
 "mouseItem": $ItemStack
 "anyClicked": $ChestMenuClickEvent$Callback
 "closed": $Runnable
 "inventoryClicked": $ChestMenuInventoryClickEvent$Callback
 "title": $Component
readonly "rows": integer
 "playerSlots": boolean
readonly "player": $ServerPlayer

constructor(player: $ServerPlayer$$Type, title: $Component$$Type, rows: integer)

public "slot"(x0: integer, y0: integer, x1: integer, y1: integer, slot: $Consumer$$Type<($ChestMenuSlot)>): void
public "slot"(x: integer, y: integer, slot: $Consumer$$Type<($ChestMenuSlot)>): void
public "getSlot"(x: integer, y: integer): $ChestMenuSlot
public "sync"(): void
public "button"(x: integer, y: integer, stack: $ItemStack$$Type, displayName: $Component$$Type, leftClicked: $ChestMenuClickEvent$Callback$$Type): void
public "handleClick"(index: integer, type: $ClickType$$Type, button: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuData$$Type = ($ChestMenuData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuData$$Original = $ChestMenuData;}
declare module "dev.latvian.mods.kubejs.script.data.VirtualResourcePack" {
import {$ExportablePackResources$$Interface} from "dev.latvian.mods.kubejs.script.data.ExportablePackResources"
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$MetadataSectionSerializer$$Type} from "net.minecraft.server.packs.metadata.MetadataSectionSerializer"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$KubeResourceGenerator$$Interface} from "dev.latvian.mods.kubejs.generator.KubeResourceGenerator"
import {$GeneratedDataStage, $GeneratedDataStage$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedDataStage"
import {$IoSupplier} from "net.minecraft.server.packs.resources.IoSupplier"
import {$Component} from "net.minecraft.network.chat.Component"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$PackType, $PackType$$Type} from "net.minecraft.server.packs.PackType"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$PackResources$ResourceOutput$$Type} from "net.minecraft.server.packs.PackResources$ResourceOutput"
import {$Set} from "java.util.Set"
import {$Path$$Type} from "java.nio.file.Path"
import {$InputStream} from "java.io.InputStream"
import {$AbstractPackResources} from "net.minecraft.server.packs.AbstractPackResources"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $VirtualResourcePack extends $AbstractPackResources implements $KubeResourceGenerator$$Interface, $ExportablePackResources$$Interface {
readonly "component": $Component
readonly "stage": $GeneratedDataStage
readonly "scriptType": $ScriptType
readonly "packType": $PackType
readonly "registries": $Supplier<($RegistryAccessContainer)>
readonly "info": StringJS

constructor(scriptType: $ScriptType$$Type, packType: $PackType$$Type, stage: $GeneratedDataStage$$Type, registries: $Supplier$$Type<($RegistryAccessContainer$$Type)>)

public "reset"(): void
public "toString"(): StringJS
public "add"(data: $GeneratedData$$Type): void
public "getResource"(type: $PackType$$Type, location: $ResourceLocation$$Type): $IoSupplier<($InputStream)>
public "close"(): void
public "export"(root: $Path$$Type): void
public "getGenerated"(id: $ResourceLocation$$Type): $GeneratedData
public "getRegistries"(): $RegistryAccessContainer
public "listResources"(packType: $PackType$$Type, namespace: StringJS, path: StringJS, visitor: $PackResources$ResourceOutput$$Type): void
public "getNamespaces"(type: $PackType$$Type): $Set<(StringJS)>
public "exportPath"(): StringJS
public "getMetadataSection"<T>(serializer: $MetadataSectionSerializer$$Type<(T)>): T
public "getRootResource"(...path: (StringJS)[]): $IoSupplier<($InputStream)>
public "packId"(): StringJS
public "flush"(): void
public "text"(id: $ResourceLocation$$Type, content: StringJS): void
public "json"(id: $ResourceLocation$$Type, json: $JsonElement$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualResourcePack$$Type = ($VirtualResourcePack);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VirtualResourcePack$$Original = $VirtualResourcePack;}
declare module "dev.latvian.mods.kubejs.block.custom.StairBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $StairBlockBuilder extends $ShapedBlockBuilder {
static readonly "STAIR_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StairBlockBuilder$$Type = ($StairBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StairBlockBuilder$$Original = $StairBlockBuilder;}
declare module "dev.latvian.mods.kubejs.registry.ModelledBuilderBase" {
import {$ModelGenerator$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator"
import {$Map$$Type} from "java.util.Map"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ModelledBuilderBase<T> extends $BuilderBase<(T)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

/**
 * Directly set the texture map.
 */
public "textures"(map: $Map$$Type<(StringJS), (StringJS)>): this
/**
 * Sets the texture by given key.
 */
public "texture"(key: (StringJS)[], tex: StringJS): this
/**
 * Sets the texture.
 */
public "texture"(tex: StringJS): this
/**
 * Sets the parent model.
 */
public "parentModel"(id: $ResourceLocation$$Type): this
/**
 * Replaces default model with custom generator.
 */
public "modelGenerator"(generator: $Consumer$$Type<($ModelGenerator)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelledBuilderBase$$Type<T> = ($ModelledBuilderBase<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModelledBuilderBase$$Original<T> = $ModelledBuilderBase<(T)>;}
declare module "dev.latvian.mods.kubejs.script.ScriptFileInfo" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$ScriptPackInfo, $ScriptPackInfo$$Type} from "dev.latvian.mods.kubejs.script.ScriptPackInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptFileInfo {
readonly "path": $Path
readonly "file": StringJS
readonly "location": StringJS
readonly "id": $ResourceLocation
readonly "pack": $ScriptPackInfo
readonly "locationPath": StringJS

constructor(p: $ScriptPackInfo$$Type, ph: $Path$$Type, f: StringJS)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptFileInfo$$Type = ($ScriptFileInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptFileInfo$$Original = $ScriptFileInfo;}
declare module "dev.latvian.mods.kubejs.block.entity.FluidTankAttachment$Factory" {
import {$BlockCapability} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockEntityAttachmentFactory$$Interface} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$List} from "java.util.List"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$BlockEntityAttachment} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record} from "java.lang.Record"

export class $FluidTankAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory$$Interface {
constructor(capacity: integer, inputFilter: ($FluidIngredient$$Type)?)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "create"(info: $BlockEntityAttachmentInfo$$Type, entity: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "capacity"(): integer
public "getCapabilities"(): $List<($BlockCapability<(never), (never)>)>
public "inputFilter"(): $Optional<($FluidIngredient)>
public "isTicking"(): boolean
get "capabilities"(): $List<($BlockCapability<(never), (never)>)>
get "ticking"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankAttachment$Factory$$Type = ({"capacity"?: integer, "inputFilter"?: ($FluidIngredient$$Type)?}) | ([capacity?: integer, inputFilter?: ($FluidIngredient$$Type)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidTankAttachment$Factory$$Original = $FluidTankAttachment$Factory;}
declare module "dev.latvian.mods.kubejs.block.custom.CarpetBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $CarpetBlockBuilder extends $ShapedBlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "CARPET_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarpetBlockBuilder$$Type = ($CarpetBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarpetBlockBuilder$$Original = $CarpetBlockBuilder;}
declare module "dev.latvian.mods.kubejs.block.RandomTickKubeEvent" {
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $RandomTickKubeEvent implements $KubeLevelEvent$$Interface {
readonly "random": $RandomSource

constructor(level: $ServerLevel$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, random: $RandomSource$$Type)

public "getLevel"(): $Level
public "getBlock"(): $LevelBlock
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "block"(): $LevelBlock
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomTickKubeEvent$$Type = ($RandomTickKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomTickKubeEvent$$Original = $RandomTickKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RegistryAwareSchema" {
import {$RecipeSchema, $RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RegistryAwareSchema$$Interface {

(cx: $RegistryAccessContainer): $RecipeSchema$$Type
}

export class $RegistryAwareSchema implements $RegistryAwareSchema$$Interface {
 "create"(cx: $RegistryAccessContainer$$Type): $RecipeSchema
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryAwareSchema$$Type = ((cx: $RegistryAccessContainer) => $RecipeSchema$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryAwareSchema$$Original = $RegistryAwareSchema;}
declare module "dev.latvian.mods.kubejs.block.BlockTintFunction$Fixed" {
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockTintFunction, $BlockTintFunction$$Interface} from "dev.latvian.mods.kubejs.block.BlockTintFunction"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Record} from "java.lang.Record"

export class $BlockTintFunction$Fixed extends $Record implements $BlockTintFunction$$Interface {
constructor(color: $KubeColor$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "color"(): $KubeColor
public "getColor"(state: $BlockState$$Type, level: $BlockAndTintGetter$$Type, pos: $BlockPos$$Type, index: integer): $KubeColor
public static "wrap"(o: any): $BlockTintFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTintFunction$Fixed$$Type = ({"color"?: $KubeColor$$Type}) | ([color?: $KubeColor$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockTintFunction$Fixed$$Original = $BlockTintFunction$Fixed;}
declare module "dev.latvian.mods.kubejs.core.DiggerItemKJS" {
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $DiggerItemKJS$$Interface {

(): $TagKey$$Type<($Block$$Type)>
}

export class $DiggerItemKJS implements $DiggerItemKJS$$Interface {
 "kjs$getMineableTag"(): $TagKey<($Block)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemKJS$$Type = (() => $TagKey$$Type<($Block$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemKJS$$Original = $DiggerItemKJS;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.DataMapWrapper" {
import {$Iterable$$Interface} from "java.lang.Iterable"
import {$Iterator} from "java.util.Iterator"
import {$Map} from "java.util.Map"
import {$Spliterator} from "java.util.Spliterator"
import {$RegistryWrapper$$Type} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.RegistryWrapper"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$DataMapWrapper$Data, $DataMapWrapper$Data$$Type} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.DataMapWrapper$Data"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$DataMapType, $DataMapType$$Type} from "net.neoforged.neoforge.registries.datamaps.DataMapType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Stream} from "java.util.stream.Stream"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $DataMapWrapper<T, A> extends $Record implements $Iterable$$Interface<($DataMapWrapper$Data<(T), (A)>)> {
constructor(registry: $Registry$$Type<(T)>, type: $DataMapType$$Type<(T), (A)>)

public "get"(item: T): A
public "type"(): $DataMapType<(T), (A)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "iterator"(): $Iterator<($DataMapWrapper$Data<(T), (A)>)>
public static "of"<T>(registry: $RegistryWrapper$$Type<(T)>, id: $ResourceLocation$$Type): $DataMapWrapper<(T), (never)>
public static "of"(registry: $ResourceLocation$$Type, id: $ResourceLocation$$Type): $DataMapWrapper<(never), (never)>
public "keys"(): $Stream<(T)>
public "registry"(): $Registry<(T)>
public static "typeOf"<T>(registry: $RegistryWrapper$$Type<(T)>, id: $ResourceLocation$$Type): $DataMapType<(T), (never)>
public static "typeOf"(registry: $ResourceLocation$$Type, id: $ResourceLocation$$Type): $DataMapType<(never), (never)>
public "byKey"(): $Map<($ResourceKey<(T)>), (A)>
public "spliterator"(): $Spliterator<($DataMapWrapper$Data<(T), (A)>)>
public "forEach"(arg0: $Consumer$$Type<($DataMapWrapper$Data<(T), (A)>)>): void
[Symbol.iterator](): IterableIterator<$DataMapWrapper$Data<(T), (A)>>;
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataMapWrapper$$Type<T, A> = ({"registry"?: $Registry$$Type<(T)>, "type"?: $DataMapType$$Type<(T), (A)>}) | ([registry?: $Registry$$Type<(T)>, type?: $DataMapType$$Type<(T), (A)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataMapWrapper$$Original<T, A> = $DataMapWrapper<(T), (A)>;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.DataMapWrapper$Data" {
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $DataMapWrapper$Data<T, A> extends $Record {
constructor(element: T, data: A)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "data"(): A
public "element"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataMapWrapper$Data$$Type<T, A> = ({"element"?: T, "data"?: A}) | ([element?: T, data?: A]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataMapWrapper$Data$$Original<T, A> = $DataMapWrapper$Data<(T), (A)>;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$AnimalArmor" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ArmorItemBuilder} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$AnimalArmorItem$BodyType$$Type} from "net.minecraft.world.item.AnimalArmorItem$BodyType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $ArmorItemBuilder$AnimalArmor extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

public "bodyType"(type: $AnimalArmorItem$BodyType$$Type): this
public "overlay"(o: boolean): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$AnimalArmor$$Type = ($ArmorItemBuilder$AnimalArmor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$AnimalArmor$$Original = $ArmorItemBuilder$AnimalArmor;}
declare module "dev.latvian.mods.kubejs.command.CommandRegistryKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$LiteralArgumentBuilder$$Type} from "com.mojang.brigadier.builder.LiteralArgumentBuilder"
import {$CommandBuildContext, $CommandBuildContext$$Type} from "net.minecraft.commands.CommandBuildContext"
import {$Commands} from "net.minecraft.commands.Commands"
import {$ArgumentTypeWrappers} from "dev.latvian.mods.kubejs.command.ArgumentTypeWrappers"
import {$CommandDispatcher, $CommandDispatcher$$Type} from "com.mojang.brigadier.CommandDispatcher"
import {$LiteralCommandNode} from "com.mojang.brigadier.tree.LiteralCommandNode"
import {$SharedSuggestionProvider} from "net.minecraft.commands.SharedSuggestionProvider"
import {$CommandSourceStack, $CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"
import {$Commands$CommandSelection, $Commands$CommandSelection$$Type} from "net.minecraft.commands.Commands$CommandSelection"

export class $CommandRegistryKubeEvent implements $KubeEvent$$Interface {
readonly "selection": $Commands$CommandSelection
readonly "context": $CommandBuildContext
readonly "dispatcher": $CommandDispatcher<($CommandSourceStack)>

constructor(dispatcher: $CommandDispatcher$$Type<($CommandSourceStack$$Type)>, context: $CommandBuildContext$$Type, selection: $Commands$CommandSelection$$Type)

public "register"(command: $LiteralArgumentBuilder$$Type<($CommandSourceStack$$Type)>): $LiteralCommandNode<($CommandSourceStack)>
public "getArguments"(): typeof $ArgumentTypeWrappers
public "getRegistry"(): $CommandBuildContext
public "getCommands"(): typeof $Commands
public "getBuiltinSuggestions"(): typeof $SharedSuggestionProvider
public "isForMultiPlayer"(): boolean
public "isForSinglePlayer"(): boolean
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "arguments"(): typeof $ArgumentTypeWrappers
get "registry"(): $CommandBuildContext
get "commands"(): typeof $Commands
get "builtinSuggestions"(): typeof $SharedSuggestionProvider
get "forMultiPlayer"(): boolean
get "forSinglePlayer"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandRegistryKubeEvent$$Type = ($CommandRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CommandRegistryKubeEvent$$Original = $CommandRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.fluid.FluidWrapper$ReadFn" {
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$StringReader, $StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$DataResult, $DataResult$$Type} from "com.mojang.serialization.DataResult"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"

export interface $FluidWrapper$ReadFn$$Interface<T> {

(registryOps: $DynamicOps<($Tag)>, reader: $StringReader): $DataResult$$Type<(T)>
}

export class $FluidWrapper$ReadFn<T> implements $FluidWrapper$ReadFn$$Interface {
 "read"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, reader: $StringReader$$Type): $DataResult<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidWrapper$ReadFn$$Type<T> = ((registryOps: $DynamicOps<($Tag)>, reader: $StringReader) => $DataResult$$Type<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidWrapper$ReadFn$$Original<T> = $FluidWrapper$ReadFn<(T)>;}
declare module "dev.latvian.mods.kubejs.core.BlockBehaviourKJS" {
import {$Map} from "java.util.Map"
import {$SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$List} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Holder} from "net.minecraft.core.Holder"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$BlockProviderKJS$$Interface} from "dev.latvian.mods.kubejs.core.BlockProviderKJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RandomTickCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $BlockBehaviourKJS$$Interface extends $BlockProviderKJS$$Interface {

(): $Block$$Type
set "soundType"(value: $SoundType$$Type)
set "friction"(value: float)
set "speedFactor"(value: float)
set "jumpFactor"(value: float)
set "randomTickCallback"(value: $Consumer$$Type<($RandomTickCallback)>)
set "isRandomlyTicking"(value: boolean)
set "hasCollision"(value: boolean)
set "explosionResistance"(value: float)
get "id"(): StringJS
get "key"(): $ResourceKey<($Block)>
get "typeData"(): $Map<(StringJS), (any)>
get "registry"(): $Registry<($Block)>
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "block"(): $Block
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $BlockBehaviourKJS implements $BlockBehaviourKJS$$Interface {
 "setSoundType"(v: $SoundType$$Type): void
 "setFriction"(v: float): void
 "setSpeedFactor"(v: float): void
 "setJumpFactor"(v: float): void
 "setRandomTickCallback"(callback: $Consumer$$Type<($RandomTickCallback)>): void
 "setIsRandomlyTicking"(v: boolean): void
 "setHasCollision"(v: boolean): void
 "setExplosionResistance"(v: float): void
 "getId"(): StringJS
 "getKey"(): $ResourceKey<($Block)>
 "getTypeData"(): $Map<(StringJS), (any)>
 "asHolder"(): $Holder<($Block)>
 "getRegistry"(): $Registry<($Block)>
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "getBlock"(): $Block
 "specialEquals"(o: any, shallow: boolean): boolean
 "getMod"(): StringJS
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getIdLocation"(): $ResourceLocation
 "getTagKeys"(): $List<($TagKey<($Block)>)>
 "getTags"(): $List<($ResourceLocation)>
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviourKJS$$Type = (() => $Block$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviourKJS$$Original = $BlockBehaviourKJS;}
declare module "dev.latvian.mods.kubejs.entity.LivingEntityDropsKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DamageSource} from "net.minecraft.world.damagesource.DamageSource"
import {$List} from "java.util.List"
import {$Level} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$LivingDropsEvent$$Type} from "net.neoforged.neoforge.event.entity.living.LivingDropsEvent"
import {$ItemEntity} from "net.minecraft.world.entity.item.ItemEntity"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $LivingEntityDropsKubeEvent implements $KubeLivingEntityEvent$$Interface {
 "eventDrops": $List<($ItemEntity)>

constructor(e: $LivingDropsEvent$$Type)

public "getSource"(): $DamageSource
public "getEntity"(): $Entity
public "isRecentlyHit"(): boolean
public "getDrops"(): $List<($ItemEntity)>
public "addDrop"(stack: $ItemStack$$Type, chance: float): $ItemEntity
public "addDrop"(stack: $ItemStack$$Type): $ItemEntity
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "source"(): $DamageSource
get "entity"(): $Entity
get "recentlyHit"(): boolean
get "drops"(): $List<($ItemEntity)>
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityDropsKubeEvent$$Type = ($LivingEntityDropsKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LivingEntityDropsKubeEvent$$Original = $LivingEntityDropsKubeEvent;}
declare module "dev.latvian.mods.kubejs.script.PlatformWrapper" {
import {$Map} from "java.util.Map"
import {$Set} from "java.util.Set"
import {$PlatformWrapper$ModInfo} from "dev.latvian.mods.kubejs.script.PlatformWrapper$ModInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $PlatformWrapper {
constructor()

/**
 * 
 * @deprecated
 */
public static "getName"(): StringJS
public static "isLoaded"(modId: StringJS): boolean
public static "getInfo"(modID: StringJS): $PlatformWrapper$ModInfo
public static "setModName"(modId: StringJS, name: StringJS): void
public static "breakpoint"(...args: (any)[]): void
/**
 * 
 * @deprecated
 */
public static "isFabric"(): boolean
public static "getModVersion"(): StringJS
public static "getMcVersion"(): StringJS
public static "getMods"(): $Map<(StringJS), ($PlatformWrapper$ModInfo)>
public static "isGeneratingData"(): boolean
public static "isDevelopmentEnvironment"(): boolean
public static "getList"(): $Set<(StringJS)>
public static "getMinecraftVersion"(): integer
public static "getPackMode"(): StringJS
public static "isClientEnvironment"(): boolean
/**
 * 
 * @deprecated
 */
public static "isForge"(): boolean
public static "getMinecraftVersionString"(): StringJS
public static "getCurrentThreadName"(): StringJS
get "name"(): StringJS
get "fabric"(): boolean
get "modVersion"(): StringJS
get "mcVersion"(): StringJS
get "mods"(): $Map<(StringJS), ($PlatformWrapper$ModInfo)>
get "generatingData"(): boolean
get "developmentEnvironment"(): boolean
get "list"(): $Set<(StringJS)>
get "minecraftVersion"(): integer
get "packMode"(): StringJS
get "clientEnvironment"(): boolean
get "forge"(): boolean
get "minecraftVersionString"(): StringJS
get "currentThreadName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformWrapper$$Type = ($PlatformWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlatformWrapper$$Original = $PlatformWrapper;}
declare module "dev.latvian.mods.kubejs.util.TinyMap$Entry" {
import {$Record} from "java.lang.Record"

export class $TinyMap$Entry<K, V> extends $Record {
constructor(key: K, value: V)

public "value"(): V
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "key"(): K
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TinyMap$Entry$$Type<K, V> = ({"value"?: V, "key"?: K}) | ([value?: V, key?: K]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TinyMap$Entry$$Original<K, V> = $TinyMap$Entry<(K), (V)>;}
declare module "dev.latvian.mods.kubejs.util.WrappedJS" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $WrappedJS$$Interface {
}

export class $WrappedJS implements $WrappedJS$$Interface {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedJS$$Type = ($WrappedJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WrappedJS$$Original = $WrappedJS;}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$CreativeTabCallback$$Type} from "dev.latvian.mods.kubejs.item.creativetab.CreativeTabCallback"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CreativeModeTab, $CreativeModeTab$$Type} from "net.minecraft.world.item.CreativeModeTab"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$CreativeModeTab$TabVisibility$$Type} from "net.minecraft.world.item.CreativeModeTab$TabVisibility"
import {$Component$$Type} from "net.minecraft.network.chat.Component"

export class $CreativeTabKubeEvent implements $KubeEvent$$Interface {
readonly "tab": $CreativeModeTab
readonly "showRestrictedItems": boolean

constructor(tab: $CreativeModeTab$$Type, showRestrictedItems: boolean, callback: $CreativeTabCallback$$Type)

public "remove"(filter: $ItemPredicate$$Type): void
public "add"(items: ($ItemStack$$Type)[]): void
public "add"(items: ($ItemStack$$Type)[], visibility: $CreativeModeTab$TabVisibility$$Type): void
public "setIcon"(icon: $ItemStack$$Type): void
public "setDisplayName"(component: $Component$$Type): void
public "addBefore"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[], visibility: $CreativeModeTab$TabVisibility$$Type): void
public "addBefore"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[]): void
public "addAfter"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[]): void
public "addAfter"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[], visibility: $CreativeModeTab$TabVisibility$$Type): void
public "removeFromParent"(filter: $ItemPredicate$$Type): void
public "removeFromSearch"(filter: $ItemPredicate$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
set "icon"(value: $ItemStack$$Type)
set "displayName"(value: $Component$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabKubeEvent$$Type = ($CreativeTabKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeTabKubeEvent$$Original = $CreativeTabKubeEvent;}
declare module "dev.latvian.mods.kubejs.item.ItemCraftedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Container$$Type} from "net.minecraft.world.Container"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player crafts an item.
 */
export class $ItemCraftedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, crafted: $ItemStack$$Type, container: $Container$$Type)

/**
 * The item that was crafted.
 */
public "getItem"(): $ItemStack
/**
 * The inventory that the item was crafted in.
 */
public "getInventory"(): $InventoryKJS
/**
 * The player that crafted the item.
 */
public "getEntity"(): $Player
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "item"(): $ItemStack
get "inventory"(): $InventoryKJS
get "entity"(): $Player
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemCraftedKubeEvent$$Type = ($ItemCraftedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemCraftedKubeEvent$$Original = $ItemCraftedKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityInfo" {
import {$BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$CustomCapabilityAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.CustomCapabilityAttachment$Factory"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$FluidTankAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.FluidTankAttachment$Factory"
import {$FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$BlockEntityAttachmentHandler$$Interface} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentHandler"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InventoryAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.InventoryAttachment$Factory"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Set$$Type} from "java.util.Set"
import {$EnergyStorageAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.EnergyStorageAttachment$Factory"
import {$BlockEntityEventCallback$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityEventCallback"

export class $BlockEntityInfo implements $BlockEntityAttachmentHandler$$Interface {
constructor(blockBuilder: $BlockBuilder$$Type)

public "toString"(): StringJS
public "ticking"(): void
public "tickOffset"(offset: integer): void
public "enableSync"(): void
public "eventHandler"(eventId: integer, callback: $BlockEntityEventCallback$$Type): void
public "initialData"(data: $CompoundTag$$Type): void
public "rightClickOpensInventory"(id: StringJS): void
public "rightClickFillsTank"(id: StringJS): void
public "serverTicking"(): void
public "clientTicking"(): void
public "tickFrequency"(frequency: integer): void
public "attach"<T extends Attachments>(id: StringJS, type: T, directions: $Set$$Type<($Direction$$Type)>, args: AttachmentMap[T]): void
public "inventory"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, width: integer, height: integer, inputFilter: $ItemPredicate$$Type): void
public "inventory"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, width: integer, height: integer): void
public "fluidTank"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer): void
public "fluidTank"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer, inputFilter: $FluidIngredient$$Type): void
public "energyStorage"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer, maxReceive: integer, maxExtract: integer, autoOutput: integer): void
public "attachCustomCapability"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capability: $BlockCapability$$Type<(never), (never)>, dataFactory: $Supplier$$Type<(never)>): void
}
export type AttachmentMap = {"kubejs:inventory": $InventoryAttachment$Factory$$Type;
"kubejs:custom_capability": $CustomCapabilityAttachment$Factory$$Type;
"kubejs:energy_storage": $EnergyStorageAttachment$Factory$$Type;
"kubejs:fluid_tank": $FluidTankAttachment$Factory$$Type};
export type Attachments = keyof AttachmentMap;
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityInfo$$Type = ($BlockEntityInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityInfo$$Original = $BlockEntityInfo;}
declare module "dev.latvian.mods.kubejs.recipe.AfterRecipesLoadedKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$RecipeFilter$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeFilter"
import {$ReloadableServerResources$$Type} from "net.minecraft.server.ReloadableServerResources"
import {$RecipeLikeKJS$$Type} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $AfterRecipesLoadedKubeEvent implements $KubeEvent$$Interface {
constructor(resources: $ReloadableServerResources$$Type)

public "remove"(filter: $RecipeFilter$$Type): integer
public "countRecipes"(filter: $RecipeFilter$$Type): integer
public "forEachRecipe"(filter: $RecipeFilter$$Type, consumer: $Consumer$$Type<($RecipeLikeKJS)>): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterRecipesLoadedKubeEvent$$Type = ($AfterRecipesLoadedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AfterRecipesLoadedKubeEvent$$Original = $AfterRecipesLoadedKubeEvent;}
declare module "dev.latvian.mods.kubejs.misc.ParticleTypeBuilder" {
import {$StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ParticleType} from "net.minecraft.core.particles.ParticleType"
import {$Registry} from "net.minecraft.core.Registry"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

export class $ParticleTypeBuilder extends $BuilderBase<($ParticleType<(never)>)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "overrideLimiter"(o: boolean): this
public "textures"(textures: $List$$Type<(StringJS)>): this
public "texture"(texture: StringJS): this
public "codec"(c: $MapCodec$$Type<($ParticleOptions$$Type)>): this
public "streamCodec"(s: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), ($ParticleOptions$$Type)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleTypeBuilder$$Type = ($ParticleTypeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ParticleTypeBuilder$$Original = $ParticleTypeBuilder;}
declare module "dev.latvian.mods.kubejs.script.ScriptPackInfo" {
import {$ScriptFileInfo} from "dev.latvian.mods.kubejs.script.ScriptFileInfo"
import {$List} from "java.util.List"
import {$Component} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptPackInfo {
readonly "displayName": $Component
readonly "namespace": StringJS
readonly "pathStart": StringJS
readonly "scripts": $List<($ScriptFileInfo)>

constructor(n: StringJS, p: StringJS)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptPackInfo$$Type = ($ScriptPackInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptPackInfo$$Original = $ScriptPackInfo;}
declare module "dev.latvian.mods.kubejs.event.IEventHandler" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $IEventHandler$$Interface {

(event: $KubeEvent): any
}

export class $IEventHandler implements $IEventHandler$$Interface {
 "onEvent"(event: $KubeEvent$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEventHandler$$Type = ((event: $KubeEvent) => any);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IEventHandler$$Original = $IEventHandler;}
declare module "dev.latvian.mods.kubejs.server.CommandKubeEvent" {
import {$ParseResults, $ParseResults$$Type} from "com.mojang.brigadier.ParseResults"
import {$CommandEvent$$Type} from "net.neoforged.neoforge.event.CommandEvent"
import {$Throwable, $Throwable$$Type} from "java.lang.Throwable"
import {$ServerKubeEvent} from "dev.latvian.mods.kubejs.server.ServerKubeEvent"
import {$CommandSourceStack, $CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"

export class $CommandKubeEvent extends $ServerKubeEvent {
readonly "server": $MinecraftServer

constructor(event: $CommandEvent$$Type)

public "getInput"(): StringJS
public "getException"(): $Throwable
public "setException"(exception: $Throwable$$Type): void
public "getParseResults"(): $ParseResults<($CommandSourceStack)>
public "getCommandName"(): StringJS
public "setParseResults"(parse: $ParseResults$$Type<($CommandSourceStack$$Type)>): void
get "input"(): StringJS
get "exception"(): $Throwable
set "exception"(value: $Throwable$$Type)
get "parseResults"(): $ParseResults<($CommandSourceStack)>
get "commandName"(): StringJS
set "parseResults"(value: $ParseResults$$Type<($CommandSourceStack$$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandKubeEvent$$Type = ($CommandKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CommandKubeEvent$$Original = $CommandKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.entity.EnergyStorageAttachment$Factory" {
import {$BlockCapability} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockEntityAttachmentFactory$$Interface} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$List} from "java.util.List"
import {$BlockEntityAttachment} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record} from "java.lang.Record"

export class $EnergyStorageAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory$$Interface {
constructor(capacity: integer, maxReceive: (integer)?, maxExtract: (integer)?, autoOutput: (integer)?)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "create"(info: $BlockEntityAttachmentInfo$$Type, entity: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "capacity"(): integer
public "isTicking"(): boolean
public "getCapabilities"(): $List<($BlockCapability<(never), (never)>)>
public "autoOutput"(): $Optional<(integer)>
public "maxExtract"(): $Optional<(integer)>
public "maxReceive"(): $Optional<(integer)>
get "ticking"(): boolean
get "capabilities"(): $List<($BlockCapability<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyStorageAttachment$Factory$$Type = ({"capacity"?: integer, "autoOutput"?: (integer)?, "maxReceive"?: (integer)?, "maxExtract"?: (integer)?}) | ([capacity?: integer, autoOutput?: (integer)?, maxReceive?: (integer)?, maxExtract?: (integer)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EnergyStorageAttachment$Factory$$Original = $EnergyStorageAttachment$Factory;}
declare module "dev.latvian.mods.kubejs.player.EntityArrayList" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$ArrayList} from "java.util.ArrayList"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection$$Type} from "java.util.Collection"
import {$SequencedCollection} from "java.util.SequencedCollection"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$List, $List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MessageSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$EntitySelector$$Type} from "net.minecraft.commands.arguments.selector.EntitySelector"
import {$DataSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.DataSenderKJS"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $EntityArrayList extends $ArrayList<($Entity)> implements $MessageSenderKJS$$Interface, $DataSenderKJS$$Interface {
static readonly "ALWAYS_TRUE_PREDICATE": $Predicate<($Entity)>

constructor(size: integer)
/**
 * 
 * @deprecated
 */
constructor(level: $Level$$Type, entities: $Iterable$$Type<($Entity$$Type)>)
constructor(entities: $Iterable$$Type<($Entity$$Type)>)

public "kill"(): void
public "filter"(filterList: $List$$Type<($Predicate$$Type<($Entity$$Type)>)>): $EntityArrayList
public "getFirst"(): $Entity
public "filterType"(type: $EntityType$$Type<(never)>): $EntityArrayList
public "filterItems"(): $EntityArrayList
public "runCommand"(command: StringJS): void
public "getName"(): $Component
public "getDisplayName"(): $Component
public "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
public "setStatusMessage"(message: $Component$$Type): void
public "runCommandSilent"(command: StringJS): void
public "setActivePostShader"(id: $ResourceLocation$$Type): void
public "tell"(message: $Component$$Type): void
public "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
public "playSound"(id: $SoundEvent$$Type): void
public "filterPlayers"(): $EntityArrayList
public "addAllIterable"(entities: $Iterable$$Type<($Entity$$Type)>): void
public "filterSelector"(selector: $EntitySelector$$Type): $EntityArrayList
public "filterDistance"(x: double, y: double, z: double, distance: double): $EntityArrayList
public "filterDistance"(pos: $BlockPos$$Type, distance: double): $EntityArrayList
public "oneFilter"(filter: $Predicate$$Type<($Entity)>): $EntityArrayList
public "sendData"(channel: StringJS): void
public static "copyOf"<E>(arg0: $Collection$$Type<(E)>): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public "reversed"(): $SequencedCollection
public "containsAll"(arg0: $Collection$$Type<(never)>): boolean
get "first"(): $Entity
get "name"(): $Component
get "displayName"(): $Component
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityArrayList$$Type = ($EntityArrayList);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityArrayList$$Original = $EntityArrayList;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.CategoryData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$Record} from "java.lang.Record"

export class $CategoryData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($CategoryData)>

constructor(category: $ResourceLocation$$Type)
constructor(category: $ResourceLocation$$Type, removedRecipes: $List$$Type<($ResourceLocation$$Type)>)

public "lock"(): $CategoryData
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "category"(): $ResourceLocation
public "removedRecipes"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CategoryData$$Type = ({"removedRecipes"?: $List$$Type<($ResourceLocation$$Type)>, "category"?: $ResourceLocation$$Type}) | ([removedRecipes?: $List$$Type<($ResourceLocation$$Type)>, category?: $ResourceLocation$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CategoryData$$Original = $CategoryData;}
declare module "dev.latvian.mods.kubejs.client.AtlasSpriteRegistryKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $AtlasSpriteRegistryKubeEvent implements $KubeEvent$$Interface {
constructor(registry: $Consumer$$Type<($ResourceLocation)>)

public "register"(id: $ResourceLocation$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AtlasSpriteRegistryKubeEvent$$Type = ($AtlasSpriteRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AtlasSpriteRegistryKubeEvent$$Original = $AtlasSpriteRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent" {
import {$TinyMap} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$OpsContainer$$Type} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$CustomObjectRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent"
import {$RecipeComponent, $RecipeComponent$$Type, $RecipeComponent$$Interface} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeKey} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$CustomObjectRecipeComponent$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$RecipeComponentBuilder} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder"
import {$RecipeComponentType} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$Either, $Either$$Type} from "com.mojang.datafixers.util.Either"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$ListRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.ListRecipeComponent"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Record} from "java.lang.Record"

export class $EitherRecipeComponent<H, L> extends $Record implements $RecipeComponent$$Interface<($Either<(H), (L)>)> {
static readonly "TYPE": $RecipeComponentType<(never)>

constructor(left: $RecipeComponent$$Type<(H)>, right: $RecipeComponent$$Type<(L)>)
constructor(left: $RecipeComponent$$Type<(H)>, right: $RecipeComponent$$Type<(L)>, codec: $Codec$$Type<($Either$$Type<(H), (L)>)>, typeInfo: $TypeInfo$$Type)

public "type"(): $RecipeComponentType<(never)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "toString"(ops: $OpsContainer$$Type, value: $Either$$Type<(H), (L)>): StringJS
public "toString"(ops: $OpsContainer$$Type, value: any): StringJS
public "hashCode"(): integer
public "wrap"(cx: $RecipeScriptContext$$Type, from: any): $Either<(H), (L)>
public "replace"(cx: $RecipeScriptContext$$Type, original: $Either$$Type<(H), (L)>, match: $ReplacementMatchInfo$$Type, arg3: any): $Either<(H), (L)>
public "replace"(cx: $RecipeScriptContext$$Type, original: any, match: $ReplacementMatchInfo$$Type, arg3: any): any
public "matches"(cx: $RecipeMatchContext$$Type, value: any, match: $ReplacementMatchInfo$$Type): boolean
public "matches"(cx: $RecipeMatchContext$$Type, value: $Either$$Type<(H), (L)>, match: $ReplacementMatchInfo$$Type): boolean
public "validate"(ctx: $RecipeValidationContext$$Type, value: any): void
public "validate"(ctx: $RecipeValidationContext$$Type, value: $Either$$Type<(H), (L)>): void
public "typeInfo"(): $TypeInfo
public "spread"(value: any): $List
public "spread"(value: $Either$$Type<(H), (L)>): $List<(never)>
public "left"(): $RecipeComponent<(H)>
public "right"(): $RecipeComponent<(L)>
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, value: $Either$$Type<(H), (L)>): void
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, value: any): void
public "codec"(): $Codec<($Either<(H), (L)>)>
public "isEmpty"(value: $Either$$Type<(H), (L)>): boolean
public static "builder"(keys: $List$$Type<($CustomObjectRecipeComponent$Key$$Type)>): $CustomObjectRecipeComponent
public static "builder"(...keys: ($CustomObjectRecipeComponent$Key$$Type)[]): $CustomObjectRecipeComponent
public "key"(name: StringJS, role: $ComponentRole$$Type): $RecipeKey<($Either<(H), (L)>)>
public "asList"(): $ListRecipeComponent<($Either<(H), (L)>)>
public "or"<O>(other: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<($Either<(H), (L)>), (O)>
public "readFromJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($Either$$Type<(H), (L)>)>, json: $JsonObject$$Type): void
public "asListOrSelf"(): $ListRecipeComponent<($Either<(H), (L)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($Either<(H), (L)>)>)>
public "asConditionalList"(): $ListRecipeComponent<($Either<(H), (L)>)>
public "writeToJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($Either$$Type<(H), (L)>)>, json: $JsonObject$$Type): void
public "isIgnored"(): boolean
public "otherKey"(name: StringJS): $RecipeKey<($Either<(H), (L)>)>
public "createBuilder"(): $RecipeComponentBuilder
public "inputKey"(name: StringJS): $RecipeKey<($Either<(H), (L)>)>
public "asMap"<K>(key: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($Either<(H), (L)>)>)>
public "orSelf"(): $RecipeComponent<($Either<(H), (L)>)>
public "allowEmpty"(): boolean
public "asConditionalListOrSelf"(): $ListRecipeComponent<($Either<(H), (L)>)>
public "withCodec"(codec: $Codec$$Type<($Either$$Type<(H), (L)>)>): $RecipeComponent<($Either<(H), (L)>)>
public "outputKey"(name: StringJS): $RecipeKey<($Either<(H), (L)>)>
public "hasPriority"(cx: $RecipeMatchContext$$Type, from: any): boolean
get "ignored"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EitherRecipeComponent$$Type<H, L> = ({"typeInfo"?: $TypeInfo$$Type, "left"?: $RecipeComponent$$Type<(H)>, "codec"?: $Codec$$Type<($Either$$Type<(H), (L)>)>, "right"?: $RecipeComponent$$Type<(L)>}) | ([typeInfo?: $TypeInfo$$Type, left?: $RecipeComponent$$Type<(H)>, codec?: $Codec$$Type<($Either$$Type<(H), (L)>)>, right?: $RecipeComponent$$Type<(L)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EitherRecipeComponent$$Original<H, L> = $EitherRecipeComponent<(H), (L)>;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.BuildingMaterialProperties" {
import {$BuildingMaterialProperties$Blocks, $BuildingMaterialProperties$Blocks$$Type} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.BuildingMaterialProperties$Blocks"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$BlockSetType, $BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$TickDuration, $TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $BuildingMaterialProperties extends $Record {
static readonly "TYPE_INFO": $TypeInfo

constructor(blocks: $BuildingMaterialProperties$Blocks$$Type, baseBlock: (boolean)?, baseBlockSuffix: (boolean)?, properties: $Consumer$$Type<($BlockBuilder)>, behaviour: ($BlockSetType$$Type)?, ticksToStayPressed: ($TickDuration$$Type)?)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "properties"(): $Consumer<($BlockBuilder)>
public "ticksToStayPressed"(): $Optional<($TickDuration)>
public "baseBlock"(): $Optional<(boolean)>
public "blocks"(): $BuildingMaterialProperties$Blocks
public "behaviour"(): $Optional<($BlockSetType)>
public "baseBlockSuffix"(): $Optional<(boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuildingMaterialProperties$$Type = ({"behaviour"?: ($BlockSetType$$Type)?, "baseBlock"?: (boolean)?, "properties"?: $Consumer$$Type<($BlockBuilder$$Type)>, "blocks"?: $BuildingMaterialProperties$Blocks$$Type, "baseBlockSuffix"?: (boolean)?, "ticksToStayPressed"?: ($TickDuration$$Type)?}) | ([behaviour?: ($BlockSetType$$Type)?, baseBlock?: (boolean)?, properties?: $Consumer$$Type<($BlockBuilder$$Type)>, blocks?: $BuildingMaterialProperties$Blocks$$Type, baseBlockSuffix?: (boolean)?, ticksToStayPressed?: ($TickDuration$$Type)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BuildingMaterialProperties$$Original = $BuildingMaterialProperties;}
declare module "dev.latvian.mods.kubejs.core.BlockStateKJS" {
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$List} from "java.util.List"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$RelativeURL} from "dev.latvian.mods.kubejs.web.RelativeURL"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Holder} from "net.minecraft.core.Holder"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $BlockStateKJS$$Interface extends $RegistryObjectKJS$$Interface<($Block)>, $Replaceable$$Interface {
get "id"(): StringJS
get "key"(): $ResourceKey<($Block)>
get "registry"(): $Registry<($Block)>
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
set "lightEmission"(value: integer)
set "requiresTool"(value: boolean)
set "destroySpeed"(value: float)
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $BlockStateKJS implements $BlockStateKJS$$Interface {
 "toString"(): StringJS
 "getWebIconURL"(size: integer): $RelativeURL
 "randomTickOverride"(state: $BlockState$$Type, level: $ServerLevel$$Type, pos: $BlockPos$$Type, random: $RandomSource$$Type): boolean
 "getId"(): StringJS
 "getKey"(): $ResourceKey<($Block)>
 "asHolder"(): $Holder<($Block)>
 "getRegistry"(): $Registry<($Block)>
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "setLightEmission"(v: integer): void
 "setRequiresTool"(v: boolean): void
 "setDestroySpeed"(v: float): void
 "specialEquals"(o: any, shallow: boolean): boolean
 "getMod"(): StringJS
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getIdLocation"(): $ResourceLocation
 "getTagKeys"(): $List<($TagKey<($Block)>)>
 "getTags"(): $List<($ResourceLocation)>
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateKJS$$Type = ($BlockStateKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateKJS$$Original = $BlockStateKJS;}
declare module "dev.latvian.mods.kubejs.block.custom.FenceGateBlockBuilder" {
import {$WoodType$$Type} from "net.minecraft.world.level.block.state.properties.WoodType"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $FenceGateBlockBuilder extends $ShapedBlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "FENCE_GATE_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "behaviour"(wt: $WoodType$$Type): this
public "behaviour"(wt: StringJS): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FenceGateBlockBuilder$$Type = ($FenceGateBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FenceGateBlockBuilder$$Original = $FenceGateBlockBuilder;}
declare module "dev.latvian.mods.kubejs.client.ClientPlayerKubeEvent" {
import {$LocalPlayer, $LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $ClientPlayerKubeEvent implements $KubePlayerEvent$$Interface, $ClientKubeEvent$$Interface {
constructor(player: $LocalPlayer$$Type)

public "getEntity"(): $Entity
public "getPlayer"(): $LocalPlayer
public "getClient"(): $Minecraft
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
get "entity"(): $Entity
get "player"(): $LocalPlayer
get "client"(): $Minecraft
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPlayerKubeEvent$$Type = ($ClientPlayerKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientPlayerKubeEvent$$Original = $ClientPlayerKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.CreativeModeTabKJS" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Component$$Type} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $CreativeModeTabKJS$$Interface {
}

export class $CreativeModeTabKJS implements $CreativeModeTabKJS$$Interface {
 "kjs$setDisplayName"(component: $Component$$Type): void
 "kjs$setIcon"(icon: $ItemStack$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeModeTabKJS$$Type = ($CreativeModeTabKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeModeTabKJS$$Original = $CreativeModeTabKJS;}
declare module "dev.latvian.mods.kubejs.block.callback.EntitySteppedOnBlockCallback" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EntitySteppedOnBlockCallback {
constructor(level: $Level$$Type, entity: $Entity$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

/**
 * Returns the BlockState
 */
public "getState"(): $BlockState
/**
 * Returns the level
 */
public "getLevel"(): $Level
/**
 * Returns the block's position
 */
public "getPos"(): $BlockPos
/**
 * Returns if the entity is suppressing bouncing (for players this is true if the player is crouching)
 */
public "isSuppressingBounce"(): boolean
/**
 * Returns the block
 */
public "getBlock"(): $LevelBlock
/**
 * Returns the entity
 */
public "getEntity"(): $Entity
get "state"(): $BlockState
get "level"(): $Level
get "pos"(): $BlockPos
get "suppressingBounce"(): boolean
get "block"(): $LevelBlock
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySteppedOnBlockCallback$$Type = ($EntitySteppedOnBlockCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntitySteppedOnBlockCallback$$Original = $EntitySteppedOnBlockCallback;}
declare module "dev.latvian.mods.kubejs.block.callback.BlockExplodedCallback" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Explosion, $Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockExplodedCallback {
constructor(level: $Level$$Type, pos: $BlockPos$$Type, explosion: $Explosion$$Type)

public "getCause"(): $Entity
public "getLevel"(): $Level
public "getBlock"(): $LevelBlock
public "getBlockState"(): $BlockState
public "getExplosion"(): $Explosion
public "getRadius"(): float
public "getIgniter"(): $LivingEntity
public "getAffectedPlayers"(): $List<($Player)>
get "cause"(): $Entity
get "level"(): $Level
get "block"(): $LevelBlock
get "blockState"(): $BlockState
get "explosion"(): $Explosion
get "radius"(): float
get "igniter"(): $LivingEntity
get "affectedPlayers"(): $List<($Player)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockExplodedCallback$$Type = ($BlockExplodedCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockExplodedCallback$$Original = $BlockExplodedCallback;}
declare module "dev.latvian.mods.kubejs.block.DetectorBlockKubeEvent" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a detector block registered in KubeJS receives a block update.
 * 
 * `Powered`/`Unpowered` event will be fired when the detector block is powered/unpowered.
 */
export class $DetectorBlockKubeEvent implements $KubeLevelEvent$$Interface {
constructor(i: StringJS, l: $Level$$Type, p: $BlockPos$$Type, pow: boolean)

/**
 * The level where the detector block is located.
 */
public "getLevel"(): $Level
/**
 * The detector block.
 */
public "getBlock"(): $LevelBlock
/**
 * If the detector block is powered.
 */
public "isPowered"(): boolean
/**
 * The id of the detector block when it was registered.
 */
public "getDetectorId"(): StringJS
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "block"(): $LevelBlock
get "powered"(): boolean
get "detectorId"(): StringJS
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DetectorBlockKubeEvent$$Type = ($DetectorBlockKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DetectorBlockKubeEvent$$Original = $DetectorBlockKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.DebugInfoKubeEvent" {
import {$LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$List, $List$$Type} from "java.util.List"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$ClientPlayerKubeEvent} from "dev.latvian.mods.kubejs.client.ClientPlayerKubeEvent"

/**
 * Invoked when the debug info is rendered.
 */
export class $DebugInfoKubeEvent extends $ClientPlayerKubeEvent {
constructor(player: $LocalPlayer$$Type, l: $List$$Type<(StringJS)>)

/**
 * The lines of debug info. Mutating this list will change the debug info.
 */
public "getLines"(): $List<(StringJS)>
/**
 * Whether the debug info should be rendered.
 */
public "getShowDebug"(): boolean
public "getEntity"(): $Entity
get "lines"(): $List<(StringJS)>
get "showDebug"(): boolean
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DebugInfoKubeEvent$$Type = ($DebugInfoKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DebugInfoKubeEvent$$Original = $DebugInfoKubeEvent;}
declare module "dev.latvian.mods.kubejs.event.EventTargetType$Transformer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $EventTargetType$Transformer$$Interface {

(source: any): any
}

export class $EventTargetType$Transformer implements $EventTargetType$Transformer$$Interface {
static readonly "IDENTITY": $EventTargetType$Transformer

 "transform"(source: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventTargetType$Transformer$$Type = ((source: any) => any);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventTargetType$Transformer$$Original = $EventTargetType$Transformer;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RemoveEntriesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $RemoveEntriesKubeEvent$$Interface<E, F> extends $KubeEvent$$Interface {

(filter: F): void
}

export class $RemoveEntriesKubeEvent<E, F> implements $RemoveEntriesKubeEvent$$Interface {
 "remove"(filter: F): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveEntriesKubeEvent$$Type<E, F> = ((filter: any) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RemoveEntriesKubeEvent$$Original<E, F> = $RemoveEntriesKubeEvent<(E), (F)>;}
declare module "dev.latvian.mods.kubejs.event.EventResult$Type" {
import {$Enum} from "java.lang.Enum"
import {$EventExit} from "dev.latvian.mods.kubejs.event.EventExit"

export class $EventResult$Type extends $Enum<($EventResult$Type)> {
static readonly "INTERRUPT_TRUE": $EventResult$Type
static readonly "PASS": $EventResult$Type
static readonly "INTERRUPT_FALSE": $EventResult$Type
static readonly "INTERRUPT_DEFAULT": $EventResult$Type
static readonly "ERROR": $EventResult$Type

public "exit"(value: any): $EventExit
public static "values"(): ($EventResult$Type)[]
public static "valueOf"(name: StringJS): $EventResult$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventResult$Type$$Type = (("error") | ("pass") | ("interrupt_default") | ("interrupt_false") | ("interrupt_true"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventResult$Type$$Original = $EventResult$Type;}
declare module "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch" {
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"

export interface $ReplacementMatch$$Interface {
}

export class $ReplacementMatch implements $ReplacementMatch$$Interface {
static readonly "NONE": $ReplacementMatch

static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplacementMatch$$Type = ($Ingredient$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReplacementMatch$$Original = $ReplacementMatch;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ItemTintFunction$$Type} from "dev.latvian.mods.kubejs.item.ItemTintFunction"
import {$JukeboxSong$$Type} from "net.minecraft.world.item.JukeboxSong"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$ItemBuilder$ReleaseUsingCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$ReleaseUsingCallback"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Function$$Type} from "java.util.function.Function"
import {$Item$Properties} from "net.minecraft.world.item.Item$Properties"
import {$ItemBuilder$HurtEnemyContext$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$HurtEnemyContext"
import {$FoodBuilder$$Type} from "dev.latvian.mods.kubejs.item.FoodBuilder"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ItemBuilder$FinishUsingCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$FinishUsingCallback"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ItemBuilder$NameCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$NameCallback"
import {$Collection$$Type} from "java.util.Collection"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$ToIntBiFunction$$Type} from "java.util.function.ToIntBiFunction"
import {$ModelledBuilderBase} from "dev.latvian.mods.kubejs.registry.ModelledBuilderBase"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$UseAnim$$Type} from "net.minecraft.world.item.UseAnim"
import {$ItemBuilder$UseCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$UseCallback"
import {$Registry} from "net.minecraft.core.Registry"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export class $ItemBuilder extends $ModelledBuilderBase<($Item)> {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

/**
 * Sets the item's name dynamically.
 */
public "name"(name: $ItemBuilder$NameCallback$$Type): this
/**
 * 
 * @deprecated
 */
public "group"(g: StringJS): this
public "component"<T>(type: $DataComponentType$$Type<(T)>, value: T): this
/**
 * Determines if player will start using the item.
 * 
 * For example, when eating food, returning true will make the player start eating the food.
 */
public "use"(use: $ItemBuilder$UseCallback$$Type): this
/**
 * Colorizes item's texture of the given index. Index is used when you have multiple layers, e.g. a crushed ore (of rock + ore).
 */
public "color"(index: integer, color: $ItemTintFunction$$Type): this
/**
 * Colorizes item's texture of the given index. Useful for coloring items, like GT ores ore dusts.
 */
public "color"(callback: $ItemTintFunction$$Type): this
/**
 * Sets the item's max stack size. Default is 64.
 */
public "maxStackSize"(v: integer): this
public "createItemProperties"(): $Item$Properties
/**
 * The duration when the item is used.
 * 
 * For example, when eating food, this is the time it takes to eat the food.
 * This can change the eating speed, or be used for other things (like making a custom bow).
 */
public "useDuration"(useDuration: $ToIntBiFunction$$Type<($ItemStack), ($LivingEntity)>): this
/**
 * Makes the item fire resistant like netherite tools.
 */
public "fireResistant"(): this
/**
 * Makes the item fire resistant like netherite tools (or not).
 */
public "fireResistant"(isFireResistant: boolean): this
public "jukeboxPlayable"(song: $ResourceKey$$Type<($JukeboxSong)>): this
public "jukeboxPlayable"(song: $ResourceKey$$Type<($JukeboxSong)>, showInTooltip: boolean): this
/**
 * Adds subtypes to the item. The function should return a collection of item stacks, each with a different subtype.
 * 
 * Each subtype will appear as a separate item in JEI and the creative inventory.
 */
public "subtypes"(fn: $Function$$Type<($ItemStack), ($Collection$$Type<($ItemStack$$Type)>)>): this
/**
 * Sets the item's max damage. Default is 0 (No durability).
 */
public "maxDamage"(v: integer): this
/**
 * Sets the item's rarity.
 */
public "rarity"(v: $Rarity$$Type): this
/**
 * Gets called when the item is used to hurt an entity.
 * 
 * For example, when using a sword to hit a mob, this is called.
 */
public "hurtEnemy"(context: $Predicate$$Type<($ItemBuilder$HurtEnemyContext)>): this
/**
 * Set the food nutrition and saturation of the item.
 */
public "food"(nutrition: integer, saturation: float): this
/**
 * Set the food properties of the item.
 */
public "food"(b: $Consumer$$Type<($FoodBuilder)>): this
/**
 * When players finish using the item.
 * 
 * This is called only when `useDuration` ticks have passed.
 * 
 * For example, when eating food, this is called when the player has finished eating the food, so hunger is restored.
 */
public "finishUsing"(finishUsing: $ItemBuilder$FinishUsingCallback$$Type): this
/**
 * Makes the item glow like enchanted, even if it's not enchanted.
 */
public "glow"(v: boolean): this
/**
 * Determines the color of the item's durability bar. Defaulted to vanilla behavior.
 */
public "barColor"(barColor: $Function$$Type<($ItemStack), ($KubeColor$$Type)>): this
/**
 * Sets the item's burn time. Default is 0 (Not a fuel).
 */
public "burnTime"(v: $TickDuration$$Type): this
/**
 * Determines the width of the item's durability bar. Defaulted to vanilla behavior.
 * 
 * The function should return a value between 0 and 13 (max width of the bar).
 */
public "barWidth"(barWidth: $ToIntFunction$$Type<($ItemStack)>): this
/**
 * When players did not finish using the item but released the right mouse button halfway through.
 * 
 * An example is the bow, where the arrow is shot when the player releases the right mouse button.
 * 
 * To ensure the bow won't finish using, Minecraft sets the `useDuration` to a very high number (1h).
 */
public "releaseUsing"(releaseUsing: $ItemBuilder$ReleaseUsingCallback$$Type): this
/**
 * Adds a tooltip to the item.
 */
public "tooltip"(text: $Component$$Type): this
/**
 * Sets the item's container item, e.g. a bucket for a milk bucket.
 */
public "containerItem"(id: $ResourceLocation$$Type): this
public "transformObject"(obj: $Item$$Type): $Item
public "disableRepair"(): this
/**
 * Determines the animation of the item when used, e.g. eating food.
 */
public "useAnimation"(animation: $UseAnim$$Type): this
/**
 * Makes the item not stackable, equivalent to setting the item's max stack size to 1.
 */
public "unstackable"(): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$$Type = ($ItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$$Original = $ItemBuilder;}
declare module "dev.latvian.mods.kubejs.util.MobEffectUtil" {
import {$MobEffectInstance, $MobEffectInstance$$Type} from "net.minecraft.world.effect.MobEffectInstance"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"

export class $MobEffectUtil {
constructor()

/**
 * Creates an instance for the given effect, duration and amplifier
 */
public static "of"(effect: $Holder$$Type<($MobEffect)>, duration: $TickDuration$$Type, amplifier: integer): $MobEffectInstance
/**
 * Creates an instance for the given effect, duration, amplifier, ambient, and visible to the HUD
 */
public static "of"(effect: $Holder$$Type<($MobEffect)>, duration: $TickDuration$$Type, amplifier: integer, ambient: boolean, visible: boolean): $MobEffectInstance
/**
 * Creates an instance for the given effect, duration, amplifier, ambient, visible to the HUD, and to show the icon on the sceen
 */
public static "of"(effect: $Holder$$Type<($MobEffect)>, duration: $TickDuration$$Type, amplifier: integer, ambient: boolean, visible: boolean, showIcon: boolean): $MobEffectInstance
/**
 * Creates an instance for the given effect and duration (in ticks)
 */
public static "of"(effect: $Holder$$Type<($MobEffect)>, duration: $TickDuration$$Type): $MobEffectInstance
/**
 * Creates an instance for the given effect. Default duration and amplifier is 0
 */
public static "of"(effect: $Holder$$Type<($MobEffect)>): $MobEffectInstance
/**
 * Copies an existing MobEffectInstance
 */
public static "of"(oldInstance: $MobEffectInstance$$Type): $MobEffectInstance
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectUtil$$Type = ($MobEffectUtil);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobEffectUtil$$Original = $MobEffectUtil;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$RegistryOps$$Type} from "net.minecraft.resources.RegistryOps"
import {$SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$KubeRecipeFactory, $KubeRecipeFactory$$Type} from "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory"
import {$RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RecipePostProcessor, $RecipePostProcessor$$Type} from "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessor"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$RecipeConstructor, $RecipeConstructor$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeConstructor"
import {$RecipeFunctionInstance, $RecipeFunctionInstance$$Type} from "dev.latvian.mods.kubejs.recipe.schema.function.RecipeFunctionInstance"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$RecipeOptional, $RecipeOptional$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Int2ObjectMap} from "it.unimi.dsi.fastutil.ints.Int2ObjectMap"

export class $RecipeSchema {
readonly "functions": $Map<(StringJS), ($RecipeFunctionInstance)>
 "recipeFactory": $KubeRecipeFactory
readonly "keys": $List<($RecipeKey<(never)>)>
readonly "keyOverrides": $Map<($RecipeKey<(never)>), ($RecipeOptional<(never)>)>
readonly "includedKeys": $List<($RecipeKey<(never)>)>

constructor(keyOverrides: $Map$$Type<($RecipeKey$$Type<(never)>), ($RecipeOptional$$Type<(never)>)>, keys: $List$$Type<($RecipeKey$$Type<(never)>)>)
constructor(...keys: ($RecipeKey$$Type<(never)>)[])

public "isHidden"(): boolean
public "getKey"<T>(id: StringJS): $RecipeKey<(T)>
public "factory"(factory: $KubeRecipeFactory$$Type): $RecipeSchema
public "addConstructor"(...keys: ($RecipeKey$$Type<(never)>)[]): $RecipeSchema
public "constructor"(arg0: $RecipeConstructor$$Type): $RecipeSchema
public "constructors"(): $Int2ObjectMap<($RecipeConstructor)>
public "function"(arg0: $RecipeFunctionInstance$$Type): $RecipeSchema
public "uniqueId"(key: $RecipeKey$$Type<(never)>): $RecipeSchema
public "typeOverride"(id: $ResourceLocation$$Type): $RecipeSchema
public "buildUniqueId"(r: $KubeRecipe$$Type): StringJS
public "setOpFunction"<T>(name: StringJS, key: $RecipeKey$$Type<(T)>, value: T): $RecipeSchema
public "getOptionalKey"<T>(id: StringJS): $RecipeKey<(T)>
public "postProcessor"(processor: $RecipePostProcessor$$Type): $RecipeSchema
public "toJson"(storage: $RecipeSchemaStorage$$Type, schemaType: $RecipeSchemaType$$Type, ops: $RegistryOps$$Type<($JsonElement$$Type)>): $JsonObject
public "deserialize"(sourceLine: $SourceLine$$Type, type: $RecipeTypeFunction$$Type, id: $ResourceLocation$$Type, json: $JsonObject$$Type): $KubeRecipe
public "postProcessors"(): $List<($RecipePostProcessor)>
public "uniqueIds"(keys: $SequencedCollection$$Type<($RecipeKey$$Type<(never)>)>): $RecipeSchema
public "uniqueIds"(): $List<($RecipeKey<(never)>)>
public "outputCount"(): integer
public "minRequiredArguments"(): integer
public "constructorsGenerated"(): boolean
public "addToListOpFunction"<T>(name: StringJS, key: $RecipeKey$$Type<($List$$Type<(T)>)>): $RecipeSchema
public "inputCount"(): integer
get "hidden"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchema$$Type = ($RecipeSchema);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeSchema$$Original = $RecipeSchema;}
declare module "dev.latvian.mods.kubejs.player.PlayerRespawnedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player respawns.
 * 
 * The reason of respawn can be either death or returning from the end.
 */
export class $PlayerRespawnedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $ServerPlayer$$Type, endConquered: boolean)

/**
 * Gets the player that respawned.
 */
public "getEntity"(): $Player
public "isEndConquered"(): boolean
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "entity"(): $Player
get "endConquered"(): boolean
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerRespawnedKubeEvent$$Type = ($PlayerRespawnedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerRespawnedKubeEvent$$Original = $PlayerRespawnedKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.custom.PressurePlateBlockBuilder" {
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$Consumer} from "java.util.function.Consumer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ButtonOrPressurePlateBuilder$$Interface} from "dev.latvian.mods.kubejs.block.custom.ButtonOrPressurePlateBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"

export class $PressurePlateBlockBuilder extends $ShapedBlockBuilder implements $ButtonOrPressurePlateBuilder$$Interface {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
static readonly "PRESSURE_PLATE_TAGS": ($ResourceLocation)[]
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "ticksToStayPressed"(ticks: $TickDuration$$Type): $BlockBuilder
public "behaviour"(behaviour: $BlockSetType$$Type): $BlockBuilder
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressurePlateBlockBuilder$$Type = ($PressurePlateBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PressurePlateBlockBuilder$$Original = $PressurePlateBlockBuilder;}
declare module "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer$ShaderChain" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$PostChain, $PostChain$$Type} from "net.minecraft.client.renderer.PostChain"
import {$Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$MutableBoolean, $MutableBoolean$$Type} from "org.apache.commons.lang3.mutable.MutableBoolean"
import {$RenderTarget, $RenderTarget$$Type} from "com.mojang.blaze3d.pipeline.RenderTarget"
import {$Record} from "java.lang.Record"

export class $HighlightRenderer$ShaderChain extends $Record {
constructor(postChain: $PostChain$$Type, renderInput: $RenderTarget$$Type, mcDepthInput: $RenderTarget$$Type, renderOutput: $RenderTarget$$Type, renderAnything: $MutableBoolean$$Type)

public "renderInput"(): $RenderTarget
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "load"(mc: $Minecraft$$Type, id: $ResourceLocation$$Type): $HighlightRenderer$ShaderChain
public "close"(): void
public "clearDepth"(mc: $Minecraft$$Type, copy: boolean): void
public "draw"(mc: $Minecraft$$Type, delta: float): void
public "postChain"(): $PostChain
public "clearInput"(mc: $Minecraft$$Type): void
public "renderAnything"(): $MutableBoolean
public "renderOutput"(): $RenderTarget
public "mcDepthInput"(): $RenderTarget
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HighlightRenderer$ShaderChain$$Type = ({"renderAnything"?: $MutableBoolean$$Type, "postChain"?: $PostChain$$Type, "renderOutput"?: $RenderTarget$$Type, "mcDepthInput"?: $RenderTarget$$Type, "renderInput"?: $RenderTarget$$Type}) | ([renderAnything?: $MutableBoolean$$Type, postChain?: $PostChain$$Type, renderOutput?: $RenderTarget$$Type, mcDepthInput?: $RenderTarget$$Type, renderInput?: $RenderTarget$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HighlightRenderer$ShaderChain$$Original = $HighlightRenderer$ShaderChain;}
declare module "dev.latvian.mods.kubejs.text.action.TextActionBuilder" {
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"

export class $TextActionBuilder {
constructor()

public "insert"(line: integer, text: $List$$Type<($Component$$Type)>): void
public "clear"(): void
public "add"(text: $List$$Type<($Component$$Type)>): void
public "dynamic"(id: StringJS): void
public "removeLine"(line: integer): void
public "removeText"(match: $Component$$Type): void
public "removeExactText"(match: $Component$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextActionBuilder$$Type = ($TextActionBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TextActionBuilder$$Original = $TextActionBuilder;}
declare module "dev.latvian.mods.kubejs.server.tag.PreTagWrapper" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$List} from "java.util.List"
import {$PreTagKubeEvent, $PreTagKubeEvent$$Type} from "dev.latvian.mods.kubejs.server.tag.PreTagKubeEvent"
import {$TagLoader$EntryWithSource} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$TagKubeEvent} from "dev.latvian.mods.kubejs.server.tag.TagKubeEvent"
import {$TagWrapper} from "dev.latvian.mods.kubejs.server.tag.TagWrapper"

export class $PreTagWrapper extends $TagWrapper {
readonly "preEvent": $PreTagKubeEvent
readonly "entries": $List<($TagLoader$EntryWithSource)>
readonly "id": $ResourceLocation
readonly "event": $TagKubeEvent

constructor(e: $PreTagKubeEvent$$Type, i: $ResourceLocation$$Type)

public "remove"(...filters: (any)[]): $TagWrapper
public "add"(...filters: (any)[]): $TagWrapper
public "removeAll"(): $TagWrapper
public "getObjectIds"(): $List<($ResourceLocation)>
get "objectIds"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PreTagWrapper$$Type = ($PreTagWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PreTagWrapper$$Original = $PreTagWrapper;}
declare module "dev.latvian.mods.kubejs.misc.SoundEventBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$SoundsGenerator$SoundGen$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundGen"

export class $SoundEventBuilder extends $BuilderBase<($SoundEvent)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "sounds"(gen: $Consumer$$Type<($SoundsGenerator$SoundGen)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundEventBuilder$$Type = ($SoundEventBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoundEventBuilder$$Original = $SoundEventBuilder;}
declare module "dev.latvian.mods.kubejs.item.ItemModificationKubeEvent$ItemModifications" {
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ComponentFunctions} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$UUID$$Type} from "java.util.UUID"
import {$EquipmentSlotGroup$$Type} from "net.minecraft.world.entity.EquipmentSlotGroup"
import {$List$$Type} from "java.util.List"
import {$ItemAttributeModifiers} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$FireworkExplosion$$Type} from "net.minecraft.world.item.component.FireworkExplosion"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$MutableToolTier$$Type} from "dev.latvian.mods.kubejs.item.MutableToolTier"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$AttributeModifier, $AttributeModifier$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map$$Type} from "java.util.Map"
import {$Instrument$$Type} from "net.minecraft.world.item.Instrument"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Tool$$Type} from "net.minecraft.world.item.component.Tool"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$ItemComponentFunctions$$Interface} from "dev.latvian.mods.kubejs.component.ItemComponentFunctions"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Record} from "java.lang.Record"
import {$Unit$$Type} from "net.minecraft.util.Unit"

export class $ItemModificationKubeEvent$ItemModifications extends $Record implements $ItemComponentFunctions$$Interface {
constructor(item: $Item$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "item"(): $Item
public "setBurnTime"(i: $TickDuration$$Type): void
public "setNameKey"(key: StringJS): void
public "getComponentMap"(): $DataComponentMap
public "setTier"(builder: $Consumer$$Type<($MutableToolTier)>): void
public "disableRepair"(): void
public "setCraftingRemainder"(item: $Item$$Type): void
public "setTool"(tool: $Tool$$Type): void
public "setInstrument"(instrument: $Holder$$Type<($Instrument)>): void
public "setRepairCost"(repairCost: integer): void
public "setFireworks"(fireworks: $Fireworks$$Type): void
public "setItemName"(component: $Component$$Type): void
public "setMaxDamage"(maxDamage: integer): void
public "setFood"(foodProperties: $FoodProperties$$Type): void
public "setFood"(nutrition: integer, saturation: float): void
public "setDamage"(damage: integer): void
public "setUnbreakable"(): void
public "setUnbreakableWithTooltip"(): void
public "setBucketEntityData"(tag: $CompoundTag$$Type): void
public "setChargedProjectiles"(items: $List$$Type<($ItemStack$$Type)>): void
public "setBundleContents"(items: $List$$Type<($ItemStack$$Type)>): void
public "setMapItemColor"(color: $KubeColor$$Type): void
public "setFireworkExplosion"(explosion: $FireworkExplosion$$Type): void
public "getAttributeModifiers"(): $ItemAttributeModifiers
public "setFireResistant"(): void
public "setBlockEntityData"(tag: $CompoundTag$$Type): void
public "setMaxStackSize"(size: integer): void
public "setNoteBlockSound"(id: $ResourceLocation$$Type): void
public "remove"(type: $DataComponentType$$Type<(never)>): $ComponentFunctions
public "get"<T>(type: $DataComponentType$$Type<(T)>): T
public "patch"(components: $DataComponentPatch$$Type): $ComponentFunctions
public "set"(components: $DataComponentMap$$Type): $ComponentFunctions
public "set"(component: $DataComponentType$$Type<(never)>, value: any): $ComponentFunctions
public "setLore"(lines: $List$$Type<($Component$$Type)>): void
public "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
public "setCustomData"(tag: $CompoundTag$$Type): void
public "setRarity"(rarity: $Rarity$$Type): void
public "setDyedColor"(color: $KubeColor$$Type): void
public "setCustomName"(name: $Component$$Type): void
public "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
public "getCustomName"(): $Component
public "getCustomData"(): $CompoundTag
public "setLockCode"(lock: StringJS): void
public "setProfile"(name: StringJS, uuid: $UUID$$Type): void
public "setProfile"(profile: $GameProfile$$Type): void
public "setBaseColor"(color: $DyeColor$$Type): void
public "setPotionId"(potion: $Holder$$Type<($Potion)>): void
public "setEntityData"(tag: $CompoundTag$$Type): void
public "setAdditionalTooltipHidden"(): void
public "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
public "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
public "setPotionContents"(contents: $PotionContents$$Type): void
public "getComponentString"(): StringJS
public "resetComponents"(): $ComponentFunctions
public "setTooltipHidden"(): void
public "setCustomModelData"(data: integer): void
public "setGlintOverride"(override: boolean): void
public "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
public "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
public "getAttackSpeed"(): double
/**
 * Sets the attack speed of this item to the given value, **removing** all other modifiers to attack speed.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 * (Example: Swords have an attack speed of -2.4, leading to a total value of 1.6 without any other changes.)
 */
public "setAttackSpeed"(speed: double): void
public "setAttributeModifiersWithTooltip"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Overrides the *base* attack damage of this item to be the given value, keeping other modifiers intact.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 */
public "setBaseAttackDamage"(dmg: double): void
public "getBaseAttackDamage"(): double
public "addAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, mod: $AttributeModifier$$Type, slot: $EquipmentSlotGroup$$Type): void
public "hasAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): boolean
/**
 * Sets the attack damage of this item to the given value, **removing** all other modifiers to attack damage.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 * (In practice, this simply means that most weapons have this value set to 1 less than what you might think.)
 */
public "setAttackDamage"(dmg: double): void
public "getAttackDamage"(): double
/**
 * Overrides the *base* attack speed of this item to be the given value, keeping other modifiers intact.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 */
public "setBaseAttackSpeed"(speed: double): void
public "getBaseAttackSpeed"(): double
public "getAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): $AttributeModifier
public "setAttributeModifiers"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
set "burnTime"(value: $TickDuration$$Type)
set "nameKey"(value: StringJS)
get "componentMap"(): $DataComponentMap
set "tier"(value: $Consumer$$Type<($MutableToolTier)>)
set "craftingRemainder"(value: $Item$$Type)
set "tool"(value: $Tool$$Type)
set "instrument"(value: $Holder$$Type<($Instrument)>)
set "repairCost"(value: integer)
set "fireworks"(value: $Fireworks$$Type)
set "itemName"(value: $Component$$Type)
set "maxDamage"(value: integer)
set "food"(value: $FoodProperties$$Type)
set "damage"(value: integer)
get "unbreakable"(): void
get "unbreakableWithTooltip"(): void
set "bucketEntityData"(value: $CompoundTag$$Type)
set "chargedProjectiles"(value: $List$$Type<($ItemStack$$Type)>)
set "bundleContents"(value: $List$$Type<($ItemStack$$Type)>)
set "mapItemColor"(value: $KubeColor$$Type)
set "fireworkExplosion"(value: $FireworkExplosion$$Type)
get "attributeModifiers"(): $ItemAttributeModifiers
get "fireResistant"(): void
set "blockEntityData"(value: $CompoundTag$$Type)
set "maxStackSize"(value: integer)
set "noteBlockSound"(value: $ResourceLocation$$Type)
set "lore"(value: $List$$Type<($Component$$Type)>)
set "customData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "dyedColor"(value: $KubeColor$$Type)
set "customName"(value: $Component$$Type)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
get "customName"(): $Component
get "customData"(): $CompoundTag
set "lockCode"(value: StringJS)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
get "additionalTooltipHidden"(): void
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
get "componentString"(): StringJS
get "tooltipHidden"(): void
set "customModelData"(value: integer)
set "glintOverride"(value: boolean)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
get "attackSpeed"(): double
set "attackSpeed"(value: double)
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "baseAttackDamage"(value: double)
get "baseAttackDamage"(): double
set "attackDamage"(value: double)
get "attackDamage"(): double
set "baseAttackSpeed"(value: double)
get "baseAttackSpeed"(): double
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModificationKubeEvent$ItemModifications$$Type = ({"item"?: $Item$$Type}) | ([item?: $Item$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemModificationKubeEvent$ItemModifications$$Original = $ItemModificationKubeEvent$ItemModifications;}
declare module "dev.latvian.mods.kubejs.script.data.ExportablePackResources" {
import {$PackLocationInfo} from "net.minecraft.server.packs.PackLocationInfo"
import {$KnownPack} from "net.minecraft.server.packs.repository.KnownPack"
import {$MetadataSectionSerializer$$Type} from "net.minecraft.server.packs.metadata.MetadataSectionSerializer"
import {$Optional} from "java.util.Optional"
import {$PackResources$$Interface} from "net.minecraft.server.packs.PackResources"
import {$IoSupplier} from "net.minecraft.server.packs.resources.IoSupplier"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$PackType$$Type} from "net.minecraft.server.packs.PackType"
import {$PackResources$ResourceOutput$$Type} from "net.minecraft.server.packs.PackResources$ResourceOutput"
import {$Set} from "java.util.Set"
import {$InputStream} from "java.io.InputStream"
import {$Path$$Type} from "java.nio.file.Path"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ExportablePackResources$$Interface extends $PackResources$$Interface {
get "hidden"(): boolean
}

export class $ExportablePackResources implements $ExportablePackResources$$Interface {
 "export"(root: $Path$$Type): void
 "exportPath"(): StringJS
 "getResource"(arg0: $PackType$$Type, arg1: $ResourceLocation$$Type): $IoSupplier<($InputStream)>
 "location"(): $PackLocationInfo
 "close"(): void
 "listResources"(arg0: $PackType$$Type, arg1: StringJS, arg2: StringJS, arg3: $PackResources$ResourceOutput$$Type): void
 "getNamespaces"(arg0: $PackType$$Type): $Set<(StringJS)>
 "getMetadataSection"<T>(arg0: $MetadataSectionSerializer$$Type<(T)>): T
 "knownPackInfo"(): $Optional<($KnownPack)>
 "getRootResource"(...arg0: (StringJS)[]): $IoSupplier<($InputStream)>
 "packId"(): StringJS
 "isHidden"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExportablePackResources$$Type = ($ExportablePackResources);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExportablePackResources$$Original = $ExportablePackResources;}
declare module "dev.latvian.mods.kubejs.core.InventoryKJS" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Container} from "net.minecraft.world.Container"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $InventoryKJS$$Interface {
get "empty"(): boolean
get "width"(): integer
get "height"(): integer
get "mutable"(): boolean
get "slots"(): integer
get "changed"(): void
get "allItems"(): $List<($ItemStack)>
}

export class $InventoryKJS implements $InventoryKJS$$Interface {
 "isEmpty"(): boolean
 "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
 "getWidth"(): integer
 "getHeight"(): integer
 "countNonEmpty"(): integer
 "countNonEmpty"(match: $ItemPredicate$$Type): integer
 "isMutable"(): boolean
 "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
 "getSlots"(): integer
 "getSlotLimit"(slot: integer): integer
 "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
 "setChanged"(): void
 "getAllItems"(): $List<($ItemStack)>
 "getStackInSlot"(slot: integer): $ItemStack
 "asContainer"(): $Container
 "clear"(): void
 "clear"(match: $ItemPredicate$$Type): void
 "find"(): integer
 "find"(match: $ItemPredicate$$Type): integer
 "count"(): integer
 "count"(match: $ItemPredicate$$Type): integer
 "getBlock"(level: $Level$$Type): $LevelBlock
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryKJS$$Type = ($InventoryKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InventoryKJS$$Original = $InventoryKJS;}
declare module "dev.latvian.mods.kubejs.util.NotificationToastData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$KubeIcon, $KubeIcon$$Type} from "dev.latvian.mods.kubejs.client.icon.KubeIcon"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Duration, $Duration$$Type} from "java.time.Duration"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $NotificationToastData extends $Record {
static readonly "CODEC": $MapCodec<($NotificationToastData)>
static readonly "DEFAULT_BORDER_COLOR": $KubeColor
static readonly "DEFAULT_BACKGROUND_COLOR": $KubeColor
static readonly "DEFAULT_DURATION": $Duration
static readonly "DEFAULT_OUTLINE_COLOR": $KubeColor
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($NotificationToastData)>

constructor(duration: $Duration$$Type, text: $Component$$Type, icon: ($KubeIcon$$Type)?, iconSize: integer, outlineColor: ($KubeColor$$Type)?, borderColor: ($KubeColor$$Type)?, backgroundColor: ($KubeColor$$Type)?, textShadow: boolean)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "duration"(): $Duration
public "text"(): $Component
public "borderColor"(): $Optional<($KubeColor)>
public static "ofText"(text: $Component$$Type): $NotificationToastData
public "iconSize"(): integer
public "backgroundColor"(): $Optional<($KubeColor)>
public "icon"(): $Optional<($KubeIcon)>
public static "ofTitle"(title: $Component$$Type, text: $Component$$Type): $NotificationToastData
public "textShadow"(): boolean
public "outlineColor"(): $Optional<($KubeColor)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotificationToastData$$Type = ({"borderColor"?: ($KubeColor$$Type)?, "backgroundColor"?: ($KubeColor$$Type)?, "duration"?: $Duration$$Type, "outlineColor"?: ($KubeColor$$Type)?, "textShadow"?: boolean, "text"?: $Component$$Type, "iconSize"?: integer, "icon"?: ($KubeIcon$$Type)?}) | ([borderColor?: ($KubeColor$$Type)?, backgroundColor?: ($KubeColor$$Type)?, duration?: $Duration$$Type, outlineColor?: ($KubeColor$$Type)?, textShadow?: boolean, text?: $Component$$Type, iconSize?: integer, icon?: ($KubeIcon$$Type)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NotificationToastData$$Original = $NotificationToastData;}
declare module "dev.latvian.mods.kubejs.util.WithCodec" {
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$JsonSerializable$$Interface} from "dev.latvian.mods.kubejs.util.JsonSerializable"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$NBTSerializable$$Interface} from "dev.latvian.mods.kubejs.util.NBTSerializable"

export interface $WithCodec$$Interface extends $NBTSerializable$$Interface, $JsonSerializable$$Interface {

(): $Codec$$Type<(never)>
get "codec"(): $Codec<(never)>
}

export class $WithCodec implements $WithCodec$$Interface {
 "toNBT"(): $Tag
 "toJson"(): $JsonElement
 "getCodec"(): $Codec<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithCodec$$Type = (() => $Codec$$Type<(never)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WithCodec$$Original = $WithCodec;}
declare module "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ItemBuilder} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$FluidBuilder, $FluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $FluidBucketItemBuilder extends $ItemBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
readonly "fluidBuilder": $FluidBuilder
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(b: $FluidBuilder$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBucketItemBuilder$$Type = ($FluidBucketItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidBucketItemBuilder$$Original = $FluidBucketItemBuilder;}
declare module "dev.latvian.mods.kubejs.core.RecipeManagerKJS" {
import {$ReloadableServerResourceHolderKJS$$Interface} from "dev.latvian.mods.kubejs.core.ReloadableServerResourceHolderKJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RecipeHolder, $RecipeHolder$$Type} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$ReloadableServerResourcesKJS, $ReloadableServerResourcesKJS$$Type} from "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RecipeManagerKJS$$Interface extends $ReloadableServerResourceHolderKJS$$Interface {
}

export class $RecipeManagerKJS implements $RecipeManagerKJS$$Interface {
 "kjs$replaceRecipes"(byName: $Map$$Type<($ResourceLocation$$Type), ($RecipeHolder$$Type<(never)>)>): void
 "kjs$getRecipeIdMap"(): $Map<($ResourceLocation), ($RecipeHolder<(never)>)>
 "kjs$setResources"(resources: $ReloadableServerResourcesKJS$$Type): void
 "kjs$getResources"(): $ReloadableServerResourcesKJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeManagerKJS$$Type = ($RecipeManagerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeManagerKJS$$Original = $RecipeManagerKJS;}
declare module "dev.latvian.mods.kubejs.client.ModelGenerator$Face" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $ModelGenerator$Face {
readonly "side": $Direction

constructor(side: $Direction$$Type)

public "toJson"(): $JsonObject
public "cull"(d: $Direction$$Type): $ModelGenerator$Face
public "cull"(): $ModelGenerator$Face
public "tex"(t: StringJS): $ModelGenerator$Face
public "uv"(u0: double, v0: double, u1: double, v1: double): $ModelGenerator$Face
public "tintindex"(i: integer): $ModelGenerator$Face
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$Face$$Type = ($ModelGenerator$Face);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModelGenerator$Face$$Original = $ModelGenerator$Face;}
declare module "dev.latvian.mods.kubejs.util.AttachedData" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$HashMap} from "java.util.HashMap"

export class $AttachedData<T> extends $HashMap<(StringJS), (any)> {
constructor(p: T)

public "add"(key: StringJS, data: any): void
public "getParent"(): T
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
get "parent"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedData$$Type<T> = ($AttachedData<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttachedData$$Original<T> = $AttachedData<(T)>;}
declare module "dev.latvian.mods.kubejs.client.MenuScreenRegistryKubeEvent" {
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$MenuType$$Type} from "net.minecraft.world.inventory.MenuType"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$RegisterMenuScreensEvent$$Type} from "net.neoforged.neoforge.client.event.RegisterMenuScreensEvent"
import {$MenuScreens$ScreenConstructor$$Type} from "net.minecraft.client.gui.screens.MenuScreens$ScreenConstructor"

export class $MenuScreenRegistryKubeEvent implements $ClientKubeEvent$$Interface {
constructor(event: $RegisterMenuScreensEvent$$Type)

public "register"(type: $MenuType$$Type<(never)>, arg1: $MenuScreens$ScreenConstructor$$Type): void
public "getClient"(): $Minecraft
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MenuScreenRegistryKubeEvent$$Type = ($MenuScreenRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MenuScreenRegistryKubeEvent$$Original = $MenuScreenRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.item.ItemClickedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player right clicks with an item **without targeting anything**.
 * 
 * Not to be confused with `BlockEvents.rightClick` or `ItemEvents.entityInteracted`.
 */
export class $ItemClickedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, hand: $InteractionHand$$Type, item: $ItemStack$$Type)

/**
 * The ray trace result of the click.
 */
public "getTarget"(): $KubeRayTraceResult
/**
 * The item that was clicked with.
 */
public "getItem"(): $ItemStack
/**
 * The player that clicked with the item.
 */
public "getEntity"(): $Entity
/**
 * The hand that the item was clicked with.
 */
public "getHand"(): $InteractionHand
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "target"(): $KubeRayTraceResult
get "item"(): $ItemStack
get "entity"(): $Entity
get "hand"(): $InteractionHand
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemClickedKubeEvent$$Type = ($ItemClickedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemClickedKubeEvent$$Original = $ItemClickedKubeEvent;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.HolderSetWrapper" {
import {$Iterable$$Interface} from "java.lang.Iterable"
import {$Iterator} from "java.util.Iterator"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Spliterator} from "java.util.Spliterator"
import {$List} from "java.util.List"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Set} from "java.util.Set"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $HolderSetWrapper<T> extends $Record implements $Iterable$$Interface<(T)> {
constructor(registry: $Registry$$Type<(T)>, holders: $HolderSet$$Type<(T)>)

public "size"(): integer
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public "iterator"(): $Iterator<(T)>
public "contains"(id: $ResourceLocation$$Type): boolean
public "containsValue"(value: T): boolean
public "getKeys"(): $Set<($ResourceLocation)>
public "getValues"(): $List<(T)>
public "registry"(): $Registry<(T)>
public "getRandom"(random: $RandomSource$$Type): T
public "getRandom"(): T
public "holders"(): $HolderSet<(T)>
public "spliterator"(): $Spliterator<(T)>
public "forEach"(arg0: $Consumer$$Type<(T)>): void
[Symbol.iterator](): IterableIterator<T>;
get "empty"(): boolean
get "keys"(): $Set<($ResourceLocation)>
get "values"(): $List<(T)>
get "random"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HolderSetWrapper$$Type<T> = ({"registry"?: $Registry$$Type<(T)>, "holders"?: $HolderSet$$Type<(T)>}) | ([registry?: $Registry$$Type<(T)>, holders?: $HolderSet$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HolderSetWrapper$$Original<T> = $HolderSetWrapper<(T)>;}
declare module "dev.latvian.mods.kubejs.core.RecipeHolderKJS" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchema} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$RecipeHolder} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$Recipe} from "net.minecraft.world.item.crafting.Recipe"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RecipeLikeKJS$$Interface} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RecipeHolderKJS$$Interface extends $RecipeLikeKJS$$Interface {
get "recipe"(): $Recipe<(never)>
get "serializer"(): $RecipeSerializer<(never)>
set "group"(value: StringJS)
get "typeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
get "schema"(): $RecipeSchema
get "orCreateId"(): $ResourceLocation
get "group"(): StringJS
get "mod"(): StringJS
get "type"(): $ResourceLocation
}

export class $RecipeHolderKJS implements $RecipeHolderKJS$$Interface {
 "getRecipe"(): $Recipe<(never)>
 "replaceOutput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "getSerializer"(): $RecipeSerializer<(never)>
 "setGroup"(group: StringJS): void
 "replaceInput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "getTypeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
 "getSchema"(): $RecipeSchema
 "getOrCreateId"(): $ResourceLocation
 "getGroup"(): StringJS
 "self"(): $RecipeHolder<(never)>
 "hasOutput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
 "hasInput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
 "getMod"(): StringJS
 "getType"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeHolderKJS$$Type = ($RecipeHolderKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeHolderKJS$$Original = $RecipeHolderKJS;}
declare module "dev.latvian.mods.kubejs.block.BlockPlacedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$BlockEvent$EntityPlaceEvent$$Type} from "net.neoforged.neoforge.event.level.BlockEvent$EntityPlaceEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a block is placed.
 */
export class $BlockPlacedKubeEvent implements $KubeEntityEvent$$Interface {
constructor(event: $BlockEvent$EntityPlaceEvent$$Type)

/**
 * The level of the block that was placed.
 */
public "getLevel"(): $Level
/**
 * The block that is placed.
 */
public "getBlock"(): $LevelBlock
/**
 * The entity that placed the block. Can be `null`, e.g. when a block is placed by a dispenser.
 */
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "block"(): $LevelBlock
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPlacedKubeEvent$$Type = ($BlockPlacedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPlacedKubeEvent$$Original = $BlockPlacedKubeEvent;}
declare module "dev.latvian.mods.kubejs.level.KubeLevelEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export interface $KubeLevelEvent$$Interface extends $KubeEvent$$Interface {

(): $Level$$Type
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}

export class $KubeLevelEvent implements $KubeLevelEvent$$Interface {
 "getLevel"(): $Level
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeLevelEvent$$Type = (() => $Level$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeLevelEvent$$Original = $KubeLevelEvent;}
declare module "dev.latvian.mods.kubejs.entity.AttributeBuilder" {
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$List} from "java.util.List"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$AttributeBuilder$Range} from "dev.latvian.mods.kubejs.entity.AttributeBuilder$Range"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$MobCategory$$Type} from "net.minecraft.world.entity.MobCategory"
import {$Registry} from "net.minecraft.core.Registry"
import {$Attribute$Sentiment$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute$Sentiment"
import {$Either} from "com.mojang.datafixers.util.Either"
import {$Attribute, $Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $AttributeBuilder extends $BuilderBase<($Attribute)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "predicateList": $List<($Predicate<($EntityType<(never)>)>)>
 "defaultValue": $Either<($AttributeBuilder$Range), (boolean)>
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

public "range"(defaultValue: double, min: double, max: double): this
public "sentiment"(sentiment: $Attribute$Sentiment$$Type): this
public "syncable"(watch: boolean): this
public "bool"(defaultValue: boolean): this
public "attachTo"(entityType: $Predicate$$Type<($EntityType<(never)>)>): this
public "transformObject"(attribute: $Attribute$$Type): $Attribute
public "attachToMonsters"(): this
public "attachToPlayers"(): this
public "neutralSentiment"(): this
public "attachToCategory"(category: $MobCategory$$Type): this
public "negativeSentiment"(): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributeBuilder$$Type = ($AttributeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttributeBuilder$$Original = $AttributeBuilder;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.IngredientWrapper" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$DataResult} from "com.mojang.serialization.DataResult"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$SizedIngredient} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

/**
 * Various Ingredient related helper methods
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IngredientWrapper$$Interface {
}

export class $IngredientWrapper implements $IngredientWrapper$$Interface {
/**
 * An ingredient that matches everything
 */
static readonly "all": $Ingredient
static readonly "TYPE_INFO": $TypeInfo
/**
 * A completely empty ingredient that will only match air
 */
static readonly "none": $Ingredient

/**
 * Returns an ingredient of the input
 */
static "of"(ingredient: $Ingredient$$Type): $Ingredient
/**
 * Returns an ingredient of the input, with the specified count
 */
static "of"(ingredient: $Ingredient$$Type, count: integer): $SizedIngredient
static "first"(ingredient: $Ingredient$$Type): $ItemStack
static "read"(reader: $StringReader$$Type): $DataResult<($Ingredient)>
static "parseString"(s: StringJS): $DataResult<($Ingredient)>
/**
 * Returns an ingredient that accepts the given set of items under the given (optionally strict) component filter.
 */
static "withData"(base: $HolderSet$$Type<($Item)>, data: $DataComponentMap$$Type, strict: boolean): $Ingredient
/**
 * Returns an ingredient that accepts the given set of items under the given component filter.
 */
static "withData"(base: $HolderSet$$Type<($Item)>, data: $DataComponentMap$$Type): $Ingredient
/**
 * Checks if the passed in object is an Ingredient.
 * Note that this does not mean it will not function as an Ingredient if passed to something that requests one.
 */
static "isIngredient"(o: any): boolean
static "parseJson"(json: $JsonElement$$Type): $DataResult<($Ingredient)>
static "tagKeyOf"(arg0: $Ingredient$$Type): $TagKey<($Item)>
static "containsAnyTag"(arg0: $Ingredient$$Type): boolean
static "isIngredientLike"(from: any): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientWrapper$$Type = ($IngredientWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientWrapper$$Original = $IngredientWrapper;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickHandler" {
import {$ChestMenuClickEvent$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent"
import {$ChestMenuClickEvent$Callback, $ChestMenuClickEvent$Callback$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"
import {$Record} from "java.lang.Record"

export class $ChestMenuClickHandler extends $Record {
constructor(type: $ClickType$$Type, button: integer, callback: $ChestMenuClickEvent$Callback$$Type, autoHandle: boolean)

public "callback"(): $ChestMenuClickEvent$Callback
public "type"(): $ClickType
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "test"(event: $ChestMenuClickEvent$$Type): boolean
public "button"(): integer
public "autoHandle"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuClickHandler$$Type = ({"type"?: $ClickType$$Type, "button"?: integer, "autoHandle"?: boolean, "callback"?: $ChestMenuClickEvent$Callback$$Type}) | ([type?: $ClickType$$Type, button?: integer, autoHandle?: boolean, callback?: $ChestMenuClickEvent$Callback$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuClickHandler$$Original = $ChestMenuClickHandler;}
declare module "dev.latvian.mods.kubejs.block.custom.FenceBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $FenceBlockBuilder extends $ShapedBlockBuilder {
static readonly "FENCE_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FenceBlockBuilder$$Type = ($FenceBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FenceBlockBuilder$$Original = $FenceBlockBuilder;}
declare module "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder" {
import {$Pattern} from "java.util.regex.Pattern"
import {$StringBuilder, $StringBuilder$$Type} from "java.lang.StringBuilder"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Record} from "java.lang.Record"

export class $UniqueIdBuilder extends $Record {
static readonly "MULTIPLE_UNDERSCORES_PATTERN": $Pattern
static readonly "NON_W_PATTERN": $Pattern

constructor(builder: $StringBuilder$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "append"(string: StringJS): void
public "append"(id: $ResourceLocation$$Type): void
public "append"(key: $ResourceKey$$Type<(never)>): void
public "hashCode"(): integer
public "builder"(): $StringBuilder
public "build"(): StringJS
public "appendSeparator"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UniqueIdBuilder$$Type = ({"builder"?: $StringBuilder$$Type}) | ([builder?: $StringBuilder$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UniqueIdBuilder$$Original = $UniqueIdBuilder;}
declare module "dev.latvian.mods.kubejs.player.KubePlayerEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Level} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export interface $KubePlayerEvent$$Interface extends $KubeLivingEntityEvent$$Interface {
get "entity"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}

export class $KubePlayerEvent implements $KubePlayerEvent$$Interface {
 "getEntity"(): $Entity
 "getPlayer"(): $Player
 "getLevel"(): $Level
 "getRegistries"(): $RegistryAccess
 "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubePlayerEvent$$Type = ($KubePlayerEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubePlayerEvent$$Original = $KubePlayerEvent;}
declare module "dev.latvian.mods.kubejs.block.callback.RandomTickCallback" {
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Level} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"

export class $RandomTickCallback {
readonly "random": $RandomSource
readonly "block": $LevelBlock

constructor(block: $LevelBlock$$Type, random: $RandomSource$$Type)

public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
get "level"(): $Level
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomTickCallback$$Type = ($RandomTickCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomTickCallback$$Original = $RandomTickCallback;}
declare module "dev.latvian.mods.kubejs.recipe.component.ComponentValueMap" {
import {$Reference2ObjectOpenHashMap} from "it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Function} from "java.util.function.Function"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"

export class $ComponentValueMap extends $Reference2ObjectOpenHashMap<($RecipeKey<(never)>), (any)> {
constructor(init: integer)

public "getValue"<T>(cx: $RecipeScriptContext$$Type, key: $RecipeKey$$Type<(T)>): T
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentValueMap$$Type = ($ComponentValueMap);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComponentValueMap$$Original = $ComponentValueMap;}
declare module "dev.latvian.mods.kubejs.core.BlockProviderKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map} from "java.util.Map"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$List} from "java.util.List"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$Holder} from "net.minecraft.core.Holder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $BlockProviderKJS$$Interface extends $RegistryObjectKJS$$Interface<($Block)> {

(): $Block$$Type
get "id"(): StringJS
get "key"(): $ResourceKey<($Block)>
get "typeData"(): $Map<(StringJS), (any)>
get "registry"(): $Registry<($Block)>
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "block"(): $Block
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $BlockProviderKJS implements $BlockProviderKJS$$Interface {
 "getId"(): StringJS
 "getKey"(): $ResourceKey<($Block)>
 "getTypeData"(): $Map<(StringJS), (any)>
 "asHolder"(): $Holder<($Block)>
 "getRegistry"(): $Registry<($Block)>
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "getBlock"(): $Block
 "specialEquals"(o: any, shallow: boolean): boolean
 "getMod"(): StringJS
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getIdLocation"(): $ResourceLocation
 "getTagKeys"(): $List<($TagKey<($Block)>)>
 "getTags"(): $List<($ResourceLocation)>
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockProviderKJS$$Type = (() => $Block$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockProviderKJS$$Original = $BlockProviderKJS;}
declare module "dev.latvian.mods.kubejs.item.custom.HandheldItemBuilder" {
import {$MutableToolTier$$Type} from "dev.latvian.mods.kubejs.item.MutableToolTier"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ItemBuilder} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier$$Type} from "net.minecraft.world.item.Tier"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $HandheldItemBuilder extends $ItemBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type, d: float, s: float)

public "tier"(t: $Tier$$Type): this
/**
 * Sets the attack speed of the tool.
 */
public "speed"(f: float): this
/**
 * Modifies the tool tier.
 */
public "modifyTier"(callback: $Consumer$$Type<($MutableToolTier)>): this
/**
 * Sets the base attack damage of the tool. Different tools have different baselines.
 * 
 * For example, a sword has a baseline of 3, while an axe has a baseline of 6.
 * 
 * The actual damage is the sum of the baseline and the attackDamageBonus from tier.
 */
public "attackDamageBaseline"(f: float): this
/**
 * Sets the base attack speed of the tool. Different tools have different baselines.
 * 
 * For example, a sword has a baseline of -2.4, while an axe has a baseline of -3.1.
 * 
 * The actual speed is the sum of the baseline and the speed from tier + 4 (bare hand).
 */
public "speedBaseline"(f: float): this
/**
 * Sets the attack damage bonus of the tool.
 */
public "attackDamageBonus"(f: float): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandheldItemBuilder$$Type = ($HandheldItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HandheldItemBuilder$$Original = $HandheldItemBuilder;}
declare module "dev.latvian.mods.kubejs.core.BlockKJS" {
import {$Map} from "java.util.Map"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$BlockBuilderProvider$$Interface} from "dev.latvian.mods.kubejs.core.BlockBuilderProvider"
import {$SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$List} from "java.util.List"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Holder} from "net.minecraft.core.Holder"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBehaviourKJS$$Interface} from "dev.latvian.mods.kubejs.core.BlockBehaviourKJS"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RandomTickCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $BlockKJS$$Interface extends $BlockBuilderProvider$$Interface, $BlockBehaviourKJS$$Interface, $Replaceable$$Interface {
set "nameKey"(value: StringJS)
get "blockStates"(): $List<($BlockState)>
set "lightEmission"(value: integer)
set "requiresTool"(value: boolean)
set "destroySpeed"(value: float)
set "blockBuilder"(value: $BlockBuilder$$Type)
get "block"(): $Block
get "blockBuilder"(): $BlockBuilder
set "soundType"(value: $SoundType$$Type)
set "friction"(value: float)
set "speedFactor"(value: float)
set "jumpFactor"(value: float)
set "randomTickCallback"(value: $Consumer$$Type<($RandomTickCallback)>)
set "isRandomlyTicking"(value: boolean)
set "hasCollision"(value: boolean)
set "explosionResistance"(value: float)
get "id"(): StringJS
get "key"(): $ResourceKey<($Block)>
get "typeData"(): $Map<(StringJS), (any)>
get "registry"(): $Registry<($Block)>
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $BlockKJS implements $BlockKJS$$Interface {
 "setNameKey"(key: StringJS): void
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "getBlockStates"(): $List<($BlockState)>
 "setLightEmission"(v: integer): void
 "setRequiresTool"(v: boolean): void
 "setDestroySpeed"(v: float): void
 "setBlockBuilder"(b: $BlockBuilder$$Type): void
 "getBlock"(): $Block
 "getBlockBuilder"(): $BlockBuilder
 "setSoundType"(v: $SoundType$$Type): void
 "setFriction"(v: float): void
 "setSpeedFactor"(v: float): void
 "setJumpFactor"(v: float): void
 "setRandomTickCallback"(callback: $Consumer$$Type<($RandomTickCallback)>): void
 "setIsRandomlyTicking"(v: boolean): void
 "setHasCollision"(v: boolean): void
 "setExplosionResistance"(v: float): void
 "getId"(): StringJS
 "getKey"(): $ResourceKey<($Block)>
 "getTypeData"(): $Map<(StringJS), (any)>
 "asHolder"(): $Holder<($Block)>
 "getRegistry"(): $Registry<($Block)>
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "specialEquals"(o: any, shallow: boolean): boolean
 "getMod"(): StringJS
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getIdLocation"(): $ResourceLocation
 "getTagKeys"(): $List<($TagKey<($Block)>)>
 "getTags"(): $List<($ResourceLocation)>
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockKJS$$Type = ($BlockKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockKJS$$Original = $BlockKJS;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$DataComponentSubtypes" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Record} from "java.lang.Record"

export class $ItemData$DataComponentSubtypes extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData$DataComponentSubtypes)>

constructor(filter: $Ingredient$$Type, components: $List$$Type<($DataComponentType$$Type<(never)>)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $Ingredient
public "components"(): $List<($DataComponentType<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$DataComponentSubtypes$$Type = ({"filter"?: $Ingredient$$Type, "components"?: $List$$Type<($DataComponentType$$Type<(never)>)>}) | ([filter?: $Ingredient$$Type, components?: $List$$Type<($DataComponentType$$Type<(never)>)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemData$DataComponentSubtypes$$Original = $ItemData$DataComponentSubtypes;}
declare module "dev.latvian.mods.kubejs.util.RegistryOpsContainer" {
import {$OpsContainer} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$DynamicOps} from "com.mojang.serialization.DynamicOps"
import {$RegistryOps, $RegistryOps$$Type} from "net.minecraft.resources.RegistryOps"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"

export class $RegistryOpsContainer extends $OpsContainer {
static readonly "DEFAULT": $OpsContainer

constructor(nbt: $RegistryOps$$Type<($Tag$$Type)>, json: $RegistryOps$$Type<($JsonElement$$Type)>, java: $RegistryOps$$Type<(any)>)

public "java"(): $DynamicOps
public "json"(): $DynamicOps
public "nbt"(): $RegistryOps<($Tag)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryOpsContainer$$Type = ($RegistryOpsContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryOpsContainer$$Original = $RegistryOpsContainer;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.SubtypeInterpreter" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $SubtypeInterpreter$$Interface {

(entry: any): any
}

export class $SubtypeInterpreter implements $SubtypeInterpreter$$Interface {
 "apply"(entry: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SubtypeInterpreter$$Type = ((entry: any) => any);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SubtypeInterpreter$$Original = $SubtypeInterpreter;}
declare module "dev.latvian.mods.kubejs.core.MinecraftServerKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$EntityCollectionKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityCollectionKJS"
import {$WithAttachedData$$Interface} from "dev.latvian.mods.kubejs.core.WithAttachedData"
import {$AdvancementNode} from "net.minecraft.advancements.AdvancementNode"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$ScheduledEvents} from "dev.latvian.mods.kubejs.util.ScheduledEvents"
import {$WithPersistentData$$Interface} from "dev.latvian.mods.kubejs.core.WithPersistentData"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MinecraftEnvironmentKJS$$Interface} from "dev.latvian.mods.kubejs.core.MinecraftEnvironmentKJS"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$ScheduledEvents$ScheduledEvent} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$AttachedData} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$PlayerSelector$$Type} from "dev.latvian.mods.kubejs.core.PlayerSelector"
import {$ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$ServerLevel} from "net.minecraft.server.level.ServerLevel"
import {$ServerPlayer} from "net.minecraft.server.level.ServerPlayer"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$DataSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.DataSenderKJS"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $MinecraftServerKJS$$Interface extends $WithAttachedData$$Interface<($MinecraftServer)>, $WithPersistentData$$Interface, $DataSenderKJS$$Interface, $MinecraftEnvironmentKJS$$Interface, $EntityCollectionKJS$$Interface {
get "name"(): $Component
get "mcEntities"(): $Iterable<($Entity)>
get "players"(): $EntityArrayList
get "mcPlayers"(): $List<($Player)>
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "overworld"(): $ServerLevel
get "data"(): $AttachedData<($MinecraftServer)>
get "persistentData"(): $CompoundTag
get "scheduledEvents"(): $ScheduledEvents
get "entities"(): $EntityArrayList
get "displayName"(): $Component
}

export class $MinecraftServerKJS implements $MinecraftServerKJS$$Interface {
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "getAdvancement"(id: $ResourceLocation$$Type): $AdvancementNode
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getMcEntities"(): $Iterable<($Entity)>
 "getPlayers"(): $EntityArrayList
 "getMcPlayers"(): $List<($Player)>
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "self"(): $MinecraftServer
 "tell"(message: $Component$$Type): void
 "restoreInventories"(): $Map<($UUID), ($Map<(integer), ($ItemStack)>)>
 "getOverworld"(): $ServerLevel
 "getPlayer"(selector: $PlayerSelector$$Type): $ServerPlayer
 "getLevel"(dimension: $ResourceLocation$$Type): $ServerLevel
 "getData"(): $AttachedData<($MinecraftServer)>
 "getPersistentData"(): $CompoundTag
 "sendData"(channel: StringJS): void
 "schedule"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeating"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getScheduledEvents"(): $ScheduledEvents
 "scheduleInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeatingInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getEntities"(): $EntityArrayList
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftServerKJS$$Type = ($MinecraftServerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MinecraftServerKJS$$Original = $MinecraftServerKJS;}
declare module "dev.latvian.mods.kubejs.entity.AttributeBuilder$Range" {
import {$Record} from "java.lang.Record"

export class $AttributeBuilder$Range extends $Record {
constructor(defaultValue: double, min: double, max: double)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "min"(): double
public "max"(): double
public "defaultValue"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributeBuilder$Range$$Type = ({"max"?: double, "min"?: double, "defaultValue"?: double}) | ([max?: double, min?: double, defaultValue?: double]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttributeBuilder$Range$$Original = $AttributeBuilder$Range;}
declare module "dev.latvian.mods.kubejs.recipe.component.ListRecipeComponent" {
import {$TinyMap} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$IntBounds, $IntBounds$$Type} from "dev.latvian.mods.kubejs.util.IntBounds"
import {$ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeComponent, $RecipeComponent$$Type, $RecipeComponent$$Interface} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeKey} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$RecipeComponentType} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"
import {$OpsContainer$$Type} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$CustomObjectRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent"
import {$EitherRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent"
import {$CustomObjectRecipeComponent$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$RecipeComponentBuilder} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder"
import {$KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$Record} from "java.lang.Record"

export class $ListRecipeComponent<T> extends $Record implements $RecipeComponent$$Interface<($List<(T)>)> {
static readonly "TYPE": $RecipeComponentType<(never)>

constructor(component: $RecipeComponent$$Type<(T)>, canWriteSelf: boolean, listTypeInfo: $TypeInfo$$Type, listCodec: $Codec$$Type<($List$$Type<(T)>)>, conditional: boolean, bounds: $IntBounds$$Type, spread: ($RecipeComponent$$Type<(never)>)?, spreadWrap: ($RecipeComponent$$Type<(never)>)?)

public "type"(): $RecipeComponentType<(never)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "wrap"(cx: $RecipeScriptContext$$Type, from: any): $List<(T)>
public "isEmpty"(value: any): boolean
public "isEmpty"(value: $List$$Type<(T)>): boolean
public "replace"(cx: $RecipeScriptContext$$Type, original: $List$$Type<(T)>, match: $ReplacementMatchInfo$$Type, arg3: any): $List<(T)>
public "replace"(cx: $RecipeScriptContext$$Type, original: any, match: $ReplacementMatchInfo$$Type, arg3: any): any
public "matches"(cx: $RecipeMatchContext$$Type, value: $List$$Type<(T)>, match: $ReplacementMatchInfo$$Type): boolean
public "matches"(cx: $RecipeMatchContext$$Type, value: any, match: $ReplacementMatchInfo$$Type): boolean
public "validate"(ctx: $RecipeValidationContext$$Type, value: $List$$Type<(T)>): void
public "validate"(ctx: $RecipeValidationContext$$Type, value: any): void
public "component"(): $RecipeComponent<(T)>
public "bounds"(): $IntBounds
public "typeInfo"(): $TypeInfo
public static "create"<L>(component: $RecipeComponent$$Type<(L)>, canWriteSelf: boolean, conditional: boolean, bounds: $IntBounds$$Type, spread: ($RecipeComponent$$Type<(never)>)?): $ListRecipeComponent<(L)>
public static "create"<L>(component: $RecipeComponent$$Type<(L)>, canWriteSelf: boolean, conditional: boolean): $ListRecipeComponent<(L)>
public "spread"(): $Optional<($RecipeComponent<(never)>)>
public "spread"(value: $List$$Type<(T)>): $List<(never)>
public "spread"(value: any): $List
public "canWriteSelf"(): boolean
public "listTypeInfo"(): $TypeInfo
public "asConditional"(): $ListRecipeComponent<(T)>
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, value: any): void
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, value: $List$$Type<(T)>): void
public "codec"(): $Codec<($List<(T)>)>
public "orSelf"(): $RecipeComponent
public "spreadWrap"(): $Optional<($RecipeComponent<(never)>)>
public static "wrap0"<T>(cx: $RecipeScriptContext$$Type, component: $RecipeComponent$$Type<(T)>, from: any): $List<(T)>
public "withSpread"(spread: ($RecipeComponent$$Type<(never)>)?): $ListRecipeComponent<(T)>
public "allowEmpty"(): boolean
public "listCodec"(): $Codec<($List<(T)>)>
public "withBounds"(bounds: $IntBounds$$Type): $ListRecipeComponent<(T)>
public "conditional"(): boolean
public "hasPriority"(cx: $RecipeMatchContext$$Type, from: any): boolean
public "toString"(ops: $OpsContainer$$Type, value: $List$$Type<(T)>): StringJS
public static "builder"(keys: $List$$Type<($CustomObjectRecipeComponent$Key$$Type)>): $CustomObjectRecipeComponent
public static "builder"(...keys: ($CustomObjectRecipeComponent$Key$$Type)[]): $CustomObjectRecipeComponent
public "key"(name: StringJS, role: $ComponentRole$$Type): $RecipeKey<($List<(T)>)>
public "asList"(): $ListRecipeComponent<($List<(T)>)>
public "or"<O>(other: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<($List<(T)>), (O)>
public "readFromJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($List$$Type<(T)>)>, json: $JsonObject$$Type): void
public "asListOrSelf"(): $ListRecipeComponent<($List<(T)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($List<(T)>)>)>
public "asConditionalList"(): $ListRecipeComponent<($List<(T)>)>
public "writeToJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($List$$Type<(T)>)>, json: $JsonObject$$Type): void
public "isIgnored"(): boolean
public "otherKey"(name: StringJS): $RecipeKey<($List<(T)>)>
public "createBuilder"(): $RecipeComponentBuilder
public "inputKey"(name: StringJS): $RecipeKey<($List<(T)>)>
public "asMap"<K>(key: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($List<(T)>)>)>
public "asConditionalListOrSelf"(): $ListRecipeComponent<($List<(T)>)>
public "withCodec"(codec: $Codec$$Type<($List$$Type<(T)>)>): $RecipeComponent<($List<(T)>)>
public "outputKey"(name: StringJS): $RecipeKey<($List<(T)>)>
get "ignored"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListRecipeComponent$$Type<T> = ({"listCodec"?: $Codec$$Type<($List$$Type<(T)>)>, "conditional"?: boolean, "listTypeInfo"?: $TypeInfo$$Type, "bounds"?: $IntBounds$$Type, "spread"?: ($RecipeComponent$$Type<(never)>)?, "spreadWrap"?: ($RecipeComponent$$Type<(never)>)?, "component"?: $RecipeComponent$$Type<(T)>, "canWriteSelf"?: boolean}) | ([listCodec?: $Codec$$Type<($List$$Type<(T)>)>, conditional?: boolean, listTypeInfo?: $TypeInfo$$Type, bounds?: $IntBounds$$Type, spread?: ($RecipeComponent$$Type<(never)>)?, spreadWrap?: ($RecipeComponent$$Type<(never)>)?, component?: $RecipeComponent$$Type<(T)>, canWriteSelf?: boolean]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ListRecipeComponent$$Original<T> = $ListRecipeComponent<(T)>;}
declare module "dev.latvian.mods.kubejs.client.KubeAnimatedParticle" {
import {$ClientLevel, $ClientLevel$$Type} from "net.minecraft.client.multiplayer.ClientLevel"
import {$TextureAtlasSprite} from "net.minecraft.client.renderer.texture.TextureAtlasSprite"
import {$Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$SimpleAnimatedParticle} from "net.minecraft.client.particle.SimpleAnimatedParticle"
import {$SpriteSet, $SpriteSet$$Type} from "net.minecraft.client.particle.SpriteSet"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $KubeAnimatedParticle extends $SimpleAnimatedParticle {
 "speedUpWhenYMotionIsBlocked": boolean
 "lifetime": integer
 "roll": float
 "yd": double
readonly "sprites": $SpriteSet
 "oRoll": float
readonly "random": $RandomSource
 "bCol": float
 "yo": double
 "alpha": float
 "sprite": $TextureAtlasSprite
 "rCol": float
 "quadSize": float
readonly "level": $ClientLevel
 "zd": double
 "xd": double
 "friction": float
 "stoppedByCollision": boolean
 "onGround": boolean
 "removed": boolean
 "bbHeight": float
 "zo": double
 "gravity": float
 "gCol": float
 "xo": double
 "x": double
 "y": double
 "hasPhysics": boolean
 "z": double
 "bbWidth": float
 "age": integer

constructor(level: $ClientLevel$$Type, x: double, y: double, z: double, sprites: $SpriteSet$$Type)

public "tick"(): void
public "setColor"(color: $KubeColor$$Type, alpha: boolean): void
public "setColor"(color: $KubeColor$$Type): void
public "getLevel"(): $ClientLevel
public "onTick"(tick: $Consumer$$Type<($KubeAnimatedParticle)>): void
public "getX"(): double
public "getZ"(): double
public "getRandom"(): $RandomSource
public "getY"(): double
public "getLightColor"(partialTick: float): integer
public "setSpeed"(speed: $Vec3$$Type): void
public "getSpriteSet"(): $SpriteSet
public "getYSpeed"(): double
public "setGravity"(g: float): void
public "getZSpeed"(): double
public "getXSpeed"(): double
public "setFasterWhenYMotionBlocked"(b: boolean): void
public "setPhysicality"(hasPhysics: boolean): void
public "setLightColor"(arg0: $Float2IntFunction$$Type): void
/**
 * Sets teh friction of the particle, the particle's motion is multiplied by this value every tick
 */
public "setFriction"(f: float): void
set "color"(value: $KubeColor$$Type)
set "speed"(value: $Vec3$$Type)
get "spriteSet"(): $SpriteSet
get "YSpeed"(): double
get "ZSpeed"(): double
get "XSpeed"(): double
set "fasterWhenYMotionBlocked"(value: boolean)
set "physicality"(value: boolean)
set "lightColor"(value: $Float2IntFunction$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeAnimatedParticle$$Type = ($KubeAnimatedParticle);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeAnimatedParticle$$Original = $KubeAnimatedParticle;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Leggings" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ArmorItemBuilder} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $ArmorItemBuilder$Leggings extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "LEGGING_TAGS": ($ResourceLocation)[]
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Leggings$$Type = ($ArmorItemBuilder$Leggings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$Leggings$$Original = $ArmorItemBuilder$Leggings;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.RegistryWrapper" {
import {$Iterable$$Interface} from "java.lang.Iterable"
import {$Iterator} from "java.util.Iterator"
import {$Map} from "java.util.Map"
import {$Spliterator} from "java.util.Spliterator"
import {$List} from "java.util.List"
import {$DataMapWrapper} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.DataMapWrapper"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Map$Entry} from "java.util.Map$Entry"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$HolderSetWrapper} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.HolderSetWrapper"
import {$Set} from "java.util.Set"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $RegistryWrapper<T> extends $Record implements $Iterable$$Interface<(T)> {
constructor(registry: $Registry$$Type<(T)>, unknownKey: $ResourceKey$$Type<(T)>)

public "get"(id: $ResourceLocation$$Type): T
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "iterator"(): $Iterator
public static "of"(id: $ResourceLocation$$Type): $RegistryWrapper<(never)>
public "contains"(id: $ResourceLocation$$Type): boolean
public "getKey"(value: T): $ResourceKey<(T)>
public static "access"(): $RegistryAccessContainer
public "getId"(value: T): $ResourceLocation
public "containsValue"(value: T): boolean
public "getKeys"(): $Set<($ResourceLocation)>
public "getValues"(filter: any): $HolderSetWrapper<(T)>
public "getValues"(): $List<(T)>
public "registry"(): $Registry<(T)>
public "getRandom"(random: $RandomSource$$Type): T
public "getRandom"(): T
public "unknownKey"(): $ResourceKey<(T)>
public "getDataMap"(id: $ResourceLocation$$Type): $DataMapWrapper<(T), (never)>
public "getEntrySet"(): $Set<($Map$Entry<($ResourceLocation), (T)>)>
public "getValueMap"(): $Map<($ResourceLocation), (T)>
public "spliterator"(): $Spliterator<(T)>
public "forEach"(arg0: $Consumer$$Type<(T)>): void
get "keys"(): $Set<($ResourceLocation)>
get "values"(): $List<(T)>
get "random"(): T
get "entrySet"(): $Set<($Map$Entry<($ResourceLocation), (T)>)>
get "valueMap"(): $Map<($ResourceLocation), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryWrapper$$Type<T> = ({"registry"?: $Registry$$Type<(T)>, "unknownKey"?: $ResourceKey$$Type<(T)>}) | ([registry?: $Registry$$Type<(T)>, unknownKey?: $ResourceKey$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryWrapper$$Original<T> = $RegistryWrapper<(T)>;}
declare module "dev.latvian.mods.kubejs.generator.KubeResourceGenerator" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $KubeResourceGenerator$$Interface extends $KubeEvent$$Interface {
get "registries"(): $RegistryAccessContainer
}

export class $KubeResourceGenerator implements $KubeResourceGenerator$$Interface {
 "flush"(): void
 "add"(data: $GeneratedData$$Type): void
 "text"(id: $ResourceLocation$$Type, content: StringJS): void
 "getGenerated"(id: $ResourceLocation$$Type): $GeneratedData
 "getRegistries"(): $RegistryAccessContainer
 "json"(id: $ResourceLocation$$Type, json: $JsonElement$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeResourceGenerator$$Type = ($KubeResourceGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeResourceGenerator$$Original = $KubeResourceGenerator;}
declare module "dev.latvian.mods.kubejs.script.ScriptPack" {
import {$List} from "java.util.List"
import {$ScriptFile} from "dev.latvian.mods.kubejs.script.ScriptFile"
import {$ScriptPackInfo, $ScriptPackInfo$$Type} from "dev.latvian.mods.kubejs.script.ScriptPackInfo"
import {$ScriptManager, $ScriptManager$$Type} from "dev.latvian.mods.kubejs.script.ScriptManager"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptPack {
readonly "manager": $ScriptManager
readonly "scripts": $List<($ScriptFile)>
readonly "info": $ScriptPackInfo

constructor(m: $ScriptManager$$Type, i: $ScriptPackInfo$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptPack$$Type = ($ScriptPack);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptPack$$Original = $ScriptPack;}
declare module "dev.latvian.mods.kubejs.core.PlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$WithAttachedData$$Interface} from "dev.latvian.mods.kubejs.core.WithAttachedData"
import {$KubeJSInventoryListener} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Stages} from "dev.latvian.mods.kubejs.stages.Stages"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$LivingEntityKJS$$Interface} from "dev.latvian.mods.kubejs.core.LivingEntityKJS"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$EntityPotionEffectsJS} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$DataSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.DataSenderKJS"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $PlayerKJS$$Interface extends $LivingEntityKJS$$Interface, $DataSenderKJS$$Interface, $WithAttachedData$$Interface<($Player)> {

(): $AttachedData$$Type<($Player$$Type)>
get "inventoryChangeListener"(): $KubeJSInventoryListener
get "craftingGrid"(): $InventoryKJS
get "openInventory"(): $AbstractContainerMenu
get "selectedSlot"(): integer
set "selectedSlot"(value: integer)
get "mouseItem"(): $ItemStack
get "xpLevel"(): integer
set "foodLevel"(value: integer)
set "saturation"(value: float)
get "miningBlock"(): boolean
set "xpLevel"(value: integer)
set "mouseItem"(value: $ItemStack$$Type)
get "stages"(): $Stages
get "saturation"(): float
get "stats"(): $PlayerStatsJS
get "inventory"(): $InventoryKJS
get "foodLevel"(): integer
get "fake"(): boolean
get "xp"(): integer
set "xp"(value: integer)
set "statusMessage"(value: $Component$$Type)
get "profile"(): $GameProfile
get "player"(): boolean
get "headArmorItem"(): $ItemStack
get "reachDistance"(): double
set "chestArmorItem"(value: $ItemStack$$Type)
get "legsArmorItem"(): $ItemStack
get "mainHandItem"(): $ItemStack
set "headArmorItem"(value: $ItemStack$$Type)
set "legsArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
get "feetArmorItem"(): $ItemStack
get "totalMovementSpeed"(): double
set "feetArmorItem"(value: $ItemStack$$Type)
set "mainHandItem"(value: $ItemStack$$Type)
get "potionEffects"(): $EntityPotionEffectsJS
get "defaultMovementSpeed"(): double
set "defaultMovementSpeed"(value: double)
set "movementSpeedAddition"(value: double)
set "totalMovementSpeedMultiplier"(value: double)
set "defaultMovementSpeedMultiplier"(value: double)
get "living"(): boolean
get "offHandItem"(): $ItemStack
set "offHandItem"(value: $ItemStack$$Type)
set "maxHealth"(value: float)
get "undead"(): boolean
get "data"(): $AttachedData<($Player)>
get "peacefulCreature"(): boolean
get "waterCreature"(): boolean
get "ambientCreature"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "nbt"(): $CompoundTag
set "x"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "z"(value: double)
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "block"(): $LevelBlock
get "server"(): $MinecraftServer
get "motionX"(): double
set "motionY"(value: double)
get "facing"(): $Direction
get "frame"(): boolean
get "passengers"(): $EntityArrayList
get "item"(): $ItemStack
get "motionZ"(): double
get "type"(): StringJS
set "motionZ"(value: double)
get "animal"(): boolean
get "monster"(): boolean
get "teamId"(): StringJS
get "motionY"(): double
set "motionX"(value: double)
get "scriptType"(): $ScriptType
set "activePostShader"(value: $ResourceLocation$$Type)
get "persistentData"(): $CompoundTag
}

export class $PlayerKJS implements $PlayerKJS$$Interface {
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "addItemCooldown"(item: $Item$$Type, ticks: integer): void
 "getCraftingGrid"(): $InventoryKJS
 "boostElytraFlight"(): void
 "sendInventoryUpdate"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "getSelectedSlot"(): integer
 "setSelectedSlot"(index: integer): void
 "spawn"(): void
 "addXPLevels"(l: integer): void
 "getMouseItem"(): $ItemStack
 "getXpLevel"(): integer
 "setFoodLevel"(foodLevel: integer): void
 "setSaturation"(saturation: float): void
 "addFood"(f: integer, m: float): void
 "isMiningBlock"(): boolean
 "setXpLevel"(l: integer): void
 "addExhaustion"(exhaustion: float): void
 "setMouseItem"(item: $ItemStack$$Type): void
 "getStages"(): $Stages
 "giveInHand"(item: $ItemStack$$Type): void
 "getSaturation"(): float
 "getStats"(): $PlayerStatsJS
 "getInventory"(): $InventoryKJS
 "getFoodLevel"(): integer
 "isFake"(): boolean
 "give"(item: $ItemStack$$Type): void
 "getXp"(): integer
 "notify"(title: $Component$$Type, text: $Component$$Type): void
 "notify"(builder: $NotificationToastData$$Type): void
 "addXP"(xp: integer): void
 "setXp"(xp: integer): void
 "setStatusMessage"(message: $Component$$Type): void
 "self"(): $Entity
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "getHeadArmorItem"(): $ItemStack
 "getReachDistance"(): double
 "setChestArmorItem"(item: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "getMainHandItem"(): $ItemStack
 "setHeadArmorItem"(item: $ItemStack$$Type): void
 "setLegsArmorItem"(item: $ItemStack$$Type): void
 "getChestArmorItem"(): $ItemStack
 "getFeetArmorItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "getAttributeTotalValue"(attribute: $Holder$$Type<($Attribute)>): double
 "getAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>): double
 "canEntityBeSeen"(entity: $LivingEntity$$Type): boolean
 "setFeetArmorItem"(item: $ItemStack$$Type): void
 "setAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>, value: double): void
 "isHoldingInAnyHand"(i: $ItemPredicate$$Type): boolean
 "modifyAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): void
 "setMainHandItem"(item: $ItemStack$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "getPotionEffects"(): $EntityPotionEffectsJS
 "removeAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): void
 "swing"(hand: $InteractionHand$$Type): void
 "swing"(): void
 "getDefaultMovementSpeed"(): double
 "setDefaultMovementSpeed"(speed: double): void
 "setMovementSpeedAddition"(speed: double): void
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "foodEaten"(is: $ItemStack$$Type, food: $FoodProperties$$Type): void
 "isLiving"(): boolean
 "damageHeldItem"(): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "getOffHandItem"(): $ItemStack
 "setOffHandItem"(item: $ItemStack$$Type): void
 "getHeldItem"(hand: $InteractionHand$$Type): $ItemStack
 "rayTraceEntity"(filter: $Predicate$$Type<($Entity)>): $Entity
 "rayTrace"(): $KubeRayTraceResult
 "setMaxHealth"(hp: float): void
 "getEquipment"(slot: $EquipmentSlot$$Type): $ItemStack
 "isUndead"(): boolean
 "setEquipment"(slot: $EquipmentSlot$$Type, item: $ItemStack$$Type): void
 "setHeldItem"(hand: $InteractionHand$$Type, item: $ItemStack$$Type): void
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "sendData"(channel: StringJS): void
 "getData"(): $AttachedData<($Player)>
 "isPeacefulCreature"(): boolean
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isAmbientCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "getNbt"(): $CompoundTag
 "setX"(x: double): void
 "attack"(hp: float): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "runCommandSilent"(command: StringJS): void
 "tell"(message: $Component$$Type): void
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "playSound"(id: $SoundEvent$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "getServer"(): $MinecraftServer
 "getMotionX"(): double
 "setMotionY"(y: double): void
 "getFacing"(): $Direction
 "isFrame"(): boolean
 "getPassengers"(): $EntityArrayList
 "getItem"(): $ItemStack
 "setRotation"(yaw: float, pitch: float): void
 "getMotionZ"(): double
 "getType"(): StringJS
 "setMotionZ"(z: double): void
 "isAnimal"(): boolean
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "isMonster"(): boolean
 "getTeamId"(): StringJS
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getMotionY"(): double
 "setMotionX"(x: double): void
 "getScriptType"(): $ScriptType
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerKJS$$Original = $PlayerKJS;}
declare module "dev.latvian.mods.kubejs.core.CustomIngredientKJS" {
import {$ItemStackSet} from "dev.latvian.mods.kubejs.item.ItemStackSet"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"
import {$ItemPredicate, $ItemPredicate$$Interface} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Set} from "java.util.Set"
import {$Stream} from "java.util.stream.Stream"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $CustomIngredientKJS$$Interface extends $ItemPredicate$$Interface {

(itemStack: $ItemStack): boolean
get "stackArray"(): ($ItemStack)[]
get "items"(): $Stream<($ItemStack)>
get "displayStacks"(): $ItemStackSet
get "itemIds"(): $Set<(StringJS)>
get "first"(): $ItemStack
get "itemTypes"(): $Set<($Item)>
get "itemStream"(): $Stream<($Item)>
get "wildcard"(): boolean
get "stacks"(): $ItemStackSet
}

export class $CustomIngredientKJS implements $CustomIngredientKJS$$Interface {
 "getStackArray"(): ($ItemStack)[]
 "getItems"(): $Stream<($ItemStack)>
 "canBeUsedForMatching"(): boolean
 "getDisplayStacks"(): $ItemStackSet
 "asIngredient"(): $Ingredient
 "test"(itemStack: any): boolean
 "test"(itemStack: $ItemStack$$Type): boolean
static "wrap"(from: any): $ItemPredicate
 "testItem"(item: $Item$$Type): boolean
 "getItemIds"(): $Set<(StringJS)>
 "getFirst"(): $ItemStack
 "getItemTypes"(): $Set<($Item)>
 "getItemStream"(): $Stream<($Item)>
 "isWildcard"(): boolean
 "getStacks"(): $ItemStackSet
 "or"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "not"<T>(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "isEqual"<T>(arg0: any): $Predicate<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomIngredientKJS$$Type = ((itemStack: $ItemStack) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomIngredientKJS$$Original = $CustomIngredientKJS;}
declare module "dev.latvian.mods.kubejs.client.KeybindRegistryKubeEvent$Builder" {
import {$KeyModifier$$Type} from "net.neoforged.neoforge.client.settings.KeyModifier"
import {$KeyConflictContext$$Type} from "net.neoforged.neoforge.client.settings.KeyConflictContext"
import {$InputConstants$Type$$Type} from "com.mojang.blaze3d.platform.InputConstants$Type"

export class $KeybindRegistryKubeEvent$Builder {
public "modifier"(modifier: $KeyModifier$$Type): $KeybindRegistryKubeEvent$Builder
public "category"(category: StringJS): $KeybindRegistryKubeEvent$Builder
public "inGame"(): $KeybindRegistryKubeEvent$Builder
public "gui"(): $KeybindRegistryKubeEvent$Builder
public "conflictContext"(keyConflictContext: $KeyConflictContext$$Type): $KeybindRegistryKubeEvent$Builder
public "defaultKey"(keyName: StringJS): $KeybindRegistryKubeEvent$Builder
public "inputType"(inputType: $InputConstants$Type$$Type): $KeybindRegistryKubeEvent$Builder
public "scanCodeInputType"(): $KeybindRegistryKubeEvent$Builder
public "mouseInputType"(): $KeybindRegistryKubeEvent$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeybindRegistryKubeEvent$Builder$$Type = ($KeybindRegistryKubeEvent$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KeybindRegistryKubeEvent$Builder$$Original = $KeybindRegistryKubeEvent$Builder;}
declare module "dev.latvian.mods.kubejs.core.EntityKJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$WithPersistentData$$Interface} from "dev.latvian.mods.kubejs.core.WithPersistentData"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MessageSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$ScriptTypeHolder$$Interface} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $EntityKJS$$Interface extends $WithPersistentData$$Interface, $MessageSenderKJS$$Interface, $ScriptTypeHolder$$Interface {
get "peacefulCreature"(): boolean
get "waterCreature"(): boolean
get "ambientCreature"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "nbt"(): $CompoundTag
set "x"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "z"(value: double)
get "living"(): boolean
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "block"(): $LevelBlock
get "server"(): $MinecraftServer
get "motionX"(): double
set "motionY"(value: double)
get "facing"(): $Direction
get "profile"(): $GameProfile
get "frame"(): boolean
get "passengers"(): $EntityArrayList
get "item"(): $ItemStack
get "player"(): boolean
get "motionZ"(): double
get "type"(): StringJS
set "motionZ"(value: double)
get "animal"(): boolean
get "monster"(): boolean
get "teamId"(): StringJS
get "motionY"(): double
set "motionX"(value: double)
get "scriptType"(): $ScriptType
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $EntityKJS implements $EntityKJS$$Interface {
 "isPeacefulCreature"(): boolean
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isAmbientCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "getNbt"(): $CompoundTag
 "setX"(x: double): void
 "attack"(hp: float): void
 "spawn"(): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "runCommandSilent"(command: StringJS): void
 "self"(): $Entity
 "tell"(message: $Component$$Type): void
 "isLiving"(): boolean
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "playSound"(id: $SoundEvent$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "getServer"(): $MinecraftServer
 "getMotionX"(): double
 "setMotionY"(y: double): void
 "getFacing"(): $Direction
 "getProfile"(): $GameProfile
 "isFrame"(): boolean
 "getPassengers"(): $EntityArrayList
 "getItem"(): $ItemStack
 "isPlayer"(): boolean
 "setRotation"(yaw: float, pitch: float): void
 "getMotionZ"(): double
 "getType"(): StringJS
 "setMotionZ"(z: double): void
 "isAnimal"(): boolean
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "isMonster"(): boolean
 "getTeamId"(): StringJS
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getMotionY"(): double
 "setMotionX"(x: double): void
 "getScriptType"(): $ScriptType
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$$Type): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityKJS$$Type = ($EntityKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityKJS$$Original = $EntityKJS;}
declare module "dev.latvian.mods.kubejs.item.ItemTintFunction" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"

export interface $ItemTintFunction$$Interface {

(stack: $ItemStack, index: integer): $KubeColor$$Type
}

export class $ItemTintFunction implements $ItemTintFunction$$Interface {
static readonly "POTION": $ItemTintFunction
static readonly "TYPE_INFO": $TypeInfo
static readonly "BLOCK": $ItemTintFunction
static readonly "DISPLAY_COLOR_NBT": $ItemTintFunction
static readonly "MAP": $ItemTintFunction

static "wrap"(o: any): $ItemTintFunction
 "getColor"(stack: $ItemStack$$Type, index: integer): $KubeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTintFunction$$Type = (($ItemTintFunction$$Type)[]) | (StringJS) | ((stack: $ItemStack, index: integer) => void) | ((stack: $ItemStack, index: integer) => $KubeColor$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemTintFunction$$Original = $ItemTintFunction;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent" {
import {$Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"

export class $ChestMenuInventoryClickEvent {
readonly "button": integer
readonly "type": $ClickType

constructor(slot: $Slot$$Type, type: $ClickType$$Type, button: integer)

public "getIndex"(): integer
public "getItem"(): $ItemStack
public "setItem"(item: $ItemStack$$Type): void
get "index"(): integer
get "item"(): $ItemStack
set "item"(value: $ItemStack$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuInventoryClickEvent$$Type = ($ChestMenuInventoryClickEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuInventoryClickEvent$$Original = $ChestMenuInventoryClickEvent;}
declare module "dev.latvian.mods.kubejs.block.BlockRenderType" {
import {$Enum} from "java.lang.Enum"

export class $BlockRenderType extends $Enum<($BlockRenderType)> {
static readonly "CUTOUT": $BlockRenderType
static readonly "TRANSLUCENT": $BlockRenderType
static readonly "CUTOUT_MIPPED": $BlockRenderType
static readonly "SOLID": $BlockRenderType

public static "values"(): ($BlockRenderType)[]
public static "valueOf"(name: StringJS): $BlockRenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRenderType$$Type = (("solid") | ("cutout") | ("cutout_mipped") | ("translucent"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockRenderType$$Original = $BlockRenderType;}
declare module "dev.latvian.mods.kubejs.recipe.CachedItemTagLookup" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List, $List$$Type} from "java.util.List"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$CachedTagLookup} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup"

export class $CachedItemTagLookup extends $CachedTagLookup<($Item)> {
readonly "registry": $Registry<(T)>
readonly "originalMap": $Map<($ResourceLocation), ($List<($TagLoader$EntryWithSource)>)>

constructor(registry: $Registry$$Type<($Item$$Type)>, originalMap: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>)

public "isEmpty"(key: $TagKey$$Type<($Item)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedItemTagLookup$$Type = ($CachedItemTagLookup);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CachedItemTagLookup$$Original = $CachedItemTagLookup;}
declare module "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction" {
import {$CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Codec} from "com.mojang.serialization.Codec"
import {$IngredientActionHolder$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionHolder"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$IngredientActionType} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionType"

export interface $IngredientAction$$Interface {
get "type"(): $IngredientActionType<(never)>
}

export class $IngredientAction implements $IngredientAction$$Interface {
static readonly "CODEC": $Codec<($IngredientAction)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IngredientAction)>

 "transform"(old: $ItemStack$$Type, index: integer, input: $CraftingInput$$Type): $ItemStack
 "getType"(): $IngredientActionType<(never)>
static "getRemaining"(input: $CraftingInput$$Type, index: integer, ingredientActions: $List$$Type<($IngredientActionHolder$$Type)>): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientAction$$Type = ($IngredientAction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientAction$$Original = $IngredientAction;}
declare module "dev.latvian.mods.kubejs.core.EntityTypeKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$List} from "java.util.List"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$Holder} from "net.minecraft.core.Holder"
import {$EntityType} from "net.minecraft.world.entity.EntityType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $EntityTypeKJS$$Interface extends $RegistryObjectKJS$$Interface<($EntityType<(never)>)> {
get "registry"(): $Registry<($EntityType<(never)>)>
get "registryId"(): $ResourceKey<($Registry<($EntityType<(never)>)>)>
get "id"(): StringJS
get "key"(): $ResourceKey<($EntityType<(never)>)>
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($EntityType<(never)>)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $EntityTypeKJS implements $EntityTypeKJS$$Interface {
 "getRegistry"(): $Registry<($EntityType<(never)>)>
 "getRegistryId"(): $ResourceKey<($Registry<($EntityType<(never)>)>)>
 "specialEquals"(o: any, shallow: boolean): boolean
 "getId"(): StringJS
 "getKey"(): $ResourceKey<($EntityType<(never)>)>
 "getMod"(): StringJS
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getIdLocation"(): $ResourceLocation
 "asHolder"(): $Holder<($EntityType<(never)>)>
 "getTagKeys"(): $List<($TagKey<($EntityType<(never)>)>)>
 "getTags"(): $List<($ResourceLocation)>
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityTypeKJS$$Type = ($EntityTypeKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityTypeKJS$$Original = $EntityTypeKJS;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment" {
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockEntityAttachment$$Interface {
get "wrappedObject"(): any
}

export class $BlockEntityAttachment implements $BlockEntityAttachment$$Interface {
 "getCapability"<CAP, SRC>(capability: $BlockCapability$$Type<(CAP), (SRC)>): CAP
 "serialize"(registries: $HolderLookup$Provider$$Type): $Tag
 "deserialize"(registries: $HolderLookup$Provider$$Type, tag: $Tag$$Type): void
 "onRemove"(level: $ServerLevel$$Type, blockEntity: $KubeBlockEntity$$Type, newState: $BlockState$$Type): void
 "serverTick"(): void
 "getWrappedObject"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachment$$Type = ($BlockEntityAttachment);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityAttachment$$Original = $BlockEntityAttachment;}
declare module "dev.latvian.mods.kubejs.client.LangKubeEvent$Key" {
import {$Record} from "java.lang.Record"

export class $LangKubeEvent$Key extends $Record {
constructor(namespace: StringJS, lang: StringJS, key: StringJS)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "key"(): StringJS
public "lang"(): StringJS
public "namespace"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LangKubeEvent$Key$$Type = ({"key"?: StringJS, "namespace"?: StringJS, "lang"?: StringJS}) | ([key?: StringJS, namespace?: StringJS, lang?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LangKubeEvent$Key$$Original = $LangKubeEvent$Key;}
declare module "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$MultipartBlockStateGenerator$Part$$Type} from "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator$Part"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $MultipartBlockStateGenerator {
constructor()

public "part"(when: StringJS, model: $ResourceLocation$$Type): void
public "part"(when: StringJS, consumer: $Consumer$$Type<($MultipartBlockStateGenerator$Part)>): void
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultipartBlockStateGenerator$$Type = ($MultipartBlockStateGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultipartBlockStateGenerator$$Original = $MultipartBlockStateGenerator;}
declare module "dev.latvian.mods.kubejs.event.EventGroup" {
import {$EventHandler} from "dev.latvian.mods.kubejs.event.EventHandler"
import {$KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Map} from "java.util.Map"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Class$$Type} from "java.lang.Class"
import {$ScriptTypePredicate$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"

export class $EventGroup {
readonly "name": StringJS

public "equals"(obj: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "add"(name: StringJS, scriptType: $ScriptTypePredicate$$Type, eventType: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public static "of"(name: StringJS): $EventGroup
public "common"(name: StringJS, eventType: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public "getHandlers"(): $Map<(StringJS), ($EventHandler)>
public "server"(name: StringJS, eventType: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public "startup"(name: StringJS, eventType: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public "client"(name: StringJS, eventType: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
get "handlers"(): $Map<(StringJS), ($EventHandler)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventGroup$$Type = ($EventGroup);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventGroup$$Original = $EventGroup;}
declare module "dev.latvian.mods.kubejs.script.data.VirtualDataPack" {
import {$GeneratedDataStage, $GeneratedDataStage$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedDataStage"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Component} from "net.minecraft.network.chat.Component"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$VirtualResourcePack} from "dev.latvian.mods.kubejs.script.data.VirtualResourcePack"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$VillagerProfession$$Type} from "net.minecraft.world.entity.npc.VillagerProfession"
import {$KubeDataGenerator$$Interface} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$PackType} from "net.minecraft.server.packs.PackType"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$VirtualDataMapFile$$Type} from "dev.latvian.mods.kubejs.script.data.VirtualDataMapFile"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$DataMapType$$Type} from "net.neoforged.neoforge.registries.datamaps.DataMapType"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$VillagerType$$Type} from "net.minecraft.world.entity.npc.VillagerType"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $VirtualDataPack extends $VirtualResourcePack implements $KubeDataGenerator$$Interface {
readonly "component": $Component
readonly "stage": $GeneratedDataStage
readonly "scriptType": $ScriptType
readonly "packType": $PackType
readonly "registries": $Supplier<($RegistryAccessContainer)>
readonly "info": StringJS

constructor(stage: $GeneratedDataStage$$Type, registries: $Supplier$$Type<($RegistryAccessContainer$$Type)>)

public "reset"(): void
public "flush"(): void
public "dataMap"<R, T>(type: $DataMapType$$Type<(R), (T)>, consumer: $Consumer$$Type<($VirtualDataMapFile<(R), (T)>)>): void
public "setWaxable"(from: $Block$$Type, to: $Block$$Type): void
public "setVillagerType"(biome: $ResourceKey$$Type<($Biome)>, villagerType: $VillagerType$$Type): void
public "setCompostable"(items: $ItemPredicate$$Type, chance: float, canVillagerCompost: boolean): void
public "removeFurnaceFuel"(items: $ItemPredicate$$Type): void
public "setParrotImitation"(type: $EntityType$$Type<(never)>, sound: $SoundEvent$$Type): void
public "setMonsterRoomMobs"(entityType: $EntityType$$Type<(never)>, weight: integer): void
public "setRaidHeroGifts"(profession: $VillagerProfession$$Type, lootTable: $ResourceKey$$Type<($LootTable)>): void
public "removeCompostable"(items: $ItemPredicate$$Type): void
public "setFurnaceFuel"(items: $ItemPredicate$$Type, ticks: $TickDuration$$Type): void
public "setOxidizable"(from: $Block$$Type, to: $Block$$Type): void
public "setVibrationFrequency"(gameEvent: $GameEvent$$Type, frequency: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualDataPack$$Type = ($VirtualDataPack);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VirtualDataPack$$Original = $VirtualDataPack;}
declare module "dev.latvian.mods.kubejs.block.entity.InventoryAttachment$Factory" {
import {$BlockCapability} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockEntityAttachmentFactory$$Interface} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$List} from "java.util.List"
import {$BlockEntityAttachment} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record} from "java.lang.Record"

export class $InventoryAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory$$Interface {
constructor(width: integer, height: integer, inputFilter: ($ItemPredicate$$Type)?)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "create"(info: $BlockEntityAttachmentInfo$$Type, entity: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "width"(): integer
public "getCapabilities"(): $List<($BlockCapability<(never), (never)>)>
public "height"(): integer
public "inputFilter"(): $Optional<($ItemPredicate)>
public "isTicking"(): boolean
get "capabilities"(): $List<($BlockCapability<(never), (never)>)>
get "ticking"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryAttachment$Factory$$Type = ({"inputFilter"?: ($ItemPredicate$$Type)?, "height"?: integer, "width"?: integer}) | ([inputFilter?: ($ItemPredicate$$Type)?, height?: integer, width?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InventoryAttachment$Factory$$Original = $InventoryAttachment$Factory;}
declare module "dev.latvian.mods.kubejs.web.KJSWSSession" {
import {$WSSession} from "dev.latvian.apps.tinyserver.ws.WSSession"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$SessionInfo} from "dev.latvian.mods.kubejs.web.SessionInfo"
import {$KJSHTTPRequest} from "dev.latvian.mods.kubejs.web.KJSHTTPRequest"

export class $KJSWSSession extends $WSSession<($KJSHTTPRequest)> {
 "info": $SessionInfo

constructor()

public "onEvent"(type: StringJS, payload: $JsonElement$$Type): void
public "onTextMessage"(message: StringJS): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KJSWSSession$$Type = ($KJSWSSession);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KJSWSSession$$Original = $KJSWSSession;}
declare module "dev.latvian.mods.kubejs.block.custom.DoorBlockBuilder" {
import {$KubeDataGenerator$$Type} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $DoorBlockBuilder extends $ShapedBlockBuilder {
static readonly "DOOR_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "WOODEN_DOOR_TAGS": ($ResourceLocation)[]

constructor(i: $ResourceLocation$$Type)

public "wooden"(): this
public "behaviour"(wt: $BlockSetType$$Type): this
public "generateLootTable"(generator: $KubeDataGenerator$$Type): $LootTable
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoorBlockBuilder$$Type = ($DoorBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoorBlockBuilder$$Original = $DoorBlockBuilder;}
declare module "dev.latvian.mods.kubejs.block.DetectorBlock$Builder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $DetectorBlock$Builder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "detectorId"(id: StringJS): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DetectorBlock$Builder$$Type = ($DetectorBlock$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DetectorBlock$Builder$$Original = $DetectorBlock$Builder;}
declare module "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"

export interface $ScheduledEvents$Callback$$Interface {

(event: $ScheduledEvents$ScheduledEvent): void
}

export class $ScheduledEvents$Callback implements $ScheduledEvents$Callback$$Interface {
static readonly "TYPE_INFO": $TypeInfo

 "onCallback"(event: $ScheduledEvents$ScheduledEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledEvents$Callback$$Type = ((event: $ScheduledEvents$ScheduledEvent) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduledEvents$Callback$$Original = $ScheduledEvents$Callback;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponent" {
import {$TinyMap} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$OpsContainer$$Type} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$CustomObjectRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent"
import {$RecipeKey} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$EitherRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent"
import {$CustomObjectRecipeComponent$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$RecipeComponentBuilder} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder"
import {$RecipeComponentType} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$ListRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.ListRecipeComponent"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"

export interface $RecipeComponent$$Interface<T> {
get "ignored"(): boolean
}

export class $RecipeComponent<T> implements $RecipeComponent$$Interface {
 "type"(): $RecipeComponentType<(never)>
 "toString"(ops: $OpsContainer$$Type, value: T): StringJS
 "wrap"(cx: $RecipeScriptContext$$Type, from: any): T
 "isEmpty"(value: T): boolean
 "replace"(cx: $RecipeScriptContext$$Type, original: T, match: $ReplacementMatchInfo$$Type, arg3: any): T
 "matches"(cx: $RecipeMatchContext$$Type, value: T, match: $ReplacementMatchInfo$$Type): boolean
static "builder"(keys: $List$$Type<($CustomObjectRecipeComponent$Key$$Type)>): $CustomObjectRecipeComponent
static "builder"(...keys: ($CustomObjectRecipeComponent$Key$$Type)[]): $CustomObjectRecipeComponent
 "validate"(ctx: $RecipeValidationContext$$Type, value: T): void
 "typeInfo"(): $TypeInfo
 "key"(name: StringJS, role: $ComponentRole$$Type): $RecipeKey<(T)>
 "asList"(): $ListRecipeComponent<(T)>
 "spread"(value: T): $List<(never)>
 "or"<O>(other: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<(T), (O)>
 "readFromJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<(T)>, json: $JsonObject$$Type): void
 "asListOrSelf"(): $ListRecipeComponent<(T)>
 "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (T)>)>
 "asConditionalList"(): $ListRecipeComponent<(T)>
 "writeToJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<(T)>, json: $JsonObject$$Type): void
 "buildUniqueId"(builder: $UniqueIdBuilder$$Type, value: T): void
 "isIgnored"(): boolean
 "otherKey"(name: StringJS): $RecipeKey<(T)>
 "createBuilder"(): $RecipeComponentBuilder
 "inputKey"(name: StringJS): $RecipeKey<(T)>
 "asMap"<K>(key: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), (T)>)>
 "codec"(): $Codec<(T)>
 "orSelf"(): $RecipeComponent<(T)>
 "allowEmpty"(): boolean
 "asConditionalListOrSelf"(): $ListRecipeComponent<(T)>
 "withCodec"(codec: $Codec$$Type<(T)>): $RecipeComponent<(T)>
 "outputKey"(name: StringJS): $RecipeKey<(T)>
 "hasPriority"(cx: $RecipeMatchContext$$Type, from: any): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponent$$Type<T> = ($RecipeComponent<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponent$$Original<T> = $RecipeComponent<(T)>;}
declare module "dev.latvian.mods.kubejs.core.ClientLevelKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$SpriteSet$$Type} from "net.minecraft.client.particle.SpriteSet"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$ExplosionProperties$$Type} from "dev.latvian.mods.kubejs.level.ExplosionProperties"
import {$LevelKJS$$Interface} from "dev.latvian.mods.kubejs.core.LevelKJS"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$KubeAnimatedParticle} from "dev.latvian.mods.kubejs.client.KubeAnimatedParticle"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ClientLevelKJS$$Interface extends $LevelKJS$$Interface {

(): $AttachedData$$Type<($Level$$Type)>
get "name"(): $Component
get "overworld"(): boolean
get "dimension"(): $ResourceLocation
set "time"(value: long)
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "side"(): $ScriptType
get "data"(): $AttachedData<($Level)>
get "mcEntities"(): $Iterable<($Entity)>
get "players"(): $EntityArrayList
get "mcPlayers"(): $List<($Player)>
get "displayName"(): $Component
get "entities"(): $EntityArrayList
}

export class $ClientLevelKJS implements $ClientLevelKJS$$Interface {
 "kubeParticle"(x: double, y: double, z: double, spriteSet: $SpriteSet$$Type): $KubeAnimatedParticle
 "self"(): $EntityGetter
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean): void
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean, cause: $ServerPlayer$$Type): void
 "isOverworld"(): boolean
 "explode"(x: double, y: double, z: double, properties: $ExplosionProperties$$Type): $Explosion
 "createEntity"(type: $EntityType$$Type<(never)>): $Entity
 "spawnEntity"(type: $EntityType$$Type<(never)>, callback: $Consumer$$Type<($Entity)>): void
 "spawnFireworks"(x: double, y: double, z: double, fireworks: $Fireworks$$Type, lifetime: integer): void
 "spawnParticles"(options: $ParticleOptions$$Type, overrideLimiter: boolean, x: double, y: double, z: double, vx: double, vy: double, vz: double, count: integer, speed: double): void
 "getDimension"(): $ResourceLocation
 "setTime"(time: long): void
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "tell"(message: $Component$$Type): void
 "getBlock"(x: integer, y: integer, z: integer): $LevelBlock
 "getBlock"(entity: $BlockEntity$$Type): $LevelBlock
 "getBlock"(pos: $BlockPos$$Type): $LevelBlock
 "getSide"(): $ScriptType
 "getData"(): $AttachedData<($Level)>
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getPlayers"(): $EntityArrayList
 "getMcPlayers"(): $List<($Player)>
 "getDisplayName"(): $Component
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntities"(): $EntityArrayList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientLevelKJS$$Type = (() => $AttachedData$$Type<($Level$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientLevelKJS$$Original = $ClientLevelKJS;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType" {
import {$RecipeTypeRegistryContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Function$$Type} from "java.util.function.Function"
import {$ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeKey} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$RecipeComponentCodecFactory$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentCodecFactory"
import {$RecipeComponentType$Unit} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType$Unit"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $RecipeComponentType<T> {
constructor(id: $ResourceLocation$$Type)

public "equals"(obj: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): $ResourceLocation
public "key"(name: StringJS, role: $ComponentRole$$Type): $RecipeKey<(T)>
public static "dynamic"<CT extends $RecipeComponent<(object)>>(id: $ResourceLocation$$Type, mapCodec: $MapCodec$$Type<(CT)>): $RecipeComponentType<(never)>
public static "dynamic"<CT extends $RecipeComponent<(object)>>(id: $ResourceLocation$$Type, codecFactory: $RecipeComponentCodecFactory$$Type<(CT)>): $RecipeComponentType<(never)>
public "instance"(): $RecipeComponent<(T)>
public static "unit"<T>(id: $ResourceLocation$$Type, instance: $RecipeComponent$$Type<(T)>): $RecipeComponentType$Unit<(T)>
public static "unit"<T>(id: $ResourceLocation$$Type, instanceGetter: $Function$$Type<($RecipeComponentType<(T)>), ($RecipeComponent$$Type<(T)>)>): $RecipeComponentType$Unit<(T)>
public "otherKey"(name: StringJS): $RecipeKey<(T)>
public "isUnit"(): boolean
public "inputKey"(name: StringJS): $RecipeKey<(T)>
public "mapCodec"(ctx: $RecipeTypeRegistryContext$$Type): $MapCodec<($RecipeComponent<(never)>)>
public "outputKey"(name: StringJS): $RecipeKey<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentType$$Type<T> = ($RecipeComponentType<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponentType$$Original<T> = $RecipeComponentType<(T)>;}
declare module "dev.latvian.mods.kubejs.core.ItemKJS" {
import {$Map} from "java.util.Map"
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"
import {$List} from "java.util.List"
import {$Holder} from "net.minecraft.core.Holder"
import {$ItemStackKey} from "dev.latvian.mods.kubejs.item.ItemStackKey"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$IngredientSupplierKJS$$Interface} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ItemBuilder, $ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ItemKJS$$Interface extends $IngredientSupplierKJS$$Interface, $RegistryObjectKJS$$Interface<($Item)> {
get "typeItemStackKey"(): $ItemStackKey
set "craftingRemainder"(value: $Item$$Type)
get "item"(): $Item
get "typeData"(): $Map<(StringJS), (any)>
set "nameKey"(value: StringJS)
set "canRepair"(value: boolean)
set "itemBuilder"(value: $ItemBuilder$$Type)
get "registry"(): $Registry<($Item)>
get "registryId"(): $ResourceKey<($Registry<($Item)>)>
get "itemBuilder"(): $ItemBuilder
get "id"(): StringJS
get "key"(): $ResourceKey<($Item)>
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Item)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $ItemKJS implements $ItemKJS$$Interface {
 "getTypeItemStackKey"(): $ItemStackKey
 "setCraftingRemainder"(i: $Item$$Type): void
 "getItem"(): $Item
 "getTypeData"(): $Map<(StringJS), (any)>
 "setNameKey"(key: StringJS): void
 "setCanRepair"(repairable: boolean): void
 "setItemBuilder"(b: $ItemBuilder$$Type): void
 "getRegistry"(): $Registry<($Item)>
 "getRegistryId"(): $ResourceKey<($Registry<($Item)>)>
 "getItemBuilder"(): $ItemBuilder
 "kjs$asIngredient"(): $Ingredient
 "specialEquals"(o: any, shallow: boolean): boolean
 "getId"(): StringJS
 "getKey"(): $ResourceKey<($Item)>
 "getMod"(): StringJS
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getIdLocation"(): $ResourceLocation
 "asHolder"(): $Holder<($Item)>
 "getTagKeys"(): $List<($TagKey<($Item)>)>
 "getTags"(): $List<($ResourceLocation)>
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemKJS$$Type = ($ItemKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemKJS$$Original = $ItemKJS;}
declare module "dev.latvian.mods.kubejs.player.InventoryKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player opens or closes a container.
 */
export class $InventoryKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, menu: $AbstractContainerMenu$$Type)

/**
 * Gets the player that opened or closed the container.
 */
public "getEntity"(): $LivingEntity
/**
 * Gets the container that was opened or closed.
 */
public "getInventoryContainer"(): $AbstractContainerMenu
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "entity"(): $LivingEntity
get "inventoryContainer"(): $AbstractContainerMenu
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryKubeEvent$$Type = ($InventoryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InventoryKubeEvent$$Original = $InventoryKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicateDataCheck" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"

export interface $BlockEntityPredicateDataCheck$$Interface {

(data: $CompoundTag): boolean
}

export class $BlockEntityPredicateDataCheck implements $BlockEntityPredicateDataCheck$$Interface {
 "checkData"(data: $CompoundTag$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityPredicateDataCheck$$Type = ((data: $CompoundTag) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityPredicateDataCheck$$Original = $BlockEntityPredicateDataCheck;}
declare module "dev.latvian.mods.kubejs.gui.KubeJSGUI" {
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$InventoryKJS, $InventoryKJS$$Type} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$SimpleContainer} from "net.minecraft.world.SimpleContainer"
import {$Component} from "net.minecraft.network.chat.Component"

export class $KubeJSGUI {
 "playerSlotsY": integer
 "playerSlotsX": integer
 "inventoryHeight": integer
 "width": integer
 "inventoryLabelY": integer
 "inventoryWidth": integer
 "inventoryLabelX": integer
 "title": $Component
 "inventory": $InventoryKJS
static readonly "EMPTY_CONTAINER": $SimpleContainer
 "height": integer

constructor()
constructor(buf: $FriendlyByteBuf$$Type)

public "write"(buf: $FriendlyByteBuf$$Type): void
public "setInventory"(inv: $InventoryKJS$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSGUI$$Type = ($KubeJSGUI);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSGUI$$Original = $KubeJSGUI;}
declare module "dev.latvian.mods.kubejs.block.entity.CustomCapabilityAttachment$Factory" {
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$BlockEntityAttachmentFactory$$Interface} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$List} from "java.util.List"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$BlockEntityAttachment} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record} from "java.lang.Record"

export class $CustomCapabilityAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory$$Interface {
constructor(type: $BlockCapability$$Type<(never), (never)>, dataFactory: $Supplier$$Type<(never)>)

public "type"(): $BlockCapability<(never), (never)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "create"(info: $BlockEntityAttachmentInfo$$Type, entity: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "dataFactory"(): $Supplier<(never)>
public "getCapabilities"(): $List<($BlockCapability<(never), (never)>)>
public "isTicking"(): boolean
get "capabilities"(): $List<($BlockCapability<(never), (never)>)>
get "ticking"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomCapabilityAttachment$Factory$$Type = ({"dataFactory"?: $Supplier$$Type<(never)>, "type"?: $BlockCapability$$Type<(never), (never)>}) | ([dataFactory?: $Supplier$$Type<(never)>, type?: $BlockCapability$$Type<(never), (never)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomCapabilityAttachment$Factory$$Original = $CustomCapabilityAttachment$Factory;}
declare module "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key" {
import {$RecipeTypeRegistryContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$Record} from "java.lang.Record"

export class $CustomObjectRecipeComponent$Key extends $Record {
constructor(name: StringJS, component: $RecipeComponent$$Type<(never)>, optional: boolean, alwaysWrite: boolean)
constructor(name: StringJS, component: $RecipeComponent$$Type<(never)>)
constructor(name: StringJS, component: $RecipeComponent$$Type<(never)>, optional: boolean)

public "name"(): StringJS
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "component"(): $RecipeComponent<(never)>
public "optional"(): boolean
public "alwaysWrite"(): boolean
public static "createCodec"(ctx: $RecipeTypeRegistryContext$$Type): $Codec<($CustomObjectRecipeComponent$Key)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomObjectRecipeComponent$Key$$Type = ({"name"?: StringJS, "optional"?: boolean, "alwaysWrite"?: boolean, "component"?: $RecipeComponent$$Type<(never)>}) | ([name?: StringJS, optional?: boolean, alwaysWrite?: boolean, component?: $RecipeComponent$$Type<(never)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomObjectRecipeComponent$Key$$Original = $CustomObjectRecipeComponent$Key;}
declare module "dev.latvian.mods.kubejs.block.BlockTintFunction" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$BlockAndTintGetter, $BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockTintFunction$Fixed} from "dev.latvian.mods.kubejs.block.BlockTintFunction$Fixed"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockTintFunction$$Interface {

(state: $BlockState, level: $BlockAndTintGetter, pos: $BlockPos, index: integer): $KubeColor$$Type
}

export class $BlockTintFunction implements $BlockTintFunction$$Interface {
static readonly "REDSTONE": $BlockTintFunction
static readonly "BIRCH_FOLIAGE": $BlockTintFunction$Fixed
static readonly "TYPE_INFO": $TypeInfo
static readonly "GRASS": $BlockTintFunction
static readonly "MANGROVE_FOLIAGE": $BlockTintFunction$Fixed
static readonly "FOLIAGE": $BlockTintFunction
static readonly "EVERGREEN_FOLIAGE": $BlockTintFunction$Fixed
static readonly "REDSTONE_COLORS": ($KubeColor)[]
static readonly "DEFAULT_FOLIAGE_COLOR": $KubeColor
static readonly "WATER": $BlockTintFunction

static "wrap"(o: any): $BlockTintFunction
 "getColor"(state: $BlockState$$Type, level: $BlockAndTintGetter$$Type, pos: $BlockPos$$Type, index: integer): $KubeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTintFunction$$Type = (($BlockTintFunction$$Type)[]) | (StringJS) | ((state: $BlockState, level: $BlockAndTintGetter, pos: $BlockPos, index: integer) => $KubeColor$$Type) | ((state: $BlockState, level: $BlockAndTintGetter, pos: $BlockPos, index: integer) => $KubeColor$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockTintFunction$$Original = $BlockTintFunction;}
declare module "dev.latvian.mods.kubejs.block.custom.CardinalBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $CardinalBlockBuilder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CardinalBlockBuilder$$Type = ($CardinalBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CardinalBlockBuilder$$Original = $CardinalBlockBuilder;}
declare module "dev.latvian.mods.kubejs.misc.PotionBuilder" {
import {$MobEffectInstance$$Type} from "net.minecraft.world.effect.MobEffectInstance"
import {$Potion} from "net.minecraft.world.item.alchemy.Potion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"

export class $PotionBuilder extends $BuilderBase<($Potion)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "addEffect"(effect: $MobEffectInstance$$Type): this
public "effect"(effect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer, ambient: boolean, visible: boolean, showIcon: boolean): this
public "effect"(effect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer, ambient: boolean, visible: boolean, showIcon: boolean, hiddenEffect: $MobEffectInstance$$Type): this
public "effect"(effect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer): this
public "effect"(effect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer, ambient: boolean, visible: boolean): this
public "effect"(effect: $Holder$$Type<($MobEffect)>, duration: integer): this
public "effect"(effect: $Holder$$Type<($MobEffect)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotionBuilder$$Type = ($PotionBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PotionBuilder$$Original = $PotionBuilder;}
declare module "dev.latvian.mods.kubejs.util.OpsContainer" {
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $OpsContainer {
static readonly "DEFAULT": $OpsContainer

constructor(nbt: $DynamicOps$$Type<($Tag$$Type)>, json: $DynamicOps$$Type<($JsonElement$$Type)>, java: $DynamicOps$$Type<(any)>)

public "decode"<T>(codec: $Codec$$Type<(T)>, o: any): T
public "java"(): $DynamicOps<(any)>
public "json"(): $DynamicOps<($JsonElement)>
public "nbt"(): $DynamicOps<($Tag)>
public "decodeMap"<T>(codec: $MapCodec$$Type<(T)>, o: any): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpsContainer$$Type = ($OpsContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OpsContainer$$Original = $OpsContainer;}
declare module "dev.latvian.mods.kubejs.item.ModifyItemTooltipsKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$TooltipRequirements$$Type} from "dev.latvian.mods.kubejs.text.tooltip.TooltipRequirements"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$ItemTooltipData$$Type} from "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$TextActionBuilder$$Type} from "dev.latvian.mods.kubejs.text.action.TextActionBuilder"

export class $ModifyItemTooltipsKubeEvent implements $KubeEvent$$Interface {
constructor(callback: $Consumer$$Type<($ItemTooltipData)>)

public "add"(filter: $Ingredient$$Type, requirements: $TooltipRequirements$$Type, text: $List$$Type<($Component$$Type)>): void
public "add"(filter: $Ingredient$$Type, text: $List$$Type<($Component$$Type)>): void
public "modify"(filter: $Ingredient$$Type, consumer: $Consumer$$Type<($TextActionBuilder)>): void
public "modify"(filter: $Ingredient$$Type, requirements: $TooltipRequirements$$Type, consumer: $Consumer$$Type<($TextActionBuilder)>): void
public "modifyAll"(requirements: $TooltipRequirements$$Type, consumer: $Consumer$$Type<($TextActionBuilder)>): void
public "modifyAll"(consumer: $Consumer$$Type<($TextActionBuilder)>): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifyItemTooltipsKubeEvent$$Type = ($ModifyItemTooltipsKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModifyItemTooltipsKubeEvent$$Original = $ModifyItemTooltipsKubeEvent;}
declare module "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS" {
import {$MobEffectInstance, $MobEffectInstance$$Type} from "net.minecraft.world.effect.MobEffectInstance"
import {$Collection} from "java.util.Collection"
import {$Map} from "java.util.Map"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$MobEffect, $MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $EntityPotionEffectsJS {
constructor(e: $LivingEntity$$Type)

public "clear"(): void
public "add"(mobEffect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer): void
public "add"(mobEffect: $Holder$$Type<($MobEffect)>, duration: integer): void
public "add"(mobEffect: $Holder$$Type<($MobEffect)>): void
public "add"(mobEffect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer, ambient: boolean, showParticles: boolean): void
public "isActive"(mobEffect: $Holder$$Type<($MobEffect)>): boolean
public "getMap"(): $Map<($Holder<($MobEffect)>), ($MobEffectInstance)>
public "getDuration"(mobEffect: $Holder$$Type<($MobEffect)>): integer
public "isApplicable"(effect: $MobEffectInstance$$Type): boolean
public "getActive"(): $Collection<($MobEffectInstance)>
public "getActive"(mobEffect: $Holder$$Type<($MobEffect)>): $MobEffectInstance
get "map"(): $Map<($Holder<($MobEffect)>), ($MobEffectInstance)>
get "active"(): $Collection<($MobEffectInstance)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityPotionEffectsJS$$Type = ($EntityPotionEffectsJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityPotionEffectsJS$$Original = $EntityPotionEffectsJS;}
declare module "dev.latvian.mods.kubejs.web.RelativeURL" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Record} from "java.lang.Record"

export class $RelativeURL extends $Record {
constructor(path: StringJS)
constructor(path: StringJS, query: $Map$$Type<(StringJS), (StringJS)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "query"(): $Map<(StringJS), (StringJS)>
public "path"(): StringJS
public "fullString"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RelativeURL$$Type = ({"path"?: StringJS, "query"?: $Map$$Type<(StringJS), (StringJS)>}) | ([path?: StringJS, query?: $Map$$Type<(StringJS), (StringJS)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RelativeURL$$Original = $RelativeURL;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentHandler" {
import {$BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Set$$Type} from "java.util.Set"
import {$FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"

export interface $BlockEntityAttachmentHandler$$Interface {
}

export class $BlockEntityAttachmentHandler implements $BlockEntityAttachmentHandler$$Interface {
 "attach"(id: StringJS, type: $ResourceLocation$$Type, directions: $Set$$Type<($Direction$$Type)>, args: any): void
 "inventory"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, width: integer, height: integer, inputFilter: $ItemPredicate$$Type): void
 "inventory"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, width: integer, height: integer): void
 "fluidTank"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer): void
 "fluidTank"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer, inputFilter: $FluidIngredient$$Type): void
 "energyStorage"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer, maxReceive: integer, maxExtract: integer, autoOutput: integer): void
 "attachCustomCapability"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capability: $BlockCapability$$Type<(never), (never)>, dataFactory: $Supplier$$Type<(never)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentHandler$$Type = ($BlockEntityAttachmentHandler);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityAttachmentHandler$$Original = $BlockEntityAttachmentHandler;}
declare module "dev.latvian.mods.kubejs.core.ReloadableServerResourceHolderKJS" {
import {$ReloadableServerResourcesKJS, $ReloadableServerResourcesKJS$$Type} from "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ReloadableServerResourceHolderKJS$$Interface {
}

export class $ReloadableServerResourceHolderKJS implements $ReloadableServerResourceHolderKJS$$Interface {
 "kjs$setResources"(resources: $ReloadableServerResourcesKJS$$Type): void
 "kjs$getResources"(): $ReloadableServerResourcesKJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReloadableServerResourceHolderKJS$$Type = ($ReloadableServerResourceHolderKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReloadableServerResourceHolderKJS$$Original = $ReloadableServerResourceHolderKJS;}
declare module "dev.latvian.mods.kubejs.recipe.CompostableRecipesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$VirtualDataMapFile, $VirtualDataMapFile$$Type} from "dev.latvian.mods.kubejs.script.data.VirtualDataMapFile"
import {$Compostable, $Compostable$$Type} from "net.neoforged.neoforge.registries.datamaps.builtin.Compostable"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Record} from "java.lang.Record"

export class $CompostableRecipesKubeEvent extends $Record implements $KubeEvent$$Interface {
constructor(compostables: $VirtualDataMapFile$$Type<($Item$$Type), ($Compostable$$Type)>)

public "remove"(match: $ItemPredicate$$Type): void
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "replaceAll"(): void
public "add"(match: $ItemPredicate$$Type, f: float, villager: boolean): void
public "add"(match: $ItemPredicate$$Type, f: float): void
public "removeAll"(): void
public "compostables"(): $VirtualDataMapFile<($Item), ($Compostable)>
public "addReplace"(match: $ItemPredicate$$Type, f: float, villager: boolean): void
public "addReplace"(match: $ItemPredicate$$Type, f: float): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompostableRecipesKubeEvent$$Type = ({"compostables"?: $VirtualDataMapFile$$Type<($Item$$Type), ($Compostable$$Type)>}) | ([compostables?: $VirtualDataMapFile$$Type<($Item$$Type), ($Compostable$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CompostableRecipesKubeEvent$$Original = $CompostableRecipesKubeEvent;}
declare module "dev.latvian.mods.kubejs.player.PlayerStatsJS" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Stat, $Stat$$Type} from "net.minecraft.stats.Stat"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$StatsCounter$$Type} from "net.minecraft.stats.StatsCounter"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $PlayerStatsJS {
readonly "player": $Player

constructor(p: $Player$$Type, s: $StatsCounter$$Type)

public "get"(stat: $Stat$$Type<(never)>): integer
public "add"(stat: $Stat$$Type<(never)>, value: integer): void
public "set"(stat: $Stat$$Type<(never)>, value: integer): void
public static "wrapStat"(o: any): $Stat<(never)>
public "getPlayTime"(): integer
public "getItemsDropped"(item: $Item$$Type): integer
public "getKilledBy"(entity: $EntityType$$Type<(never)>): integer
public "getCrouchDistance"(): integer
public "getDamageAbsorbed"(): integer
public "getDamageResisted"(): integer
public "getMobKills"(): integer
public "getAnimalsBred"(): integer
public "getPlayerKills"(): integer
public "getTimeSinceRest"(): integer
public "getFishCaught"(): integer
public "getDamageTaken"(): integer
public "getBlocksMined"(block: $Block$$Type): integer
public "getItemsCrafted"(item: $Item$$Type): integer
public "getItemsUsed"(item: $Item$$Type): integer
public "getItemsPickedUp"(item: $Item$$Type): integer
public "getTimeSinceDeath"(): integer
public "getSwimDistance"(): integer
public "getItemsBroken"(item: $Item$$Type): integer
public "getTimeCrouchTime"(): integer
public "getSprintDistance"(): integer
public "getWalkDistance"(): integer
public "getDamageDealt"(): integer
public "getDeaths"(): integer
public "getJumps"(): integer
public "getKilled"(entity: $EntityType$$Type<(never)>): integer
public "getDamageBlocked_by_shield"(): integer
public "getDamageDealt_absorbed"(): integer
public "getDamageDealt_resisted"(): integer
get "playTime"(): integer
get "crouchDistance"(): integer
get "damageAbsorbed"(): integer
get "damageResisted"(): integer
get "mobKills"(): integer
get "animalsBred"(): integer
get "playerKills"(): integer
get "timeSinceRest"(): integer
get "fishCaught"(): integer
get "damageTaken"(): integer
get "timeSinceDeath"(): integer
get "swimDistance"(): integer
get "timeCrouchTime"(): integer
get "sprintDistance"(): integer
get "walkDistance"(): integer
get "damageDealt"(): integer
get "deaths"(): integer
get "jumps"(): integer
get "damageBlocked_by_shield"(): integer
get "damageDealt_absorbed"(): integer
get "damageDealt_resisted"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerStatsJS$$Type = ($PlayerStatsJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerStatsJS$$Original = $PlayerStatsJS;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $RecipeComponentBuilder$$Interface {
}

export class $RecipeComponentBuilder implements $RecipeComponentBuilder$$Interface {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentBuilder$$Type = ($RecipeComponentBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponentBuilder$$Original = $RecipeComponentBuilder;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.AddEntriesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $AddEntriesKubeEvent$$Interface<E, F> extends $KubeEvent$$Interface {

(items: E): void
}

export class $AddEntriesKubeEvent<E, F> implements $AddEntriesKubeEvent$$Interface {
 "add"(items: E): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddEntriesKubeEvent$$Type<E, F> = ((items: (any)[]) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AddEntriesKubeEvent$$Original<E, F> = $AddEntriesKubeEvent<(E), (F)>;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$FinishUsingCallback" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export interface $ItemBuilder$FinishUsingCallback$$Interface {

(itemStack: $ItemStack, level: $Level, livingEntity: $LivingEntity): $ItemStack$$Type
}

export class $ItemBuilder$FinishUsingCallback implements $ItemBuilder$FinishUsingCallback$$Interface {
 "finishUsingItem"(itemStack: $ItemStack$$Type, level: $Level$$Type, livingEntity: $LivingEntity$$Type): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$FinishUsingCallback$$Type = ((itemStack: $ItemStack, level: $Level, livingEntity: $LivingEntity) => $ItemStack$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$FinishUsingCallback$$Original = $ItemBuilder$FinishUsingCallback;}
declare module "dev.latvian.mods.kubejs.component.ItemComponentFunctions" {
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ComponentFunctions, $ComponentFunctions$$Interface} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$UUID$$Type} from "java.util.UUID"
import {$EquipmentSlotGroup$$Type} from "net.minecraft.world.entity.EquipmentSlotGroup"
import {$List$$Type} from "java.util.List"
import {$ItemAttributeModifiers} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$FireworkExplosion$$Type} from "net.minecraft.world.item.component.FireworkExplosion"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$AttributeModifier, $AttributeModifier$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map$$Type} from "java.util.Map"
import {$Instrument$$Type} from "net.minecraft.world.item.Instrument"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Tool$$Type} from "net.minecraft.world.item.component.Tool"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$AttributeModifierFunctions$$Interface} from "dev.latvian.mods.kubejs.component.AttributeModifierFunctions"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Unit$$Type} from "net.minecraft.util.Unit"

export interface $ItemComponentFunctions$$Interface extends $ComponentFunctions$$Interface, $AttributeModifierFunctions$$Interface {
set "tool"(value: $Tool$$Type)
set "instrument"(value: $Holder$$Type<($Instrument)>)
set "repairCost"(value: integer)
set "fireworks"(value: $Fireworks$$Type)
set "itemName"(value: $Component$$Type)
set "maxDamage"(value: integer)
set "food"(value: $FoodProperties$$Type)
set "damage"(value: integer)
get "unbreakable"(): void
get "unbreakableWithTooltip"(): void
set "bucketEntityData"(value: $CompoundTag$$Type)
set "chargedProjectiles"(value: $List$$Type<($ItemStack$$Type)>)
set "bundleContents"(value: $List$$Type<($ItemStack$$Type)>)
set "mapItemColor"(value: $KubeColor$$Type)
set "fireworkExplosion"(value: $FireworkExplosion$$Type)
get "attributeModifiers"(): $ItemAttributeModifiers
get "fireResistant"(): void
set "blockEntityData"(value: $CompoundTag$$Type)
set "maxStackSize"(value: integer)
set "noteBlockSound"(value: $ResourceLocation$$Type)
set "lore"(value: $List$$Type<($Component$$Type)>)
set "customData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "dyedColor"(value: $KubeColor$$Type)
set "customName"(value: $Component$$Type)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
get "customName"(): $Component
get "customData"(): $CompoundTag
set "lockCode"(value: StringJS)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
get "additionalTooltipHidden"(): void
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
get "componentString"(): StringJS
get "tooltipHidden"(): void
get "componentMap"(): $DataComponentMap
set "customModelData"(value: integer)
set "glintOverride"(value: boolean)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
get "attackSpeed"(): double
set "attackSpeed"(value: double)
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "baseAttackDamage"(value: double)
get "baseAttackDamage"(): double
set "attackDamage"(value: double)
get "attackDamage"(): double
set "baseAttackSpeed"(value: double)
get "baseAttackSpeed"(): double
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
}

export class $ItemComponentFunctions implements $ItemComponentFunctions$$Interface {
 "setTool"(tool: $Tool$$Type): void
 "setInstrument"(instrument: $Holder$$Type<($Instrument)>): void
 "setRepairCost"(repairCost: integer): void
 "setFireworks"(fireworks: $Fireworks$$Type): void
 "setItemName"(component: $Component$$Type): void
 "setMaxDamage"(maxDamage: integer): void
 "setFood"(foodProperties: $FoodProperties$$Type): void
 "setFood"(nutrition: integer, saturation: float): void
 "setDamage"(damage: integer): void
 "setUnbreakable"(): void
 "setUnbreakableWithTooltip"(): void
 "setBucketEntityData"(tag: $CompoundTag$$Type): void
 "setChargedProjectiles"(items: $List$$Type<($ItemStack$$Type)>): void
 "setBundleContents"(items: $List$$Type<($ItemStack$$Type)>): void
 "setMapItemColor"(color: $KubeColor$$Type): void
 "setFireworkExplosion"(explosion: $FireworkExplosion$$Type): void
 "getAttributeModifiers"(): $ItemAttributeModifiers
 "setFireResistant"(): void
 "setBlockEntityData"(tag: $CompoundTag$$Type): void
 "setMaxStackSize"(size: integer): void
 "setNoteBlockSound"(id: $ResourceLocation$$Type): void
 "remove"(type: $DataComponentType$$Type<(never)>): $ComponentFunctions
 "get"<T>(type: $DataComponentType$$Type<(T)>): T
 "patch"(components: $DataComponentPatch$$Type): $ComponentFunctions
 "set"(components: $DataComponentMap$$Type): $ComponentFunctions
 "set"(component: $DataComponentType$$Type<(never)>, value: any): $ComponentFunctions
 "setLore"(lines: $List$$Type<($Component$$Type)>): void
 "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
 "setCustomData"(tag: $CompoundTag$$Type): void
 "setRarity"(rarity: $Rarity$$Type): void
 "setDyedColor"(color: $KubeColor$$Type): void
 "setCustomName"(name: $Component$$Type): void
 "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "getCustomName"(): $Component
 "getCustomData"(): $CompoundTag
 "setLockCode"(lock: StringJS): void
 "setProfile"(name: StringJS, uuid: $UUID$$Type): void
 "setProfile"(profile: $GameProfile$$Type): void
 "setBaseColor"(color: $DyeColor$$Type): void
 "setPotionId"(potion: $Holder$$Type<($Potion)>): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "setAdditionalTooltipHidden"(): void
 "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
 "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
 "setPotionContents"(contents: $PotionContents$$Type): void
 "getComponentString"(): StringJS
 "resetComponents"(): $ComponentFunctions
 "setTooltipHidden"(): void
 "getComponentMap"(): $DataComponentMap
 "setCustomModelData"(data: integer): void
 "setGlintOverride"(override: boolean): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
 "getAttackSpeed"(): double
/**
 * Sets the attack speed of this item to the given value, **removing** all other modifiers to attack speed.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 * (Example: Swords have an attack speed of -2.4, leading to a total value of 1.6 without any other changes.)
 */
 "setAttackSpeed"(speed: double): void
 "setAttributeModifiersWithTooltip"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Overrides the *base* attack damage of this item to be the given value, keeping other modifiers intact.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 */
 "setBaseAttackDamage"(dmg: double): void
 "getBaseAttackDamage"(): double
 "addAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, mod: $AttributeModifier$$Type, slot: $EquipmentSlotGroup$$Type): void
 "hasAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): boolean
/**
 * Sets the attack damage of this item to the given value, **removing** all other modifiers to attack damage.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 * (In practice, this simply means that most weapons have this value set to 1 less than what you might think.)
 */
 "setAttackDamage"(dmg: double): void
 "getAttackDamage"(): double
/**
 * Overrides the *base* attack speed of this item to be the given value, keeping other modifiers intact.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 */
 "setBaseAttackSpeed"(speed: double): void
 "getBaseAttackSpeed"(): double
 "getAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): $AttributeModifier
 "setAttributeModifiers"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemComponentFunctions$$Type = ($ItemComponentFunctions);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemComponentFunctions$$Original = $ItemComponentFunctions;}
declare module "dev.latvian.mods.kubejs.core.ItemStackKJS" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$EquipmentSlotGroup$$Type} from "net.minecraft.world.entity.EquipmentSlotGroup"
import {$RelativeURL} from "dev.latvian.mods.kubejs.web.RelativeURL"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ItemEnchantments, $ItemEnchantments$$Type} from "net.minecraft.world.item.enchantment.ItemEnchantments"
import {$SpecialEquality$$Interface} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$MutableDataComponentHolderFunctions, $MutableDataComponentHolderFunctions$$Interface} from "dev.latvian.mods.kubejs.component.MutableDataComponentHolderFunctions"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$AttributeModifier, $AttributeModifier$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$ItemMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ItemMatch"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$ItemComponentFunctions$$Interface} from "dev.latvian.mods.kubejs.component.ItemComponentFunctions"
import {$LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Unit$$Type} from "net.minecraft.util.Unit"
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ComponentFunctions} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$MutableDataComponentHolder} from "net.neoforged.neoforge.common.MutableDataComponentHolder"
import {$UUID$$Type} from "java.util.UUID"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$ItemAttributeModifiers} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$List, $List$$Type} from "java.util.List"
import {$FireworkExplosion$$Type} from "net.minecraft.world.item.component.FireworkExplosion"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$ToStringJS$$Interface} from "dev.latvian.mods.rhino.util.ToStringJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item} from "net.minecraft.world.item.Item"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Instrument$$Type} from "net.minecraft.world.item.Instrument"
import {$Map, $Map$$Type} from "java.util.Map"
import {$WithCodec$$Interface} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Tool$$Type} from "net.minecraft.world.item.component.Tool"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Enchantment$$Type} from "net.minecraft.world.item.enchantment.Enchantment"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$IngredientSupplierKJS$$Interface} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ItemStackKJS$$Interface extends $SpecialEquality$$Interface, $WithCodec$$Interface, $IngredientSupplierKJS$$Interface, $ToStringJS$$Interface, $Replaceable$$Interface, $ItemComponentFunctions$$Interface, $MutableDataComponentHolderFunctions$$Interface, $ItemMatch$$Interface, $RegistryObjectKJS$$Interface<($Item)> {
get "id"(): StringJS
get "codec"(): $Codec<($ItemStack)>
get "key"(): $ResourceKey<($Item)>
get "typeData"(): $Map<(StringJS), (any)>
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "registry"(): $Registry<($Item)>
get "registryId"(): $ResourceKey<($Registry<($Item)>)>
get "block"(): $Block
get "componentString"(): StringJS
get "enchantments"(): $ItemEnchantments
get "harvestSpeed"(): float
set "tool"(value: $Tool$$Type)
set "instrument"(value: $Holder$$Type<($Instrument)>)
set "repairCost"(value: integer)
set "fireworks"(value: $Fireworks$$Type)
set "itemName"(value: $Component$$Type)
set "maxDamage"(value: integer)
set "food"(value: $FoodProperties$$Type)
set "damage"(value: integer)
get "unbreakable"(): void
get "unbreakableWithTooltip"(): void
set "bucketEntityData"(value: $CompoundTag$$Type)
set "chargedProjectiles"(value: $List$$Type<($ItemStack$$Type)>)
set "bundleContents"(value: $List$$Type<($ItemStack$$Type)>)
set "mapItemColor"(value: $KubeColor$$Type)
set "fireworkExplosion"(value: $FireworkExplosion$$Type)
get "attributeModifiers"(): $ItemAttributeModifiers
get "fireResistant"(): void
set "blockEntityData"(value: $CompoundTag$$Type)
set "maxStackSize"(value: integer)
set "noteBlockSound"(value: $ResourceLocation$$Type)
get "componentMap"(): $DataComponentMap
get "componentHolder"(): $MutableDataComponentHolder
get "tagKeys"(): $List<($TagKey<($Item)>)>
get "tags"(): $List<($ResourceLocation)>
set "lore"(value: $List$$Type<($Component$$Type)>)
set "customData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "dyedColor"(value: $KubeColor$$Type)
set "customName"(value: $Component$$Type)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
get "customName"(): $Component
get "customData"(): $CompoundTag
set "lockCode"(value: StringJS)
set "profile"(value: $GameProfile$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "potionId"(value: $Holder$$Type<($Potion)>)
set "entityData"(value: $CompoundTag$$Type)
get "additionalTooltipHidden"(): void
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "potionContents"(value: $PotionContents$$Type)
get "tooltipHidden"(): void
set "customModelData"(value: integer)
set "glintOverride"(value: boolean)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
get "attackSpeed"(): double
set "attackSpeed"(value: double)
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "baseAttackDamage"(value: double)
get "baseAttackDamage"(): double
set "attackDamage"(value: double)
get "attackDamage"(): double
set "baseAttackSpeed"(value: double)
get "baseAttackSpeed"(): double
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
}

export class $ItemStackKJS implements $ItemStackKJS$$Interface {
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $Ingredient$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, itemLike: $ItemLike$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, s: $ItemStack$$Type, exact: boolean): boolean
 "specialEquals"(o: any, shallow: boolean): boolean
 "getWebIconURL"(ops: $DynamicOps$$Type<($Tag$$Type)>, size: integer): $RelativeURL
 "toStringJS"(): StringJS
 "hasEnchantment"(enchantment: $Holder$$Type<($Enchantment)>, level: integer): boolean
 "toItemString"(): StringJS
 "enchant"(enchantments: $ItemEnchantments$$Type): this
 "enchant"(enchantment: $Holder$$Type<($Enchantment)>, level: integer): this
 "withCustomName"(name: $Component$$Type): this
 "areItemsEqual"(other: $ItemStack$$Type): boolean
/**
 * 
 * @deprecated
 */
 "withChance"(chance: float): $ItemStack
 "withLore"(lines: ($Component$$Type)[]): this
 "withLore"(lines: ($Component$$Type)[], styledLines: ($Component$$Type)[]): this
 "withCount"(c: integer): this
 "toItemString0"(dynamicOps: $DynamicOps$$Type<($Tag$$Type)>): StringJS
 "getId"(): StringJS
 "getCodec"(): $Codec<($ItemStack)>
 "self"(): $ItemStack
 "getKey"(): $ResourceKey<($Item)>
 "asIngredient"(): $Ingredient
 "getTypeData"(): $Map<(StringJS), (any)>
 "getMod"(): StringJS
 "getIdLocation"(): $ResourceLocation
 "asHolder"(): $Holder<($Item)>
 "getRegistry"(): $Registry<($Item)>
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "getRegistryId"(): $ResourceKey<($Registry<($Item)>)>
 "getBlock"(): $Block
 "getComponentString"(): StringJS
 "getEnchantments"(): $ItemEnchantments
 "equalsIgnoringCount"(stack: $ItemStack$$Type): boolean
 "getHarvestSpeed"(block: $LevelBlock$$Type): float
 "getHarvestSpeed"(): float
 "areComponentsEqual"(other: $ItemStack$$Type): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
 "toNBT"(): $Tag
 "toJson"(): $JsonElement
static "toStringJS"(arg1: any): StringJS
 "setTool"(tool: $Tool$$Type): void
 "setInstrument"(instrument: $Holder$$Type<($Instrument)>): void
 "setRepairCost"(repairCost: integer): void
 "setFireworks"(fireworks: $Fireworks$$Type): void
 "setItemName"(component: $Component$$Type): void
 "setMaxDamage"(maxDamage: integer): void
 "setFood"(foodProperties: $FoodProperties$$Type): void
 "setFood"(nutrition: integer, saturation: float): void
 "setDamage"(damage: integer): void
 "setUnbreakable"(): void
 "setUnbreakableWithTooltip"(): void
 "setBucketEntityData"(tag: $CompoundTag$$Type): void
 "setChargedProjectiles"(items: $List$$Type<($ItemStack$$Type)>): void
 "setBundleContents"(items: $List$$Type<($ItemStack$$Type)>): void
 "setMapItemColor"(color: $KubeColor$$Type): void
 "setFireworkExplosion"(explosion: $FireworkExplosion$$Type): void
 "getAttributeModifiers"(): $ItemAttributeModifiers
 "setFireResistant"(): void
 "setBlockEntityData"(tag: $CompoundTag$$Type): void
 "setMaxStackSize"(size: integer): void
 "setNoteBlockSound"(id: $ResourceLocation$$Type): void
 "patch"(components: $DataComponentPatch$$Type): $ComponentFunctions
 "set"(components: $DataComponentMap$$Type): $MutableDataComponentHolderFunctions
 "getComponentMap"(): $DataComponentMap
 "getComponentHolder"(): $MutableDataComponentHolder
 "matchesAny"(cx: $RecipeMatchContext$$Type, itemLikes: $Iterable$$Type<($ItemLike$$Type)>, exact: boolean): boolean
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getTagKeys"(): $List<($TagKey<($Item)>)>
 "getTags"(): $List<($ResourceLocation)>
 "remove"(type: $DataComponentType$$Type<(never)>): $ComponentFunctions
 "get"<T>(type: $DataComponentType$$Type<(T)>): T
 "set"(component: $DataComponentType$$Type<(never)>, value: any): $ComponentFunctions
 "setLore"(lines: $List$$Type<($Component$$Type)>): void
 "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
 "setCustomData"(tag: $CompoundTag$$Type): void
 "setRarity"(rarity: $Rarity$$Type): void
 "setDyedColor"(color: $KubeColor$$Type): void
 "setCustomName"(name: $Component$$Type): void
 "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "getCustomName"(): $Component
 "getCustomData"(): $CompoundTag
 "setLockCode"(lock: StringJS): void
 "setProfile"(name: StringJS, uuid: $UUID$$Type): void
 "setProfile"(profile: $GameProfile$$Type): void
 "setBaseColor"(color: $DyeColor$$Type): void
 "setPotionId"(potion: $Holder$$Type<($Potion)>): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "setAdditionalTooltipHidden"(): void
 "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
 "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
 "setPotionContents"(contents: $PotionContents$$Type): void
 "resetComponents"(): $ComponentFunctions
 "setTooltipHidden"(): void
 "setCustomModelData"(data: integer): void
 "setGlintOverride"(override: boolean): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
 "getAttackSpeed"(): double
/**
 * Sets the attack speed of this item to the given value, **removing** all other modifiers to attack speed.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 * (Example: Swords have an attack speed of -2.4, leading to a total value of 1.6 without any other changes.)
 */
 "setAttackSpeed"(speed: double): void
 "setAttributeModifiersWithTooltip"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Overrides the *base* attack damage of this item to be the given value, keeping other modifiers intact.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 */
 "setBaseAttackDamage"(dmg: double): void
 "getBaseAttackDamage"(): double
 "addAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, mod: $AttributeModifier$$Type, slot: $EquipmentSlotGroup$$Type): void
 "hasAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): boolean
/**
 * Sets the attack damage of this item to the given value, **removing** all other modifiers to attack damage.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 * (In practice, this simply means that most weapons have this value set to 1 less than what you might think.)
 */
 "setAttackDamage"(dmg: double): void
 "getAttackDamage"(): double
/**
 * Overrides the *base* attack speed of this item to be the given value, keeping other modifiers intact.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 */
 "setBaseAttackSpeed"(speed: double): void
 "getBaseAttackSpeed"(): double
 "getAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): $AttributeModifier
 "setAttributeModifiers"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackKJS$$Type = ($ItemStackKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemStackKJS$$Original = $ItemStackKJS;}
declare module "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundInstance" {
import {$JsonElement} from "com.google.gson.JsonElement"

export class $SoundsGenerator$SoundInstance {
constructor(fileLocation: StringJS)

public "stream"(): $SoundsGenerator$SoundInstance
public "stream"(b: boolean): $SoundsGenerator$SoundInstance
public "attenuationDistance"(i: integer): $SoundsGenerator$SoundInstance
public "weight"(i: integer): $SoundsGenerator$SoundInstance
public "pitch"(f: float): $SoundsGenerator$SoundInstance
public "toJson"(): $JsonElement
public "volume"(f: float): $SoundsGenerator$SoundInstance
public "preload"(b: boolean): $SoundsGenerator$SoundInstance
public "preload"(): $SoundsGenerator$SoundInstance
public "asReferenceToEvent"(): $SoundsGenerator$SoundInstance
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundsGenerator$SoundInstance$$Type = ($SoundsGenerator$SoundInstance);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoundsGenerator$SoundInstance$$Original = $SoundsGenerator$SoundInstance;}
declare module "dev.latvian.mods.kubejs.misc.CustomStatBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $CustomStatBuilder extends $BuilderBase<($ResourceLocation)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomStatBuilder$$Type = ($CustomStatBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomStatBuilder$$Original = $CustomStatBuilder;}
declare module "dev.latvian.mods.kubejs.core.ServerLevelKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$WithPersistentData$$Interface} from "dev.latvian.mods.kubejs.core.WithPersistentData"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$ExplosionProperties$$Type} from "dev.latvian.mods.kubejs.level.ExplosionProperties"
import {$LevelKJS$$Interface} from "dev.latvian.mods.kubejs.core.LevelKJS"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ServerLevelKJS$$Interface extends $LevelKJS$$Interface, $WithPersistentData$$Interface {

(): $AttachedData$$Type<($Level$$Type)>
get "name"(): $Component
get "overworld"(): boolean
get "dimension"(): $ResourceLocation
set "time"(value: long)
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "side"(): $ScriptType
get "persistentData"(): $CompoundTag
get "data"(): $AttachedData<($Level)>
get "mcEntities"(): $Iterable<($Entity)>
get "players"(): $EntityArrayList
get "mcPlayers"(): $List<($Player)>
get "displayName"(): $Component
get "entities"(): $EntityArrayList
}

export class $ServerLevelKJS implements $ServerLevelKJS$$Interface {
 "spawnParticles"(options: $ParticleOptions$$Type, overrideLimiter: boolean, x: double, y: double, z: double, vx: double, vy: double, vz: double, count: integer, speed: double): void
 "self"(): $EntityGetter
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean): void
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean, cause: $ServerPlayer$$Type): void
 "isOverworld"(): boolean
 "explode"(x: double, y: double, z: double, properties: $ExplosionProperties$$Type): $Explosion
 "createEntity"(type: $EntityType$$Type<(never)>): $Entity
 "spawnEntity"(type: $EntityType$$Type<(never)>, callback: $Consumer$$Type<($Entity)>): void
 "spawnFireworks"(x: double, y: double, z: double, fireworks: $Fireworks$$Type, lifetime: integer): void
 "getDimension"(): $ResourceLocation
 "setTime"(time: long): void
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "tell"(message: $Component$$Type): void
 "getBlock"(x: integer, y: integer, z: integer): $LevelBlock
 "getBlock"(entity: $BlockEntity$$Type): $LevelBlock
 "getBlock"(pos: $BlockPos$$Type): $LevelBlock
 "getSide"(): $ScriptType
 "getPersistentData"(): $CompoundTag
 "getData"(): $AttachedData<($Level)>
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getPlayers"(): $EntityArrayList
 "getMcPlayers"(): $List<($Player)>
 "getDisplayName"(): $Component
 "getEntityByNetworkID"(id: integer): $Entity
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntities"(): $EntityArrayList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerLevelKJS$$Type = (() => $AttachedData$$Type<($Level$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerLevelKJS$$Original = $ServerLevelKJS;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.ParticleOptionsWrapper" {
import {$DustParticleOptions} from "net.minecraft.core.particles.DustParticleOptions"
import {$RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ParticleOptionsWrapper$$Interface {
}

export class $ParticleOptionsWrapper implements $ParticleOptionsWrapper$$Interface {
static readonly "ERROR": $DustParticleOptions

static "wrap"(registries: $RegistryAccessContainer$$Type, o: any): $ParticleOptions
static "create"(options: $ParticleOptions$$Type): $ParticleOptions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleOptionsWrapper$$Type = ($ParticleOptionsWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ParticleOptionsWrapper$$Original = $ParticleOptionsWrapper;}
declare module "dev.latvian.mods.kubejs.event.EventHandlerContainer" {
import {$EventHandler$$Type} from "dev.latvian.mods.kubejs.event.EventHandler"
import {$KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ConsoleJS$$Type} from "dev.latvian.mods.kubejs.script.ConsoleJS"
import {$IEventHandler, $IEventHandler$$Type} from "dev.latvian.mods.kubejs.event.IEventHandler"
import {$EventResult} from "dev.latvian.mods.kubejs.event.EventResult"

export class $EventHandlerContainer {
readonly "handler": $IEventHandler
readonly "line": integer
readonly "source": StringJS
readonly "target": any

constructor(target: any, handler: $IEventHandler$$Type, source: StringJS, line: integer)

public "toString"(): StringJS
public static "isEmpty"(array: ($EventHandlerContainer$$Type)[]): boolean
public "add"(extraId: any, handler: $IEventHandler$$Type, source: StringJS, line: integer): void
public "handle"(console: $ConsoleJS$$Type, handler: $EventHandler$$Type, event: $KubeEvent$$Type): $EventResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventHandlerContainer$$Type = ($EventHandlerContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventHandlerContainer$$Original = $EventHandlerContainer;}
declare module "dev.latvian.mods.kubejs.util.Tristate" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BooleanSupplier$$Type} from "java.util.function.BooleanSupplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $Tristate extends $Enum<($Tristate)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($Tristate)>
static readonly "TRUE": $Tristate
static readonly "FALSE": $Tristate
static readonly "VALUES": ($Tristate)[]
static readonly "DEFAULT": $Tristate
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($Tristate)>

public static "values"(): ($Tristate)[]
public "test"(enabled: $BooleanSupplier$$Type): boolean
public "test"(enabled: boolean): boolean
public static "valueOf"(name: StringJS): $Tristate
public static "wrap"(from: any): $Tristate
public "getSerializedName"(): StringJS
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public "getRemappedEnumConstantName"(): StringJS
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Tristate$$Type = (("false") | ("true") | ("default"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Tristate$$Original = $Tristate;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.SizedIngredientWrapper" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$SizedIngredient, $SizedIngredient$$Type} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

/**
 * Various SizedIngredient related helper methods
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $SizedIngredientWrapper$$Interface {
}

export class $SizedIngredientWrapper implements $SizedIngredientWrapper$$Interface {
/**
 * An ingredient that matches everything
 */
static readonly "all": $SizedIngredient
static readonly "TYPE_INFO": $TypeInfo
/**
 * A completely empty ingredient that will only match air
 */
static readonly "empty": $SizedIngredient

/**
 * Returns a sized ingredient of the input
 */
static "of"(ingredient: $SizedIngredient$$Type): $SizedIngredient
/**
 * Returns a sized ingredient of the input
 */
static "of"(ingredient: $Ingredient$$Type, count: integer): $SizedIngredient
static "ofTag"(tag: $TagKey$$Type<($Item)>, count: integer): $SizedIngredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SizedIngredientWrapper$$Type = ($SizedIngredientWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SizedIngredientWrapper$$Original = $SizedIngredientWrapper;}
declare module "dev.latvian.mods.kubejs.block.custom.TrapdoorBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $TrapdoorBlockBuilder extends $ShapedBlockBuilder {
static readonly "TRAPDOOR_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "behaviour"(wt: $BlockSetType$$Type): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrapdoorBlockBuilder$$Type = ($TrapdoorBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrapdoorBlockBuilder$$Original = $TrapdoorBlockBuilder;}
declare module "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$Map} from "java.util.Map"
import {$UUID} from "java.util.UUID"
import {$BlockEntityInfo, $BlockEntityInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityInfo"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$ClientGamePacketListener} from "net.minecraft.network.protocol.game.ClientGamePacketListener"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $KubeBlockEntity extends $BlockEntity {
readonly "attachments": $Map<(StringJS), (any)>
 "data": $CompoundTag
 "level": $Level
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "tick": integer
 "placerId": $UUID
 "cycle": integer
 "remove": boolean
readonly "blockKey": $ResourceKey<($Block)>
static readonly "TICKER": $BlockEntityTicker<($KubeBlockEntity)>
 "worldPosition": $BlockPos
readonly "x": integer
readonly "y": integer
readonly "z": integer
 "hasComparators": byte
readonly "info": $BlockEntityInfo

constructor(blockPos: $BlockPos$$Type, blockState: $BlockState$$Type, entityInfo: $BlockEntityInfo$$Type)

public "save"(): void
public "sync"(): void
public "setLevel"(level: $Level$$Type): void
public "getUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "getBlock"(): $LevelBlock
public "triggerEvent"(eventId: integer, data: integer): boolean
public "loadAdditional"(tag: $CompoundTag$$Type, registries: $HolderLookup$Provider$$Type): void
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "getPlacer"(): $Entity
public "sendEvent"(eventId: integer, data: integer): void
get "block"(): $LevelBlock
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
get "placer"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeBlockEntity$$Type = ($KubeBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeBlockEntity$$Original = $KubeBlockEntity;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$ReleaseUsingCallback" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export interface $ItemBuilder$ReleaseUsingCallback$$Interface {

(itemStack: $ItemStack, level: $Level, user: $LivingEntity, tick: integer): void
}

export class $ItemBuilder$ReleaseUsingCallback implements $ItemBuilder$ReleaseUsingCallback$$Interface {
 "releaseUsing"(itemStack: $ItemStack$$Type, level: $Level$$Type, user: $LivingEntity$$Type, tick: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$ReleaseUsingCallback$$Type = ((itemStack: $ItemStack, level: $Level, user: $LivingEntity, tick: integer) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$ReleaseUsingCallback$$Original = $ItemBuilder$ReleaseUsingCallback;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory" {
import {$BlockCapability} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$KubeBlockEntity, $KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockEntityAttachmentInfo, $BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$List} from "java.util.List"
import {$BlockEntityAttachment, $BlockEntityAttachment$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"

export interface $BlockEntityAttachmentFactory$$Interface {

(info: $BlockEntityAttachmentInfo, entity: $KubeBlockEntity): $BlockEntityAttachment$$Type
get "ticking"(): boolean
get "capabilities"(): $List<($BlockCapability<(never), (never)>)>
}

export class $BlockEntityAttachmentFactory implements $BlockEntityAttachmentFactory$$Interface {
 "create"(info: $BlockEntityAttachmentInfo$$Type, entity: $KubeBlockEntity$$Type): $BlockEntityAttachment
 "isTicking"(): boolean
 "getCapabilities"(): $List<($BlockCapability<(never), (never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentFactory$$Type = ((info: $BlockEntityAttachmentInfo, entity: $KubeBlockEntity) => $BlockEntityAttachment$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityAttachmentFactory$$Original = $BlockEntityAttachmentFactory;}
declare module "dev.latvian.mods.kubejs.util.TinyMap" {
import {$Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$TinyMap$Entry, $TinyMap$Entry$$Type} from "dev.latvian.mods.kubejs.util.TinyMap$Entry"
import {$Record} from "java.lang.Record"

export class $TinyMap<K, V> extends $Record {
constructor(entries: ($TinyMap$Entry$$Type<(K), (V)>)[])
constructor(map: $TinyMap$$Type<(K), (V)>)
constructor(collection: $Collection$$Type<($TinyMap$Entry$$Type<(K), (V)>)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public "toMap"(): $Map<(K), (V)>
public "entries"(): ($TinyMap$Entry<(K), (V)>)[]
public static "ofMap"<K, V>(map: $Map$$Type<(K), (V)>): $TinyMap<(K), (V)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TinyMap$$Type<K, V> = ({"entries"?: ($TinyMap$Entry$$Type<(K), (V)>)[]}) | ([entries?: ($TinyMap$Entry$$Type<(K), (V)>)[]]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TinyMap$$Original<K, V> = $TinyMap<(K), (V)>;}
declare module "dev.latvian.mods.kubejs.text.tooltip.TooltipRequirements" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Tristate, $Tristate$$Type} from "dev.latvian.mods.kubejs.util.Tristate"
import {$Record} from "java.lang.Record"

export class $TooltipRequirements extends $Record {
static readonly "DEFAULT": $TooltipRequirements
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($TooltipRequirements)>

constructor(shift: $Tristate$$Type, ctrl: $Tristate$$Type, alt: $Tristate$$Type, advanced: $Tristate$$Type, creative: $Tristate$$Type, stages: $Map$$Type<(StringJS), ($Tristate$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "shift"(): $Tristate
public "creative"(): $Tristate
public "alt"(): $Tristate
public "ctrl"(): $Tristate
public "advanced"(): $Tristate
public "stages"(): $Map<(StringJS), ($Tristate)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipRequirements$$Type = ({"shift"?: $Tristate$$Type, "advanced"?: $Tristate$$Type, "stages"?: $Map$$Type<(StringJS), ($Tristate$$Type)>, "ctrl"?: $Tristate$$Type, "alt"?: $Tristate$$Type, "creative"?: $Tristate$$Type}) | ([shift?: $Tristate$$Type, advanced?: $Tristate$$Type, stages?: $Map$$Type<(StringJS), ($Tristate$$Type)>, ctrl?: $Tristate$$Type, alt?: $Tristate$$Type, creative?: $Tristate$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TooltipRequirements$$Original = $TooltipRequirements;}
declare module "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS" {
import {$TagManager} from "net.minecraft.tags.TagManager"
import {$ServerScriptManager} from "dev.latvian.mods.kubejs.server.ServerScriptManager"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ReloadableServerResourcesKJS$$Interface {
}

export class $ReloadableServerResourcesKJS implements $ReloadableServerResourcesKJS$$Interface {
 "kjs$getServerScriptManager"(): $ServerScriptManager
 "kjs$getTagManager"(): $TagManager
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReloadableServerResourcesKJS$$Type = ($ReloadableServerResourcesKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReloadableServerResourcesKJS$$Original = $ReloadableServerResourcesKJS;}
declare module "dev.latvian.mods.kubejs.util.Object2LongEntry" {
import {$Comparable$$Interface} from "java.lang.Comparable"
import {$Object2LongMap$Entry$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongMap$Entry"

export class $Object2LongEntry implements $Comparable$$Interface<($Object2LongEntry)> {
readonly "value": long
readonly "key": any

constructor(k: any, v: long)
constructor(entry: $Object2LongMap$Entry$$Type<(any)>)

public "compareTo"(o: any): integer
public "compareTo"(o: $Object2LongEntry$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2LongEntry$$Type = ($Object2LongEntry);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Object2LongEntry$$Original = $Object2LongEntry;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo" {
import {$BlockEntityAttachmentFactory, $BlockEntityAttachmentFactory$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$BlockEntityAttachmentType, $BlockEntityAttachmentType$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentType"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$EnumSet, $EnumSet$$Type} from "java.util.EnumSet"
import {$Record} from "java.lang.Record"

export class $BlockEntityAttachmentInfo extends $Record {
constructor(id: StringJS, type: $BlockEntityAttachmentType$$Type, index: integer, directions: $EnumSet$$Type<($Direction$$Type)>, factory: $BlockEntityAttachmentFactory$$Type)

public "index"(): integer
public "type"(): $BlockEntityAttachmentType
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "factory"(): $BlockEntityAttachmentFactory
public "id"(): StringJS
public "directions"(): $EnumSet<($Direction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentInfo$$Type = ({"type"?: $BlockEntityAttachmentType$$Type, "directions"?: $EnumSet$$Type<($Direction$$Type)>, "factory"?: $BlockEntityAttachmentFactory$$Type, "index"?: integer, "id"?: StringJS}) | ([type?: $BlockEntityAttachmentType$$Type, directions?: $EnumSet$$Type<($Direction$$Type)>, factory?: $BlockEntityAttachmentFactory$$Type, index?: integer, id?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityAttachmentInfo$$Original = $BlockEntityAttachmentInfo;}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabContentSupplier" {
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"

export interface $CreativeTabContentSupplier$$Interface {

(showRestrictedItems: boolean): $ItemPredicate$$Type
}

export class $CreativeTabContentSupplier implements $CreativeTabContentSupplier$$Interface {
static readonly "DEFAULT": $CreativeTabContentSupplier

 "getContent"(showRestrictedItems: boolean): $ItemPredicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabContentSupplier$$Type = ((showRestrictedItems: boolean) => $ItemPredicate$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeTabContentSupplier$$Original = $CreativeTabContentSupplier;}
declare module "dev.latvian.mods.kubejs.command.ArgumentTypeWrapper" {
import {$CommandContext$$Type} from "com.mojang.brigadier.context.CommandContext"
import {$ArgumentType} from "com.mojang.brigadier.arguments.ArgumentType"
import {$CommandRegistryKubeEvent$$Type} from "dev.latvian.mods.kubejs.command.CommandRegistryKubeEvent"
import {$CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"

export interface $ArgumentTypeWrapper$$Interface {
}

export class $ArgumentTypeWrapper implements $ArgumentTypeWrapper$$Interface {
 "create"(event: $CommandRegistryKubeEvent$$Type): $ArgumentType<(never)>
 "getResult"(context: $CommandContext$$Type<($CommandSourceStack$$Type)>, input: StringJS): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArgumentTypeWrapper$$Type = ($ArgumentTypeWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArgumentTypeWrapper$$Original = $ArgumentTypeWrapper;}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$CreativeModeTab} from "net.minecraft.world.item.CreativeModeTab"
import {$Registry} from "net.minecraft.core.Registry"
import {$CreativeTabContentSupplier$$Type} from "dev.latvian.mods.kubejs.item.creativetab.CreativeTabContentSupplier"
import {$CreativeTabIconSupplier$$Type} from "dev.latvian.mods.kubejs.item.creativetab.CreativeTabIconSupplier"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $CreativeTabBuilder extends $BuilderBase<($CreativeModeTab)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "content"(content: $CreativeTabContentSupplier$$Type): this
public "icon"(icon: $CreativeTabIconSupplier$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabBuilder$$Type = ($CreativeTabBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeTabBuilder$$Original = $CreativeTabBuilder;}
declare module "dev.latvian.mods.kubejs.block.state.BlockStatePredicate" {
import {$ReplacementMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Collection} from "java.util.Collection"
import {$List$$Type} from "java.util.List"
import {$OreConfiguration$TargetBlockState$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration$TargetBlockState"
import {$Predicate, $Predicate$$Type, $Predicate$$Interface} from "java.util.function.Predicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Set} from "java.util.Set"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockStatePredicate$$Interface extends $Predicate$$Interface<($BlockState)>, $ReplacementMatch$$Interface {

(state: $BlockState): boolean
get "blockStates"(): $Collection<($BlockState)>
get "blocks"(): $Collection<($Block)>
get "blockIds"(): $Set<($ResourceLocation)>
}

export class $BlockStatePredicate implements $BlockStatePredicate$$Interface {
 "test"(state: $BlockState$$Type): boolean
 "test"(state: any): boolean
static "wrap"(o: any): $BlockStatePredicate
 "check"(targetStates: $List$$Type<($OreConfiguration$TargetBlockState$$Type)>): boolean
static "fromString"(s: StringJS): $BlockStatePredicate
 "getBlockStates"(): $Collection<($BlockState)>
 "getBlocks"(): $Collection<($Block)>
static "wrapRuleTest"(o: any): $RuleTest
 "getBlockIds"(): $Set<($ResourceLocation)>
 "asRuleTest"(): $RuleTest
 "testBlock"(block: $Block$$Type): boolean
 "or"(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockState)>
 "negate"(): $Predicate<($BlockState)>
 "and"(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockState)>
static "not"<T>(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockState)>
static "isEqual"<T>(arg0: any): $Predicate<($BlockState)>
}
export type BlockStatePredicateObject = {"or"?: $BlockStatePredicate$$Type, "not"?: $BlockStatePredicate$$Type};
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStatePredicate$$Type = (($BlockStatePredicate$$Type)[]) | (BlockStatePredicateObject) | ($Block$$Type) | (Special.BlockTag) | (RegExp) | ("*") | ("-") | ((state: $BlockState) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStatePredicate$$Original = $BlockStatePredicate;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.NativeEventWrapper$Listeners$Key" {
import {$EventPriority, $EventPriority$$Type} from "net.neoforged.bus.api.EventPriority"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $NativeEventWrapper$Listeners$Key extends $Record {
constructor(eventClass: $Class$$Type<(never)>, priority: $EventPriority$$Type)

public "priority"(): $EventPriority
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "eventClass"(): $Class<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeEventWrapper$Listeners$Key$$Type = ({"priority"?: $EventPriority$$Type, "eventClass"?: $Class$$Type<(never)>}) | ([priority?: $EventPriority$$Type, eventClass?: $Class$$Type<(never)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NativeEventWrapper$Listeners$Key$$Original = $NativeEventWrapper$Listeners$Key;}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Shovel" {
import {$BiFunction} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DiggerItemBuilder} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$Item$Properties} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Shovel extends $DiggerItemBuilder {
static readonly "SHOVEL_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "SHOVEL_MODEL": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Shovel$$Type = ($DiggerItemBuilder$Shovel);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemBuilder$Shovel$$Original = $DiggerItemBuilder$Shovel;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeConstructor" {
import {$OpsContainer$$Type} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Map} from "java.util.Map"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ComponentValueMap$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentValueMap"
import {$KubeRecipe} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$RecipeOptional, $RecipeOptional$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $RecipeConstructor {
readonly "keys": $List<($RecipeKey<(never)>)>
 "defaultValues": $Map<($RecipeKey<(never)>), ($RecipeOptional<(never)>)>
 "overrides": $Map<($RecipeKey<(never)>), ($RecipeOptional<(never)>)>

constructor(keys: $List$$Type<($RecipeKey$$Type<(never)>)>)
constructor(...keys: ($RecipeKey$$Type<(never)>)[])

public "toString"(): StringJS
public "toString"(ops: $OpsContainer$$Type): StringJS
public "defaultValue"<T>(key: $RecipeKey$$Type<(T)>, value: $RecipeOptional$$Type<(T)>): $RecipeConstructor
public "override"<T>(key: $RecipeKey$$Type<(T)>, value: $RecipeOptional$$Type<(T)>): $RecipeConstructor
public "create"(sourceLine: $SourceLine$$Type, type: $RecipeTypeFunction$$Type, schemaType: $RecipeSchemaType$$Type, from: $ComponentValueMap$$Type): $KubeRecipe
public "setValues"(cx: $RecipeScriptContext$$Type, schemaType: $RecipeSchemaType$$Type, from: $ComponentValueMap$$Type): void
public "toJson"(type: $RecipeSchemaType$$Type, ops: $DynamicOps$$Type<($JsonElement$$Type)>): $JsonObject
public "overrideValue"<T>(key: $RecipeKey$$Type<(T)>, value: T): $RecipeConstructor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeConstructor$$Type = ($RecipeConstructor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeConstructor$$Original = $RecipeConstructor;}
declare module "dev.latvian.mods.kubejs.item.ItemDestroyedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$PlayerDestroyItemEvent$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerDestroyItemEvent"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$InteractionHand} from "net.minecraft.world.InteractionHand"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $ItemDestroyedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(e: $PlayerDestroyItemEvent$$Type)

public "getItem"(): $ItemStack
public "getEntity"(): $Entity
public "getHand"(): $InteractionHand
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "item"(): $ItemStack
get "entity"(): $Entity
get "hand"(): $InteractionHand
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDestroyedKubeEvent$$Type = ($ItemDestroyedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemDestroyedKubeEvent$$Original = $ItemDestroyedKubeEvent;}
declare module "dev.latvian.mods.kubejs.script.ScriptManager" {
import {$ScriptPack, $ScriptPack$$Type} from "dev.latvian.mods.kubejs.script.ScriptPack"
import {$Map} from "java.util.Map"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Path$$Type} from "java.nio.file.Path"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$KubeJSContextFactory} from "dev.latvian.mods.kubejs.script.KubeJSContextFactory"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptManager {
readonly "scriptType": $ScriptType
 "canListenEvents": boolean
readonly "packs": $Map<(StringJS), ($ScriptPack)>
 "contextFactory": $KubeJSContextFactory

constructor(t: $ScriptType$$Type)

public "unload"(): void
public "reload"(): void
public "isClassAllowed"(name: StringJS): boolean
public "loadFromDirectory"(): void
public "loadAdditional"(): void
public "getRegistries"(): $RegistryAccessContainer
public "collectScripts"(pack: $ScriptPack$$Type, dir: $Path$$Type, path: StringJS): void
public "loadPackFromDirectory"(path: $Path$$Type, name: StringJS, exampleFile: boolean): void
get "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptManager$$Type = ($ScriptManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptManager$$Original = $ScriptManager;}
declare module "dev.latvian.mods.kubejs.server.BasicCommandKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $BasicCommandKubeEvent implements $KubeEntityEvent$$Interface {
readonly "input": StringJS
readonly "id": StringJS

constructor(source: $CommandSourceStack$$Type, id: StringJS, input: StringJS)

public "getId"(): StringJS
public "getLevel"(): $Level
public "getBlock"(): $LevelBlock
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "respond"(text: $Component$$Type): void
public "respondLazily"(text: $Supplier$$Type<($Component$$Type)>, informAdmins: boolean): void
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "block"(): $LevelBlock
get "entity"(): $Entity
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicCommandKubeEvent$$Type = ($BasicCommandKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BasicCommandKubeEvent$$Original = $BasicCommandKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.MessageSenderKJS" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $MessageSenderKJS$$Interface {
get "name"(): $Component
get "displayName"(): $Component
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $MessageSenderKJS implements $MessageSenderKJS$$Interface {
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "tell"(message: $Component$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageSenderKJS$$Type = ($MessageSenderKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MessageSenderKJS$$Original = $MessageSenderKJS;}
declare module "dev.latvian.mods.kubejs.client.KeybindRegistryKubeEvent" {
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$KeybindRegistryKubeEvent$Builder} from "dev.latvian.mods.kubejs.client.KeybindRegistryKubeEvent$Builder"
import {$Minecraft} from "net.minecraft.client.Minecraft"

export class $KeybindRegistryKubeEvent implements $ClientKubeEvent$$Interface {
constructor()

public "register"(id: StringJS, defaultKey: StringJS): $KeybindRegistryKubeEvent$Builder
public "register"(id: StringJS): $KeybindRegistryKubeEvent$Builder
public "getClient"(): $Minecraft
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeybindRegistryKubeEvent$$Type = ($KeybindRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KeybindRegistryKubeEvent$$Original = $KeybindRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.schema.function.RecipeFunctionInstance" {
import {$ResolvedRecipeSchemaFunction, $ResolvedRecipeSchemaFunction$$Type} from "dev.latvian.mods.kubejs.recipe.schema.function.ResolvedRecipeSchemaFunction"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$Record} from "java.lang.Record"

export class $RecipeFunctionInstance extends $Record {
constructor(name: StringJS, arg1: $ResolvedRecipeSchemaFunction$$Type)
constructor(name: StringJS, arg1: $List$$Type<($RecipeComponent$$Type<(never)>)>, arg2: $ResolvedRecipeSchemaFunction$$Type)

public "name"(): StringJS
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "function"(): $ResolvedRecipeSchemaFunction
public "arguments"(): $List<($RecipeComponent<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeFunctionInstance$$Type = ({"arguments"?: $List$$Type<($RecipeComponent$$Type<(never)>)>, "function"?: $ResolvedRecipeSchemaFunction$$Type, "name"?: StringJS}) | ([arg?: $List$$Type<($RecipeComponent$$Type<(never)>)>, arg?: $ResolvedRecipeSchemaFunction$$Type, name?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeFunctionInstance$$Original = $RecipeFunctionInstance;}
declare module "dev.latvian.mods.kubejs.text.action.TooltipActionType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$TextAction} from "dev.latvian.mods.kubejs.text.action.TextAction"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Record} from "java.lang.Record"

export class $TooltipActionType<T extends $TextAction> extends $Record {
constructor(type: integer, streamCodec: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>)

public "type"(): integer
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipActionType$$Type<T> = ({"type"?: integer, "streamCodec"?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>}) | ([type?: integer, streamCodec?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TooltipActionType$$Original<T> = $TooltipActionType<(T)>;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Helmet" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ArmorItemBuilder} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"

export class $ArmorItemBuilder$Helmet extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
static readonly "HELMET_TAGS": ($ResourceLocation)[]
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Helmet$$Type = ($ArmorItemBuilder$Helmet);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$Helmet$$Original = $ArmorItemBuilder$Helmet;}
declare module "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessorType" {
import {$RecipePostProcessor} from "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessor"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$RecipeTypeRegistryContext, $RecipeTypeRegistryContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $RecipePostProcessorType<T extends $RecipePostProcessor> extends $Record {
static readonly "CODEC": $Codec<($RecipePostProcessorType<(never)>)>
static readonly "MAP": $Lazy<($Map<($ResourceLocation), ($RecipePostProcessorType<(never)>)>)>

constructor(id: $ResourceLocation$$Type, mapCodec: $Function$$Type<($RecipeTypeRegistryContext), ($MapCodec$$Type<(T)>)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): $ResourceLocation
public "mapCodec"(): $Function<($RecipeTypeRegistryContext), ($MapCodec<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipePostProcessorType$$Type<T> = ({"id"?: $ResourceLocation$$Type, "mapCodec"?: $Function$$Type<($RecipeTypeRegistryContext$$Type), ($MapCodec$$Type<(T)>)>}) | ([id?: $ResourceLocation$$Type, mapCodec?: $Function$$Type<($RecipeTypeRegistryContext$$Type), ($MapCodec$$Type<(T)>)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipePostProcessorType$$Original<T> = $RecipePostProcessorType<(T)>;}
declare module "dev.latvian.mods.kubejs.recipe.match.ItemMatch" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$ReplacementMatch, $ReplacementMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"

export interface $ItemMatch$$Interface extends $ReplacementMatch$$Interface {
}

export class $ItemMatch implements $ItemMatch$$Interface {
 "matches"(cx: $RecipeMatchContext$$Type, itemLike: $ItemLike$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $Ingredient$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, item: $ItemStack$$Type, exact: boolean): boolean
 "matchesAny"(cx: $RecipeMatchContext$$Type, itemLikes: $Iterable$$Type<($ItemLike$$Type)>, exact: boolean): boolean
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemMatch$$Type = ($ItemMatch);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemMatch$$Original = $ItemMatch;}
declare module "dev.latvian.mods.kubejs.level.LevelBlock" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$Holder} from "net.minecraft.core.Holder"
import {$BlockProviderKJS$$Interface} from "dev.latvian.mods.kubejs.core.BlockProviderKJS"
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ExplosionProperties$$Type} from "dev.latvian.mods.kubejs.level.ExplosionProperties"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

export interface $LevelBlock$$Interface extends $BlockProviderKJS$$Interface {
get "centerY"(): double
get "down"(): $LevelBlock
get "west"(): $LevelBlock
get "south"(): $LevelBlock
get "biomeId"(): $ResourceLocation
get "light"(): integer
get "north"(): $LevelBlock
get "up"(): $LevelBlock
get "east"(): $LevelBlock
get "properties"(): $Map<(StringJS), (StringJS)>
get "level"(): $Level
get "item"(): $ItemStack
get "dimension"(): $ResourceLocation
get "centerZ"(): double
get "centerX"(): double
get "pos"(): $BlockPos
get "inventory"(): $InventoryKJS
get "x"(): integer
get "z"(): integer
get "entityData"(): $CompoundTag
set "blockState"(value: $BlockState$$Type)
get "entity"(): $BlockEntity
get "dimensionKey"(): $ResourceKey<($Level)>
get "y"(): integer
get "blockState"(): $BlockState
get "skyLight"(): integer
get "playersInRadius"(): $EntityArrayList
get "entityId"(): StringJS
set "entityData"(value: $CompoundTag$$Type)
get "blockLight"(): integer
get "canSeeSky"(): boolean
get "drops"(): $List<($ItemStack)>
get "block"(): $Block
get "id"(): StringJS
get "key"(): $ResourceKey<($Block)>
get "typeData"(): $Map<(StringJS), (any)>
get "registry"(): $Registry<($Block)>
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $LevelBlock implements $LevelBlock$$Interface {
 "getCenterY"(): double
 "getDown"(): $LevelBlock
 "getWest"(): $LevelBlock
 "getSouth"(): $LevelBlock
 "getBiomeId"(): $ResourceLocation
 "getLight"(): integer
 "getNorth"(): $LevelBlock
 "getUp"(): $LevelBlock
 "popItem"(item: $ItemStack$$Type): void
 "getEast"(): $LevelBlock
 "offset"(f: $Direction$$Type, d: integer): $LevelBlock
 "offset"(f: $Direction$$Type): $LevelBlock
 "offset"(x: integer, y: integer, z: integer): $LevelBlock
 "set"(block: $Block$$Type, properties: $Map$$Type<(never), (never)>, flags: integer): void
 "set"(block: $Block$$Type, properties: $Map$$Type<(never), (never)>): void
 "set"(block: $Block$$Type): void
 "getProperties"(): $Map<(StringJS), (StringJS)>
 "getLevel"(): $Level
 "getItem"(): $ItemStack
 "getDimension"(): $ResourceLocation
 "getCenterZ"(): double
 "getCenterX"(): double
 "explode"(properties: $ExplosionProperties$$Type): $Explosion
 "getPos"(): $BlockPos
 "createEntity"(type: $EntityType$$Type<(never)>): $Entity
 "getInventory"(): $InventoryKJS
 "getInventory"(facing: $Direction$$Type): $InventoryKJS
 "getX"(): integer
 "getZ"(): integer
 "getEntityData"(): $CompoundTag
 "setBlockState"(state: $BlockState$$Type, flags: integer): void
 "setBlockState"(state: $BlockState$$Type): void
 "getEntity"(): $BlockEntity
 "getDimensionKey"(): $ResourceKey<($Level)>
 "getY"(): integer
 "getBlockState"(): $BlockState
 "getSkyLight"(): integer
 "toBlockStateString"(): StringJS
 "getPlayersInRadius"(radius: double): $EntityArrayList
 "getPlayersInRadius"(): $EntityArrayList
 "getEntityId"(): StringJS
 "popItemFromFace"(item: $ItemStack$$Type, dir: $Direction$$Type): void
 "spawnFireworks"(fireworks: $Fireworks$$Type, lifetime: integer): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "mergeEntityData"(tag: $CompoundTag$$Type): void
 "getBlockLight"(): integer
 "spawnLightning"(effectOnly: boolean): void
 "spawnLightning"(): void
 "spawnLightning"(effectOnly: boolean, player: $ServerPlayer$$Type): void
 "getCanSeeSky"(): boolean
 "canSeeSkyFromBelowWater"(): boolean
 "getDrops"(): $List<($ItemStack)>
 "getDrops"(entity: $Entity$$Type, heldItem: $ItemStack$$Type): $List<($ItemStack)>
 "getBlock"(): $Block
 "getId"(): StringJS
 "getKey"(): $ResourceKey<($Block)>
 "getTypeData"(): $Map<(StringJS), (any)>
 "asHolder"(): $Holder<($Block)>
 "getRegistry"(): $Registry<($Block)>
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "specialEquals"(o: any, shallow: boolean): boolean
 "getMod"(): StringJS
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getIdLocation"(): $ResourceLocation
 "getTagKeys"(): $List<($TagKey<($Block)>)>
 "getTags"(): $List<($ResourceLocation)>
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelBlock$$Type = ($LevelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelBlock$$Original = $LevelBlock;}
declare module "dev.latvian.mods.kubejs.client.ClientKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Minecraft} from "net.minecraft.client.Minecraft"

export interface $ClientKubeEvent$$Interface extends $KubeEvent$$Interface {
get "client"(): $Minecraft
}

export class $ClientKubeEvent implements $ClientKubeEvent$$Interface {
 "getClient"(): $Minecraft
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientKubeEvent$$Type = ($ClientKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientKubeEvent$$Original = $ClientKubeEvent;}
declare module "dev.latvian.mods.kubejs.item.ItemStackSet" {
import {$Iterator} from "java.util.Iterator"
import {$Iterable$$Interface} from "java.lang.Iterable"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Spliterator} from "java.util.Spliterator"
import {$List} from "java.util.List"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$Stream} from "java.util.stream.Stream"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ItemStackSet implements $Iterable$$Interface<($ItemStack)> {
constructor(...items: ($ItemStack$$Type)[])
constructor()
constructor(initialSize: integer)

public "remove"(stack: $ItemStack$$Type): void
public "size"(): integer
public "isEmpty"(): boolean
public "add"(stack: $ItemStack$$Type): void
public "toArray"(): ($ItemStack)[]
public "iterator"(): $Iterator<($ItemStack)>
public "toList"(): $List<($ItemStack)>
public "stream"(): $Stream<($ItemStack)>
public "contains"(stack: $ItemStack$$Type): boolean
public "addAll"(other: $ItemStackSet$$Type): void
public static "merge"(first: $ItemStackSet$$Type, second: $ItemStackSet$$Type): $ItemStackSet
public "forEach"(action: $Consumer$$Type<($ItemStack)>): void
public "getFirst"(): $ItemStack
public "addItem"(item: $Item$$Type): void
public "spliterator"(): $Spliterator<($ItemStack)>
[Symbol.iterator](): IterableIterator<$ItemStack>;
get "empty"(): boolean
get "first"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackSet$$Type = ($ItemStackSet);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemStackSet$$Original = $ItemStackSet;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent$Callback" {
import {$ChestMenuInventoryClickEvent, $ChestMenuInventoryClickEvent$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent"

export interface $ChestMenuInventoryClickEvent$Callback$$Interface {

(event: $ChestMenuInventoryClickEvent): void
}

export class $ChestMenuInventoryClickEvent$Callback implements $ChestMenuInventoryClickEvent$Callback$$Interface {
 "onClick"(event: $ChestMenuInventoryClickEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuInventoryClickEvent$Callback$$Type = ((event: $ChestMenuInventoryClickEvent) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuInventoryClickEvent$Callback$$Original = $ChestMenuInventoryClickEvent$Callback;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeMappingRegistry" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"

export class $RecipeMappingRegistry implements $KubeEvent$$Interface {
constructor(storage: $RecipeSchemaStorage$$Type)

public "register"(name: StringJS, type: $ResourceLocation$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeMappingRegistry$$Type = ($RecipeMappingRegistry);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeMappingRegistry$$Original = $RecipeMappingRegistry;}
declare module "dev.latvian.mods.kubejs.core.ClientPlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubeJSInventoryListener} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$PlayerKJS$$Interface} from "dev.latvian.mods.kubejs.core.PlayerKJS"
import {$Stages} from "dev.latvian.mods.kubejs.stages.Stages"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$EntityPotionEffectsJS} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ClientPlayerKJS$$Interface extends $PlayerKJS$$Interface {

(): $AttachedData$$Type<($Player$$Type)>
get "miningBlock"(): boolean
get "stats"(): $PlayerStatsJS
get "inventoryChangeListener"(): $KubeJSInventoryListener
get "craftingGrid"(): $InventoryKJS
get "openInventory"(): $AbstractContainerMenu
get "selectedSlot"(): integer
set "selectedSlot"(value: integer)
get "mouseItem"(): $ItemStack
get "xpLevel"(): integer
set "foodLevel"(value: integer)
set "saturation"(value: float)
set "xpLevel"(value: integer)
set "mouseItem"(value: $ItemStack$$Type)
get "stages"(): $Stages
get "saturation"(): float
get "inventory"(): $InventoryKJS
get "foodLevel"(): integer
get "fake"(): boolean
get "xp"(): integer
set "xp"(value: integer)
set "statusMessage"(value: $Component$$Type)
get "profile"(): $GameProfile
get "player"(): boolean
get "headArmorItem"(): $ItemStack
get "reachDistance"(): double
set "chestArmorItem"(value: $ItemStack$$Type)
get "legsArmorItem"(): $ItemStack
get "mainHandItem"(): $ItemStack
set "headArmorItem"(value: $ItemStack$$Type)
set "legsArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
get "feetArmorItem"(): $ItemStack
get "totalMovementSpeed"(): double
set "feetArmorItem"(value: $ItemStack$$Type)
set "mainHandItem"(value: $ItemStack$$Type)
get "potionEffects"(): $EntityPotionEffectsJS
get "defaultMovementSpeed"(): double
set "defaultMovementSpeed"(value: double)
set "movementSpeedAddition"(value: double)
set "totalMovementSpeedMultiplier"(value: double)
set "defaultMovementSpeedMultiplier"(value: double)
get "living"(): boolean
get "offHandItem"(): $ItemStack
set "offHandItem"(value: $ItemStack$$Type)
set "maxHealth"(value: float)
get "undead"(): boolean
get "data"(): $AttachedData<($Player)>
get "peacefulCreature"(): boolean
get "waterCreature"(): boolean
get "ambientCreature"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "nbt"(): $CompoundTag
set "x"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "z"(value: double)
get "level"(): $Level
set "position"(value: $LevelBlock$$Type)
get "block"(): $LevelBlock
get "server"(): $MinecraftServer
get "motionX"(): double
set "motionY"(value: double)
get "facing"(): $Direction
get "frame"(): boolean
get "passengers"(): $EntityArrayList
get "item"(): $ItemStack
get "motionZ"(): double
get "type"(): StringJS
set "motionZ"(value: double)
get "animal"(): boolean
get "monster"(): boolean
get "teamId"(): StringJS
get "motionY"(): double
set "motionX"(value: double)
get "scriptType"(): $ScriptType
set "activePostShader"(value: $ResourceLocation$$Type)
get "persistentData"(): $CompoundTag
}

export class $ClientPlayerKJS implements $ClientPlayerKJS$$Interface {
 "isSelf"(): boolean
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "isMiningBlock"(): boolean
 "getStats"(): $PlayerStatsJS
 "notify"(notification: $NotificationToastData$$Type): void
 "self"(): $Entity
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "addItemCooldown"(item: $Item$$Type, ticks: integer): void
 "getCraftingGrid"(): $InventoryKJS
 "boostElytraFlight"(): void
 "sendInventoryUpdate"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "getSelectedSlot"(): integer
 "setSelectedSlot"(index: integer): void
 "spawn"(): void
 "addXPLevels"(l: integer): void
 "getMouseItem"(): $ItemStack
 "getXpLevel"(): integer
 "setFoodLevel"(foodLevel: integer): void
 "setSaturation"(saturation: float): void
 "addFood"(f: integer, m: float): void
 "setXpLevel"(l: integer): void
 "addExhaustion"(exhaustion: float): void
 "setMouseItem"(item: $ItemStack$$Type): void
 "getStages"(): $Stages
 "giveInHand"(item: $ItemStack$$Type): void
 "getSaturation"(): float
 "getInventory"(): $InventoryKJS
 "getFoodLevel"(): integer
 "isFake"(): boolean
 "give"(item: $ItemStack$$Type): void
 "getXp"(): integer
 "notify"(title: $Component$$Type, text: $Component$$Type): void
 "addXP"(xp: integer): void
 "setXp"(xp: integer): void
 "setStatusMessage"(message: $Component$$Type): void
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "getHeadArmorItem"(): $ItemStack
 "getReachDistance"(): double
 "setChestArmorItem"(item: $ItemStack$$Type): void
 "getLegsArmorItem"(): $ItemStack
 "getMainHandItem"(): $ItemStack
 "setHeadArmorItem"(item: $ItemStack$$Type): void
 "setLegsArmorItem"(item: $ItemStack$$Type): void
 "getChestArmorItem"(): $ItemStack
 "getFeetArmorItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "getAttributeTotalValue"(attribute: $Holder$$Type<($Attribute)>): double
 "getAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>): double
 "canEntityBeSeen"(entity: $LivingEntity$$Type): boolean
 "setFeetArmorItem"(item: $ItemStack$$Type): void
 "setAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>, value: double): void
 "isHoldingInAnyHand"(i: $ItemPredicate$$Type): boolean
 "modifyAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): void
 "setMainHandItem"(item: $ItemStack$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "getPotionEffects"(): $EntityPotionEffectsJS
 "removeAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): void
 "swing"(hand: $InteractionHand$$Type): void
 "swing"(): void
 "getDefaultMovementSpeed"(): double
 "setDefaultMovementSpeed"(speed: double): void
 "setMovementSpeedAddition"(speed: double): void
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "foodEaten"(is: $ItemStack$$Type, food: $FoodProperties$$Type): void
 "isLiving"(): boolean
 "damageHeldItem"(): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "getOffHandItem"(): $ItemStack
 "setOffHandItem"(item: $ItemStack$$Type): void
 "getHeldItem"(hand: $InteractionHand$$Type): $ItemStack
 "rayTraceEntity"(filter: $Predicate$$Type<($Entity)>): $Entity
 "rayTrace"(): $KubeRayTraceResult
 "setMaxHealth"(hp: float): void
 "getEquipment"(slot: $EquipmentSlot$$Type): $ItemStack
 "isUndead"(): boolean
 "setEquipment"(slot: $EquipmentSlot$$Type, item: $ItemStack$$Type): void
 "setHeldItem"(hand: $InteractionHand$$Type, item: $ItemStack$$Type): void
 "sendData"(channel: StringJS): void
 "getData"(): $AttachedData<($Player)>
 "isPeacefulCreature"(): boolean
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isAmbientCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "getNbt"(): $CompoundTag
 "setX"(x: double): void
 "attack"(hp: float): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setZ"(z: double): void
 "runCommandSilent"(command: StringJS): void
 "tell"(message: $Component$$Type): void
 "getLevel"(): $Level
 "setPosition"(block: $LevelBlock$$Type): void
 "setPosition"(x: double, y: double, z: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getBlock"(): $LevelBlock
 "playSound"(id: $SoundEvent$$Type): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "getServer"(): $MinecraftServer
 "getMotionX"(): double
 "setMotionY"(y: double): void
 "getFacing"(): $Direction
 "isFrame"(): boolean
 "getPassengers"(): $EntityArrayList
 "getItem"(): $ItemStack
 "setRotation"(yaw: float, pitch: float): void
 "getMotionZ"(): double
 "getType"(): StringJS
 "setMotionZ"(z: double): void
 "isAnimal"(): boolean
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "isMonster"(): boolean
 "getTeamId"(): StringJS
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getMotionY"(): double
 "setMotionX"(x: double): void
 "getScriptType"(): $ScriptType
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientPlayerKJS$$Original = $ClientPlayerKJS;}
declare module "dev.latvian.mods.kubejs.script.ScriptFile" {
import {$ScriptPack, $ScriptPack$$Type} from "dev.latvian.mods.kubejs.script.ScriptPack"
import {$ScriptFileInfo, $ScriptFileInfo$$Type} from "dev.latvian.mods.kubejs.script.ScriptFileInfo"
import {$Comparable$$Interface} from "java.lang.Comparable"
import {$List} from "java.util.List"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptFile implements $Comparable$$Interface<($ScriptFile)> {
 "lastModified": long
 "lines": (StringJS)[]
readonly "pack": $ScriptPack
readonly "info": $ScriptFileInfo

constructor(pack: $ScriptPack$$Type, info: $ScriptFileInfo$$Type)

public "getProperty"(s: StringJS, def: StringJS): StringJS
public "compareTo"(o: any): integer
public "compareTo"(o: $ScriptFile$$Type): integer
public "load"(): void
public "getProperties"(s: StringJS): $List<(StringJS)>
public "getPriority"(): integer
public "skipLoading"(): StringJS
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptFile$$Type = ($ScriptFile);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptFile$$Original = $ScriptFile;}
declare module "dev.latvian.mods.kubejs.event.EventTargetType" {
import {$TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$EventTargetType$Transformer$$Type} from "dev.latvian.mods.kubejs.event.EventTargetType$Transformer"
import {$Enum} from "java.lang.Enum"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"

export class $EventTargetType<T> {
static readonly "STRING": $EventTargetType<(StringJS)>
static readonly "ID": $EventTargetType<($ResourceLocation)>
readonly "type": $Class<(T)>
static readonly "REGISTRY": $EventTargetType<($ResourceKey<($Registry<(never)>)>)>

public "toString"(factory: $EventTargetType$Transformer$$Type): $EventTargetType<(T)>
public "identity"(): $EventTargetType<(T)>
public static "create"<T>(type: $Class$$Type<(T)>): $EventTargetType<(T)>
public "transformer"(factory: $EventTargetType$Transformer$$Type): $EventTargetType<(T)>
public "describeType"(describeType: $TypeInfo$$Type): $EventTargetType<(T)>
public "validator"(validator: $Predicate$$Type<(any)>): $EventTargetType<(T)>
public static "registryKey"<T>(registry: $ResourceKey$$Type<($Registry<(T)>)>, type: $Class$$Type<(never)>): $EventTargetType<($ResourceKey<(T)>)>
public static "fromEnum"<T extends $Enum<(object)>>(type: $Class$$Type<(T)>): $EventTargetType<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventTargetType$$Type<T> = ($EventTargetType<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventTargetType$$Original<T> = $EventTargetType<(T)>;}
declare module "dev.latvian.mods.kubejs.net.NetworkKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a network packet is received.
 * 
 * Note that the behaviour of this event is depending on the **script type**.
 * 
 * In `server_scripts`, this event is invoked on the server side when a packet is received from a client.
 * 
 * In `client_scripts`, this event is invoked on the client side when a packet is received from the server.
 */
export class $NetworkKubeEvent implements $KubePlayerEvent$$Interface {
constructor(p: $Player$$Type, c: StringJS, d: $CompoundTag$$Type)

/**
 * The channel of the packet.
 */
public "getChannel"(): StringJS
/**
 * The data of the packet.
 */
public "getData"(): $CompoundTag
/**
 * The player that sent the packet. Always `Minecraft.player` in `client_scripts`.
 */
public "getEntity"(): $Player
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "channel"(): StringJS
get "data"(): $CompoundTag
get "entity"(): $Player
get "player"(): $Player
get "level"(): $Level
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkKubeEvent$$Type = ($NetworkKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NetworkKubeEvent$$Original = $NetworkKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.RecipesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Pattern} from "java.util.regex.Pattern"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DocumentedRecipes} from "moe.wolfgirl.probejs.generated.DocumentedRecipes"
import {$Shaped} from "moe.wolfgirl.probejs.generated.schema.kubejs.Shaped"
import {$List$$Type} from "java.util.List"
import {$ServerScriptManager$$Type} from "dev.latvian.mods.kubejs.server.ServerScriptManager"
import {$Stonecutting} from "moe.wolfgirl.probejs.generated.schema.minecraft.Stonecutting"
import {$RecipeSchemaStorage} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$RecipeTypeFunction} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$RecipeFilter$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeFilter"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$Stream} from "java.util.stream.Stream"
import {$SmithingTransform} from "moe.wolfgirl.probejs.generated.schema.minecraft.SmithingTransform"
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Smelting} from "moe.wolfgirl.probejs.generated.schema.minecraft.Smelting"
import {$Blasting} from "moe.wolfgirl.probejs.generated.schema.minecraft.Blasting"
import {$CampfireCooking} from "moe.wolfgirl.probejs.generated.schema.minecraft.CampfireCooking"
import {$Shapeless} from "moe.wolfgirl.probejs.generated.schema.kubejs.Shapeless"
import {$Smoking} from "moe.wolfgirl.probejs.generated.schema.minecraft.Smoking"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$SmithingTrim} from "moe.wolfgirl.probejs.generated.schema.minecraft.SmithingTrim"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$ResourceManager, $ResourceManager$$Type} from "net.minecraft.server.packs.resources.ResourceManager"

export class $RecipesKubeEvent implements $KubeEvent$$Interface {
readonly "smithingTrim": (template: $Ingredient$$Type, base: $Ingredient$$Type, addition: $Ingredient$$Type) => $SmithingTrim
readonly "addedRecipes": $Collection<($KubeRecipe)>
readonly "stonecutting": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type) => $Stonecutting
readonly "shaped": (result: $ItemStack$$Type, pattern: $List$$Type<(StringJS)>, key: $Map$$Type<(character), ($Ingredient$$Type)>) => $Shaped
readonly "registries": $RegistryAccessContainer
readonly "removedRecipes": $Collection<($KubeRecipe)>
readonly "recipeSchemaStorage": $RecipeSchemaStorage
readonly "campfireCooking": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, time?: $TickDuration$$Type) => $CampfireCooking
readonly "shapeless": (result: $ItemStack$$Type, ingredients: $List$$Type<($Ingredient$$Type)>) => $Shapeless
readonly "blasting": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, time?: $TickDuration$$Type) => $Blasting
readonly "smithing": (result: $ItemStack$$Type, template: $Ingredient$$Type, base: $Ingredient$$Type, addition: $Ingredient$$Type) => $SmithingTransform
readonly "ops": $RegistryOpsContainer
static readonly "CREATE_RECIPE_SKIP_ERROR": $Pattern
readonly "originalRecipes": $Map<($ResourceLocation), ($KubeRecipe)>
readonly "smoking": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, time?: $TickDuration$$Type) => $Smoking
static readonly "POST_SKIP_ERROR": $Pattern
readonly "resourceManager": $ResourceManager
readonly "smelting": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, time?: $TickDuration$$Type) => $Smelting

constructor(manager: $ServerScriptManager$$Type, resourceManager: $ResourceManager$$Type)

public "remove"(filter: $RecipeFilter$$Type): void
public "stage"(filter: $RecipeFilter$$Type, stage: StringJS): void
public "getRecipeFunction"(id: StringJS): $RecipeTypeFunction
public "findRecipes"(filter: $RecipeFilter$$Type): $Collection<($KubeRecipe)>
public "findRecipeIds"(filter: $RecipeFilter$$Type): $Collection<($ResourceLocation)>
public "recipeStream"(filter: $RecipeFilter$$Type): $Stream<($KubeRecipe)>
public "printAllTypes"(): void
public "containsRecipe"(filter: $RecipeFilter$$Type): boolean
public "countRecipes"(filter: $RecipeFilter$$Type): integer
public "printExamples"(type: StringJS): void
public "forEachRecipe"(filter: $RecipeFilter$$Type, consumer: $Consumer$$Type<($KubeRecipe)>): void
public "printTypes"(): void
public "getRecipes"(): $DocumentedRecipes
public "replaceOutput"(filter: $RecipeFilter$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): void
public "replaceInput"(filter: $RecipeFilter$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): void
public "custom"(json: $JsonObject$$Type): $KubeRecipe
public "addRecipe"(r: $KubeRecipe$$Type, json: boolean): $KubeRecipe
public "takeId"(recipe: $KubeRecipe$$Type, prefix: StringJS, ids: StringJS): $ResourceLocation
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "recipes"(): $DocumentedRecipes
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipesKubeEvent$$Type = ($RecipesKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipesKubeEvent$$Original = $RecipesKubeEvent;}
declare module "dev.latvian.mods.kubejs.util.JsonUtils" {
import {$JsonPrimitive} from "com.google.gson.JsonPrimitive"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$MapLike} from "com.mojang.serialization.MapLike"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$JsonArray} from "com.google.gson.JsonArray"

export interface $JsonUtils$$Interface {
}

export class $JsonUtils implements $JsonUtils$$Interface {
static readonly "MAP_LIKE": $MapLike<($JsonElement)>

static "toString"(json: $JsonElement$$Type): StringJS
static "of"(o: any): $JsonElement
static "copy"(element: $JsonElement$$Type): $JsonElement
static "fromString"(string: StringJS): $JsonElement
static "objectOf"(map: any): $JsonObject
static "toObject"(json: $JsonElement$$Type): any
static "arrayOf"(array: any): $JsonArray
static "toPrimitive"(element: $JsonElement$$Type): any
static "primitiveOf"(o: any): $JsonPrimitive
static "toPrettyString"(json: $JsonElement$$Type): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonUtils$$Type = ($JsonUtils);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JsonUtils$$Original = $JsonUtils;}
declare module "dev.latvian.mods.kubejs.misc.MobEffectBuilder" {
import {$MobEffectBuilder$EffectEntityCallback$$Type} from "dev.latvian.mods.kubejs.misc.MobEffectBuilder$EffectEntityCallback"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$Registry} from "net.minecraft.core.Registry"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$MobEffectCategory$$Type} from "net.minecraft.world.effect.MobEffectCategory"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$MobEffect} from "net.minecraft.world.effect.MobEffect"

export class $MobEffectBuilder extends $BuilderBase<($MobEffect)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "color"(col: $KubeColor$$Type): this
public "instant"(): this
public "instant"(instant: boolean): this
public "category"(c: $MobEffectCategory$$Type): this
public "getTranslationKeyGroup"(): StringJS
public "beneficial"(): this
public "effectTick"(effectTick: $MobEffectBuilder$EffectEntityCallback$$Type): this
public "harmful"(): this
public "modifyAttribute"(attribute: $ResourceLocation$$Type, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): this
get "translationKeyGroup"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectBuilder$$Type = ($MobEffectBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobEffectBuilder$$Original = $MobEffectBuilder;}
declare module "dev.latvian.mods.kubejs.event.EventResult" {
import {$Context} from "dev.latvian.mods.rhino.Context"
import {$ICancellableEvent$$Type} from "net.neoforged.bus.api.ICancellableEvent"
import {$EventResult$Type} from "dev.latvian.mods.kubejs.event.EventResult$Type"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$TriState$$Type} from "net.neoforged.neoforge.common.util.TriState"

export class $EventResult {
static readonly "PASS": $EventResult

public "type"(): $EventResult$Type
public "value"(): any
public "override"(): boolean
public "pass"(): boolean
public "cx"(): $Context
public "interruptFalse"(): boolean
public "interruptTrue"(): boolean
public "interruptDefault"(): boolean
public "applyTristate"(consumer: $Consumer$$Type<($TriState)>): void
public "applyCancel"(event: $ICancellableEvent$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventResult$$Type = ($EventResult);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventResult$$Original = $EventResult;}
declare module "dev.latvian.mods.kubejs.core.BlockBuilderProvider" {
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $BlockBuilderProvider$$Interface {
get "blockBuilder"(): $BlockBuilder
}

export class $BlockBuilderProvider implements $BlockBuilderProvider$$Interface {
 "getBlockBuilder"(): $BlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBuilderProvider$$Type = ($BlockBuilderProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBuilderProvider$$Original = $BlockBuilderProvider;}
declare module "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent" {
import {$ScheduledEvents} from "dev.latvian.mods.kubejs.util.ScheduledEvents"

export class $ScheduledEvents$ScheduledEvent {
 "timer": long
 "repeating": boolean
 "scheduledEvents": $ScheduledEvents
 "id": integer
 "endTime": long
 "ofTicks": boolean

constructor()

public "clear"(): void
public "reschedule"(): $ScheduledEvents$ScheduledEvent
public "reschedule"(timer: long): $ScheduledEvents$ScheduledEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledEvents$ScheduledEvent$$Type = ($ScheduledEvents$ScheduledEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduledEvents$ScheduledEvent$$Original = $ScheduledEvents$ScheduledEvent;}
declare module "dev.latvian.mods.kubejs.registry.BuilderBase" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Supplier$$Interface} from "java.util.function.Supplier"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $BuilderBase<T> implements $Supplier$$Interface<(T)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

public "get"(): T
public "toString"(): StringJS
/**
 * Sets the display name for this object, e.g. `Stone`.
 * 
 * This will be overridden by a lang file if it exists.
 */
public "displayName"(name: $Component$$Type): this
/**
 * Adds a tag to this object, e.g. `minecraft:stone`.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): this
public "getTranslationKeyGroup"(): StringJS
public "getBuilderTranslationKey"(): StringJS
/**
 * Sets the translation key for this object, e.g. `block.minecraft.stone`.
 */
public "translationKey"(key: StringJS): this
/**
 * Combined method of formattedDisplayName().displayName(name).
 */
public "formattedDisplayName"(name: $Component$$Type): this
/**
 * Makes displayName() override language files.
 */
public "formattedDisplayName"(): this
get "translationKeyGroup"(): StringJS
get "builderTranslationKey"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuilderBase$$Type<T> = ($BuilderBase<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BuilderBase$$Original<T> = $BuilderBase<(T)>;}
declare module "dev.latvian.mods.kubejs.event.EventExit" {
import {$Exception} from "java.lang.Exception"
import {$EventResult, $EventResult$$Type} from "dev.latvian.mods.kubejs.event.EventResult"

export class $EventExit extends $Exception {
readonly "result": $EventResult

constructor(result: $EventResult$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventExit$$Type = ($EventExit);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventExit$$Original = $EventExit;}
declare module "dev.latvian.mods.kubejs.generator.KubeAssetGenerator" {
import {$ParticleGenerator$$Type} from "dev.latvian.mods.kubejs.client.ParticleGenerator"
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$SoundsGenerator$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator"
import {$Map$$Type} from "java.util.Map"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$KubeResourceGenerator$$Interface} from "dev.latvian.mods.kubejs.generator.KubeResourceGenerator"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$VariantBlockStateGenerator$$Type} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ModelGenerator$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$MultipartBlockStateGenerator$$Type} from "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$LoadedTexture, $LoadedTexture$$Type} from "dev.latvian.mods.kubejs.client.LoadedTexture"

export interface $KubeAssetGenerator$$Interface extends $KubeResourceGenerator$$Interface {
get "registries"(): $RegistryAccessContainer
}

export class $KubeAssetGenerator implements $KubeAssetGenerator$$Interface {
static readonly "HANDHELD_ITEM_MODEL": $ResourceLocation
static readonly "CUBE_BLOCK_MODEL": $ResourceLocation
static readonly "CUBE_ALL_BLOCK_MODEL": $ResourceLocation
static readonly "GENERATED_ITEM_MODEL": $ResourceLocation

 "mask"(target: $ResourceLocation$$Type, mask: $ResourceLocation$$Type, input: $ResourceLocation$$Type): boolean
 "particle"(id: $ResourceLocation$$Type, consumer: $Consumer$$Type<($ParticleGenerator)>): void
 "loadTexture"(id: $ResourceLocation$$Type): $LoadedTexture
 "defaultItemModel"(id: $ResourceLocation$$Type): void
 "multipartState"(id: $ResourceLocation$$Type, consumer: $Consumer$$Type<($MultipartBlockStateGenerator)>): void
 "texture"(target: $ResourceLocation$$Type, texture: $LoadedTexture$$Type): void
 "blockState"(id: $ResourceLocation$$Type, consumer: $Consumer$$Type<($VariantBlockStateGenerator)>): void
 "stencil"(target: $ResourceLocation$$Type, stencil: $ResourceLocation$$Type, colors: $Map$$Type<($KubeColor$$Type), ($KubeColor$$Type)>): void
 "defaultHandheldItemModel"(id: $ResourceLocation$$Type): void
 "sounds"(namespace: StringJS, consumer: $Consumer$$Type<($SoundsGenerator)>): void
 "itemModel"(id: $ResourceLocation$$Type, consumer: $Consumer$$Type<($ModelGenerator)>): void
 "blockModel"(id: $ResourceLocation$$Type, consumer: $Consumer$$Type<($ModelGenerator)>): void
 "flush"(): void
 "add"(data: $GeneratedData$$Type): void
 "text"(id: $ResourceLocation$$Type, content: StringJS): void
 "getGenerated"(id: $ResourceLocation$$Type): $GeneratedData
 "getRegistries"(): $RegistryAccessContainer
 "json"(id: $ResourceLocation$$Type, json: $JsonElement$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeAssetGenerator$$Type = ($KubeAssetGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeAssetGenerator$$Original = $KubeAssetGenerator;}
declare module "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$SurviveCallback" {
import {$LevelReader, $LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $CropBlockBuilder$SurviveCallback$$Interface {

(state: $BlockState, reader: $LevelReader, pos: $BlockPos): boolean
}

export class $CropBlockBuilder$SurviveCallback implements $CropBlockBuilder$SurviveCallback$$Interface {
 "survive"(state: $BlockState$$Type, reader: $LevelReader$$Type, pos: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlockBuilder$SurviveCallback$$Type = ((state: $BlockState, reader: $LevelReader, pos: $BlockPos) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CropBlockBuilder$SurviveCallback$$Original = $CropBlockBuilder$SurviveCallback;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.StringUtilsWrapper" {
import {$Pattern} from "java.util.regex.Pattern"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Function$$Type} from "java.util.function.Function"
import {$Set} from "java.util.Set"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $StringUtilsWrapper$$Interface {
}

export class $StringUtilsWrapper implements $StringUtilsWrapper$$Interface {
static readonly "ALWAYS_LOWER_CASE": $Set<(StringJS)>
static readonly "SNAKE_CASE_SPLIT": $Pattern
static readonly "EMPTY_STRING_ARRAY": (StringJS)[]

/**
 * Tries to parse the first parameter as an integer, and returns that. The second parameter is returned if parsing fails
 */
static "parseInt"(object: any, def: integer): integer
/**
 * Capitalises the first letter of the string. If ignoreSpecial is true, it will also capitalise articles and prepositions
 */
static "toTitleCase"(s: StringJS, ignoreSpecial: boolean): StringJS
/**
 * Capitalises the first letter of the string unless it is "a", "an", "the", "of", "on", "in", "and", "or", "but" or "for"
 */
static "toTitleCase"(s: StringJS): StringJS
/**
 * Tries to parse the first parameter as a double and returns that. The second parameter is returned if parsing fails
 */
static "parseDouble"(object: any, def: double): double
static "parseLong"(object: any, def: long): long
/**
 * Returns the provided snake_case_string in Title Case
 */
static "snakeCaseToTitleCase"(string: StringJS): StringJS
static "getUniqueId"(json: $JsonElement$$Type): StringJS
static "getUniqueId"<T>(input: T, toJson: $Function$$Type<(T), ($JsonElement$$Type)>): StringJS
/**
 * Returns the provided snake_case_string in camelCase
 */
static "snakeCaseToCamelCase"(string: StringJS): StringJS
static "stripIdForEvent"(id: $ResourceLocation$$Type): StringJS
static "stripEventName"(s: StringJS): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringUtilsWrapper$$Type = ($StringUtilsWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StringUtilsWrapper$$Original = $StringUtilsWrapper;}
declare module "dev.latvian.mods.kubejs.util.FluidAmounts" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $FluidAmounts$$Interface {
}

export class $FluidAmounts implements $FluidAmounts$$Interface {
static readonly "B": long
static readonly "METAL_BLOCK": long
static readonly "MB": long
static readonly "BOTTLE": long
static readonly "BUCKET": long
static readonly "MILLIBUCKET": long
static readonly "INGOT": long
static readonly "NUGGET": long

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidAmounts$$Type = ($FluidAmounts);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidAmounts$$Original = $FluidAmounts;}
declare module "dev.latvian.mods.kubejs.web.KJSHTTPRequest" {
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Runnable$$Type} from "java.lang.Runnable"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$DataComponentPatch} from "net.minecraft.core.component.DataComponentPatch"
import {$HTTPResponse, $HTTPResponse$$Type} from "dev.latvian.apps.tinyserver.http.response.HTTPResponse"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$BlockableEventLoop, $BlockableEventLoop$$Type} from "net.minecraft.util.thread.BlockableEventLoop"
import {$Tag$$Type} from "net.minecraft.nbt.Tag"
import {$Throwable$$Type} from "java.lang.Throwable"
import {$HTTPRequest} from "dev.latvian.apps.tinyserver.http.HTTPRequest"
import {$HTTPPayload$$Type} from "dev.latvian.apps.tinyserver.http.response.HTTPPayload"

export class $KJSHTTPRequest extends $HTTPRequest {
readonly "eventLoop": $BlockableEventLoop<(never)>

constructor(eventLoop: $BlockableEventLoop$$Type<(never)>)

public "id"(): $ResourceLocation
public "id"(ns: StringJS, path: StringJS): $ResourceLocation
public "registries"(): $RegistryAccessContainer
public "runInMainThread"(task: $Runnable$$Type): void
public "components"(ops: $DynamicOps$$Type<($Tag$$Type)>): $DataComponentPatch
public "handleResponse"(payload: $HTTPPayload$$Type, response: $HTTPResponse$$Type, error: $Throwable$$Type): $HTTPResponse
public "supplyInMainThread"<T>(task: $Supplier$$Type<(T)>): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KJSHTTPRequest$$Type = ($KJSHTTPRequest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KJSHTTPRequest$$Original = $KJSHTTPRequest;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.UUIDWrapper" {
import {$StringBuilder$$Type} from "java.lang.StringBuilder"
import {$UUID, $UUID$$Type} from "java.util.UUID"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $UUIDWrapper$$Interface {
}

export class $UUIDWrapper implements $UUIDWrapper$$Interface {
static "toString"(id: $UUID$$Type): StringJS
static "digits"(sb: $StringBuilder$$Type, val: long, digits: integer): void
static "fromString"(o: any): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UUIDWrapper$$Type = ($UUIDWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UUIDWrapper$$Original = $UUIDWrapper;}
declare module "dev.latvian.mods.kubejs.registry.RegistryKubeEvent" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$KubeStartupEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeStartupEvent"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$List} from "java.util.List"
import {$CustomBuilderObject} from "dev.latvian.mods.kubejs.registry.CustomBuilderObject"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$AdditionalObjectRegistry$$Interface} from "dev.latvian.mods.kubejs.registry.AdditionalObjectRegistry"

export class $RegistryKubeEvent<T> implements $KubeStartupEvent$$Interface, $AdditionalObjectRegistry$$Interface {
readonly "created": $List<($BuilderBase<(T)>)>

constructor(registryKey: $ResourceKey$$Type<($Registry<(T)>)>)

public "add"<R>(registry: $ResourceKey$$Type<($Registry<(R)>)>, builder: $BuilderBase$$Type<(R)>): void
public "create"(id: $ResourceLocation$$Type, type: $ResourceLocation$$Type): $BuilderBase<(T)>
public "create"(id: $ResourceLocation$$Type): $BuilderBase<(T)>
public "createCustom"(id: $ResourceLocation$$Type, object: () => T): $CustomBuilderObject
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryKubeEvent$$Type<T> = ($RegistryKubeEvent<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryKubeEvent$$Original<T> = $RegistryKubeEvent<(T)>;}
declare module "dev.latvian.mods.kubejs.recipe.schema.UnknownKubeRecipe" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$KubeRecipe} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeTypeFunction} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$KubeRecipeFactory} from "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"

export class $UnknownKubeRecipe extends $KubeRecipe {
 "newRecipe": boolean
static readonly "RECIPE_FACTORY": $KubeRecipeFactory
 "type": $RecipeTypeFunction
 "sourceLine": $SourceLine
 "originalJson": $JsonObject
 "removed": boolean
 "creationError": boolean
static readonly "TYPE_INFO": $TypeInfo
 "json": $JsonObject
static readonly "CHANGED_MARKER": StringJS
 "changed": boolean

constructor()

public "serialize"(): void
public "deserialize"(merge: boolean): void
public "replaceOutput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "replaceInput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "hasOutput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
public "hasInput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnknownKubeRecipe$$Type = ($UnknownKubeRecipe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UnknownKubeRecipe$$Original = $UnknownKubeRecipe;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Info" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Record} from "java.lang.Record"

export class $ItemData$Info extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData$Info)>

constructor(filter: $Ingredient$$Type, info: $List$$Type<($Component$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $Ingredient
public "info"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$Info$$Type = ({"filter"?: $Ingredient$$Type, "info"?: $List$$Type<($Component$$Type)>}) | ([filter?: $Ingredient$$Type, info?: $List$$Type<($Component$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemData$Info$$Original = $ItemData$Info;}
declare module "dev.latvian.mods.kubejs.item.FoodEatenKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an entity eats food.
 */
export class $FoodEatenKubeEvent implements $KubeEntityEvent$$Interface {
constructor(e: $LivingEntity$$Type, is: $ItemStack$$Type)

/**
 * The food that was eaten.
 */
public "getItem"(): $ItemStack
/**
 * The entity that ate the food.
 */
public "getEntity"(): $Entity
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "item"(): $ItemStack
get "entity"(): $Entity
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoodEatenKubeEvent$$Type = ($FoodEatenKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FoodEatenKubeEvent$$Original = $FoodEatenKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.FluidIngredientKJS" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Codec} from "com.mojang.serialization.Codec"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$WithCodec$$Interface} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$FluidMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.FluidMatch"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$SizedFluidIngredient} from "net.neoforged.neoforge.fluids.crafting.SizedFluidIngredient"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $FluidIngredientKJS$$Interface extends $WithCodec$$Interface, $FluidMatch$$Interface {
get "codec"(): $Codec<(never)>
}

export class $FluidIngredientKJS implements $FluidIngredientKJS$$Interface {
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $FluidIngredient$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, s: $FluidStack$$Type, exact: boolean): boolean
 "getCodec"(): $Codec<(never)>
 "self"(): $FluidIngredient
 "withAmount"(amount: integer): $SizedFluidIngredient
 "toNBT"(): $Tag
 "toJson"(): $JsonElement
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidIngredientKJS$$Type = ($FluidIngredientKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidIngredientKJS$$Original = $FluidIngredientKJS;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentCodecFactory" {
import {$RecipeTypeRegistryContext, $RecipeTypeRegistryContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext"
import {$RecipeComponentType, $RecipeComponentType$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$RecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export interface $RecipeComponentCodecFactory$$Interface<CT extends $RecipeComponent<(object)>> {

(type: $RecipeComponentType<(never)>, ctx: $RecipeTypeRegistryContext): $MapCodec$$Type<(CT)>
}

export class $RecipeComponentCodecFactory<CT extends $RecipeComponent<(object)>> implements $RecipeComponentCodecFactory$$Interface {
 "create"(type: $RecipeComponentType$$Type<(never)>, ctx: $RecipeTypeRegistryContext$$Type): $MapCodec<(CT)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentCodecFactory$$Type<CT> = ((type: $RecipeComponentType<(never)>, ctx: $RecipeTypeRegistryContext) => $MapCodec$$Type<(CT)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponentCodecFactory$$Original<CT> = $RecipeComponentCodecFactory<(CT)>;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.GroupEntriesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $GroupEntriesKubeEvent$$Interface<E, F> extends $KubeEvent$$Interface {

(filter: F, groupId: $ResourceLocation, description: $Component): void
}

export class $GroupEntriesKubeEvent<E, F> implements $GroupEntriesKubeEvent$$Interface {
 "group"(filter: F, groupId: $ResourceLocation$$Type, description: $Component$$Type): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GroupEntriesKubeEvent$$Type<E, F> = ((filter: any, groupId: $ResourceLocation, description: $Component) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GroupEntriesKubeEvent$$Original<E, F> = $GroupEntriesKubeEvent<(E), (F)>;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.DirectionWrapper" {
import {$Map} from "java.util.Map"
import {$Direction} from "net.minecraft.core.Direction"
import {$EnumSet} from "java.util.EnumSet"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $DirectionWrapper$$Interface {
}

export class $DirectionWrapper implements $DirectionWrapper$$Interface {
static readonly "ALL": $Map<(StringJS), ($Direction)>
static readonly "DOWN": $Direction
static readonly "ALL_SET": $EnumSet<($Direction)>
static readonly "south": $Direction
static readonly "north": $Direction
static readonly "WEST": $Direction
static readonly "down": $Direction
static readonly "east": $Direction
static readonly "NORTH": $Direction
static readonly "west": $Direction
static readonly "EMPTY_SET": $EnumSet<($Direction)>
static readonly "VALUES": ($Direction)[]
static readonly "up": $Direction
static readonly "UP": $Direction
static readonly "SOUTH": $Direction
static readonly "NONE": ($Direction)[]
static readonly "EAST": $Direction

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectionWrapper$$Type = ($DirectionWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectionWrapper$$Original = $DirectionWrapper;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.EntitySelectorWrapper" {
import {$EntitySelector, $EntitySelector$$Type} from "net.minecraft.commands.arguments.selector.EntitySelector"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $EntitySelectorWrapper {
constructor()

public static "of"(selector: $EntitySelector$$Type): $EntitySelector
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySelectorWrapper$$Type = ($EntitySelectorWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntitySelectorWrapper$$Original = $EntitySelectorWrapper;}
declare module "dev.latvian.mods.kubejs.block.custom.SlabBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $SlabBlockBuilder extends $ShapedBlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "SLAB_TAGS": ($ResourceLocation)[]

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlabBlockBuilder$$Type = ($SlabBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SlabBlockBuilder$$Original = $SlabBlockBuilder;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$NameCallback" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $ItemBuilder$NameCallback$$Interface {

(itemStack: $ItemStack): $Component$$Type
}

export class $ItemBuilder$NameCallback implements $ItemBuilder$NameCallback$$Interface {
 "apply"(itemStack: $ItemStack$$Type): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$NameCallback$$Type = ((itemStack: $ItemStack) => $Component$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$NameCallback$$Original = $ItemBuilder$NameCallback;}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabCallback" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$CreativeModeTab$TabVisibility$$Type} from "net.minecraft.world.item.CreativeModeTab$TabVisibility"

export interface $CreativeTabCallback$$Interface {
}

export class $CreativeTabCallback implements $CreativeTabCallback$$Interface {
 "remove"(filter: $ItemPredicate$$Type, removeParent: boolean, removeSearch: boolean): void
 "addBefore"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[], visibility: $CreativeModeTab$TabVisibility$$Type): void
 "addAfter"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[], visibility: $CreativeModeTab$TabVisibility$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabCallback$$Type = ($CreativeTabCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeTabCallback$$Original = $CreativeTabCallback;}
declare module "dev.latvian.mods.kubejs.core.WithAttachedData" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MessageSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $WithAttachedData$$Interface<T> extends $MessageSenderKJS$$Interface {

(): $AttachedData$$Type<(T)>
get "data"(): $AttachedData<(T)>
get "name"(): $Component
get "displayName"(): $Component
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $WithAttachedData<T> implements $WithAttachedData$$Interface {
 "getData"(): $AttachedData<(T)>
 "runCommand"(command: StringJS): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "tell"(message: $Component$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithAttachedData$$Type<T> = (() => $AttachedData$$Type<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WithAttachedData$$Original<T> = $WithAttachedData<(T)>;}
declare module "dev.latvian.mods.kubejs.item.custom.ItemToolTierRegistryKubeEvent" {
import {$MutableToolTier$$Type} from "dev.latvian.mods.kubejs.item.MutableToolTier"
import {$Map, $Map$$Type} from "java.util.Map"
import {$KubeStartupEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeStartupEvent"
import {$Tier, $Tier$$Type} from "net.minecraft.world.item.Tier"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$Record} from "java.lang.Record"

/**
 * Invoked when the game is starting up and the item tool tiers are being registered.
 */
export class $ItemToolTierRegistryKubeEvent extends $Record implements $KubeStartupEvent$$Interface {
constructor(tiers: $Map$$Type<(StringJS), ($Tier$$Type)>)

public "tiers"(): $Map<(StringJS), ($Tier)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
/**
 * Adds a new tool tier.
 */
public "add"(id: StringJS, tier: $Consumer$$Type<($MutableToolTier)>): void
public "addExisting"(id: StringJS, tier: $Tier$$Type): void
public "addBasedOnExisting"(id: StringJS, existing: StringJS, tier: $Consumer$$Type<($MutableToolTier)>): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemToolTierRegistryKubeEvent$$Type = ({"tiers"?: $Map$$Type<(StringJS), ($Tier$$Type)>}) | ([tiers?: $Map$$Type<(StringJS), ($Tier$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemToolTierRegistryKubeEvent$$Original = $ItemToolTierRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.script.ScriptsLoadedEvent" {
import {$Event} from "net.neoforged.bus.api.Event"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptsLoadedEvent extends $Event {
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptsLoadedEvent$$Type = ($ScriptsLoadedEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptsLoadedEvent$$Original = $ScriptsLoadedEvent;}
declare module "dev.latvian.mods.kubejs.registry.AdditionalObjectRegistry" {
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"

export interface $AdditionalObjectRegistry$$Interface {

(registry: $ResourceKey<($Registry<(T)>)>, builder: $BuilderBase<(T)>): void
}

export class $AdditionalObjectRegistry implements $AdditionalObjectRegistry$$Interface {
 "add"<T>(registry: $ResourceKey$$Type<($Registry<(T)>)>, builder: $BuilderBase$$Type<(T)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdditionalObjectRegistry$$Type = ((registry: $ResourceKey<($Registry<(T)>)>, builder: $BuilderBase<(T)>) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AdditionalObjectRegistry$$Original = $AdditionalObjectRegistry;}
declare module "dev.latvian.mods.kubejs.recipe.special.SpecialRecipeSerializerManager$AfterPost" {
import {$Event} from "net.neoforged.bus.api.Event"

export class $SpecialRecipeSerializerManager$AfterPost extends $Event {
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpecialRecipeSerializerManager$AfterPost$$Type = ($SpecialRecipeSerializerManager$AfterPost);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpecialRecipeSerializerManager$AfterPost$$Original = $SpecialRecipeSerializerManager$AfterPost;}
declare module "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundGen" {
import {$SoundsGenerator$SoundInstance$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundInstance"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $SoundsGenerator$SoundGen {
constructor()

public "replace"(): $SoundsGenerator$SoundGen
public "replace"(b: boolean): $SoundsGenerator$SoundGen
public "subtitle"(subtitle: StringJS): $SoundsGenerator$SoundGen
public "sound"(file: StringJS, consumer: $Consumer$$Type<($SoundsGenerator$SoundInstance)>): $SoundsGenerator$SoundGen
public "sound"(file: StringJS): $SoundsGenerator$SoundGen
public "toJson"(): $JsonObject
public "sounds"(...sounds: (StringJS)[]): $SoundsGenerator$SoundGen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundsGenerator$SoundGen$$Type = ($SoundsGenerator$SoundGen);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoundsGenerator$SoundGen$$Original = $SoundsGenerator$SoundGen;}
declare module "dev.latvian.mods.kubejs.level.WrappedSpawner" {
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Either$$Type} from "com.mojang.datafixers.util.Either"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$Record} from "java.lang.Record"

export class $WrappedSpawner extends $Record {
constructor(entity: $Entity$$Type, block: $LevelBlock$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "of"(spawner: $Either$$Type<($BlockEntity$$Type), ($Entity$$Type)>): $WrappedSpawner
public "block"(): $LevelBlock
public "entity"(): $Entity
public "isWorldgen"(): boolean
get "worldgen"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedSpawner$$Type = ({"block"?: $LevelBlock$$Type, "entity"?: $Entity$$Type}) | ([block?: $LevelBlock$$Type, entity?: $Entity$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WrappedSpawner$$Original = $WrappedSpawner;}
declare module "dev.latvian.mods.kubejs.util.ClassWrapper" {
import {$CustomJavaToJsWrapper$$Interface} from "dev.latvian.mods.rhino.util.CustomJavaToJsWrapper"
import {$TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$Record} from "java.lang.Record"

export class $ClassWrapper<T> extends $Record implements $CustomJavaToJsWrapper$$Interface {
constructor(wrappedClass: $Class$$Type<(T)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "wrappedClass"(): $Class<(T)>
public "convertJavaToJs"(scope: $Scriptable$$Type, staticType: $TypeInfo$$Type): $Scriptable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassWrapper$$Type<T> = ({"wrappedClass"?: $Class$$Type<(T)>}) | ([wrappedClass?: $Class$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClassWrapper$$Original<T> = $ClassWrapper<(T)>;}
declare module "dev.latvian.mods.kubejs.entity.BeforeLivingEntityHurtKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$DamageSource} from "net.minecraft.world.damagesource.DamageSource"
import {$LivingDamageEvent$Pre$$Type} from "net.neoforged.neoforge.event.entity.living.LivingDamageEvent$Pre"
import {$Level} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked before an entity is hurt by a damage source.
 */
export class $BeforeLivingEntityHurtKubeEvent implements $KubeLivingEntityEvent$$Interface {
constructor(event: $LivingDamageEvent$Pre$$Type)

/**
 * The damage source.
 */
public "getSource"(): $DamageSource
/**
 * The entity that was hurt.
 */
public "getEntity"(): $Entity
/**
 * The amount of damage.
 */
public "getDamage"(): float
public "setDamage"(damage: float): void
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "source"(): $DamageSource
get "entity"(): $Entity
get "damage"(): float
set "damage"(value: float)
get "level"(): $Level
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeforeLivingEntityHurtKubeEvent$$Type = ($BeforeLivingEntityHurtKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeforeLivingEntityHurtKubeEvent$$Original = $BeforeLivingEntityHurtKubeEvent;}
declare module "dev.latvian.mods.kubejs.server.tag.PreTagKubeEvent" {
import {$EventExceptionHandler} from "dev.latvian.mods.kubejs.event.EventExceptionHandler"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$PreTagWrapper} from "dev.latvian.mods.kubejs.server.tag.PreTagWrapper"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$Set} from "java.util.Set"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$TagKubeEvent} from "dev.latvian.mods.kubejs.server.tag.TagKubeEvent"
import {$Consumer} from "java.util.function.Consumer"

export class $PreTagKubeEvent extends $TagKubeEvent {
readonly "registryKey": $ResourceKey<(never)>
 "totalRemoved": integer
 "invalid": boolean
static readonly "SOURCE": StringJS
readonly "vanillaRegistry": $Registry<(never)>
 "totalAdded": integer
static readonly "TAG_EVENT_HANDLER": $EventExceptionHandler
readonly "actions": $List<($Consumer<($TagKubeEvent)>)>
readonly "tags": $Map<($ResourceLocation), ($PreTagWrapper)>

constructor(registryKey: $ResourceKey$$Type<(never)>)

public static "handle"(tagEventHolders: $Map$$Type<($ResourceKey$$Type<(never)>), ($PreTagKubeEvent$$Type)>): void
public "getElementIds"(): $Set<($ResourceLocation)>
public "removeAllTagsFrom"(...ignored: (any)[]): void
get "elementIds"(): $Set<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PreTagKubeEvent$$Type = ($PreTagKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PreTagKubeEvent$$Original = $PreTagKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.match.Replaceable" {
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"

export interface $Replaceable$$Interface {
}

export class $Replaceable implements $Replaceable$$Interface {
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Replaceable$$Type = ($Replaceable);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Replaceable$$Original = $Replaceable;}
declare module "dev.latvian.mods.kubejs.block.custom.WallBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $WallBlockBuilder extends $ShapedBlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "WALL_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WallBlockBuilder$$Type = ($WallBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WallBlockBuilder$$Original = $WallBlockBuilder;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.AddInformationKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $AddInformationKubeEvent$$Interface<E, F> extends $KubeEvent$$Interface {

(filter: F, info: $List<($Component)>): void
}

export class $AddInformationKubeEvent<E, F> implements $AddInformationKubeEvent$$Interface {
 "add"(filter: F, info: $List$$Type<($Component$$Type)>): void
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddInformationKubeEvent$$Type<E, F> = ((filter: any, info: $List<($Component)>) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AddInformationKubeEvent$$Original<E, F> = $AddInformationKubeEvent<(E), (F)>;}
declare module "dev.latvian.mods.kubejs.block.BlockBuilder" {
import {$BlockRenderType$$Type} from "dev.latvian.mods.kubejs.block.BlockRenderType"
import {$BlockRightClickedKubeEvent$$Type} from "dev.latvian.mods.kubejs.block.BlockRightClickedKubeEvent"
import {$MapColor$$Type} from "net.minecraft.world.level.material.MapColor"
import {$AfterEntityFallenOnBlockCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.AfterEntityFallenOnBlockCallback"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockBehaviour$Properties} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$NoteBlockInstrument$$Type} from "net.minecraft.world.level.block.state.properties.NoteBlockInstrument"
import {$BlockDropSupplier$$Type} from "dev.latvian.mods.kubejs.block.drop.BlockDropSupplier"
import {$KubeDataGenerator$$Type} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Function$$Type} from "java.util.function.Function"
import {$EntitySteppedOnBlockCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.EntitySteppedOnBlockCallback"
import {$ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$CanBeReplacedCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.CanBeReplacedCallback"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BlockTintFunction$$Type} from "dev.latvian.mods.kubejs.block.BlockTintFunction"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback, $RandomTickCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BlockEntityInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityInfo"
import {$SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$BlockStateRotateCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.BlockStateRotateCallback"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockStateModifyPlacementCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.BlockStateModifyPlacementCallback"
import {$BlockExplodedCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.BlockExplodedCallback"
import {$ModelledBuilderBase} from "dev.latvian.mods.kubejs.registry.ModelledBuilderBase"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$BlockStateMirrorCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.BlockStateMirrorCallback"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$EntityFallenOnBlockCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.EntityFallenOnBlockCallback"
import {$Registry} from "net.minecraft.core.Registry"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$BlockStateModifyCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.BlockStateModifyCallback"
import {$Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $BlockBuilder extends $ModelledBuilderBase<($Block)> {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

/**
 * Set the callback for determining the blocks state when placed.
 */
public "placementState"(callbackJS: $Consumer$$Type<($BlockStateModifyPlacementCallback)>): this
public "createProperties"(): $BlockBehaviour$Properties
/**
 * Add a blockstate property to the block.
 * 
 * For example, facing, lit, etc.
 */
public "property"(property: $Property$$Type<(never)>): this
/**
 * Set the shape of the block.
 */
public "box"(x0: double, y0: double, z0: double, x1: double, y1: double, z1: double, scale16: boolean): this
/**
 * Set the shape of the block.
 */
public "box"(x0: double, y0: double, z0: double, x1: double, y1: double, z1: double): this
/**
 * Set the color of a specific layer of the block.
 */
public "color"(color: $BlockTintFunction$$Type): this
/**
 * Set the color of a specific layer of the block.
 */
public "color"(index: integer, color: $BlockTintFunction$$Type): this
/**
 * Sets the display name for this object, e.g. `Stone`.
 * 
 * This will be overridden by a lang file if it exists.
 */
public "displayName"(name: $Component$$Type): $BuilderBase<($Block)>
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
/**
 * Modifies the block's item representation.
 */
public "item"(i: $Consumer$$Type<($ItemBuilder)>): this
/**
 * Note block instrument.
 */
public "instrument"(i: $NoteBlockInstrument$$Type): this
/**
 * Makes the block transparent.
 */
public "transparent"(b: boolean): this
/**
 * Sets the render type of the block. Can be `cutout`, `cutout_mipped`, `translucent`, or `basic`.
 */
public "renderType"(l: $BlockRenderType$$Type): this
/**
 * Sets the opacity of the block. Opaque blocks do not let light through.
 */
public "opaque"(o: boolean): this
/**
 * Creates a Block Entity for this block
 */
public "blockEntity"(callback: $Consumer$$Type<($BlockEntityInfo)>): this
/**
 * Sets the hardness of the block. Defaults to 1.5.
 * 
 * Setting this to -1 will make the block unbreakable like bedrock.
 */
public "hardness"(h: float): this
/**
 * Makes the block suffocating.
 */
public "suffocating"(b: boolean): this
/**
 * Set if the block can be replaced by something else.
 */
public "canBeReplaced"(callbackJS: $Predicate$$Type<($CanBeReplacedCallback)>): this
/**
 * Set how fast you can walk on the block.
 * 
 * Any value above 1 will make you walk insanely fast as your speed is multiplied by this value each tick.
 * 
 * Recommended values are between 0.1 and 1, useful for mimicking soul sand or ice.
 */
public "speedFactor"(f: float): this
/**
 * Sets the blast resistance of the block. Defaults to 3.
 */
public "resistance"(r: float): this
/**
 * Sets the block should be a full block or not, like cactus or doors.
 */
public "fullBlock"(f: boolean): this
/**
 * Set the callback used for right-clicking on the block
 */
public "rightClick"(callbackJS: $Consumer$$Type<($BlockRightClickedKubeEvent)>): this
/**
 * Sets the light level of the block. Defaults to 0 (no light).
 */
public "lightLevel"(light: float): this
/**
 * Makes the block can be waterlogged.
 */
public "waterlogged"(): this
/**
 * Set the default state of the block.
 */
public "defaultState"(callbackJS: $Consumer$$Type<($BlockStateModifyCallback)>): this
/**
 * Set how high you can jump on the block.
 */
public "jumpFactor"(f: float): this
/**
 * Sets the block's sound type. Defaults to wood.
 */
public "soundType"(m: $SoundType$$Type): this
/**
 * Sets random tick callback for this black.
 */
public "randomTick"(randomTickCallback: $Consumer$$Type<($RandomTickCallback)>): this
/**
 * Sets the block's map color. Defaults to NONE.
 */
public "mapColor"(m: $MapColor$$Type): this
/**
 * Makes the block unbreakable.
 */
public "unbreakable"(): this
/**
 * Change drops of this block
 */
public "drops"(drops: $BlockDropSupplier$$Type): this
/**
 * Makes the block not collide with entities.
 */
public "noCollision"(): this
public "transformObject"(obj: $Block$$Type): $Block
public "generateLootTable"(generator: $KubeDataGenerator$$Type): $LootTable
/**
 * 
 * @deprecated
 */
public "generateLootTable"(): $LootTable
public "copyPropertiesFrom"(block: $Block$$Type): this
public "noSoundType"(): this
/**
 * Makes mobs not spawn on the block.
 */
public "noValidSpawns"(b: boolean): this
/**
 * Helper method for setting the render type of the block to `cutout` correctly.
 */
public "defaultCutout"(): this
/**
 * Checks if the block can be waterlogged.
 */
public "canBeWaterlogged"(): boolean
/**
 * Set how this block bounces/moves entities that land on top of this. Do not use this to modify the block, use fallOn instead!
 * Use ctx.bounce(height) or ctx.setVelocity(x, y, z) to change the entities velocity.
 */
public "afterFallenOn"(callbackJS: $Consumer$$Type<($AfterEntityFallenOnBlockCallback)>): this
/**
 * Makes the block view blocking.
 */
public "viewBlocking"(b: boolean): this
/**
 * Makes the block a redstone conductor.
 */
public "redstoneConductor"(b: boolean): this
public "woodSoundType"(): this
public "stoneSoundType"(): this
public "gravelSoundType"(): this
/**
 * Set how slippery the block is.
 */
public "slipperiness"(f: float): this
/**
 * Makes the block require a tool to have drops when broken.
 */
public "requiresTool"(): this
/**
 * Makes the block require a tool to have drops when broken.
 */
public "requiresTool"(f: boolean): this
public "cropSoundType"(): this
/**
 * Set the callback used for determining how the block rotates
 */
public "rotateState"(callbackJS: $Consumer$$Type<($BlockStateRotateCallback)>): this
public "glassSoundType"(): this
/**
 * 
 * @deprecated
 */
public "getWaterlogged"(): boolean
/**
 * 
 * @deprecated
 */
public "setWaterlogged"(waterlogged: boolean): this
/**
 * Set the callback used for determining how the block is mirrored
 */
public "mirrorState"(callbackJS: $Consumer$$Type<($BlockStateMirrorCallback)>): this
/**
 * Helper method for setting the render type of the block to `translucent` correctly.
 */
public "defaultTranslucent"(): this
public "grassSoundType"(): this
public "sandSoundType"(): this
/**
 * Sets the block's map color dynamically per block state. If unset, defaults to NONE.
 */
public "dynamicMapColor"(m: $Function$$Type<($BlockState), (any)>): this
public static "createShape"(boxes: $List$$Type<($AABB$$Type)>): $VoxelShape
/**
 * Set what happens when an entity falls on the block. Do not use this for moving them, use bounce instead!
 */
public "fallenOn"(callbackJS: $Consumer$$Type<($EntityFallenOnBlockCallback)>): this
/**
 * Bounces entities that land on this block by bounciness * their fall velocity.
 * Do not make bounciness negative, as that is a recipe for a long and laggy trip to the void
 */
public "bounciness"(bounciness: float): this
/**
 * Set the block to have no corresponding item.
 */
public "noItem"(): this
/**
 * Set what happens when an entity steps on the block
 * This is called every tick for every entity standing on the block, so be careful what you do here.
 */
public "steppedOn"(callbackJS: $Consumer$$Type<($EntitySteppedOnBlockCallback)>): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tagBoth"(tag: ($ResourceLocation$$Type)[]): this
/**
 * Makes the block not be solid.
 */
public "notSolid"(): this
/**
 * Set how this block reacts after an explosion. Note the block has already been destroyed at this point
 */
public "exploded"(callbackJS: $Consumer$$Type<($BlockExplodedCallback)>): this
/**
 * Tags the item with the given tag.
 */
public "tagItem"(tag: ($ResourceLocation$$Type)[]): this
/**
 * Clears all drops for the block.
 */
public "noDrops"(): this
/**
 * Tags the block with the given tag.
 */
public "tagBlock"(tag: ($ResourceLocation$$Type)[]): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBuilder$$Type = ($BlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBuilder$$Original = $BlockBuilder;}
declare module "dev.latvian.mods.kubejs.component.AttributeModifierFunctions" {
import {$AttributeModifier, $AttributeModifier$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$EquipmentSlotGroup$$Type} from "net.minecraft.world.entity.EquipmentSlotGroup"
import {$List$$Type} from "java.util.List"
import {$ItemAttributeModifiers, $ItemAttributeModifiers$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export interface $AttributeModifierFunctions$$Interface {

(): $ItemAttributeModifiers$$Type
get "attackSpeed"(): double
set "attackSpeed"(value: double)
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "baseAttackDamage"(value: double)
get "baseAttackDamage"(): double
set "attackDamage"(value: double)
get "attackDamage"(): double
set "baseAttackSpeed"(value: double)
get "baseAttackSpeed"(): double
get "attributeModifiers"(): $ItemAttributeModifiers
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
}

export class $AttributeModifierFunctions implements $AttributeModifierFunctions$$Interface {
 "getAttackSpeed"(): double
/**
 * Sets the attack speed of this item to the given value, **removing** all other modifiers to attack speed.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 * (Example: Swords have an attack speed of -2.4, leading to a total value of 1.6 without any other changes.)
 */
 "setAttackSpeed"(speed: double): void
 "setAttributeModifiersWithTooltip"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Overrides the *base* attack damage of this item to be the given value, keeping other modifiers intact.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 */
 "setBaseAttackDamage"(dmg: double): void
 "getBaseAttackDamage"(): double
 "addAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, mod: $AttributeModifier$$Type, slot: $EquipmentSlotGroup$$Type): void
 "hasAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): boolean
/**
 * Sets the attack damage of this item to the given value, **removing** all other modifiers to attack damage.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 * (In practice, this simply means that most weapons have this value set to 1 less than what you might think.)
 */
 "setAttackDamage"(dmg: double): void
 "getAttackDamage"(): double
/**
 * Overrides the *base* attack speed of this item to be the given value, keeping other modifiers intact.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 */
 "setBaseAttackSpeed"(speed: double): void
 "getBaseAttackSpeed"(): double
 "getAttributeModifiers"(): $ItemAttributeModifiers
 "getAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): $AttributeModifier
 "setAttributeModifiers"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributeModifierFunctions$$Type = (() => $ItemAttributeModifiers$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttributeModifierFunctions$$Original = $AttributeModifierFunctions;}
declare module "dev.latvian.mods.kubejs.recipe.RecipeScriptContext" {
import {$Context} from "dev.latvian.mods.rhino.Context"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$ErrorStack} from "dev.latvian.mods.kubejs.util.ErrorStack"
import {$RecipeValidationContext$$Interface} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$RecipeMatchContext$$Interface} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$WithScriptContext$$Interface} from "dev.latvian.mods.kubejs.script.WithScriptContext"
import {$RecipeLikeKJS} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$KubeRecipeContext$$Interface} from "dev.latvian.mods.kubejs.recipe.KubeRecipeContext"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RecipeScriptContext$$Interface extends $WithScriptContext$$Interface, $RecipeValidationContext$$Interface, $KubeRecipeContext$$Interface, $RecipeMatchContext$$Interface {
}

export class $RecipeScriptContext implements $RecipeScriptContext$$Interface {
 "cx"(): $Context
 "errors"(): $ErrorStack
 "ops"(): $RegistryOpsContainer
 "recipe"(): $RecipeLikeKJS
 "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeScriptContext$$Type = ($RecipeScriptContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeScriptContext$$Original = $RecipeScriptContext;}
declare module "dev.latvian.mods.kubejs.recipe.CachedTagLookup$Entry" {
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$CachedTagLookup, $CachedTagLookup$$Type} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup"
import {$Record} from "java.lang.Record"

export class $CachedTagLookup$Entry<T> extends $Record {
constructor(key: $ResourceKey$$Type<(T)>, registry: $Registry$$Type<(T)>, lookup: $CachedTagLookup$$Type<(T)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "lookup"(): $CachedTagLookup<(T)>
public "key"(): $ResourceKey<(T)>
public "registry"(): $Registry<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedTagLookup$Entry$$Type<T> = ({"lookup"?: $CachedTagLookup$$Type<(T)>, "key"?: $ResourceKey$$Type<(T)>, "registry"?: $Registry$$Type<(T)>}) | ([lookup?: $CachedTagLookup$$Type<(T)>, key?: $ResourceKey$$Type<(T)>, registry?: $Registry$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CachedTagLookup$Entry$$Original<T> = $CachedTagLookup$Entry<(T)>;}
declare module "dev.latvian.mods.kubejs.color.KubeColor" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Optional} from "java.util.Optional"
import {$SpecialEquality$$Interface} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$TextColor} from "net.minecraft.network.chat.TextColor"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export interface $KubeColor$$Interface extends $SpecialEquality$$Interface {

(): integer
get "rgb"(): integer
get "argb"(): integer
get "fireworkRGB"(): integer
}

export class $KubeColor implements $KubeColor$$Interface {
static readonly "CODEC": $Codec<($KubeColor)>
static readonly "OPTIONAL_STREAM_CODEC": $StreamCodec<($ByteBuf), ($Optional<($KubeColor)>)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($KubeColor)>

 "specialEquals"(o: any, shallow: boolean): boolean
 "createTextColor"(): $TextColor
 "getRgb"(): integer
 "serialize"(): StringJS
 "getArgb"(): integer
 "toHexString"(): StringJS
 "getFireworkRGB"(): integer
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeColor$$Type = (("") | ("light_blue_dye") | ("blue_dye") | ("purple_dye") | ("dark_red") | ("lightgraydye") | ("dark_aqua") | ("none") | ("green_dye") | ("blackdye") | ("dark_blue") | ("red") | ("pink_dye") | ("aqua") | ("white") | ("white_dye") | ("dark_gray") | ("light_purple") | ("brown_dye") | ("black") | ("darkpurple") | ("lightbluedye") | ("limedye") | ("magenta_dye") | ("-") | ("lime_dye") | ("yellowdye") | ("graydye") | ("purpledye") | ("dark_purple") | ("orange_dye") | ("darkgray") | ("browndye") | ("yellow") | ("bluedye") | ("pinkdye") | ("cyandye") | ("gold") | ("gray") | ("blue") | ("darkblue") | ("transparent") | ("red_dye") | ("darkred") | ("greendye") | ("reddye") | ("gray_dye") | ("orangedye") | ("yellow_dye") | ("black_dye") | ("magentadye") | ("green") | ("light_gray_dye") | ("darkgreen") | ("dark_green") | ("lightpurple") | ("darkaqua") | ("cyan_dye") | ("whitedye")) | (`#${string}`) | (integer) | (() => integer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeColor$$Original = $KubeColor;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.AABBWrapper" {
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AABB} from "net.minecraft.world.phys.AABB"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $AABBWrapper$$Interface {
}

export class $AABBWrapper implements $AABBWrapper$$Interface {
static readonly "CUBE": $AABB
static readonly "EMPTY": $AABB

static "wrap"(o: any): $AABB
static "of"(x0: double, y0: double, z0: double, x1: double, y1: double, z1: double): $AABB
static "ofSize"(x: double, y: double, z: double): $AABB
static "ofSize"(vec3: $Vec3$$Type, x: double, y: double, z: double): $AABB
static "ofBlocks"(pos1: $BlockPos$$Type, pos2: $BlockPos$$Type): $AABB
static "ofBlock"(pos: $BlockPos$$Type): $AABB
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AABBWrapper$$Type = ($AABBWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AABBWrapper$$Original = $AABBWrapper;}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate$PropertyObject" {
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"
import {$Record} from "java.lang.Record"

export class $BlockIDPredicate$PropertyObject extends $Record {
constructor(property: $Property$$Type<(never)>, value: any)

public "value"(): any
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "property"(): $Property<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockIDPredicate$PropertyObject$$Type = ({"property"?: $Property$$Type<(never)>, "value"?: any}) | ([property?: $Property$$Type<(never)>, value?: any]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockIDPredicate$PropertyObject$$Original = $BlockIDPredicate$PropertyObject;}
declare module "dev.latvian.mods.kubejs.util.RegistryAccessContainer" {
import {$OpsContainer} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$Collection} from "java.util.Collection"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$DynamicOps} from "com.mojang.serialization.DynamicOps"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List$$Type} from "java.util.List"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$DamageSources} from "net.minecraft.world.damagesource.DamageSources"
import {$Holder} from "net.minecraft.core.Holder"
import {$RegistryWrapper} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.RegistryWrapper"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$CachedItemTagLookup} from "dev.latvian.mods.kubejs.recipe.CachedItemTagLookup"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryAccess$Frozen, $RegistryAccess$Frozen$$Type} from "net.minecraft.core.RegistryAccess$Frozen"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$ICondition$IContext$$Interface} from "net.neoforged.neoforge.common.conditions.ICondition$IContext"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$CachedTagLookup$Entry} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup$Entry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$CachedTagLookup} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup"

export class $RegistryAccessContainer extends $RegistryOpsContainer implements $ICondition$IContext$$Interface {
static "current": $RegistryAccessContainer
 "cachedBlockTags": $CachedTagLookup<($Block)>
 "cachedFluidTags": $CachedTagLookup<($Fluid)>
 "cachedItemTags": $CachedItemTagLookup
static readonly "BUILTIN": $RegistryAccessContainer
readonly "cachedRegistryTags": $Map<($ResourceKey<(never)>), ($CachedTagLookup$Entry<(never)>)>
static readonly "DEFAULT": $OpsContainer

constructor(access: $RegistryAccess$Frozen$$Type)

public static "of"(): $RegistryAccessContainer
public "access"(): $RegistryAccess$Frozen
public "getAllTags"<T>(key: $ResourceKey$$Type<($Registry<(T)>)>): $Map<($ResourceLocation), ($Collection<($Holder<(T)>)>)>
public "wrapRegistry"(id: $ResourceLocation$$Type): $RegistryWrapper<(never)>
public "damageSources"(): $DamageSources
public "cacheTags"<T>(registry: $Registry$$Type<(T)>, map: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>): void
public "itemStackParseCache"(): $Map<(StringJS), ($ItemStack)>
public "getTag"<T>(arg0: $TagKey$$Type<(T)>): $Collection<($Holder<(T)>)>
public "java"(): $DynamicOps
public "json"(): $DynamicOps
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryAccessContainer$$Type = ($RegistryAccessContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryAccessContainer$$Original = $RegistryAccessContainer;}
declare module "dev.latvian.mods.kubejs.item.MutableToolTier" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Tool} from "net.minecraft.world.item.component.Tool"
import {$Tier, $Tier$$Type, $Tier$$Interface} from "net.minecraft.world.item.Tier"

export class $MutableToolTier implements $Tier$$Interface {
readonly "parent": $Tier

constructor(p: $Tier$$Type)

public "setUses"(i: integer): void
public "getVanillaRepairIngredient"(): $Ingredient
public "getIncorrectBlocksForDrops"(): $TagKey<($Block)>
public "getAttackDamageBonus"(): float
public "getUses"(): integer
public "getEnchantmentValue"(): integer
public "getSpeed"(): float
public "setSpeed"(f: float): void
public "setIncorrectBlocksForDropsTag"(tag: $ResourceLocation$$Type): void
public "getIncorrectBlocksForDropsTag"(): $ResourceLocation
public "setAttackDamageBonus"(f: float): void
public "setEnchantmentValue"(i: integer): void
public "setRepairIngredient"(arg0: $Ingredient$$Type): void
public "createToolProperties"(arg0: $TagKey$$Type<($Block)>): $Tool
set "uses"(value: integer)
get "vanillaRepairIngredient"(): $Ingredient
get "incorrectBlocksForDrops"(): $TagKey<($Block)>
get "attackDamageBonus"(): float
get "uses"(): integer
get "enchantmentValue"(): integer
get "speed"(): float
set "speed"(value: float)
set "incorrectBlocksForDropsTag"(value: $ResourceLocation$$Type)
get "incorrectBlocksForDropsTag"(): $ResourceLocation
set "attackDamageBonus"(value: float)
set "enchantmentValue"(value: integer)
set "repairIngredient"(value: $Ingredient$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableToolTier$$Type = ($MutableToolTier);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MutableToolTier$$Original = $MutableToolTier;}
declare module "dev.latvian.mods.kubejs.client.ModelGenerator" {
import {$Map$$Type} from "java.util.Map"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ModelGenerator$Override$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator$Override"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$ModelGenerator$Element$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator$Element"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ModelGenerator {
constructor()

public "parent"(s: $ResourceLocation$$Type): void
public "override"(model: $ResourceLocation$$Type, override: $Consumer$$Type<($ModelGenerator$Override)>): void
public "element"(consumer: $Consumer$$Type<($ModelGenerator$Element)>): void
public "toJson"(): $JsonObject
public "custom"(json: $Consumer$$Type<($JsonObject)>): void
public "textures"(map: $Map$$Type<(StringJS), (StringJS)>): void
public "texture"(name: (StringJS)[], texture: StringJS): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$$Type = ($ModelGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModelGenerator$$Original = $ModelGenerator;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuSlot" {
import {$ChestMenuData, $ChestMenuData$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuData"
import {$ChestMenuClickHandler} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickHandler"
import {$Map} from "java.util.Map"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$ChestMenuClickEvent$Callback$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$ClickType$$Type} from "net.minecraft.world.inventory.ClickType"

export class $ChestMenuSlot {
 "data": $Map<(StringJS), (any)>
readonly "clickHandlers": $List<($ChestMenuClickHandler)>
readonly "x": integer
readonly "index": integer
readonly "y": integer
 "inventorySlot": integer
readonly "gui": $ChestMenuData
 "inventory": $InventoryKJS

constructor(gui: $ChestMenuData$$Type, index: integer)

public "toString"(): StringJS
public "setThrown"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "getItem"(): $ItemStack
public "clicked"(type: $ClickType$$Type, button: integer, callback: $ChestMenuClickEvent$Callback$$Type, autoHandle: boolean): void
public "setLeftClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setRightClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "resetClickHandlers"(): void
public "setDoubleClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setMiddleClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setItem"(stack: $ItemStack$$Type): void
public "setSwapped"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setShiftLeftClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setShiftRightClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
set "thrown"(value: $ChestMenuClickEvent$Callback$$Type)
get "item"(): $ItemStack
set "leftClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "rightClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "doubleClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "middleClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "item"(value: $ItemStack$$Type)
set "swapped"(value: $ChestMenuClickEvent$Callback$$Type)
set "shiftLeftClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "shiftRightClicked"(value: $ChestMenuClickEvent$Callback$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuSlot$$Type = ($ChestMenuSlot);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuSlot$$Original = $ChestMenuSlot;}
declare module "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$ShapeBuilder" {
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$List} from "java.util.List"

export class $CropBlockBuilder$ShapeBuilder {
constructor(age: integer)

/**
 * Describe the shape of the crop at a specific age.
 * min/max coordinates are double values between 0 and 16.
 */
public "shape"(age: integer, minX: double, minY: double, minZ: double, maxX: double, maxY: double, maxZ: double): $CropBlockBuilder$ShapeBuilder
/**
 * Makes the block to have a box like wheat for each stage.
 */
public "wheat"(): $CropBlockBuilder$ShapeBuilder
/**
 * Makes the block to have a box like beetroot for each stage.
 */
public "beetroot"(): $CropBlockBuilder$ShapeBuilder
/**
 * Makes the block to have a box like carrot for each stage.
 */
public "carrot"(): $CropBlockBuilder$ShapeBuilder
/**
 * Makes the block to have a box like potato for each stage.
 */
public "potato"(): $CropBlockBuilder$ShapeBuilder
public "getShapes"(): $List<($VoxelShape)>
get "shapes"(): $List<($VoxelShape)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlockBuilder$ShapeBuilder$$Type = ($CropBlockBuilder$ShapeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CropBlockBuilder$ShapeBuilder$$Original = $CropBlockBuilder$ShapeBuilder;}
declare module "dev.latvian.mods.kubejs.level.ExplosionKubeEvent" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $ExplosionKubeEvent implements $KubeLevelEvent$$Interface {
constructor(level: $Level$$Type, explosion: $Explosion$$Type)

public "getPosition"(): $Vec3
public "getLevel"(): $Level
public "getX"(): double
public "getZ"(): double
public "getBlock"(): $LevelBlock
public "getY"(): double
public "getExploder"(): $LivingEntity
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "position"(): $Vec3
get "level"(): $Level
get "x"(): double
get "z"(): double
get "block"(): $LevelBlock
get "y"(): double
get "exploder"(): $LivingEntity
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionKubeEvent$$Type = ($ExplosionKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExplosionKubeEvent$$Original = $ExplosionKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.FarmlandTrampledKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockEvent$FarmlandTrampleEvent$$Type} from "net.neoforged.neoforge.event.level.BlockEvent$FarmlandTrampleEvent"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an entity attempts to trample farmland.
 */
export class $FarmlandTrampledKubeEvent implements $KubeEntityEvent$$Interface {
constructor(event: $BlockEvent$FarmlandTrampleEvent$$Type)

/**
 * The level that the farmland and the entity are in.
 */
public "getLevel"(): $Level
/**
 * The farmland block.
 */
public "getBlock"(): $LevelBlock
/**
 * The entity that is attempting to trample the farmland.
 */
public "getEntity"(): $Entity
/**
 * The distance of the entity from the block.
 */
public "getDistance"(): float
public "getPlayer"(): $Player
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "block"(): $LevelBlock
get "entity"(): $Entity
get "distance"(): float
get "player"(): $Player
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FarmlandTrampledKubeEvent$$Type = ($FarmlandTrampledKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FarmlandTrampledKubeEvent$$Original = $FarmlandTrampledKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityTickKubeEvent" {
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $BlockEntityTickKubeEvent implements $KubeLevelEvent$$Interface {
constructor(entity: $KubeBlockEntity$$Type)

public "getLevel"(): $Level
public "getBlock"(): $LevelBlock
public "getTick"(): integer
public "getCycle"(): integer
public "getRegistries"(): $RegistryAccess
public "getServer"(): $MinecraftServer
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "block"(): $LevelBlock
get "tick"(): integer
get "cycle"(): integer
get "registries"(): $RegistryAccess
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityTickKubeEvent$$Type = ($BlockEntityTickKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityTickKubeEvent$$Original = $BlockEntityTickKubeEvent;}

declare module "dev.latvian.mods.kubejs.recipe.RecipeKey" {
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$ComponentRole, $ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$SequencedSet} from "java.util.SequencedSet"
import {$Codec} from "com.mojang.serialization.Codec"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$RecipeOptional$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional"

export class $RecipeKey<T> {
 "excluded": boolean
readonly "codec": $Codec<(T)>
readonly "component": $RecipeComponent<(T)>
readonly "typeInfo": $TypeInfo
readonly "role": $ComponentRole
readonly "names": $SequencedSet<(StringJS)>
readonly "name": StringJS

constructor(component: $RecipeComponent$$Type<(T)>, name: StringJS, role: $ComponentRole$$Type)

public "toString"(): StringJS
public "hashCode"(): integer
public "optional"(): boolean
public "optional"(value: $RecipeOptional$$Type<(T)>): $RecipeKey<(T)>
public "optional"(value: T): $RecipeKey<(T)>
public "toJson"(storage: $RecipeSchemaStorage$$Type, type: $RecipeSchemaType$$Type, ops: $DynamicOps$$Type<($JsonElement$$Type)>): $JsonObject
public "getValidFunctionNames"(): $List<(StringJS)>
public "getPrimaryFunctionName"(): StringJS
public "alt"(...names: (StringJS)[]): $RecipeKey<(T)>
public "alt"(name: StringJS): $RecipeKey<(T)>
public "exclude"(): $RecipeKey<(T)>
public "functionNames"(names: $List$$Type<(StringJS)>): $RecipeKey<(T)>
public "functionNames"(...names: (StringJS)[]): $RecipeKey<(T)>
public "noFunctions"(): $RecipeKey<(T)>
public "defaultOptional"(): $RecipeKey<(T)>
public "alwaysWrite"(): $RecipeKey<(T)>
get "validFunctionNames"(): $List<(StringJS)>
get "primaryFunctionName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeKey$$Type<T> = ($RecipeKey<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeKey$$Original<T> = $RecipeKey<(T)>;}
declare module "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$FluidBuilder, $FluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

export class $FluidBlockBuilder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
readonly "fluidBuilder": $FluidBuilder
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(b: $FluidBuilder$$Type)

public "item"(i: $Consumer$$Type<($ItemBuilder)>): $BlockBuilder
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBlockBuilder$$Type = ($FluidBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidBlockBuilder$$Original = $FluidBlockBuilder;}
declare module "dev.latvian.mods.kubejs.core.MinecraftClientKJS" {
import {$TextureAtlasSprite} from "net.minecraft.client.renderer.texture.TextureAtlasSprite"
import {$Screen, $Screen$$Type} from "net.minecraft.client.gui.screens.Screen"
import {$ScheduledEvents, $ScheduledEvents$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents"
import {$KeyMapping$$Type} from "net.minecraft.client.KeyMapping"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MinecraftEnvironmentKJS$$Interface} from "dev.latvian.mods.kubejs.core.MinecraftEnvironmentKJS"
import {$ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Function} from "java.util.function.Function"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$ScheduledEvents$ScheduledEvent} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $MinecraftClientKJS$$Interface extends $MinecraftEnvironmentKJS$$Interface {

(): $ScheduledEvents$$Type
set "statusMessage"(value: $Component$$Type)
get "blockTextureAtlas"(): $Function<($ResourceLocation), ($TextureAtlasSprite)>
get "currentScreen"(): $Screen
get "currentWorldName"(): StringJS
set "currentScreen"(value: $Screen$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "particleTextureAtlas"(): $Function<($ResourceLocation), ($TextureAtlasSprite)>
get "name"(): $Component
get "title"(): StringJS
get "shiftDown"(): boolean
get "altDown"(): boolean
set "title"(value: StringJS)
get "ctrlDown"(): boolean
get "scheduledEvents"(): $ScheduledEvents
get "displayName"(): $Component
}

export class $MinecraftClientKJS implements $MinecraftClientKJS$$Interface {
 "setStatusMessage"(message: $Component$$Type): void
 "isKeyMappingDown"(key: $KeyMapping$$Type): boolean
 "getBlockTextureAtlas"(): $Function<($ResourceLocation), ($TextureAtlasSprite)>
 "getCurrentScreen"(): $Screen
 "getCurrentWorldName"(): StringJS
 "setCurrentScreen"(gui: $Screen$$Type): void
 "getKeyBindPressedTicks"(id: StringJS): integer
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "tell"(message: $Component$$Type): void
 "self"(): $Minecraft
 "getParticleTextureAtlas"(): $Function<($ResourceLocation), ($TextureAtlasSprite)>
 "getName"(): $Component
 "isKeyBindDown"(id: StringJS): boolean
 "getTitle"(): StringJS
 "isShiftDown"(): boolean
 "runCommand"(command: StringJS): void
 "isAltDown"(): boolean
 "isKeyDown"(keyName: StringJS): boolean
 "isKeyDown"(key: integer): boolean
 "setTitle"(t: StringJS): void
 "isCtrlDown"(): boolean
 "scheduleRepeating"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeatingInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "schedule"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getScheduledEvents"(): $ScheduledEvents
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftClientKJS$$Type = (() => $ScheduledEvents$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MinecraftClientKJS$$Original = $MinecraftClientKJS;}
declare module "dev.latvian.mods.kubejs.event.KubeStartupEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $KubeStartupEvent$$Interface extends $KubeEvent$$Interface {
}

export class $KubeStartupEvent implements $KubeStartupEvent$$Interface {
static readonly "BASIC": $KubeStartupEvent

/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeStartupEvent$$Type = ($KubeStartupEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeStartupEvent$$Original = $KubeStartupEvent;}
declare module "dev.latvian.mods.kubejs.core.SizedIngredientKJS" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$ItemMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ItemMatch"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$IngredientSupplierKJS$$Interface} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$SizedIngredient} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $SizedIngredientKJS$$Interface extends $Replaceable$$Interface, $IngredientSupplierKJS$$Interface, $ItemMatch$$Interface {
}

export class $SizedIngredientKJS implements $SizedIngredientKJS$$Interface {
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $Ingredient$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, item: $ItemStack$$Type, exact: boolean): boolean
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "kjs$toNestedJson"(): $JsonElement
 "kjs$toFlatJson"(): $JsonElement
 "kjs$self"(): $SizedIngredient
 "kjs$asIngredient"(): $Ingredient
 "matchesAny"(cx: $RecipeMatchContext$$Type, itemLikes: $Iterable$$Type<($ItemLike$$Type)>, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, itemLike: $ItemLike$$Type, exact: boolean): boolean
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SizedIngredientKJS$$Type = ($SizedIngredientKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SizedIngredientKJS$$Original = $SizedIngredientKJS;}
declare module "dev.latvian.mods.kubejs.util.Lazy" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Supplier$$Type, $Supplier$$Interface} from "java.util.function.Supplier"
import {$Class$$Type} from "java.lang.Class"
import {$Duration$$Type} from "java.time.Duration"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $Lazy<T> implements $Supplier$$Interface<(T)> {
public "get"(): T
public static "map"<K, V>(supplier: $Consumer$$Type<($Map<(K), (V)>)>): $Lazy<($Map<(K), (V)>)>
public static "of"<T>(supplier: $Supplier$$Type<(T)>): $Lazy<(T)>
public static "of"<T>(supplier: $Supplier$$Type<(T)>, expires: $Duration$$Type): $Lazy<(T)>
public "forget"(): void
public static "serviceLoader"<T>(type: $Class$$Type<(T)>): $Lazy<(T)>
public static "identityMap"<K, V>(supplier: $Consumer$$Type<($Map<(K), (V)>)>): $Lazy<($Map<(K), (V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Lazy$$Type<T> = ($Lazy<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Lazy$$Original<T> = $Lazy<(T)>;}
declare module "dev.latvian.mods.kubejs.core.ClientPacketListenerKJS" {
import {$KubeSessionData} from "dev.latvian.mods.kubejs.client.KubeSessionData"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ClientPacketListenerKJS$$Interface {
}

export class $ClientPacketListenerKJS implements $ClientPacketListenerKJS$$Interface {
 "kjs$sessionData"(): $KubeSessionData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPacketListenerKJS$$Type = ($ClientPacketListenerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientPacketListenerKJS$$Original = $ClientPacketListenerKJS;}
declare module "dev.latvian.mods.kubejs.util.JsonSerializable" {
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"

export interface $JsonSerializable$$Interface {

(): $JsonElement$$Type
}

export class $JsonSerializable implements $JsonSerializable$$Interface {
 "toJson"(): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonSerializable$$Type = (() => $JsonElement$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JsonSerializable$$Original = $JsonSerializable;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Boots" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ArmorItemBuilder} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ArmorItemBuilder$Boots extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "BOOT_TAGS": ($ResourceLocation)[]
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Boots$$Type = ($ArmorItemBuilder$Boots);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$Boots$$Original = $ArmorItemBuilder$Boots;}
declare module "dev.latvian.mods.kubejs.client.KubeJSKeybinds$TickingKeyEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$KubeJSKeybinds$KubeKey$$Type} from "dev.latvian.mods.kubejs.client.KubeJSKeybinds$KubeKey"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$KubeJSKeybinds$KeyEvent} from "dev.latvian.mods.kubejs.client.KubeJSKeybinds$KeyEvent"

export class $KubeJSKeybinds$TickingKeyEvent extends $KubeJSKeybinds$KeyEvent {
constructor(player: $LocalPlayer$$Type, key: $KubeJSKeybinds$KubeKey$$Type)

public "getTicks"(): integer
public "getPlayer"(): $Player
public "getEntity"(): $Entity
get "ticks"(): integer
get "player"(): $Player
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSKeybinds$TickingKeyEvent$$Type = ($KubeJSKeybinds$TickingKeyEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSKeybinds$TickingKeyEvent$$Original = $KubeJSKeybinds$TickingKeyEvent;}
declare module "dev.latvian.mods.kubejs.core.MinecraftEnvironmentKJS" {
import {$ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScheduledEvents, $ScheduledEvents$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents"
import {$TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$ScheduledEvents$ScheduledEvent} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"
import {$MessageSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $MinecraftEnvironmentKJS$$Interface extends $MessageSenderKJS$$Interface {

(): $ScheduledEvents$$Type
get "scheduledEvents"(): $ScheduledEvents
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "displayName"(): $Component
}

export class $MinecraftEnvironmentKJS implements $MinecraftEnvironmentKJS$$Interface {
 "scheduleRepeating"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeatingInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "schedule"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getScheduledEvents"(): $ScheduledEvents
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "tell"(message: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(command: StringJS): void
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftEnvironmentKJS$$Type = (() => $ScheduledEvents$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MinecraftEnvironmentKJS$$Original = $MinecraftEnvironmentKJS;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentType" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$Map} from "java.util.Map"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Class$$Type} from "java.lang.Class"
import {$Record} from "java.lang.Record"

export class $BlockEntityAttachmentType extends $Record {
static readonly "ALL": $Lazy<($Map<($ResourceLocation), ($BlockEntityAttachmentType)>)>

constructor(id: $ResourceLocation$$Type, type: $Class$$Type<(never)>)
constructor(id: $ResourceLocation$$Type, typeInfo: $TypeInfo$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "typeInfo"(): $TypeInfo
public "id"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentType$$Type = ({"typeInfo"?: $TypeInfo$$Type, "id"?: $ResourceLocation$$Type}) | ([typeInfo?: $TypeInfo$$Type, id?: $ResourceLocation$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityAttachmentType$$Original = $BlockEntityAttachmentType;}
declare module "dev.latvian.mods.kubejs.stages.StageCreationEvent" {
import {$ICancellableEvent$$Interface} from "net.neoforged.bus.api.ICancellableEvent"
import {$PlayerEvent} from "net.neoforged.neoforge.event.entity.player.PlayerEvent"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$Stages, $Stages$$Type} from "dev.latvian.mods.kubejs.stages.Stages"

export class $StageCreationEvent extends $PlayerEvent implements $ICancellableEvent$$Interface {
public "getPlayerStages"(): $Stages
public "setPlayerStages"(s: $Stages$$Type): void
public "isCanceled"(): boolean
public "setCanceled"(arg0: boolean): void
public "getEntity"(): $Entity
get "playerStages"(): $Stages
set "playerStages"(value: $Stages$$Type)
get "canceled"(): boolean
set "canceled"(value: boolean)
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StageCreationEvent$$Type = ($StageCreationEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StageCreationEvent$$Original = $StageCreationEvent;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RegisterSubtypesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$List$$Type} from "java.util.List"
import {$SubtypeInterpreter$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.SubtypeInterpreter"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"

export interface $RegisterSubtypesKubeEvent$$Interface<E, F> extends $KubeEvent$$Interface {
}

export class $RegisterSubtypesKubeEvent<E, F> implements $RegisterSubtypesKubeEvent$$Interface {
 "register"(filter: F, interpreter: $SubtypeInterpreter$$Type): void
 "useComponents"(filter: F): void
 "useComponents"(filter: F, components: $List$$Type<($DataComponentType$$Type<(never)>)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterSubtypesKubeEvent$$Type<E, F> = ($RegisterSubtypesKubeEvent<(E), (F)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegisterSubtypesKubeEvent$$Original<E, F> = $RegisterSubtypesKubeEvent<(E), (F)>;}
declare module "dev.latvian.mods.kubejs.block.callback.BlockStateRotateCallback" {
import {$Rotation, $Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockStateModifyCallback} from "dev.latvian.mods.kubejs.block.callback.BlockStateModifyCallback"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStateRotateCallback extends $BlockStateModifyCallback {
constructor(state: $BlockState$$Type, rotation: $Rotation$$Type)

/**
 * Rotates the specified direction
 */
public "rotate"(dir: $Direction$$Type): $Direction
/**
 * Get the Rotation that this block is being rotated by
 */
public "getRotation"(): $Rotation
get "rotation"(): $Rotation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateRotateCallback$$Type = ($BlockStateRotateCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateRotateCallback$$Original = $BlockStateRotateCallback;}
declare module "dev.latvian.mods.kubejs.block.callback.EntityFallenOnBlockCallback" {
import {$DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$EntitySteppedOnBlockCallback} from "dev.latvian.mods.kubejs.block.callback.EntitySteppedOnBlockCallback"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EntityFallenOnBlockCallback extends $EntitySteppedOnBlockCallback {
constructor(level: $Level$$Type, entity: $Entity$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, fallHeight: float)

/**
 * Applies fall damage to the entity, multiplier by the multiplier.
 * Note this does not force it, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(multiplier: float): boolean
/**
 * Applies fall damage to the entity as if they had fallen from the provided height, and multiplies it by the provided multiplier.
 * Note this does not force it, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(fallHeight: float, multiplier: float): boolean
/**
 * Damages the entity using the provided damage source, using the fall height and multiplier to calculate the damage amount.
 * Note this does not force the damage, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(fallHeight: float, multiplier: float, damageSource: $DamageSource$$Type): boolean
/**
 * Applies default fall damage to the entity.
 * Note this does not force it, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(): boolean
/**
 * Get the height the entity has fallen
 */
public "getFallHeight"(): float
get "fallHeight"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityFallenOnBlockCallback$$Type = ($EntityFallenOnBlockCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityFallenOnBlockCallback$$Original = $EntityFallenOnBlockCallback;}
declare module "dev.latvian.mods.kubejs.misc.MobEffectBuilder$EffectEntityCallback" {
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export interface $MobEffectBuilder$EffectEntityCallback$$Interface {

(entity: $LivingEntity, level: integer): void
}

export class $MobEffectBuilder$EffectEntityCallback implements $MobEffectBuilder$EffectEntityCallback$$Interface {
 "applyEffectTick"(entity: $LivingEntity$$Type, level: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectBuilder$EffectEntityCallback$$Type = ((entity: $LivingEntity, level: integer) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobEffectBuilder$EffectEntityCallback$$Original = $MobEffectBuilder$EffectEntityCallback;}
declare module "dev.latvian.mods.kubejs.entity.LivingEntityDeathKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$Level} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked before a living entity dies.
 * 
 * **NOTE**: You need to set hp to > 0 besides cancelling the event to prevent the entity from dying.
 */
export class $LivingEntityDeathKubeEvent implements $KubeLivingEntityEvent$$Interface {
constructor(entity: $LivingEntity$$Type, source: $DamageSource$$Type)

/**
 * The damage source that triggers the death.
 */
public "getSource"(): $DamageSource
/**
 * The entity that dies.
 */
public "getEntity"(): $LivingEntity
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "source"(): $DamageSource
get "entity"(): $LivingEntity
get "level"(): $Level
get "player"(): $Player
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityDeathKubeEvent$$Type = ($LivingEntityDeathKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LivingEntityDeathKubeEvent$$Original = $LivingEntityDeathKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.RecipeLikeKJS" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$RecipeSchema} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RecipeLikeKJS$$Interface {
get "type"(): $ResourceLocation
get "mod"(): StringJS
set "group"(value: StringJS)
get "schema"(): $RecipeSchema
get "typeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
get "orCreateId"(): $ResourceLocation
get "serializer"(): $RecipeSerializer<(never)>
get "group"(): StringJS
}

export class $RecipeLikeKJS implements $RecipeLikeKJS$$Interface {
 "getType"(): $ResourceLocation
 "getMod"(): StringJS
 "replaceInput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "setGroup"(group: StringJS): void
 "getSchema"(): $RecipeSchema
 "replaceOutput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "getTypeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
 "getOrCreateId"(): $ResourceLocation
 "getSerializer"(): $RecipeSerializer<(never)>
 "getGroup"(): StringJS
 "hasInput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
 "hasOutput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeLikeKJS$$Type = ($RecipeLikeKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeLikeKJS$$Original = $RecipeLikeKJS;}
declare module "dev.latvian.mods.kubejs.script.ConsoleLine" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Collection} from "java.util.Collection"
import {$FriendlyByteBuf} from "net.minecraft.network.FriendlyByteBuf"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Supplier$$Interface} from "java.util.function.Supplier"
import {$List} from "java.util.List"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$ConsoleJS, $ConsoleJS$$Type} from "dev.latvian.mods.kubejs.script.ConsoleJS"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$SourceLine, $SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$LogType} from "dev.latvian.mods.kubejs.util.LogType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ConsoleLine implements $Supplier$$Interface<($JsonElement)> {
readonly "console": $ConsoleJS
static readonly "EMPTY_ARRAY": ($ConsoleLine)[]
 "sourceLines": $Collection<($SourceLine)>
 "externalFile": $Path
 "stackTrace": $List<(StringJS)>
 "message": StringJS
 "type": $LogType
static readonly "STREAM_CODEC": $StreamCodec<($FriendlyByteBuf), ($ConsoleLine)>
readonly "timestamp": long
 "group": StringJS

constructor(console: $ConsoleJS$$Type, timestamp: long, message: StringJS)

public "get"(): $JsonElement
public "toString"(): StringJS
public "getText"(): StringJS
public "toJson"(): $JsonObject
public "customData"(key: StringJS, data: $JsonElement$$Type, override: boolean): $ConsoleLine
public "withExternalFile"(path: $Path$$Type): $ConsoleLine
public "withSourceLine"(source: StringJS, line: integer): $ConsoleLine
public "withSourceLine"(sourceLine: $SourceLine$$Type): $ConsoleLine
get "text"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConsoleLine$$Type = ($ConsoleLine);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConsoleLine$$Original = $ConsoleLine;}
declare module "dev.latvian.mods.kubejs.misc.PaintingVariantBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$PaintingVariant} from "net.minecraft.world.entity.decoration.PaintingVariant"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $PaintingVariantBuilder extends $BuilderBase<($PaintingVariant)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

public "size"(width: integer, height: integer): this
public "assetId"(assetId: $ResourceLocation$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PaintingVariantBuilder$$Type = ($PaintingVariantBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PaintingVariantBuilder$$Original = $PaintingVariantBuilder;}
declare module "dev.latvian.mods.kubejs.stages.Stages" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Collection, $Collection$$Type} from "java.util.Collection"

export interface $Stages$$Interface {
get "all"(): $Collection<(StringJS)>
get "player"(): $Player
}

export class $Stages implements $Stages$$Interface {
 "remove"(stage: StringJS): boolean
 "clear"(): boolean
 "replace"(stages: $Collection$$Type<(StringJS)>): void
 "add"(stage: StringJS): boolean
 "set"(stage: StringJS, enabled: boolean): boolean
 "sync"(): void
 "getAll"(): $Collection<(StringJS)>
 "has"(stage: StringJS): boolean
 "toggle"(stage: StringJS): boolean
 "getPlayer"(): $Player
 "addNoUpdate"(stage: StringJS): boolean
 "removeNoUpdate"(stage: StringJS): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Stages$$Type = ($Stages);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Stages$$Original = $Stages;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Group" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Record} from "java.lang.Record"

export class $FluidData$Group extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData$Group)>

constructor(filter: $FluidIngredient$$Type, groupId: $ResourceLocation$$Type, description: $Component$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $FluidIngredient
public "description"(): $Component
public "groupId"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$Group$$Type = ({"filter"?: $FluidIngredient$$Type, "groupId"?: $ResourceLocation$$Type, "description"?: $Component$$Type}) | ([filter?: $FluidIngredient$$Type, groupId?: $ResourceLocation$$Type, description?: $Component$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidData$Group$$Original = $FluidData$Group;}
declare module "dev.latvian.mods.kubejs.item.ArmorMaterialBuilder" {
import {$ArmorMaterial} from "net.minecraft.world.item.ArmorMaterial"
import {$Map$$Type} from "java.util.Map"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$ArmorMaterial$Layer$$Type} from "net.minecraft.world.item.ArmorMaterial$Layer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$ArmorItem$Type$$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ArmorMaterialBuilder extends $BuilderBase<($ArmorMaterial)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "layers"(v: ($ArmorMaterial$Layer$$Type)[]): this
public "enchantmentValue"(v: integer): this
public "repairIngredient"(v: $Supplier$$Type<($Ingredient$$Type)>): this
public "toughness"(v: float): this
public "equipSound"(sound: $Holder$$Type<($SoundEvent)>): this
public "defense"(v: $Map$$Type<($ArmorItem$Type$$Type), (integer)>): this
public "knockbackResistance"(v: float): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorMaterialBuilder$$Type = ($ArmorMaterialBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorMaterialBuilder$$Original = $ArmorMaterialBuilder;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.JavaWrapper" {
import {$TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Map$$Type} from "java.util.Map"
import {$BaseFunction$$Type} from "dev.latvian.mods.rhino.BaseFunction"
import {$Class$$Type} from "java.lang.Class"
import {$ConsoleJS} from "dev.latvian.mods.kubejs.script.ConsoleJS"
import {$Record, $Record$$Type} from "java.lang.Record"

/**
 * Methods for working with Java classes. Reflection my beloved â™¥
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $JavaWrapper$$Interface {
}

export class $JavaWrapper implements $JavaWrapper$$Interface {
/**
 * Loads the specified class, and throws error if class it not found or allowed.
 * The returned object can have public static methods and fields accessed directly from it.
 * Constructors can be used with the new keyword.
 */
static "loadClass"(className: StringJS): any
/**
 * Cast the object to a target type, use if Rhino can't determine the parameter type due to type erasure.
 */
static "cast"<T>(targetClass: $Class$$Type<(T)>, object: any): T
/**
 * Creates a custom ConsoleJS instance for you to use to, well, log stuff
 */
static "createConsole"(name: StringJS): $ConsoleJS
static "mergeRecord"<R extends $Record>(original: R, merge: $Map$$Type<(StringJS), (never)>): R
static "makeFunctionProxy"<T>(targetClass: $TypeInfo$$Type, arg1: $BaseFunction$$Type): T
/**
 * Loads the specified class, and returns null if class is not found or allowed.
 * The returned object can have public static methods and fields accessed directly from it.
 * Constructors can be used with the new keyword.
 */
static "tryLoadClass"(className: StringJS): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaWrapper$$Type = ($JavaWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JavaWrapper$$Original = $JavaWrapper;}
declare module "dev.latvian.mods.kubejs.script.KubeJSContextFactory" {
import {$ContextFactory} from "dev.latvian.mods.rhino.ContextFactory"
import {$ScriptManager, $ScriptManager$$Type} from "dev.latvian.mods.kubejs.script.ScriptManager"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $KubeJSContextFactory extends $ContextFactory {
readonly "manager": $ScriptManager

constructor(manager: $ScriptManager$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSContextFactory$$Type = ($KubeJSContextFactory);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSContextFactory$$Original = $KubeJSContextFactory;}
declare module "dev.latvian.mods.kubejs.util.CountingMap" {
import {$Collection} from "java.util.Collection"
import {$Object2LongEntry, $Object2LongEntry$$Type} from "dev.latvian.mods.kubejs.util.Object2LongEntry"
import {$List} from "java.util.List"
import {$Set} from "java.util.Set"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $CountingMap {
constructor()

public "get"(key: any): long
public "clear"(): void
public "add"(key: any, value: long): long
public "set"(key: any, value: long): long
public "forEach"(forEach: $Consumer$$Type<($Object2LongEntry)>): void
public "getSize"(): integer
public "getEntries"(): $List<($Object2LongEntry)>
public "getKeys"(): $Set<(any)>
public "getTotalCount"(): long
public "getValues"(): $Collection<(long)>
get "size"(): integer
get "entries"(): $List<($Object2LongEntry)>
get "keys"(): $Set<(any)>
get "totalCount"(): long
get "values"(): $Collection<(long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CountingMap$$Type = ($CountingMap);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CountingMap$$Original = $CountingMap;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$UseCallback" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"

export interface $ItemBuilder$UseCallback$$Interface {

(level: $Level, player: $Player, interactionHand: $InteractionHand): boolean
}

export class $ItemBuilder$UseCallback implements $ItemBuilder$UseCallback$$Interface {
 "use"(level: $Level$$Type, player: $Player$$Type, interactionHand: $InteractionHand$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$UseCallback$$Type = ((level: $Level, player: $Player, interactionHand: $InteractionHand) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$UseCallback$$Original = $ItemBuilder$UseCallback;}
declare module "dev.latvian.mods.kubejs.client.highlight.HighlightKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$HighlightRenderer$$Type} from "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Minecraft, $Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntitySelector$$Type} from "net.minecraft.commands.arguments.selector.EntitySelector"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$ClientPlayerKubeEvent} from "dev.latvian.mods.kubejs.client.ClientPlayerKubeEvent"

/**
 * Invoked when block and entity highlight is rendered.
 */
export class $HighlightKubeEvent extends $ClientPlayerKubeEvent {
constructor(mc: $Minecraft$$Type, renderer: $HighlightRenderer$$Type)

public "addEntity"(entity: $Entity$$Type, color: $KubeColor$$Type): void
public "addEntities"(selector: $EntitySelector$$Type, color: $KubeColor$$Type): void
public "getClient"(): $Minecraft
public "addBlock"(pos: $BlockPos$$Type, color: $KubeColor$$Type): void
public "getTargetBlock"(): $LevelBlock
public "addEntitiesByType"(type: $EntityType$$Type<(never)>, color: $KubeColor$$Type): void
public "addTargetBlock"(color: $KubeColor$$Type): void
public "addTargetEntity"(color: $KubeColor$$Type): void
public "getTargetEntity"(): $Entity
public "addTarget"(color: $KubeColor$$Type): void
public "addBlocks"(from: $BlockPos$$Type, to: $BlockPos$$Type, color: $KubeColor$$Type): void
public "getPlayer"(): $Player
public "getEntity"(): $Entity
get "client"(): $Minecraft
get "targetBlock"(): $LevelBlock
get "targetEntity"(): $Entity
get "player"(): $Player
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HighlightKubeEvent$$Type = ($HighlightKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HighlightKubeEvent$$Original = $HighlightKubeEvent;}
declare module "dev.latvian.mods.kubejs.util.ScheduledEvents" {
import {$ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$LinkedList} from "java.util.LinkedList"
import {$AtomicInteger} from "java.util.concurrent.atomic.AtomicInteger"
import {$TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"

export class $ScheduledEvents {
 "currentTick": long
readonly "factory": $Supplier<($ScheduledEvents$ScheduledEvent)>
readonly "nextId": $AtomicInteger
 "currentMillis": long
readonly "events": $LinkedList<($ScheduledEvents$ScheduledEvent)>
readonly "futureEvents": $LinkedList<($ScheduledEvents$ScheduledEvent)>

constructor(factory: $Supplier$$Type<($ScheduledEvents$ScheduledEvent$$Type)>)

public "clear"(id: integer): void
public "schedule"(timer: $TemporalAmount$$Type, repeating: boolean, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
public "schedule"(timer: long, ofTicks: boolean, repeating: boolean, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
public "tickAll"(nowTicks: long): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledEvents$$Type = ($ScheduledEvents);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduledEvents$$Original = $ScheduledEvents;}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabIconSupplier" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"

export interface $CreativeTabIconSupplier$$Interface {

(): $ItemStack$$Type
get "icon"(): $ItemStack
}

export class $CreativeTabIconSupplier implements $CreativeTabIconSupplier$$Interface {
static readonly "DEFAULT": $CreativeTabIconSupplier

 "getIcon"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabIconSupplier$$Type = (() => $ItemStack$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeTabIconSupplier$$Original = $CreativeTabIconSupplier;}
declare module "dev.latvian.mods.kubejs.player.PlayerChatReceivedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$ServerChatEvent$$Type} from "net.neoforged.neoforge.event.ServerChatEvent"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $PlayerChatReceivedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(event: $ServerChatEvent$$Type)

public "getMessage"(): StringJS
public "getUsername"(): StringJS
public "getEntity"(): $LivingEntity
public "getComponent"(): $Component
public "setComponent"(component: $Component$$Type): void
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "message"(): StringJS
get "username"(): StringJS
get "entity"(): $LivingEntity
get "component"(): $Component
set "component"(value: $Component$$Type)
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerChatReceivedKubeEvent$$Type = ($PlayerChatReceivedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerChatReceivedKubeEvent$$Original = $PlayerChatReceivedKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockPredicate" {
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"

export interface $BlockPredicate$$Interface {

(block: $LevelBlock): boolean
}

export class $BlockPredicate implements $BlockPredicate$$Interface {
 "check"(block: $LevelBlock$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPredicate$$Type = ((block: $LevelBlock) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPredicate$$Original = $BlockPredicate;}
declare module "dev.latvian.mods.kubejs.util.OrderedCompoundTag" {
import {$TagType} from "net.minecraft.nbt.TagType"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$DataOutput$$Type} from "java.io.DataOutput"

export class $OrderedCompoundTag extends $CompoundTag {
static readonly "CODEC": $Codec<($CompoundTag)>
readonly "tagMap": $Map<(StringJS), ($Tag)>
static readonly "TYPE": $TagType<($CompoundTag)>
readonly "tags": $Map<(StringJS), ($Tag)>

constructor(map: $Map$$Type<(StringJS), ($Tag$$Type)>)
constructor()

public "write"(dataOutput: $DataOutput$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrderedCompoundTag$$Type = ($OrderedCompoundTag);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OrderedCompoundTag$$Original = $OrderedCompoundTag;}
declare module "dev.latvian.mods.kubejs.core.GameRulesKJS" {
import {$GameRules$Value} from "net.minecraft.world.level.GameRules$Value"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $GameRulesKJS$$Interface {
}

export class $GameRulesKJS implements $GameRulesKJS$$Interface {
 "kjs$get"(rule: StringJS): $GameRules$Value<(never)>
 "kjs$set"(rule: StringJS, value: StringJS): void
 "kjs$getInt"(rule: StringJS): integer
 "kjs$getString"(rule: StringJS): StringJS
 "kjs$getBoolean"(rule: StringJS): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRulesKJS$$Type = ($GameRulesKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GameRulesKJS$$Original = $GameRulesKJS;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuData" {
import {$Container} from "net.minecraft.world.Container"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ChestMenuSlot, $ChestMenuSlot$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuSlot"
import {$ChestMenuClickEvent$Callback, $ChestMenuClickEvent$Callback$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback"
import {$ClickType$$Type} from "net.minecraft.world.inventory.ClickType"
import {$Runnable} from "java.lang.Runnable"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$ChestMenuInventoryClickEvent$Callback} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent$Callback"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ChestMenuData {
 "capturedInventory": $Container
readonly "slots": ($ChestMenuSlot)[]
 "mouseItem": $ItemStack
 "anyClicked": $ChestMenuClickEvent$Callback
 "closed": $Runnable
 "inventoryClicked": $ChestMenuInventoryClickEvent$Callback
 "title": $Component
readonly "rows": integer
 "playerSlots": boolean
readonly "player": $ServerPlayer

constructor(player: $ServerPlayer$$Type, title: $Component$$Type, rows: integer)

public "slot"(x0: integer, y0: integer, x1: integer, y1: integer, slot: $Consumer$$Type<($ChestMenuSlot)>): void
public "slot"(x: integer, y: integer, slot: $Consumer$$Type<($ChestMenuSlot)>): void
public "getSlot"(x: integer, y: integer): $ChestMenuSlot
public "sync"(): void
public "button"(x: integer, y: integer, stack: $ItemStack$$Type, displayName: $Component$$Type, leftClicked: $ChestMenuClickEvent$Callback$$Type): void
public "handleClick"(index: integer, type: $ClickType$$Type, button: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuData$$Type = ($ChestMenuData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuData$$Original = $ChestMenuData;}
declare module "dev.latvian.mods.kubejs.item.ItemSmeltedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an item is smelted by a player.
 */
export class $ItemSmeltedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, smelted: $ItemStack$$Type)

/**
 * The item that was smelted.
 */
public "getItem"(): $ItemStack
/**
 * The player that smelted the item.
 */
public "getEntity"(): $Player
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "item"(): $ItemStack
get "entity"(): $Player
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemSmeltedKubeEvent$$Type = ($ItemSmeltedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemSmeltedKubeEvent$$Original = $ItemSmeltedKubeEvent;}
declare module "dev.latvian.mods.kubejs.script.data.VirtualResourcePack" {
import {$ExportablePackResources$$Interface} from "dev.latvian.mods.kubejs.script.data.ExportablePackResources"
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$MetadataSectionSerializer$$Type} from "net.minecraft.server.packs.metadata.MetadataSectionSerializer"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$KubeResourceGenerator$$Interface} from "dev.latvian.mods.kubejs.generator.KubeResourceGenerator"
import {$GeneratedDataStage, $GeneratedDataStage$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedDataStage"
import {$IoSupplier} from "net.minecraft.server.packs.resources.IoSupplier"
import {$Component} from "net.minecraft.network.chat.Component"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$PackType, $PackType$$Type} from "net.minecraft.server.packs.PackType"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$PackResources$ResourceOutput$$Type} from "net.minecraft.server.packs.PackResources$ResourceOutput"
import {$Set} from "java.util.Set"
import {$InputStream} from "java.io.InputStream"
import {$Path$$Type} from "java.nio.file.Path"
import {$AbstractPackResources} from "net.minecraft.server.packs.AbstractPackResources"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $VirtualResourcePack extends $AbstractPackResources implements $KubeResourceGenerator$$Interface, $ExportablePackResources$$Interface {
readonly "component": $Component
readonly "stage": $GeneratedDataStage
readonly "scriptType": $ScriptType
readonly "packType": $PackType
readonly "registries": $Supplier<($RegistryAccessContainer)>
readonly "info": StringJS

constructor(scriptType: $ScriptType$$Type, packType: $PackType$$Type, stage: $GeneratedDataStage$$Type, registries: $Supplier$$Type<($RegistryAccessContainer$$Type)>)

public "reset"(): void
public "toString"(): StringJS
public "add"(data: $GeneratedData$$Type): void
public "getResource"(type: $PackType$$Type, location: $ResourceLocation$$Type): $IoSupplier<($InputStream)>
public "close"(): void
public "export"(root: $Path$$Type): void
public "getNamespaces"(type: $PackType$$Type): $Set<(StringJS)>
public "listResources"(packType: $PackType$$Type, namespace: StringJS, path: StringJS, visitor: $PackResources$ResourceOutput$$Type): void
public "getRegistries"(): $RegistryAccessContainer
public "exportPath"(): StringJS
public "getGenerated"(id: $ResourceLocation$$Type): $GeneratedData
public "packId"(): StringJS
public "getMetadataSection"<T>(serializer: $MetadataSectionSerializer$$Type<(T)>): T
public "getRootResource"(...path: (StringJS)[]): $IoSupplier<($InputStream)>
public "flush"(): void
public "text"(id: $ResourceLocation$$Type, content: StringJS): void
public "json"(id: $ResourceLocation$$Type, json: $JsonElement$$Type): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualResourcePack$$Type = ($VirtualResourcePack);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VirtualResourcePack$$Original = $VirtualResourcePack;}
declare module "dev.latvian.mods.kubejs.block.BlockDropsKubeEvent" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Level} from "net.minecraft.world.level.Level"
import {$ItemEntity} from "net.minecraft.world.entity.item.ItemEntity"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockDropsEvent$$Type} from "net.neoforged.neoforge.event.level.BlockDropsEvent"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Modify dropped items and xp from block.
 */
export class $BlockDropsKubeEvent implements $KubeEntityEvent$$Interface {
constructor(event: $BlockDropsEvent$$Type)

public "getLevel"(): $Level
public "addItem"(item: $ItemStack$$Type): $ItemEntity
/**
 * The block that was broken.
 */
public "getBlock"(): $LevelBlock
public "getEntity"(): $Entity
public "removeItem"(item: $ItemPredicate$$Type): void
/**
 * Dropped items. Immutable.
 */
public "getItems"(): $List<($ItemStack)>
/**
 * The experience dropped by the block.
 */
public "getXp"(): integer
/**
 * The tool used when breaking this block. May be null.
 */
public "getTool"(): $ItemStack
/**
 * Sets the experience dropped by the block.
 */
public "setXp"(xp: integer): void
public "containsItem"(item: $ItemPredicate$$Type): boolean
/**
 * Dropped item entities.
 */
public "getItemEntities"(): $List<($ItemEntity)>
public "getPlayer"(): $Player
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "block"(): $LevelBlock
get "entity"(): $Entity
get "items"(): $List<($ItemStack)>
get "xp"(): integer
get "tool"(): $ItemStack
set "xp"(value: integer)
get "itemEntities"(): $List<($ItemEntity)>
get "player"(): $Player
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockDropsKubeEvent$$Type = ($BlockDropsKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockDropsKubeEvent$$Original = $BlockDropsKubeEvent;}
declare module "dev.latvian.mods.kubejs.util.SlotFilter" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Record} from "java.lang.Record"

export class $SlotFilter extends $Record {
static readonly "CODEC": $Codec<($SlotFilter)>
static readonly "TYPE_INFO": $TypeInfo
static readonly "EMPTY": $SlotFilter
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($SlotFilter)>

constructor(item: $Ingredient$$Type, index: integer)

public "index"(): integer
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "wrap"(o: any, target: $TypeInfo$$Type): $SlotFilter
public static "of"(ingredient: $Ingredient$$Type, index: integer): $SlotFilter
public "item"(): $Ingredient
public "checkFilter"(index: integer, stack: $ItemStack$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotFilter$$Type = ({"index"?: integer, "item"?: $Ingredient$$Type}) | ([index?: integer, item?: $Ingredient$$Type]) | ((integer) | ($Ingredient$$Type) | ({"item"?: $Ingredient$$Type, "index"?: integer}) | ([item?: $Ingredient$$Type, index?: integer]));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SlotFilter$$Original = $SlotFilter;}
declare module "dev.latvian.mods.kubejs.block.custom.StairBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $StairBlockBuilder extends $ShapedBlockBuilder {
static readonly "STAIR_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StairBlockBuilder$$Type = ($StairBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StairBlockBuilder$$Original = $StairBlockBuilder;}
declare module "dev.latvian.mods.kubejs.event.TargetedEventHandler" {
import {$EventHandler} from "dev.latvian.mods.kubejs.event.EventHandler"
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$EventGroup} from "dev.latvian.mods.kubejs.event.EventGroup"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$Supplier} from "java.util.function.Supplier"
import {$ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$ScriptTypeHolder$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$ScriptTypePredicate} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"
import {$Set} from "java.util.Set"
import {$Class} from "java.lang.Class"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$EventHandlerContainer$$Type} from "dev.latvian.mods.kubejs.event.EventHandlerContainer"
import {$EventResult} from "dev.latvian.mods.kubejs.event.EventResult"

export class $TargetedEventHandler<E> extends $EventHandler {
static readonly "DONTENUM": integer
readonly "eventType": $Supplier<($Class<($KubeEvent)>)>
readonly "scriptTypePredicate": $ScriptTypePredicate
static readonly "CONST": integer
readonly "name": StringJS
static readonly "UNINITIALIZED_CONST": integer
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "PERMANENT": integer
readonly "group": $EventGroup

public "hasListeners"(): boolean
public "hasListeners"(extraId: E): boolean
public "post"(type: $ScriptTypeHolder$$Type, extraId: E, event: $KubeEvent$$Type): $EventResult
public "post"(event: $KubeEvent$$Type, extraId: E): $EventResult
public "hasResult"(): $EventHandler
public "findUniqueExtraIds"(type: $ScriptType$$Type): $Set<(E)>
public "forEachListener"(type: $ScriptType$$Type, callback: $Consumer$$Type<($EventHandlerContainer)>): void
public "getIds"(): (any)[]
public "getAllIds"(): (any)[]
public "get"(arg1: integer, arg2: $Scriptable$$Type): any
public "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
public "delete"(arg1: integer): void
public "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
public "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
public "setPrototype"(arg0: $Scriptable$$Type): void
public "getPrototype"(): $Scriptable
public "getParentScope"(): $Scriptable
public "setParentScope"(arg0: $Scriptable$$Type): void
get "ids"(): (any)[]
get "allIds"(): (any)[]
set "prototype"(value: $Scriptable$$Type)
get "prototype"(): $Scriptable
get "parentScope"(): $Scriptable
set "parentScope"(value: $Scriptable$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TargetedEventHandler$$Type<E> = ($TargetedEventHandler<(E)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TargetedEventHandler$$Original<E> = $TargetedEventHandler<(E)>;}
declare module "dev.latvian.mods.kubejs.registry.ModelledBuilderBase" {
import {$ModelGenerator$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map$$Type} from "java.util.Map"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ModelledBuilderBase<T> extends $BuilderBase<(T)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

/**
 * Sets the texture by given key.
 */
public "texture"(key: (StringJS)[], tex: StringJS): this
/**
 * Sets the texture.
 */
public "texture"(tex: StringJS): this
/**
 * Directly set the texture map.
 */
public "textures"(map: $Map$$Type<(StringJS), (StringJS)>): this
/**
 * Replaces default model with custom generator.
 */
public "modelGenerator"(generator: $Consumer$$Type<($ModelGenerator)>): this
/**
 * Sets the parent model.
 */
public "parentModel"(id: $ResourceLocation$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelledBuilderBase$$Type<T> = ($ModelledBuilderBase<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModelledBuilderBase$$Original<T> = $ModelledBuilderBase<(T)>;}
declare module "dev.latvian.mods.kubejs.block.BlockBrokenKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$BlockEvent$BreakEvent$$Type} from "net.neoforged.neoforge.event.level.BlockEvent$BreakEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a block is destroyed by a player.
 */
export class $BlockBrokenKubeEvent implements $KubePlayerEvent$$Interface {
constructor(event: $BlockEvent$BreakEvent$$Type)

/**
 * The block that was broken.
 */
public "getBlock"(): $LevelBlock
/**
 * The player that broke the block.
 */
public "getEntity"(): $Player
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "block"(): $LevelBlock
get "entity"(): $Player
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBrokenKubeEvent$$Type = ($BlockBrokenKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBrokenKubeEvent$$Original = $BlockBrokenKubeEvent;}
declare module "dev.latvian.mods.kubejs.script.ScriptFileInfo" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Path, $Path$$Type} from "java.nio.file.Path"
import {$ScriptPackInfo, $ScriptPackInfo$$Type} from "dev.latvian.mods.kubejs.script.ScriptPackInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptFileInfo {
readonly "path": $Path
readonly "file": StringJS
readonly "location": StringJS
readonly "id": $ResourceLocation
readonly "pack": $ScriptPackInfo
readonly "locationPath": StringJS

constructor(p: $ScriptPackInfo$$Type, ph: $Path$$Type, f: StringJS)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptFileInfo$$Type = ($ScriptFileInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptFileInfo$$Original = $ScriptFileInfo;}
declare module "dev.latvian.mods.kubejs.block.entity.FluidTankAttachment$Factory" {
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockCapability} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$BlockEntityAttachmentFactory$$Interface} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$List} from "java.util.List"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$BlockEntityAttachment} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record} from "java.lang.Record"

export class $FluidTankAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory$$Interface {
constructor(capacity: integer, inputFilter: ($FluidIngredient$$Type)?)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "create"(info: $BlockEntityAttachmentInfo$$Type, entity: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "capacity"(): integer
public "getCapabilities"(): $List<($BlockCapability<(never), (never)>)>
public "inputFilter"(): $Optional<($FluidIngredient)>
public "isTicking"(): boolean
get "capabilities"(): $List<($BlockCapability<(never), (never)>)>
get "ticking"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTankAttachment$Factory$$Type = ({"inputFilter"?: ($FluidIngredient$$Type)?, "capacity"?: integer}) | ([inputFilter?: ($FluidIngredient$$Type)?, capacity?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidTankAttachment$Factory$$Original = $FluidTankAttachment$Factory;}
declare module "dev.latvian.mods.kubejs.block.custom.CarpetBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $CarpetBlockBuilder extends $ShapedBlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "CARPET_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarpetBlockBuilder$$Type = ($CarpetBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CarpetBlockBuilder$$Original = $CarpetBlockBuilder;}
declare module "dev.latvian.mods.kubejs.block.RandomTickKubeEvent" {
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $RandomTickKubeEvent implements $KubeLevelEvent$$Interface {
readonly "random": $RandomSource

constructor(level: $ServerLevel$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, random: $RandomSource$$Type)

public "getLevel"(): $Level
public "getBlock"(): $LevelBlock
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "block"(): $LevelBlock
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomTickKubeEvent$$Type = ($RandomTickKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomTickKubeEvent$$Original = $RandomTickKubeEvent;}
declare module "dev.latvian.mods.kubejs.misc.VillagerTypeBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$VillagerType} from "net.minecraft.world.entity.npc.VillagerType"

export class $VillagerTypeBuilder extends $BuilderBase<($VillagerType)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VillagerTypeBuilder$$Type = ($VillagerTypeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VillagerTypeBuilder$$Original = $VillagerTypeBuilder;}
declare module "dev.latvian.mods.kubejs.item.ItemDroppedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player drops an item.
 */
export class $ItemDroppedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, entity: $ItemEntity$$Type)

/**
 * The item entity that was spawned when dropping.
 */
public "getItemEntity"(): $ItemEntity
/**
 * The item that was dropped.
 */
public "getItem"(): $ItemStack
/**
 * The player that dropped the item.
 */
public "getEntity"(): $Player
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "itemEntity"(): $ItemEntity
get "item"(): $ItemStack
get "entity"(): $Player
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDroppedKubeEvent$$Type = ($ItemDroppedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemDroppedKubeEvent$$Original = $ItemDroppedKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.BlockPickedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when player middle-clicks on a block.
 */
export class $BlockPickedKubeEvent implements $KubePlayerEvent$$Interface {
readonly "level": $Level
readonly "block": $LevelBlock
readonly "player": $Player

constructor(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, player: $Player$$Type, hitResult: $HitResult$$Type)

public "getTarget"(): $KubeRayTraceResult
public "getLevel"(): $Level
public "getEntity"(): $LivingEntity
public "getPlayer"(): $Player
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "target"(): $KubeRayTraceResult
get "entity"(): $LivingEntity
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPickedKubeEvent$$Type = ($BlockPickedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPickedKubeEvent$$Original = $BlockPickedKubeEvent;}
declare module "dev.latvian.mods.kubejs.util.ID" {
import {$UnaryOperator} from "java.util.function.UnaryOperator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$DataResult} from "com.mojang.serialization.DataResult"

export interface $ID$$Interface {
}

export class $ID implements $ID$$Interface {
static readonly "ITEM": $UnaryOperator<(StringJS)>
static readonly "PNG_TEXTURE_MCMETA": $UnaryOperator<(StringJS)>
static readonly "PARTICLE": $UnaryOperator<(StringJS)>
static readonly "BLOCK_MODEL": $UnaryOperator<(StringJS)>
static readonly "BLOCKSTATE": $UnaryOperator<(StringJS)>
static readonly "BLOCK": $UnaryOperator<(StringJS)>
static readonly "ITEM_MODEL": $UnaryOperator<(StringJS)>
static readonly "PNG_TEXTURE": $UnaryOperator<(StringJS)>
static readonly "AIR": $ResourceLocation
static readonly "BLOCK_LOOT_TABLE": $UnaryOperator<(StringJS)>
static readonly "UNKNOWN": $ResourceLocation
static readonly "MODEL": $UnaryOperator<(StringJS)>

static "of"(o: any, preferKJS: boolean): $ResourceLocation
static "url"(id: $ResourceLocation$$Type): StringJS
static "read"(reader: $StringReader$$Type): $DataResult<($ResourceLocation)>
static "mc"(o: any): $ResourceLocation
static "path"(s: StringJS): StringJS
static "reduce"(id: $ResourceLocation$$Type): StringJS
static "string"(id: StringJS): StringJS
static "isKey"(from: any): boolean
static "reduceKjs"(id: $ResourceLocation$$Type): StringJS
static "kjsString"(id: StringJS): StringJS
static "kjs"(o: any): $ResourceLocation
static "namespace"(s: StringJS): StringJS
static "resourcePath"(id: $ResourceLocation$$Type): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ID$$Type = ($ID);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ID$$Original = $ID;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RegistryAwareSchema" {
import {$RecipeSchema, $RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RegistryAwareSchema$$Interface {

(cx: $RegistryAccessContainer): $RecipeSchema$$Type
}

export class $RegistryAwareSchema implements $RegistryAwareSchema$$Interface {
 "create"(cx: $RegistryAccessContainer$$Type): $RecipeSchema
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryAwareSchema$$Type = ((cx: $RegistryAccessContainer) => $RecipeSchema$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryAwareSchema$$Original = $RegistryAwareSchema;}
declare module "dev.latvian.mods.kubejs.block.BlockTintFunction$Fixed" {
import {$BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockTintFunction, $BlockTintFunction$$Interface} from "dev.latvian.mods.kubejs.block.BlockTintFunction"
import {$Record} from "java.lang.Record"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockTintFunction$Fixed extends $Record implements $BlockTintFunction$$Interface {
constructor(color: $KubeColor$$Type)

public "getColor"(state: $BlockState$$Type, level: $BlockAndTintGetter$$Type, pos: $BlockPos$$Type, index: integer): $KubeColor
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "color"(): $KubeColor
public static "wrap"(o: any): $BlockTintFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTintFunction$Fixed$$Type = ({"color"?: $KubeColor$$Type}) | ([color?: $KubeColor$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockTintFunction$Fixed$$Original = $BlockTintFunction$Fixed;}
declare module "dev.latvian.mods.kubejs.core.DiggerItemKJS" {
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $DiggerItemKJS$$Interface {

(): $TagKey$$Type<($Block$$Type)>
}

export class $DiggerItemKJS implements $DiggerItemKJS$$Interface {
 "kjs$getMineableTag"(): $TagKey<($Block)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemKJS$$Type = (() => $TagKey$$Type<($Block$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemKJS$$Original = $DiggerItemKJS;}
declare module "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Model" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $VariantBlockStateGenerator$Model {
constructor()

public "uvlock"(): $VariantBlockStateGenerator$Model
public "x"(x: integer): $VariantBlockStateGenerator$Model
public "y"(y: integer): $VariantBlockStateGenerator$Model
public "toJson"(): $JsonObject
public "model"(s: $ResourceLocation$$Type): $VariantBlockStateGenerator$Model
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateGenerator$Model$$Type = ($VariantBlockStateGenerator$Model);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VariantBlockStateGenerator$Model$$Original = $VariantBlockStateGenerator$Model;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.DataMapWrapper" {
import {$Iterator} from "java.util.Iterator"
import {$Iterable$$Interface} from "java.lang.Iterable"
import {$Map} from "java.util.Map"
import {$Spliterator} from "java.util.Spliterator"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$RegistryWrapper$$Type} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.RegistryWrapper"
import {$DataMapWrapper$Data, $DataMapWrapper$Data$$Type} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.DataMapWrapper$Data"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$DataMapType, $DataMapType$$Type} from "net.neoforged.neoforge.registries.datamaps.DataMapType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Stream} from "java.util.stream.Stream"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $DataMapWrapper<T, A> extends $Record implements $Iterable$$Interface<($DataMapWrapper$Data<(T), (A)>)> {
constructor(registry: $Registry$$Type<(T)>, type: $DataMapType$$Type<(T), (A)>)

public static "typeOf"<T>(registry: $RegistryWrapper$$Type<(T)>, id: $ResourceLocation$$Type): $DataMapType<(T), (never)>
public static "typeOf"(registry: $ResourceLocation$$Type, id: $ResourceLocation$$Type): $DataMapType<(never), (never)>
public "get"(item: T): A
public "type"(): $DataMapType<(T), (A)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "iterator"(): $Iterator<($DataMapWrapper$Data<(T), (A)>)>
public static "of"<T>(registry: $RegistryWrapper$$Type<(T)>, id: $ResourceLocation$$Type): $DataMapWrapper<(T), (never)>
public static "of"(registry: $ResourceLocation$$Type, id: $ResourceLocation$$Type): $DataMapWrapper<(never), (never)>
public "keys"(): $Stream<(T)>
public "byKey"(): $Map<($ResourceKey<(T)>), (A)>
public "registry"(): $Registry<(T)>
public "spliterator"(): $Spliterator<($DataMapWrapper$Data<(T), (A)>)>
public "forEach"(arg0: $Consumer$$Type<($DataMapWrapper$Data<(T), (A)>)>): void
[Symbol.iterator](): IterableIterator<$DataMapWrapper$Data<(T), (A)>>;
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataMapWrapper$$Type<T, A> = ({"registry"?: $Registry$$Type<(T)>, "type"?: $DataMapType$$Type<(T), (A)>}) | ([registry?: $Registry$$Type<(T)>, type?: $DataMapType$$Type<(T), (A)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataMapWrapper$$Original<T, A> = $DataMapWrapper<(T), (A)>;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.DataMapWrapper$Data" {
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $DataMapWrapper$Data<T, A> extends $Record {
constructor(element: T, data: A)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "data"(): A
public "element"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataMapWrapper$Data$$Type<T, A> = ({"element"?: T, "data"?: A}) | ([element?: T, data?: A]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataMapWrapper$Data$$Original<T, A> = $DataMapWrapper$Data<(T), (A)>;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$AnimalArmor" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ArmorItemBuilder} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$AnimalArmorItem$BodyType$$Type} from "net.minecraft.world.item.AnimalArmorItem$BodyType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ArmorItemBuilder$AnimalArmor extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

public "bodyType"(type: $AnimalArmorItem$BodyType$$Type): this
public "overlay"(o: boolean): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$AnimalArmor$$Type = ($ArmorItemBuilder$AnimalArmor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$AnimalArmor$$Original = $ArmorItemBuilder$AnimalArmor;}
declare module "dev.latvian.mods.kubejs.util.ErrorStack" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ErrorStack {
static readonly "NONE": $ErrorStack

constructor()

public "toString"(): StringJS
public "push"(parent: any): void
public "pop"(): void
public "setKey"(key: any): void
public "setKey"(index: integer): void
public "stringAt"(): StringJS
public "atString"(): StringJS
set "key"(value: any)
set "key"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ErrorStack$$Type = ($ErrorStack);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ErrorStack$$Original = $ErrorStack;}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Hoe" {
import {$BiFunction} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DiggerItemBuilder} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$Item$Properties} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Hoe extends $DiggerItemBuilder {
 "sourceLine": $SourceLine
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
static readonly "HOE_TAGS": ($ResourceLocation)[]
readonly "id": $ResourceLocation
static readonly "HOE_MODEL": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Hoe$$Type = ($DiggerItemBuilder$Hoe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemBuilder$Hoe$$Original = $DiggerItemBuilder$Hoe;}
declare module "dev.latvian.mods.kubejs.fluid.FluidLike" {
import {$ReplacementMatch, $ReplacementMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"

export interface $FluidLike$$Interface extends $ReplacementMatch$$Interface {
get "amount"(): integer
get "fluid"(): $Fluid
get "empty"(): boolean
}

export class $FluidLike implements $FluidLike$$Interface {
 "copy"(amount: integer): $FluidLike
 "getAmount"(): integer
 "getFluid"(): $Fluid
 "isEmpty"(): boolean
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidLike$$Type = ($FluidLike);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidLike$$Original = $FluidLike;}
declare module "dev.latvian.mods.kubejs.recipe.special.SpecialRecipeSerializerManager" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Recipe$$Type} from "net.minecraft.world.item.crafting.Recipe"

export class $SpecialRecipeSerializerManager implements $KubeEvent$$Interface {
static readonly "INSTANCE": $SpecialRecipeSerializerManager

constructor()

public "reset"(): void
public "isSpecial"(recipe: $Recipe$$Type<(never)>): boolean
public "addSpecialMod"(modid: StringJS): void
public "ignoreSpecialFlag"(id: $ResourceLocation$$Type): void
public "ignoreSpecialMod"(modid: StringJS): void
public "addSpecialFlag"(id: $ResourceLocation$$Type): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpecialRecipeSerializerManager$$Type = ($SpecialRecipeSerializerManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpecialRecipeSerializerManager$$Original = $SpecialRecipeSerializerManager;}
declare module "dev.latvian.mods.kubejs.level.ExplosionProperties" {
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$Level$ExplosionInteraction, $Level$ExplosionInteraction$$Type} from "net.minecraft.world.level.Level$ExplosionInteraction"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$DamageSource, $DamageSource$$Type} from "net.minecraft.world.damagesource.DamageSource"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent, $SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ExplosionDamageCalculator, $ExplosionDamageCalculator$$Type} from "net.minecraft.world.level.ExplosionDamageCalculator"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$Record} from "java.lang.Record"

export class $ExplosionProperties extends $Record {
constructor(source: $Entity$$Type, damageSource: $DamageSource$$Type, damageCalculator: $ExplosionDamageCalculator$$Type, strength: (float)?, causesFire: (boolean)?, mode: $Level$ExplosionInteraction$$Type, particles: (boolean)?, smallParticles: $ParticleOptions$$Type, largeParticles: $ParticleOptions$$Type, explosionSound: $Holder$$Type<($SoundEvent)>)

public "particles"(): $Optional<(boolean)>
public "damageCalculator"(): $ExplosionDamageCalculator
public "explosionSound"(): $Holder<($SoundEvent)>
public "mode"(): $Level$ExplosionInteraction
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "source"(): $Entity
public "explode"(level: $Level$$Type, x: double, y: double, z: double): $Explosion
public "damageSource"(): $DamageSource
public "strength"(): $Optional<(float)>
public "causesFire"(): $Optional<(boolean)>
public "largeParticles"(): $ParticleOptions
public "smallParticles"(): $ParticleOptions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionProperties$$Type = ({"largeParticles"?: $ParticleOptions$$Type, "explosionSound"?: $Holder$$Type<($SoundEvent)>, "damageSource"?: $DamageSource$$Type, "particles"?: (boolean)?, "causesFire"?: (boolean)?, "mode"?: $Level$ExplosionInteraction$$Type, "source"?: $Entity$$Type, "strength"?: (float)?, "smallParticles"?: $ParticleOptions$$Type, "damageCalculator"?: $ExplosionDamageCalculator$$Type}) | ([largeParticles?: $ParticleOptions$$Type, explosionSound?: $Holder$$Type<($SoundEvent)>, damageSource?: $DamageSource$$Type, particles?: (boolean)?, causesFire?: (boolean)?, mode?: $Level$ExplosionInteraction$$Type, source?: $Entity$$Type, strength?: (float)?, smallParticles?: $ParticleOptions$$Type, damageCalculator?: $ExplosionDamageCalculator$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExplosionProperties$$Original = $ExplosionProperties;}
declare module "dev.latvian.mods.kubejs.script.data.VirtualDataMapFile" {
import {$VirtualDataPack$$Type} from "dev.latvian.mods.kubejs.script.data.VirtualDataPack"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$KubeDataGenerator} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$DataMapType$$Type} from "net.neoforged.neoforge.registries.datamaps.DataMapType"
import {$BiConsumer, $BiConsumer$$Type, $BiConsumer$$Interface} from "java.util.function.BiConsumer"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Holder$$Type} from "net.minecraft.core.Holder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $VirtualDataMapFile<RT, DT> implements $BiConsumer$$Interface<($ResourceLocation), (DT)> {
readonly "registryAccess": $RegistryAccessContainer
readonly "registry": $Registry<(RT)>
readonly "pack": $KubeDataGenerator

constructor(type: $DataMapType$$Type<(RT), (DT)>, pack: $VirtualDataPack$$Type)

public "removeTag"(tag: $TagKey$$Type<(RT)>): void
public "addTag"(tag: $TagKey$$Type<(RT)>, value: DT, replace: boolean): void
public "addTag"(tag: $TagKey$$Type<(RT)>, value: DT): void
public "remove"(holder: RT): void
public "remove"(holder: $Holder$$Type<(RT)>): void
public "remove"(holders: $HolderSet$$Type<(RT)>): void
public "clear"(): void
public "replaceAll"(): void
public "add"(holders: $HolderSet$$Type<(RT)>, value: DT, replace: boolean): void
public "add"(holders: $HolderSet$$Type<(RT)>, value: DT): void
public "add"(holder: $Holder$$Type<(RT)>, value: DT, replace: boolean): void
public "add"(holder: $Holder$$Type<(RT)>, value: DT): void
public "add"(holder: RT, value: DT): void
public "add"(holder: RT, value: DT, replace: boolean): void
public "andThen"(arg0: $BiConsumer$$Type<($ResourceLocation), (DT)>): $BiConsumer<($ResourceLocation), (DT)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualDataMapFile$$Type<RT, DT> = ($VirtualDataMapFile<(RT), (DT)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VirtualDataMapFile$$Original<RT, DT> = $VirtualDataMapFile<(RT), (DT)>;}
declare module "dev.latvian.mods.kubejs.item.FoodBuilder" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$FoodEatenKubeEvent$$Type} from "dev.latvian.mods.kubejs.item.FoodEatenKubeEvent"
import {$MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"
import {$FoodProperties, $FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $FoodBuilder {
constructor()
constructor(properties: $FoodProperties$$Type)

/**
 * Sets the hunger restored.
 */
public "nutrition"(h: integer): $FoodBuilder
/**
 * Adds an effect to the food. Note that the effect duration is in ticks (20 ticks = 1 second).
 * 
 * @param mobEffectId - The id of the effect. Can be either a string or a ResourceLocation.
 * @param duration - The duration of the effect in ticks.
 * @param amplifier - The amplifier of the effect. 0 means level 1, 1 means level 2, etc.
 * @param probability - The probability of the effect being applied. 1 = 100%.
 */
public "effect"(mobEffectId: $ResourceLocation$$Type, duration: integer, amplifier: integer, probability: float): $FoodBuilder
/**
 * Sets a callback that is called when the food is eaten.
 * 
 * Note: This is currently not having effect in `ItemEvents.modification`,
 * as firing this callback requires an `ItemBuilder` instance in the `Item`.
 */
public "eaten"(e: $Consumer$$Type<($FoodEatenKubeEvent)>): $FoodBuilder
public "build"(): $FoodProperties
/**
 * Sets the saturation modifier. Note that the saturation restored is hunger * saturation.
 */
public "saturation"(s: float): $FoodBuilder
public "usingConvertsTo"(stack: $ItemStack$$Type): $FoodBuilder
/**
 * Sets whether the food is always edible.
 */
public "alwaysEdible"(flag: boolean): $FoodBuilder
/**
 * Sets the food is always edible.
 */
public "alwaysEdible"(): $FoodBuilder
/**
 * Removes an effect from the food.
 */
public "removeEffect"(mobEffect: $MobEffect$$Type): $FoodBuilder
/**
 * Sets seconds it takes to eat the food.
 */
public "eatSeconds"(seconds: float): $FoodBuilder
/**
 * Sets the food is fast to eat (having half of the eating time).
 */
public "fastToEat"(): $FoodBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoodBuilder$$Type = ($FoodBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FoodBuilder$$Original = $FoodBuilder;}
declare module "dev.latvian.mods.kubejs.command.CommandRegistryKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$LiteralArgumentBuilder$$Type} from "com.mojang.brigadier.builder.LiteralArgumentBuilder"
import {$CommandBuildContext, $CommandBuildContext$$Type} from "net.minecraft.commands.CommandBuildContext"
import {$ArgumentTypeWrappers} from "dev.latvian.mods.kubejs.command.ArgumentTypeWrappers"
import {$Commands} from "net.minecraft.commands.Commands"
import {$CommandDispatcher, $CommandDispatcher$$Type} from "com.mojang.brigadier.CommandDispatcher"
import {$SharedSuggestionProvider} from "net.minecraft.commands.SharedSuggestionProvider"
import {$LiteralCommandNode} from "com.mojang.brigadier.tree.LiteralCommandNode"
import {$CommandSourceStack, $CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"
import {$Commands$CommandSelection, $Commands$CommandSelection$$Type} from "net.minecraft.commands.Commands$CommandSelection"

export class $CommandRegistryKubeEvent implements $KubeEvent$$Interface {
readonly "selection": $Commands$CommandSelection
readonly "context": $CommandBuildContext
readonly "dispatcher": $CommandDispatcher<($CommandSourceStack)>

constructor(dispatcher: $CommandDispatcher$$Type<($CommandSourceStack$$Type)>, context: $CommandBuildContext$$Type, selection: $Commands$CommandSelection$$Type)

public "register"(command: $LiteralArgumentBuilder$$Type<($CommandSourceStack$$Type)>): $LiteralCommandNode<($CommandSourceStack)>
public "getCommands"(): typeof $Commands
public "getArguments"(): typeof $ArgumentTypeWrappers
public "getRegistry"(): $CommandBuildContext
public "getBuiltinSuggestions"(): typeof $SharedSuggestionProvider
public "isForSinglePlayer"(): boolean
public "isForMultiPlayer"(): boolean
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "commands"(): typeof $Commands
get "arguments"(): typeof $ArgumentTypeWrappers
get "registry"(): $CommandBuildContext
get "builtinSuggestions"(): typeof $SharedSuggestionProvider
get "forSinglePlayer"(): boolean
get "forMultiPlayer"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandRegistryKubeEvent$$Type = ($CommandRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CommandRegistryKubeEvent$$Original = $CommandRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.icon.KubeIconType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map} from "java.util.Map"
import {$KubeIcon} from "dev.latvian.mods.kubejs.client.icon.KubeIcon"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $KubeIconType<T extends $KubeIcon> extends $Record {
static readonly "TYPES": $Lazy<($Map<($ResourceLocation), ($KubeIconType<(never)>)>)>
static readonly "CODEC": $Codec<($KubeIconType<(never)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($KubeIconType<(never)>)>

constructor(id: $ResourceLocation$$Type, codec: $MapCodec$$Type<(T)>)
constructor(id: $ResourceLocation$$Type, codec: $MapCodec$$Type<(T)>, streamCodec: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): $ResourceLocation
public "codec"(): $MapCodec<(T)>
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeIconType$$Type<T> = ({"codec"?: $MapCodec$$Type<(T)>, "id"?: $ResourceLocation$$Type, "streamCodec"?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>}) | ([codec?: $MapCodec$$Type<(T)>, id?: $ResourceLocation$$Type, streamCodec?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeIconType$$Original<T> = $KubeIconType<(T)>;}
declare module "dev.latvian.mods.kubejs.fluid.FluidWrapper$ReadFn" {
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$StringReader, $StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$DataResult, $DataResult$$Type} from "com.mojang.serialization.DataResult"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"

export interface $FluidWrapper$ReadFn$$Interface<T> {

(registryOps: $DynamicOps<($Tag)>, reader: $StringReader): $DataResult$$Type<(T)>
}

export class $FluidWrapper$ReadFn<T> implements $FluidWrapper$ReadFn$$Interface {
 "read"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, reader: $StringReader$$Type): $DataResult<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidWrapper$ReadFn$$Type<T> = ((registryOps: $DynamicOps<($Tag)>, reader: $StringReader) => $DataResult$$Type<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidWrapper$ReadFn$$Original<T> = $FluidWrapper$ReadFn<(T)>;}
declare module "dev.latvian.mods.kubejs.core.BlockBehaviourKJS" {
import {$Map} from "java.util.Map"
import {$List} from "java.util.List"
import {$SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Holder} from "net.minecraft.core.Holder"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$BlockProviderKJS$$Interface} from "dev.latvian.mods.kubejs.core.BlockProviderKJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RandomTickCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $BlockBehaviourKJS$$Interface extends $BlockProviderKJS$$Interface {

(): $Block$$Type
set "speedFactor"(value: float)
set "soundType"(value: $SoundType$$Type)
set "friction"(value: float)
set "jumpFactor"(value: float)
set "explosionResistance"(value: float)
set "randomTickCallback"(value: $Consumer$$Type<($RandomTickCallback)>)
set "hasCollision"(value: boolean)
set "isRandomlyTicking"(value: boolean)
get "id"(): StringJS
get "block"(): $Block
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "registry"(): $Registry<($Block)>
get "typeData"(): $Map<(StringJS), (any)>
get "key"(): $ResourceKey<($Block)>
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $BlockBehaviourKJS implements $BlockBehaviourKJS$$Interface {
 "setSpeedFactor"(v: float): void
 "setSoundType"(v: $SoundType$$Type): void
 "setFriction"(v: float): void
 "setJumpFactor"(v: float): void
 "setExplosionResistance"(v: float): void
 "setRandomTickCallback"(callback: $Consumer$$Type<($RandomTickCallback)>): void
 "setHasCollision"(v: boolean): void
 "setIsRandomlyTicking"(v: boolean): void
 "getId"(): StringJS
 "getBlock"(): $Block
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "getRegistry"(): $Registry<($Block)>
 "asHolder"(): $Holder<($Block)>
 "getTypeData"(): $Map<(StringJS), (any)>
 "getKey"(): $ResourceKey<($Block)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getMod"(): StringJS
 "getIdLocation"(): $ResourceLocation
 "getTagKeys"(): $List<($TagKey<($Block)>)>
 "getTags"(): $List<($ResourceLocation)>
 "specialEquals"(o: any, shallow: boolean): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBehaviourKJS$$Type = (() => $Block$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBehaviourKJS$$Original = $BlockBehaviourKJS;}
declare module "dev.latvian.mods.kubejs.player.InventoryChangedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player's inventory changes.
 */
export class $InventoryChangedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(p: $Player$$Type, is: $ItemStack$$Type, s: integer)

/**
 * Gets the slot that was changed.
 */
public "getSlot"(): integer
/**
 * Gets the item that was changed.
 */
public "getItem"(): $ItemStack
/**
 * Gets the player that changed their inventory.
 */
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "slot"(): integer
get "item"(): $ItemStack
get "entity"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryChangedKubeEvent$$Type = ($InventoryChangedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InventoryChangedKubeEvent$$Original = $InventoryChangedKubeEvent;}
declare module "dev.latvian.mods.kubejs.entity.LivingEntityDropsKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DamageSource} from "net.minecraft.world.damagesource.DamageSource"
import {$List} from "java.util.List"
import {$Level} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$LivingDropsEvent$$Type} from "net.neoforged.neoforge.event.entity.living.LivingDropsEvent"
import {$ItemEntity} from "net.minecraft.world.entity.item.ItemEntity"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $LivingEntityDropsKubeEvent implements $KubeLivingEntityEvent$$Interface {
 "eventDrops": $List<($ItemEntity)>

constructor(e: $LivingDropsEvent$$Type)

public "isRecentlyHit"(): boolean
public "getSource"(): $DamageSource
public "getDrops"(): $List<($ItemEntity)>
public "getEntity"(): $Entity
public "addDrop"(stack: $ItemStack$$Type): $ItemEntity
public "addDrop"(stack: $ItemStack$$Type, chance: float): $ItemEntity
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "recentlyHit"(): boolean
get "source"(): $DamageSource
get "drops"(): $List<($ItemEntity)>
get "entity"(): $Entity
get "level"(): $Level
get "player"(): $Player
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityDropsKubeEvent$$Type = ($LivingEntityDropsKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LivingEntityDropsKubeEvent$$Original = $LivingEntityDropsKubeEvent;}
declare module "dev.latvian.mods.kubejs.script.PlatformWrapper" {
import {$Map} from "java.util.Map"
import {$Set} from "java.util.Set"
import {$PlatformWrapper$ModInfo} from "dev.latvian.mods.kubejs.script.PlatformWrapper$ModInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $PlatformWrapper {
constructor()

/**
 * 
 * @deprecated
 */
public static "getName"(): StringJS
public static "isLoaded"(modId: StringJS): boolean
public static "getInfo"(modID: StringJS): $PlatformWrapper$ModInfo
public static "getMods"(): $Map<(StringJS), ($PlatformWrapper$ModInfo)>
public static "getPackMode"(): StringJS
public static "getMcVersion"(): StringJS
public static "getMinecraftVersion"(): integer
public static "isClientEnvironment"(): boolean
public static "isGeneratingData"(): boolean
public static "getCurrentThreadName"(): StringJS
public static "getMinecraftVersionString"(): StringJS
public static "setModName"(modId: StringJS, name: StringJS): void
public static "breakpoint"(...args: (any)[]): void
public static "getModVersion"(): StringJS
/**
 * 
 * @deprecated
 */
public static "isFabric"(): boolean
/**
 * 
 * @deprecated
 */
public static "isForge"(): boolean
public static "getList"(): $Set<(StringJS)>
public static "isDevelopmentEnvironment"(): boolean
get "name"(): StringJS
get "mods"(): $Map<(StringJS), ($PlatformWrapper$ModInfo)>
get "packMode"(): StringJS
get "mcVersion"(): StringJS
get "minecraftVersion"(): integer
get "clientEnvironment"(): boolean
get "generatingData"(): boolean
get "currentThreadName"(): StringJS
get "minecraftVersionString"(): StringJS
get "modVersion"(): StringJS
get "fabric"(): boolean
get "forge"(): boolean
get "list"(): $Set<(StringJS)>
get "developmentEnvironment"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformWrapper$$Type = ($PlatformWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlatformWrapper$$Original = $PlatformWrapper;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType$Unit" {
import {$RecipeTypeRegistryContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext"
import {$RecipeComponentType} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$RecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $RecipeComponentType$Unit<T> extends $RecipeComponentType<(T)> {
public "instance"(): $RecipeComponent<(T)>
public "mapCodec"(ctx: $RecipeTypeRegistryContext$$Type): $MapCodec<($RecipeComponent<(never)>)>
public "isUnit"(): boolean
get "unit"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentType$Unit$$Type<T> = ($RecipeComponentType$Unit<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponentType$Unit$$Original<T> = $RecipeComponentType$Unit<(T)>;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Info" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Record} from "java.lang.Record"

export class $FluidData$Info extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData$Info)>

constructor(filter: $FluidIngredient$$Type, info: $List$$Type<($Component$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $FluidIngredient
public "info"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$Info$$Type = ({"filter"?: $FluidIngredient$$Type, "info"?: $List$$Type<($Component$$Type)>}) | ([filter?: $FluidIngredient$$Type, info?: $List$$Type<($Component$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidData$Info$$Original = $FluidData$Info;}
declare module "dev.latvian.mods.kubejs.component.MutableDataComponentHolderFunctions" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$ComponentFunctions, $ComponentFunctions$$Interface} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$Map$$Type} from "java.util.Map"
import {$MutableDataComponentHolder} from "net.neoforged.neoforge.common.MutableDataComponentHolder"
import {$UUID$$Type} from "java.util.UUID"
import {$List$$Type} from "java.util.List"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$Unit$$Type} from "net.minecraft.util.Unit"

export interface $MutableDataComponentHolderFunctions$$Interface extends $ComponentFunctions$$Interface {
get "componentMap"(): $DataComponentMap
get "componentHolder"(): $MutableDataComponentHolder
get "additionalTooltipHidden"(): void
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
get "componentString"(): StringJS
set "customModelData"(value: integer)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
get "tooltipHidden"(): void
set "potionContents"(value: $PotionContents$$Type)
set "glintOverride"(value: boolean)
set "dyedColor"(value: $KubeColor$$Type)
set "customData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
set "potionId"(value: $Holder$$Type<($Potion)>)
get "customData"(): $CompoundTag
set "lockCode"(value: StringJS)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "entityData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "customName"(value: $Component$$Type)
}

export class $MutableDataComponentHolderFunctions implements $MutableDataComponentHolderFunctions$$Interface {
 "getComponentMap"(): $DataComponentMap
 "patch"(components: $DataComponentPatch$$Type): $ComponentFunctions
 "set"(components: $DataComponentMap$$Type): this
 "getComponentHolder"(): $MutableDataComponentHolder
 "setAdditionalTooltipHidden"(): void
 "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
 "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
 "resetComponents"(): $ComponentFunctions
 "getComponentString"(): StringJS
 "setCustomModelData"(data: integer): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
 "setTooltipHidden"(): void
 "setPotionContents"(contents: $PotionContents$$Type): void
 "setGlintOverride"(override: boolean): void
 "get"<T>(type: $DataComponentType$$Type<(T)>): T
 "remove"(type: $DataComponentType$$Type<(never)>): $ComponentFunctions
 "set"(component: $DataComponentType$$Type<(never)>, value: any): $ComponentFunctions
 "setDyedColor"(color: $KubeColor$$Type): void
 "setCustomData"(tag: $CompoundTag$$Type): void
 "setProfile"(profile: $GameProfile$$Type): void
 "setProfile"(name: StringJS, uuid: $UUID$$Type): void
 "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "setPotionId"(potion: $Holder$$Type<($Potion)>): void
 "getCustomData"(): $CompoundTag
 "setLockCode"(lock: StringJS): void
 "getCustomName"(): $Component
 "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
 "setLore"(lines: $List$$Type<($Component$$Type)>): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "setRarity"(rarity: $Rarity$$Type): void
 "setBaseColor"(color: $DyeColor$$Type): void
 "setCustomName"(name: $Component$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableDataComponentHolderFunctions$$Type = ($MutableDataComponentHolderFunctions);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MutableDataComponentHolderFunctions$$Original = $MutableDataComponentHolderFunctions;}
declare module "dev.latvian.mods.kubejs.util.TinyMap$Entry" {
import {$Record} from "java.lang.Record"

export class $TinyMap$Entry<K, V> extends $Record {
constructor(key: K, value: V)

public "value"(): V
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "key"(): K
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TinyMap$Entry$$Type<K, V> = ({"value"?: V, "key"?: K}) | ([value?: V, key?: K]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TinyMap$Entry$$Original<K, V> = $TinyMap$Entry<(K), (V)>;}
declare module "dev.latvian.mods.kubejs.client.LangKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Pattern} from "java.util.regex.Pattern"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$LangKubeEvent$Key, $LangKubeEvent$Key$$Type} from "dev.latvian.mods.kubejs.client.LangKubeEvent$Key"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Record} from "java.lang.Record"

export class $LangKubeEvent extends $Record implements $KubeEvent$$Interface {
static readonly "PATTERN": $Pattern

constructor(lang: StringJS, map: $Map$$Type<($LangKubeEvent$Key$$Type), (StringJS)>)

public "renameEntity"(id: $ResourceLocation$$Type, name: StringJS): void
public "renameBiome"(id: $ResourceLocation$$Type, name: StringJS): void
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "add"(key: StringJS, value: StringJS): void
public "add"(namespace: StringJS, key: StringJS, value: StringJS): void
public "map"(): $Map<($LangKubeEvent$Key), (StringJS)>
public "addAll"(map: $Map$$Type<(StringJS), (StringJS)>): void
public "addAll"(namespace: StringJS, map: $Map$$Type<(StringJS), (StringJS)>): void
public "lang"(): StringJS
public "painting"(paintingId: $ResourceLocation$$Type, title: StringJS, author: StringJS): void
public "renameBlock"(block: $Block$$Type, name: StringJS): void
public "renameItem"(item: $ItemStack$$Type, name: StringJS): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LangKubeEvent$$Type = ({"map"?: $Map$$Type<($LangKubeEvent$Key$$Type), (StringJS)>, "lang"?: StringJS}) | ([map?: $Map$$Type<($LangKubeEvent$Key$$Type), (StringJS)>, lang?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LangKubeEvent$$Original = $LangKubeEvent;}
declare module "dev.latvian.mods.kubejs.util.WrappedJS" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $WrappedJS$$Interface {
}

export class $WrappedJS implements $WrappedJS$$Interface {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedJS$$Type = ($WrappedJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WrappedJS$$Original = $WrappedJS;}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$CreativeTabCallback$$Type} from "dev.latvian.mods.kubejs.item.creativetab.CreativeTabCallback"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$CreativeModeTab, $CreativeModeTab$$Type} from "net.minecraft.world.item.CreativeModeTab"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$CreativeModeTab$TabVisibility$$Type} from "net.minecraft.world.item.CreativeModeTab$TabVisibility"
import {$Component$$Type} from "net.minecraft.network.chat.Component"

export class $CreativeTabKubeEvent implements $KubeEvent$$Interface {
readonly "tab": $CreativeModeTab
readonly "showRestrictedItems": boolean

constructor(tab: $CreativeModeTab$$Type, showRestrictedItems: boolean, callback: $CreativeTabCallback$$Type)

public "setIcon"(icon: $ItemStack$$Type): void
public "setDisplayName"(component: $Component$$Type): void
public "remove"(filter: $ItemPredicate$$Type): void
public "add"(items: ($ItemStack$$Type)[]): void
public "add"(items: ($ItemStack$$Type)[], visibility: $CreativeModeTab$TabVisibility$$Type): void
public "addAfter"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[]): void
public "addAfter"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[], visibility: $CreativeModeTab$TabVisibility$$Type): void
public "addBefore"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[]): void
public "addBefore"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[], visibility: $CreativeModeTab$TabVisibility$$Type): void
public "removeFromSearch"(filter: $ItemPredicate$$Type): void
public "removeFromParent"(filter: $ItemPredicate$$Type): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
set "icon"(value: $ItemStack$$Type)
set "displayName"(value: $Component$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabKubeEvent$$Type = ($CreativeTabKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeTabKubeEvent$$Original = $CreativeTabKubeEvent;}
declare module "dev.latvian.mods.kubejs.misc.VillagerProfessionBuilder" {
import {$VillagerProfession} from "net.minecraft.world.entity.npc.VillagerProfession"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $VillagerProfessionBuilder extends $BuilderBase<($VillagerProfession)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "poiType"(t: $ResourceLocation$$Type): this
public "poiTypeTag"(t: $ResourceLocation$$Type): this
public "secondaryPoi"(t: ($Block$$Type)[]): this
public "requestedItems"(t: ($Item$$Type)[]): this
public "workSound"(t: $SoundEvent$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VillagerProfessionBuilder$$Type = ($VillagerProfessionBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VillagerProfessionBuilder$$Original = $VillagerProfessionBuilder;}
declare module "dev.latvian.mods.kubejs.item.ItemCraftedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Container$$Type} from "net.minecraft.world.Container"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player crafts an item.
 */
export class $ItemCraftedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, crafted: $ItemStack$$Type, container: $Container$$Type)

/**
 * The item that was crafted.
 */
public "getItem"(): $ItemStack
/**
 * The player that crafted the item.
 */
public "getEntity"(): $LivingEntity
/**
 * The inventory that the item was crafted in.
 */
public "getInventory"(): $InventoryKJS
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "item"(): $ItemStack
get "entity"(): $LivingEntity
get "inventory"(): $InventoryKJS
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemCraftedKubeEvent$$Type = ($ItemCraftedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemCraftedKubeEvent$$Original = $ItemCraftedKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityInfo" {
import {$BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$CustomCapabilityAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.CustomCapabilityAttachment$Factory"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$FluidTankAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.FluidTankAttachment$Factory"
import {$FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$BlockEntityAttachmentHandler$$Interface} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentHandler"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$InventoryAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.InventoryAttachment$Factory"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Set$$Type} from "java.util.Set"
import {$EnergyStorageAttachment$Factory$$Type} from "dev.latvian.mods.kubejs.block.entity.EnergyStorageAttachment$Factory"
import {$BlockEntityEventCallback$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityEventCallback"

export class $BlockEntityInfo implements $BlockEntityAttachmentHandler$$Interface {
constructor(blockBuilder: $BlockBuilder$$Type)

public "initialData"(data: $CompoundTag$$Type): void
public "toString"(): StringJS
public "ticking"(): void
public "eventHandler"(eventId: integer, callback: $BlockEntityEventCallback$$Type): void
public "rightClickOpensInventory"(id: StringJS): void
public "rightClickFillsTank"(id: StringJS): void
public "tickOffset"(offset: integer): void
public "enableSync"(): void
public "tickFrequency"(frequency: integer): void
public "clientTicking"(): void
public "serverTicking"(): void
public "inventory"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, width: integer, height: integer): void
public "inventory"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, width: integer, height: integer, inputFilter: $ItemPredicate$$Type): void
public "attach"<T extends Attachments>(id: StringJS, type: T, directions: $Set$$Type<($Direction$$Type)>, args: AttachmentMap[T]): void
public "fluidTank"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer, inputFilter: $FluidIngredient$$Type): void
public "fluidTank"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer): void
public "energyStorage"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer, maxReceive: integer, maxExtract: integer, autoOutput: integer): void
public "attachCustomCapability"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capability: $BlockCapability$$Type<(never), (never)>, dataFactory: $Supplier$$Type<(never)>): void
}
export type AttachmentMap = {"kubejs:fluid_tank": $FluidTankAttachment$Factory$$Type;
"kubejs:energy_storage": $EnergyStorageAttachment$Factory$$Type;
"kubejs:custom_capability": $CustomCapabilityAttachment$Factory$$Type;
"kubejs:inventory": $InventoryAttachment$Factory$$Type};
export type Attachments = keyof AttachmentMap;
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityInfo$$Type = ($BlockEntityInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityInfo$$Original = $BlockEntityInfo;}
declare module "dev.latvian.mods.kubejs.recipe.AfterRecipesLoadedKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$RecipeFilter$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeFilter"
import {$ReloadableServerResources$$Type} from "net.minecraft.server.ReloadableServerResources"
import {$RecipeLikeKJS$$Type} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $AfterRecipesLoadedKubeEvent implements $KubeEvent$$Interface {
constructor(resources: $ReloadableServerResources$$Type)

public "remove"(filter: $RecipeFilter$$Type): integer
public "countRecipes"(filter: $RecipeFilter$$Type): integer
public "forEachRecipe"(filter: $RecipeFilter$$Type, consumer: $Consumer$$Type<($RecipeLikeKJS)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterRecipesLoadedKubeEvent$$Type = ($AfterRecipesLoadedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AfterRecipesLoadedKubeEvent$$Original = $AfterRecipesLoadedKubeEvent;}
declare module "dev.latvian.mods.kubejs.script.ConsoleJS" {
import {$ContextFactory} from "dev.latvian.mods.rhino.ContextFactory"
import {$Pattern, $Pattern$$Type} from "java.util.regex.Pattern"
import {$KJSWSSession} from "dev.latvian.mods.kubejs.web.KJSWSSession"
import {$Component} from "net.minecraft.network.chat.Component"
import {$WeakReference} from "java.lang.ref.WeakReference"
import {$LogType$$Type} from "dev.latvian.mods.kubejs.util.LogType"
import {$HTTPResponse} from "dev.latvian.apps.tinyserver.http.response.HTTPResponse"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Class$$Type} from "java.lang.Class"
import {$Throwable$$Type} from "java.lang.Throwable"
import {$WSHandler} from "dev.latvian.apps.tinyserver.ws.WSHandler"
import {$KJSHTTPRequest, $KJSHTTPRequest$$Type} from "dev.latvian.mods.kubejs.web.KJSHTTPRequest"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Logger, $Logger$$Type} from "org.slf4j.Logger"
import {$ConsoleLine, $ConsoleLine$$Type} from "dev.latvian.mods.kubejs.script.ConsoleLine"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ConsoleJS {
static "SERVER": $ConsoleJS
readonly "scriptType": $ScriptType
static "STARTUP": $ConsoleJS
 "wsBroadcaster": $WSHandler<($KJSHTTPRequest), ($KJSWSSession)>
static "CLIENT": $ConsoleJS
 "contextFactory": $WeakReference<($ContextFactory)>

constructor(m: $ScriptType$$Type, log: $Logger$$Type)

public "startCapturingErrors"(): void
public "group"(): void
public "log"(...message: (any)[]): void
public "flush"(sync: boolean): void
public "info"(message: any): $ConsoleLine
public "getLogger"(): $Logger
public "trace"(): void
public "debug"(message: any): $ConsoleLine
public "error"(message: StringJS, sourceLine: $SourceLine$$Type, error: $Throwable$$Type, exitPattern: $Pattern$$Type): $ConsoleLine
public "error"(message: StringJS, throwable: $Throwable$$Type): $ConsoleLine
public "error"(message: StringJS, error: $Throwable$$Type, exitPattern: $Pattern$$Type): $ConsoleLine
public "error"(message: any): $ConsoleLine
public "warn"(message: StringJS, sourceLine: $SourceLine$$Type, error: $Throwable$$Type, exitPattern: $Pattern$$Type): $ConsoleLine
public "warn"(message: any): $ConsoleLine
public "warn"(message: StringJS, error: $Throwable$$Type): $ConsoleLine
public "warn"(message: StringJS, error: $Throwable$$Type, exitPattern: $Pattern$$Type): $ConsoleLine
public "groupEnd"(): void
public "writeToFile"(type: $LogType$$Type, line: StringJS): void
public "writeToFile"(type: $LogType$$Type, timestamp: long, line: StringJS): void
public "getWarningsResponse"(ctx: $KJSHTTPRequest$$Type): $HTTPResponse
public "resetFile"(): void
public static "getCurrent"(): $ConsoleJS
public "debugf"(message: StringJS, ...args: (any)[]): $ConsoleLine
public "infof"(message: StringJS, ...args: (any)[]): $ConsoleLine
public "printClass"(className: StringJS, tree: boolean): void
public "printClass"(className: StringJS): void
public "warnf"(message: StringJS, ...args: (any)[]): $ConsoleLine
public "errorf"(message: StringJS, ...args: (any)[]): $ConsoleLine
public "setMuted"(m: boolean): void
public "getMuted"(): boolean
public "handleError"(line: $ConsoleLine$$Type, error: $Throwable$$Type, exitPattern: $Pattern$$Type, print: boolean): void
public "printObject"(o: any, tree: boolean): void
public "printObject"(o: any): void
public "getErrorsResponse"(ctx: $KJSHTTPRequest$$Type): $HTTPResponse
public "shouldPrintDebug"(): boolean
public "errorsComponent"(command: StringJS): $Component
public "getDebugEnabled"(): boolean
public "getWriteToFile"(): boolean
public "setWriteToFile"(m: boolean): void
public static "methodPattern"(c: $Class$$Type<(never)>, method: StringJS): $Pattern
public "getScriptLine"(): integer
public "setDebugEnabled"(m: boolean): void
public "stopCapturingErrors"(): void
get "logger"(): $Logger
get "current"(): $ConsoleJS
set "muted"(value: boolean)
get "muted"(): boolean
get "debugEnabled"(): boolean
get "scriptLine"(): integer
set "debugEnabled"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConsoleJS$$Type = ($ConsoleJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ConsoleJS$$Original = $ConsoleJS;}
declare module "dev.latvian.mods.kubejs.fluid.FluidWrapper" {
import {$DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$DataResult} from "com.mojang.serialization.DataResult"
import {$List} from "java.util.List"
import {$SizedFluidIngredient, $SizedFluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.SizedFluidIngredient"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$FluidWrapper$ReadFn$$Type} from "dev.latvian.mods.kubejs.fluid.FluidWrapper$ReadFn"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Fluid, $Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Tag$$Type} from "net.minecraft.nbt.Tag"

export interface $FluidWrapper$$Interface {
get "empty"(): $FluidStack
get "types"(): $List<(StringJS)>
}

export class $FluidWrapper implements $FluidWrapper$$Interface {
static readonly "FLUID_TYPE_INFO": $TypeInfo
static readonly "EMPTY_STACK_RESULT": $DataResult<($FluidStack)>
static readonly "EMPTY_SIZED_RESULT": $DataResult<($SizedFluidIngredient)>
static readonly "TYPE_INFO": $TypeInfo
static readonly "EMPTY_SIZED": $SizedFluidIngredient
static readonly "INGREDIENT_TYPE_INFO": $TypeInfo
static readonly "SIZED_INGREDIENT_TYPE_INFO": $TypeInfo
static readonly "EMPTY_INGREDIENT_RESULT": $DataResult<($FluidIngredient)>

static "lava"(): $FluidStack
static "lava"(amount: integer): $FluidStack
/**
 * Returns a FluidStack of the input
 */
static "of"(o: $FluidStack$$Type): $FluidStack
/**
 * Returns a FluidStack of the input, with the specified amount
 */
static "of"(o: $FluidStack$$Type, amount: integer): $FluidStack
/**
 * Returns a FluidStack of the input, with the specified data components
 */
static "of"(o: $FluidStack$$Type, components: $DataComponentMap$$Type): $FluidStack
/**
 * Returns a FluidStack of the input, with the specified amount and data components
 */
static "of"(o: $FluidStack$$Type, amount: integer, components: $DataComponentMap$$Type): $FluidStack
static "read"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, reader: $StringReader$$Type): $DataResult<($FluidStack)>
static "getId"(fluid: $Fluid$$Type): $ResourceLocation
static "getType"(id: $ResourceLocation$$Type): $Fluid
static "exists"(id: $ResourceLocation$$Type): boolean
static "parseString"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, s: StringJS): $DataResult<($FluidStack)>
static "ingredientOfString"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, s: StringJS): $DataResult<($FluidIngredient)>
static "readWithContext"<T>(registryOps: $DynamicOps$$Type<($Tag$$Type)>, s: StringJS, fn: $FluidWrapper$ReadFn$$Type<(T)>, name: StringJS): $DataResult<(T)>
static "sizedIngredientOf"(arg0: $FluidIngredient$$Type, amount: integer): $SizedFluidIngredient
static "sizedIngredientOf"(of: $SizedFluidIngredient$$Type): $SizedFluidIngredient
static "ingredientOf"(of: $FluidIngredient$$Type): $FluidIngredient
/**
 * Returns an ingredient that accepts the given set of items under the given (optionally strict) component filter.
 */
static "ingredientOf"(base: $HolderSet$$Type<($Fluid)>, data: $DataComponentMap$$Type, strict: boolean): $FluidIngredient
/**
 * Returns an ingredient that accepts the given set of fluids under the given component filter.
 */
static "ingredientOf"(base: $HolderSet$$Type<($Fluid)>, data: $DataComponentMap$$Type): $FluidIngredient
static "water"(amount: integer): $FluidStack
static "water"(): $FluidStack
static "getEmpty"(): $FluidStack
static "getTypes"(): $List<(StringJS)>
static "sizedIngredientOfString"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, s: StringJS): $DataResult<($SizedFluidIngredient)>
static "readSizedIngredient"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, reader: $StringReader$$Type): $DataResult<($SizedFluidIngredient)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidWrapper$$Type = ($FluidWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidWrapper$$Original = $FluidWrapper;}
declare module "dev.latvian.mods.kubejs.misc.ParticleTypeBuilder" {
import {$StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ParticleType} from "net.minecraft.core.particles.ParticleType"
import {$RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

export class $ParticleTypeBuilder extends $BuilderBase<($ParticleType<(never)>)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "texture"(texture: StringJS): this
public "textures"(textures: $List$$Type<(StringJS)>): this
public "codec"(c: $MapCodec$$Type<($ParticleOptions$$Type)>): this
public "streamCodec"(s: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), ($ParticleOptions$$Type)>): this
public "overrideLimiter"(o: boolean): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleTypeBuilder$$Type = ($ParticleTypeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ParticleTypeBuilder$$Original = $ParticleTypeBuilder;}
declare module "dev.latvian.mods.kubejs.script.ScriptPackInfo" {
import {$ScriptFileInfo} from "dev.latvian.mods.kubejs.script.ScriptFileInfo"
import {$List} from "java.util.List"
import {$Component} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptPackInfo {
readonly "displayName": $Component
readonly "namespace": StringJS
readonly "pathStart": StringJS
readonly "scripts": $List<($ScriptFileInfo)>

constructor(n: StringJS, p: StringJS)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptPackInfo$$Type = ($ScriptPackInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptPackInfo$$Original = $ScriptPackInfo;}
declare module "dev.latvian.mods.kubejs.core.SizedFluidIngredientKJS" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$FluidMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.FluidMatch"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$SizedFluidIngredient} from "net.neoforged.neoforge.fluids.crafting.SizedFluidIngredient"
import {$FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $SizedFluidIngredientKJS$$Interface extends $Replaceable$$Interface, $FluidMatch$$Interface {
}

export class $SizedFluidIngredientKJS implements $SizedFluidIngredientKJS$$Interface {
 "matches"(cx: $RecipeMatchContext$$Type, s: $FluidStack$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $FluidIngredient$$Type, exact: boolean): boolean
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "toNestedJson"(): $JsonElement
 "toFlatJson"(): $JsonElement
 "self"(): $SizedFluidIngredient
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SizedFluidIngredientKJS$$Type = ($SizedFluidIngredientKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SizedFluidIngredientKJS$$Original = $SizedFluidIngredientKJS;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent" {
import {$ChestMenuSlot, $ChestMenuSlot$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuSlot"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"

export class $ChestMenuClickEvent {
readonly "button": integer
readonly "slot": $ChestMenuSlot
readonly "type": $ClickType

constructor(slot: $ChestMenuSlot$$Type, type: $ClickType$$Type, button: integer)

public "setHandled"(): void
get "handled"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuClickEvent$$Type = ($ChestMenuClickEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuClickEvent$$Original = $ChestMenuClickEvent;}
declare module "dev.latvian.mods.kubejs.event.IEventHandler" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $IEventHandler$$Interface {

(event: $KubeEvent): any
}

export class $IEventHandler implements $IEventHandler$$Interface {
 "onEvent"(event: $KubeEvent$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEventHandler$$Type = ((event: $KubeEvent) => any);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IEventHandler$$Original = $IEventHandler;}
declare module "dev.latvian.mods.kubejs.server.CommandKubeEvent" {
import {$ParseResults, $ParseResults$$Type} from "com.mojang.brigadier.ParseResults"
import {$CommandEvent$$Type} from "net.neoforged.neoforge.event.CommandEvent"
import {$Throwable, $Throwable$$Type} from "java.lang.Throwable"
import {$ServerKubeEvent} from "dev.latvian.mods.kubejs.server.ServerKubeEvent"
import {$CommandSourceStack, $CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"

export class $CommandKubeEvent extends $ServerKubeEvent {
readonly "server": $MinecraftServer

constructor(event: $CommandEvent$$Type)

public "getInput"(): StringJS
public "getException"(): $Throwable
public "setException"(exception: $Throwable$$Type): void
public "getCommandName"(): StringJS
public "getParseResults"(): $ParseResults<($CommandSourceStack)>
public "setParseResults"(parse: $ParseResults$$Type<($CommandSourceStack$$Type)>): void
get "input"(): StringJS
get "exception"(): $Throwable
set "exception"(value: $Throwable$$Type)
get "commandName"(): StringJS
get "parseResults"(): $ParseResults<($CommandSourceStack)>
set "parseResults"(value: $ParseResults$$Type<($CommandSourceStack$$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandKubeEvent$$Type = ($CommandKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CommandKubeEvent$$Original = $CommandKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.schema.function.ResolvedRecipeSchemaFunction" {
import {$RecipeScriptContext, $RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"

export interface $ResolvedRecipeSchemaFunction$$Interface {

(cx: $RecipeScriptContext, args: $List<(any)>): void
}

export class $ResolvedRecipeSchemaFunction implements $ResolvedRecipeSchemaFunction$$Interface {
 "execute"(cx: $RecipeScriptContext$$Type, args: $List$$Type<(any)>): void
 "arguments"(): $List<($RecipeComponent<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResolvedRecipeSchemaFunction$$Type = ((cx: $RecipeScriptContext, args: $List<(any)>) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ResolvedRecipeSchemaFunction$$Original = $ResolvedRecipeSchemaFunction;}
declare module "dev.latvian.mods.kubejs.block.entity.EnergyStorageAttachment$Factory" {
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockCapability} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$BlockEntityAttachmentFactory$$Interface} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$List} from "java.util.List"
import {$BlockEntityAttachment} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record} from "java.lang.Record"

export class $EnergyStorageAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory$$Interface {
constructor(capacity: integer, maxReceive: (integer)?, maxExtract: (integer)?, autoOutput: (integer)?)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "create"(info: $BlockEntityAttachmentInfo$$Type, entity: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "capacity"(): integer
public "getCapabilities"(): $List<($BlockCapability<(never), (never)>)>
public "isTicking"(): boolean
public "maxExtract"(): $Optional<(integer)>
public "maxReceive"(): $Optional<(integer)>
public "autoOutput"(): $Optional<(integer)>
get "capabilities"(): $List<($BlockCapability<(never), (never)>)>
get "ticking"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnergyStorageAttachment$Factory$$Type = ({"maxReceive"?: (integer)?, "autoOutput"?: (integer)?, "capacity"?: integer, "maxExtract"?: (integer)?}) | ([maxReceive?: (integer)?, autoOutput?: (integer)?, capacity?: integer, maxExtract?: (integer)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EnergyStorageAttachment$Factory$$Original = $EnergyStorageAttachment$Factory;}
declare module "dev.latvian.mods.kubejs.player.EntityArrayList" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$ArrayList} from "java.util.ArrayList"
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Collection$$Type} from "java.util.Collection"
import {$SequencedCollection} from "java.util.SequencedCollection"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$List, $List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MessageSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntitySelector$$Type} from "net.minecraft.commands.arguments.selector.EntitySelector"
import {$DataSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.DataSenderKJS"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $EntityArrayList extends $ArrayList<($Entity)> implements $MessageSenderKJS$$Interface, $DataSenderKJS$$Interface {
static readonly "ALWAYS_TRUE_PREDICATE": $Predicate<($Entity)>

constructor(size: integer)
/**
 * 
 * @deprecated
 */
constructor(level: $Level$$Type, entities: $Iterable$$Type<($Entity$$Type)>)
constructor(entities: $Iterable$$Type<($Entity$$Type)>)

public "playSound"(id: $SoundEvent$$Type): void
public "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
public "kill"(): void
public "filter"(filterList: $List$$Type<($Predicate$$Type<($Entity$$Type)>)>): $EntityArrayList
public "getFirst"(): $Entity
public "filterType"(type: $EntityType$$Type<(never)>): $EntityArrayList
public "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
public "setStatusMessage"(message: $Component$$Type): void
public "runCommandSilent"(command: StringJS): void
public "setActivePostShader"(id: $ResourceLocation$$Type): void
public "filterItems"(): $EntityArrayList
public "tell"(message: $Component$$Type): void
public "getName"(): $Component
public "runCommand"(command: StringJS): void
public "getDisplayName"(): $Component
public "filterSelector"(selector: $EntitySelector$$Type): $EntityArrayList
public "filterDistance"(pos: $BlockPos$$Type, distance: double): $EntityArrayList
public "filterDistance"(x: double, y: double, z: double, distance: double): $EntityArrayList
public "filterPlayers"(): $EntityArrayList
public "addAllIterable"(entities: $Iterable$$Type<($Entity$$Type)>): void
public "oneFilter"(filter: $Predicate$$Type<($Entity)>): $EntityArrayList
public "sendData"(channel: StringJS): void
public static "copyOf"<E>(arg0: $Collection$$Type<(E)>): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public "reversed"(): $SequencedCollection
public "containsAll"(arg0: $Collection$$Type<(never)>): boolean
get "first"(): $Entity
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "displayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityArrayList$$Type = ($EntityArrayList);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityArrayList$$Original = $EntityArrayList;}
declare module "dev.latvian.mods.kubejs.core.EntityCollectionKJS" {
import {$Iterable, $Iterable$$Type} from "java.lang.Iterable"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $EntityCollectionKJS$$Interface {

(): $Iterable$$Type<($Entity$$Type)>
get "players"(): $EntityArrayList
get "mcEntities"(): $Iterable<($Entity)>
get "entities"(): $EntityArrayList
get "mcPlayers"(): $List<($Player)>
}

export class $EntityCollectionKJS implements $EntityCollectionKJS$$Interface {
 "getPlayers"(): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getEntities"(): $EntityArrayList
 "getMcPlayers"(): $List<($Player)>
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityCollectionKJS$$Type = (() => $Iterable$$Type<($Entity$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityCollectionKJS$$Original = $EntityCollectionKJS;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.CategoryData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$Record} from "java.lang.Record"

export class $CategoryData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($CategoryData)>

constructor(category: $ResourceLocation$$Type)
constructor(category: $ResourceLocation$$Type, removedRecipes: $List$$Type<($ResourceLocation$$Type)>)

public "lock"(): $CategoryData
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "category"(): $ResourceLocation
public "removedRecipes"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CategoryData$$Type = ({"removedRecipes"?: $List$$Type<($ResourceLocation$$Type)>, "category"?: $ResourceLocation$$Type}) | ([removedRecipes?: $List$$Type<($ResourceLocation$$Type)>, category?: $ResourceLocation$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CategoryData$$Original = $CategoryData;}
declare module "dev.latvian.mods.kubejs.client.AtlasSpriteRegistryKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $AtlasSpriteRegistryKubeEvent implements $KubeEvent$$Interface {
constructor(registry: $Consumer$$Type<($ResourceLocation)>)

public "register"(id: $ResourceLocation$$Type): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AtlasSpriteRegistryKubeEvent$$Type = ($AtlasSpriteRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AtlasSpriteRegistryKubeEvent$$Original = $AtlasSpriteRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent" {
import {$TinyMap} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$OpsContainer$$Type} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$List, $List$$Type} from "java.util.List"
import {$ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$CustomObjectRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent"
import {$RecipeComponent, $RecipeComponent$$Type, $RecipeComponent$$Interface} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeKey} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$CustomObjectRecipeComponent$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$RecipeComponentBuilder} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder"
import {$RecipeComponentType} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$Either, $Either$$Type} from "com.mojang.datafixers.util.Either"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$ListRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.ListRecipeComponent"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Record} from "java.lang.Record"

export class $EitherRecipeComponent<H, L> extends $Record implements $RecipeComponent$$Interface<($Either<(H), (L)>)> {
static readonly "TYPE": $RecipeComponentType<(never)>

constructor(left: $RecipeComponent$$Type<(H)>, right: $RecipeComponent$$Type<(L)>)
constructor(left: $RecipeComponent$$Type<(H)>, right: $RecipeComponent$$Type<(L)>, codec: $Codec$$Type<($Either$$Type<(H), (L)>)>, typeInfo: $TypeInfo$$Type)

public "type"(): $RecipeComponentType<(never)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "toString"(ops: $OpsContainer$$Type, value: $Either$$Type<(H), (L)>): StringJS
public "toString"(ops: $OpsContainer$$Type, value: any): StringJS
public "hashCode"(): integer
public "wrap"(cx: $RecipeScriptContext$$Type, from: any): $Either<(H), (L)>
public "replace"(cx: $RecipeScriptContext$$Type, original: $Either$$Type<(H), (L)>, match: $ReplacementMatchInfo$$Type, arg3: any): $Either<(H), (L)>
public "replace"(cx: $RecipeScriptContext$$Type, original: any, match: $ReplacementMatchInfo$$Type, arg3: any): any
public "matches"(cx: $RecipeMatchContext$$Type, value: any, match: $ReplacementMatchInfo$$Type): boolean
public "matches"(cx: $RecipeMatchContext$$Type, value: $Either$$Type<(H), (L)>, match: $ReplacementMatchInfo$$Type): boolean
public "validate"(ctx: $RecipeValidationContext$$Type, value: any): void
public "validate"(ctx: $RecipeValidationContext$$Type, value: $Either$$Type<(H), (L)>): void
public "typeInfo"(): $TypeInfo
public "spread"(value: any): $List
public "spread"(value: $Either$$Type<(H), (L)>): $List<(never)>
public "left"(): $RecipeComponent<(H)>
public "right"(): $RecipeComponent<(L)>
public "codec"(): $Codec<($Either<(H), (L)>)>
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, value: any): void
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, value: $Either$$Type<(H), (L)>): void
public "isEmpty"(value: $Either$$Type<(H), (L)>): boolean
public static "builder"(keys: $List$$Type<($CustomObjectRecipeComponent$Key$$Type)>): $CustomObjectRecipeComponent
public static "builder"(...keys: ($CustomObjectRecipeComponent$Key$$Type)[]): $CustomObjectRecipeComponent
public "key"(name: StringJS, role: $ComponentRole$$Type): $RecipeKey<($Either<(H), (L)>)>
public "asList"(): $ListRecipeComponent<($Either<(H), (L)>)>
public "or"<O>(other: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<($Either<(H), (L)>), (O)>
public "allowEmpty"(): boolean
public "orSelf"(): $RecipeComponent<($Either<(H), (L)>)>
public "createBuilder"(): $RecipeComponentBuilder
public "asConditionalListOrSelf"(): $ListRecipeComponent<($Either<(H), (L)>)>
public "asMap"<K>(key: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($Either<(H), (L)>)>)>
public "otherKey"(name: StringJS): $RecipeKey<($Either<(H), (L)>)>
public "inputKey"(name: StringJS): $RecipeKey<($Either<(H), (L)>)>
public "hasPriority"(cx: $RecipeMatchContext$$Type, from: any): boolean
public "outputKey"(name: StringJS): $RecipeKey<($Either<(H), (L)>)>
public "readFromJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($Either$$Type<(H), (L)>)>, json: $JsonObject$$Type): void
public "writeToJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($Either$$Type<(H), (L)>)>, json: $JsonObject$$Type): void
public "asListOrSelf"(): $ListRecipeComponent<($Either<(H), (L)>)>
public "asConditionalList"(): $ListRecipeComponent<($Either<(H), (L)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($Either<(H), (L)>)>)>
public "isIgnored"(): boolean
public "withCodec"(codec: $Codec$$Type<($Either$$Type<(H), (L)>)>): $RecipeComponent<($Either<(H), (L)>)>
get "ignored"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EitherRecipeComponent$$Type<H, L> = ({"left"?: $RecipeComponent$$Type<(H)>, "typeInfo"?: $TypeInfo$$Type, "right"?: $RecipeComponent$$Type<(L)>, "codec"?: $Codec$$Type<($Either$$Type<(H), (L)>)>}) | ([left?: $RecipeComponent$$Type<(H)>, typeInfo?: $TypeInfo$$Type, right?: $RecipeComponent$$Type<(L)>, codec?: $Codec$$Type<($Either$$Type<(H), (L)>)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EitherRecipeComponent$$Original<H, L> = $EitherRecipeComponent<(H), (L)>;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.NativeEventWrapper" {
import {$EventPriority$$Type} from "net.neoforged.bus.api.EventPriority"
import {$Event, $Event$$Type} from "net.neoforged.bus.api.Event"
import {$Class$$Type} from "java.lang.Class"
import {$Consumer$$Type} from "java.util.function.Consumer"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $NativeEventWrapper$$Interface {
}

export class $NativeEventWrapper implements $NativeEventWrapper$$Interface {
static "onEvent"<T extends typeof $Event<(unknown)>>(eventClass: T, consumer: (event: InstanceType<(T)>) => void): void
static "onEvent"<T extends typeof $Event<(unknown)>>(priority: $EventPriority$$Type, eventClass: T, consumer: (event: InstanceType<(T)>) => void): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeEventWrapper$$Type = ($NativeEventWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NativeEventWrapper$$Original = $NativeEventWrapper;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.BuildingMaterialProperties" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$BuildingMaterialProperties$Blocks, $BuildingMaterialProperties$Blocks$$Type} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.BuildingMaterialProperties$Blocks"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$BlockSetType, $BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$TickDuration, $TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$Record} from "java.lang.Record"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $BuildingMaterialProperties extends $Record {
static readonly "TYPE_INFO": $TypeInfo

constructor(blocks: $BuildingMaterialProperties$Blocks$$Type, baseBlock: (boolean)?, baseBlockSuffix: (boolean)?, properties: $Consumer$$Type<($BlockBuilder)>, behaviour: ($BlockSetType$$Type)?, ticksToStayPressed: ($TickDuration$$Type)?)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "properties"(): $Consumer<($BlockBuilder)>
public "blocks"(): $BuildingMaterialProperties$Blocks
public "behaviour"(): $Optional<($BlockSetType)>
public "ticksToStayPressed"(): $Optional<($TickDuration)>
public "baseBlock"(): $Optional<(boolean)>
public "baseBlockSuffix"(): $Optional<(boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuildingMaterialProperties$$Type = ({"blocks"?: $BuildingMaterialProperties$Blocks$$Type, "properties"?: $Consumer$$Type<($BlockBuilder$$Type)>, "baseBlock"?: (boolean)?, "behaviour"?: ($BlockSetType$$Type)?, "ticksToStayPressed"?: ($TickDuration$$Type)?, "baseBlockSuffix"?: (boolean)?}) | ([blocks?: $BuildingMaterialProperties$Blocks$$Type, properties?: $Consumer$$Type<($BlockBuilder$$Type)>, baseBlock?: (boolean)?, behaviour?: ($BlockSetType$$Type)?, ticksToStayPressed?: ($TickDuration$$Type)?, baseBlockSuffix?: (boolean)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BuildingMaterialProperties$$Original = $BuildingMaterialProperties;}
declare module "dev.latvian.mods.kubejs.core.BlockStateKJS" {
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$List} from "java.util.List"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$RelativeURL} from "dev.latvian.mods.kubejs.web.RelativeURL"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Holder} from "net.minecraft.core.Holder"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $BlockStateKJS$$Interface extends $RegistryObjectKJS$$Interface<($Block)>, $Replaceable$$Interface {
get "id"(): StringJS
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "registry"(): $Registry<($Block)>
get "key"(): $ResourceKey<($Block)>
set "destroySpeed"(value: float)
set "requiresTool"(value: boolean)
set "lightEmission"(value: integer)
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $BlockStateKJS implements $BlockStateKJS$$Interface {
 "getId"(): StringJS
 "toString"(): StringJS
 "getWebIconURL"(size: integer): $RelativeURL
 "randomTickOverride"(state: $BlockState$$Type, level: $ServerLevel$$Type, pos: $BlockPos$$Type, random: $RandomSource$$Type): boolean
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "getRegistry"(): $Registry<($Block)>
 "asHolder"(): $Holder<($Block)>
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "getKey"(): $ResourceKey<($Block)>
 "setDestroySpeed"(v: float): void
 "setRequiresTool"(v: boolean): void
 "setLightEmission"(v: integer): void
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getMod"(): StringJS
 "getIdLocation"(): $ResourceLocation
 "getTagKeys"(): $List<($TagKey<($Block)>)>
 "getTags"(): $List<($ResourceLocation)>
 "specialEquals"(o: any, shallow: boolean): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateKJS$$Type = ($BlockStateKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateKJS$$Original = $BlockStateKJS;}
declare module "dev.latvian.mods.kubejs.client.icon.KubeIcon" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$KubeIconType, $KubeIconType$$Type} from "dev.latvian.mods.kubejs.client.icon.KubeIconType"

export interface $KubeIcon$$Interface {

(): $KubeIconType$$Type<(never)>
get "type"(): $KubeIconType<(never)>
}

export class $KubeIcon implements $KubeIcon$$Interface {
static readonly "CODEC": $Codec<($KubeIcon)>
static readonly "OPTIONAL_STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($Optional<($KubeIcon)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($KubeIcon)>

 "getType"(): $KubeIconType<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeIcon$$Type = (() => $KubeIconType$$Type<(never)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeIcon$$Original = $KubeIcon;}
declare module "dev.latvian.mods.kubejs.util.NBTSerializable" {
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"

export interface $NBTSerializable$$Interface {

(): $Tag$$Type
}

export class $NBTSerializable implements $NBTSerializable$$Interface {
 "toNBT"(): $Tag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTSerializable$$Type = (() => $Tag$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NBTSerializable$$Original = $NBTSerializable;}
declare module "dev.latvian.mods.kubejs.block.custom.FenceGateBlockBuilder" {
import {$WoodType$$Type} from "net.minecraft.world.level.block.state.properties.WoodType"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $FenceGateBlockBuilder extends $ShapedBlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "FENCE_GATE_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "behaviour"(wt: $WoodType$$Type): this
public "behaviour"(wt: StringJS): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FenceGateBlockBuilder$$Type = ($FenceGateBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FenceGateBlockBuilder$$Original = $FenceGateBlockBuilder;}
declare module "dev.latvian.mods.kubejs.script.data.GeneratedData" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$IoSupplier, $IoSupplier$$Interface} from "net.minecraft.server.packs.resources.IoSupplier"
import {$InputStream} from "java.io.InputStream"
import {$Path$$Type} from "java.nio.file.Path"
import {$ZipFile$$Type} from "java.util.zip.ZipFile"
import {$Record} from "java.lang.Record"
import {$ZipEntry$$Type} from "java.util.zip.ZipEntry"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $GeneratedData extends $Record implements $IoSupplier$$Interface<($InputStream)> {
static readonly "PACK_META": $GeneratedData
static readonly "INTERNAL_RELOAD": $GeneratedData
static readonly "PACK_ICON": $GeneratedData

constructor(id: $ResourceLocation$$Type, data: $Supplier$$Type<((byte)[])>)

public "get"(): $InputStream
public "equals"(obj: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "data"(): $Supplier<((byte)[])>
public "id"(): $ResourceLocation
public static "json"(id: $ResourceLocation$$Type, json: $Supplier$$Type<($JsonElement$$Type)>): $GeneratedData
public static "create"(arg0: $Path$$Type): $IoSupplier<($InputStream)>
public static "create"(arg0: $ZipFile$$Type, arg1: $ZipEntry$$Type): $IoSupplier<($InputStream)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedData$$Type = ({"data"?: $Supplier$$Type<((byte)[])>, "id"?: $ResourceLocation$$Type}) | ([data?: $Supplier$$Type<((byte)[])>, id?: $ResourceLocation$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeneratedData$$Original = $GeneratedData;}
declare module "dev.latvian.mods.kubejs.util.LogType" {
import {$Enum} from "java.lang.Enum"
import {$BiConsumer} from "java.util.function.BiConsumer"
import {$Logger} from "org.slf4j.Logger"

export class $LogType extends $Enum<($LogType)> {
static readonly "INIT": $LogType
readonly "callback": $BiConsumer<($Logger), (StringJS)>
static readonly "ERROR": $LogType
static readonly "VALUES": ($LogType)[]
readonly "id": StringJS
static readonly "INFO": $LogType
static readonly "DEBUG": $LogType
static readonly "WARN": $LogType

public static "values"(): ($LogType)[]
public static "valueOf"(name: StringJS): $LogType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogType$$Type = (("init") | ("debug") | ("info") | ("warn") | ("error"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LogType$$Original = $LogType;}
declare module "dev.latvian.mods.kubejs.client.ClientPlayerKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $ClientPlayerKubeEvent implements $KubePlayerEvent$$Interface, $ClientKubeEvent$$Interface {
constructor(player: $LocalPlayer$$Type)

public "getPlayer"(): $Player
public "getEntity"(): $Entity
public "getClient"(): $Minecraft
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
get "player"(): $Player
get "entity"(): $Entity
get "client"(): $Minecraft
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPlayerKubeEvent$$Type = ($ClientPlayerKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientPlayerKubeEvent$$Original = $ClientPlayerKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext" {
import {$RecipePostProcessor} from "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessor"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeSchemaStorage, $RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Record} from "java.lang.Record"

export class $RecipeTypeRegistryContext extends $Record {
constructor(registries: $RegistryAccessContainer$$Type, storage: $RecipeSchemaStorage$$Type)

public "registries"(): $RegistryAccessContainer
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "storage"(): $RecipeSchemaStorage
public "recipeComponentCodec"(): $Codec<($RecipeComponent<(never)>)>
public "recipePostProcessorCodec"(): $Codec<($RecipePostProcessor)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeTypeRegistryContext$$Type = ({"storage"?: $RecipeSchemaStorage$$Type, "registries"?: $RegistryAccessContainer$$Type}) | ([storage?: $RecipeSchemaStorage$$Type, registries?: $RegistryAccessContainer$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeTypeRegistryContext$$Original = $RecipeTypeRegistryContext;}
declare module "dev.latvian.mods.kubejs.core.FireworkRocketEntityKJS" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $FireworkRocketEntityKJS$$Interface {

(lifetime: integer): void
set "lifetimeKJS"(value: integer)
}

export class $FireworkRocketEntityKJS implements $FireworkRocketEntityKJS$$Interface {
 "setLifetimeKJS"(lifetime: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FireworkRocketEntityKJS$$Type = ((lifetime: integer) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FireworkRocketEntityKJS$$Original = $FireworkRocketEntityKJS;}
declare module "dev.latvian.mods.kubejs.core.CreativeModeTabKJS" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Component$$Type} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $CreativeModeTabKJS$$Interface {
}

export class $CreativeModeTabKJS implements $CreativeModeTabKJS$$Interface {
 "kjs$setDisplayName"(component: $Component$$Type): void
 "kjs$setIcon"(icon: $ItemStack$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeModeTabKJS$$Type = ($CreativeModeTabKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeModeTabKJS$$Original = $CreativeModeTabKJS;}
declare module "dev.latvian.mods.kubejs.block.BlockLeftClickedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Direction} from "net.minecraft.core.Direction"
import {$PlayerInteractEvent$LeftClickBlock$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerInteractEvent$LeftClickBlock"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player left clicks on a block.
 */
export class $BlockLeftClickedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(event: $PlayerInteractEvent$LeftClickBlock$$Type)

/**
 * The item that was used to left click the block.
 */
public "getItem"(): $ItemStack
/**
 * The block that was left clicked.
 */
public "getBlock"(): $LevelBlock
/**
 * The player that left clicked the block.
 */
public "getEntity"(): $LivingEntity
/**
 * The face of the block that was left clicked.
 */
public "getFacing"(): $Direction
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "item"(): $ItemStack
get "block"(): $LevelBlock
get "entity"(): $LivingEntity
get "facing"(): $Direction
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockLeftClickedKubeEvent$$Type = ($BlockLeftClickedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockLeftClickedKubeEvent$$Original = $BlockLeftClickedKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator$Part" {
import {$VariantBlockStateGenerator$Model} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Model"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $MultipartBlockStateGenerator$Part {
constructor()

public "toJson"(): $JsonObject
public "model"(s: $ResourceLocation$$Type): $VariantBlockStateGenerator$Model
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultipartBlockStateGenerator$Part$$Type = ($MultipartBlockStateGenerator$Part);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultipartBlockStateGenerator$Part$$Original = $MultipartBlockStateGenerator$Part;}
declare module "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$FlowingFluid} from "net.minecraft.world.level.material.FlowingFluid"
import {$FluidBuilder, $FluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $FlowingFluidBuilder extends $BuilderBase<($FlowingFluid)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "fluidBuilder": $FluidBuilder
readonly "id": $ResourceLocation

constructor(b: $FluidBuilder$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlowingFluidBuilder$$Type = ($FlowingFluidBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FlowingFluidBuilder$$Original = $FlowingFluidBuilder;}
declare module "dev.latvian.mods.kubejs.block.callback.EntitySteppedOnBlockCallback" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $EntitySteppedOnBlockCallback {
constructor(level: $Level$$Type, entity: $Entity$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type)

/**
 * Returns the BlockState
 */
public "getState"(): $BlockState
/**
 * Returns the level
 */
public "getLevel"(): $Level
/**
 * Returns if the entity is suppressing bouncing (for players this is true if the player is crouching)
 */
public "isSuppressingBounce"(): boolean
/**
 * Returns the block's position
 */
public "getPos"(): $BlockPos
/**
 * Returns the block
 */
public "getBlock"(): $LevelBlock
/**
 * Returns the entity
 */
public "getEntity"(): $Entity
get "state"(): $BlockState
get "level"(): $Level
get "suppressingBounce"(): boolean
get "pos"(): $BlockPos
get "block"(): $LevelBlock
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySteppedOnBlockCallback$$Type = ($EntitySteppedOnBlockCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntitySteppedOnBlockCallback$$Original = $EntitySteppedOnBlockCallback;}
declare module "dev.latvian.mods.kubejs.event.EventHandler" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$EventGroup} from "dev.latvian.mods.kubejs.event.EventGroup"
import {$BaseFunction} from "dev.latvian.mods.rhino.BaseFunction"
import {$IEventHandler$$Type} from "dev.latvian.mods.kubejs.event.IEventHandler"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$TargetedEventHandler} from "dev.latvian.mods.kubejs.event.TargetedEventHandler"
import {$Supplier} from "java.util.function.Supplier"
import {$ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$ScriptTypeHolder$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$ScriptTypePredicate} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"
import {$Class} from "java.lang.Class"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$EventTargetType$$Type} from "dev.latvian.mods.kubejs.event.EventTargetType"
import {$EventHandlerContainer$$Type} from "dev.latvian.mods.kubejs.event.EventHandlerContainer"
import {$EventResult} from "dev.latvian.mods.kubejs.event.EventResult"

export class $EventHandler extends $BaseFunction {
static readonly "DONTENUM": integer
readonly "eventType": $Supplier<($Class<($KubeEvent)>)>
readonly "scriptTypePredicate": $ScriptTypePredicate
static readonly "CONST": integer
readonly "name": StringJS
static readonly "UNINITIALIZED_CONST": integer
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "PERMANENT": integer
readonly "group": $EventGroup

public "hasListeners"(): boolean
public "toString"(): StringJS
public "listen"(type: $ScriptType$$Type, extraId: any, handler: $IEventHandler$$Type): void
public "call"(scope: $Scriptable$$Type, thisObj: $Scriptable$$Type, args: (any)[]): any
public "post"(scriptType: $ScriptTypeHolder$$Type, event: $KubeEvent$$Type): $EventResult
public "post"(event: $KubeEvent$$Type): $EventResult
public "hasResult"(): $EventHandler
public "supportsTarget"<E>(type: $EventTargetType$$Type<(E)>): $TargetedEventHandler<(E)>
public "forEachListener"(type: $ScriptType$$Type, callback: $Consumer$$Type<($EventHandlerContainer)>): void
public "requiredTarget"<E>(type: $EventTargetType$$Type<(E)>): $TargetedEventHandler<(E)>
public "getIds"(): (any)[]
public "getAllIds"(): (any)[]
public "get"(arg1: integer, arg2: $Scriptable$$Type): any
public "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
public "delete"(arg1: integer): void
public "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
public "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
public "setPrototype"(arg0: $Scriptable$$Type): void
public "getPrototype"(): $Scriptable
public "getParentScope"(): $Scriptable
public "setParentScope"(arg0: $Scriptable$$Type): void
get "ids"(): (any)[]
get "allIds"(): (any)[]
set "prototype"(value: $Scriptable$$Type)
get "prototype"(): $Scriptable
get "parentScope"(): $Scriptable
set "parentScope"(value: $Scriptable$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventHandler$$Type = ($EventHandler);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventHandler$$Original = $EventHandler;}
declare module "dev.latvian.mods.kubejs.block.callback.BlockExplodedCallback" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Explosion, $Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockExplodedCallback {
constructor(level: $Level$$Type, pos: $BlockPos$$Type, explosion: $Explosion$$Type)

public "getExplosion"(): $Explosion
public "getCause"(): $Entity
public "getLevel"(): $Level
public "getBlock"(): $LevelBlock
public "getBlockState"(): $BlockState
public "getRadius"(): float
public "getIgniter"(): $LivingEntity
public "getAffectedPlayers"(): $List<($Player)>
get "explosion"(): $Explosion
get "cause"(): $Entity
get "level"(): $Level
get "block"(): $LevelBlock
get "blockState"(): $BlockState
get "radius"(): float
get "igniter"(): $LivingEntity
get "affectedPlayers"(): $List<($Player)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockExplodedCallback$$Type = ($BlockExplodedCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockExplodedCallback$$Original = $BlockExplodedCallback;}
declare module "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionHolder" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List} from "java.util.List"
import {$SlotFilter, $SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"
import {$IngredientAction, $IngredientAction$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction"
import {$Record} from "java.lang.Record"

export class $IngredientActionHolder extends $Record {
static readonly "LIST_STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($List<($IngredientActionHolder)>)>
static readonly "CODEC": $Codec<($IngredientActionHolder)>
static readonly "LIST_CODEC": $Codec<($List<($IngredientActionHolder)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IngredientActionHolder)>

constructor(action: $IngredientAction$$Type, filter: $SlotFilter$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $SlotFilter
public "action"(): $IngredientAction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientActionHolder$$Type = ({"filter"?: $SlotFilter$$Type, "action"?: $IngredientAction$$Type}) | ([filter?: $SlotFilter$$Type, action?: $IngredientAction$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientActionHolder$$Original = $IngredientActionHolder;}
declare module "dev.latvian.mods.kubejs.block.DetectorBlockKubeEvent" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a detector block registered in KubeJS receives a block update.
 * 
 * `Powered`/`Unpowered` event will be fired when the detector block is powered/unpowered.
 */
export class $DetectorBlockKubeEvent implements $KubeLevelEvent$$Interface {
constructor(i: StringJS, l: $Level$$Type, p: $BlockPos$$Type, pow: boolean)

/**
 * The level where the detector block is located.
 */
public "getLevel"(): $Level
/**
 * If the detector block is powered.
 */
public "isPowered"(): boolean
/**
 * The detector block.
 */
public "getBlock"(): $LevelBlock
/**
 * The id of the detector block when it was registered.
 */
public "getDetectorId"(): StringJS
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "powered"(): boolean
get "block"(): $LevelBlock
get "detectorId"(): StringJS
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DetectorBlockKubeEvent$$Type = ($DetectorBlockKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DetectorBlockKubeEvent$$Original = $DetectorBlockKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.DebugInfoKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$List, $List$$Type} from "java.util.List"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$ClientPlayerKubeEvent} from "dev.latvian.mods.kubejs.client.ClientPlayerKubeEvent"

/**
 * Invoked when the debug info is rendered.
 */
export class $DebugInfoKubeEvent extends $ClientPlayerKubeEvent {
constructor(player: $LocalPlayer$$Type, l: $List$$Type<(StringJS)>)

/**
 * The lines of debug info. Mutating this list will change the debug info.
 */
public "getLines"(): $List<(StringJS)>
/**
 * Whether the debug info should be rendered.
 */
public "getShowDebug"(): boolean
public "getPlayer"(): $Player
public "getEntity"(): $Entity
get "lines"(): $List<(StringJS)>
get "showDebug"(): boolean
get "player"(): $Player
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DebugInfoKubeEvent$$Type = ($DebugInfoKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DebugInfoKubeEvent$$Original = $DebugInfoKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.BlockStoppedFallingKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$FallingBlockEntity$$Type} from "net.minecraft.world.entity.item.FallingBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a falling block finishes falling.
 */
export class $BlockStoppedFallingKubeEvent implements $KubeEntityEvent$$Interface {
readonly "fallSpeed": double
readonly "replacedBlock": $LevelBlock
readonly "block": $LevelBlock

constructor(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, entity: $FallingBlockEntity$$Type, fallSpeed: double, replacedState: $BlockState$$Type)

public "getLevel"(): $Level
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "entity"(): $Entity
get "player"(): $Player
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStoppedFallingKubeEvent$$Type = ($BlockStoppedFallingKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStoppedFallingKubeEvent$$Original = $BlockStoppedFallingKubeEvent;}
declare module "dev.latvian.mods.kubejs.event.EventTargetType$Transformer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $EventTargetType$Transformer$$Interface {

(source: any): any
}

export class $EventTargetType$Transformer implements $EventTargetType$Transformer$$Interface {
static readonly "IDENTITY": $EventTargetType$Transformer

 "transform"(source: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventTargetType$Transformer$$Type = ((source: any) => any);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventTargetType$Transformer$$Original = $EventTargetType$Transformer;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RemoveEntriesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $RemoveEntriesKubeEvent$$Interface<E, F> extends $KubeEvent$$Interface {

(filter: F): void
}

export class $RemoveEntriesKubeEvent<E, F> implements $RemoveEntriesKubeEvent$$Interface {
 "remove"(filter: F): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveEntriesKubeEvent$$Type<E, F> = ((filter: any) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RemoveEntriesKubeEvent$$Original<E, F> = $RemoveEntriesKubeEvent<(E), (F)>;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext" {
import {$ErrorStack, $ErrorStack$$Type} from "dev.latvian.mods.kubejs.util.ErrorStack"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$RecipeMatchContext$$Interface} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$KubeRecipeContext$$Interface} from "dev.latvian.mods.kubejs.recipe.KubeRecipeContext"
import {$RecipeLikeKJS} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RecipeValidationContext$$Interface extends $KubeRecipeContext$$Interface, $RecipeMatchContext$$Interface {

(): $ErrorStack$$Type
}

export class $RecipeValidationContext implements $RecipeValidationContext$$Interface {
 "errors"(): $ErrorStack
 "registries"(): $RegistryAccessContainer
 "ops"(): $RegistryOpsContainer
 "recipe"(): $RecipeLikeKJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeValidationContext$$Type = (() => $ErrorStack$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeValidationContext$$Original = $RecipeValidationContext;}
declare module "dev.latvian.mods.kubejs.event.EventResult$Type" {
import {$Enum} from "java.lang.Enum"
import {$EventExit} from "dev.latvian.mods.kubejs.event.EventExit"

export class $EventResult$Type extends $Enum<($EventResult$Type)> {
static readonly "INTERRUPT_TRUE": $EventResult$Type
static readonly "PASS": $EventResult$Type
static readonly "INTERRUPT_FALSE": $EventResult$Type
static readonly "INTERRUPT_DEFAULT": $EventResult$Type
static readonly "ERROR": $EventResult$Type

public "exit"(value: any): $EventExit
public static "values"(): ($EventResult$Type)[]
public static "valueOf"(name: StringJS): $EventResult$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventResult$Type$$Type = (("error") | ("pass") | ("interrupt_default") | ("interrupt_false") | ("interrupt_true"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventResult$Type$$Original = $EventResult$Type;}
declare module "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch" {
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"

export interface $ReplacementMatch$$Interface {
}

export class $ReplacementMatch implements $ReplacementMatch$$Interface {
static readonly "NONE": $ReplacementMatch

static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplacementMatch$$Type = ($Ingredient$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReplacementMatch$$Original = $ReplacementMatch;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RemoveRecipesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"

export interface $RemoveRecipesKubeEvent$$Interface extends $KubeEvent$$Interface {

(category: $ResourceLocation, recipesToRemove: ($ResourceLocation)[]): void
}

export class $RemoveRecipesKubeEvent implements $RemoveRecipesKubeEvent$$Interface {
 "remove"(recipesToRemove: (Special.RecipeId)[]): void
 "removeFromCategory"(category: $ResourceLocation$$Type, recipesToRemove: ($ResourceLocation$$Type)[]): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveRecipesKubeEvent$$Type = ((category: $ResourceLocation, recipesToRemove: ($ResourceLocation)[]) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RemoveRecipesKubeEvent$$Original = $RemoveRecipesKubeEvent;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.TextIcons" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Style} from "net.minecraft.network.chat.Style"
import {$MutableComponent, $MutableComponent$$Type} from "net.minecraft.network.chat.MutableComponent"
import {$Component} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $TextIcons$$Interface {
}

export class $TextIcons implements $TextIcons$$Interface {
static readonly "STYLE": $Style
static readonly "FONT": $ResourceLocation
static readonly "NAME": $Component
static readonly "ALL_ICONS": StringJS

static "crafting"(): $MutableComponent
static "fire"(): $MutableComponent
static "info"(): $MutableComponent
static "id"(): $MutableComponent
static "copy"(): $MutableComponent
static "error"(): $MutableComponent
static "warn"(): $MutableComponent
static "minus"(): $MutableComponent
static "tag"(): $MutableComponent
static "plus"(): $MutableComponent
static "no"(): $MutableComponent
static "itemTag"(): $MutableComponent
static "yes"(yes: boolean): $MutableComponent
static "yes"(): $MutableComponent
static "camera"(): $MutableComponent
static "vscode"(): $MutableComponent
static "icons"(characters: StringJS): $MutableComponent
static "smallSpace"(): $MutableComponent
static "fluidTag"(): $MutableComponent
static "tilde"(): $MutableComponent
static "logo"(): $MutableComponent
static "prototypeComponent"(): $MutableComponent
static "patchedComponent"(): $MutableComponent
static "entityTypeTag"(): $MutableComponent
static "blockTagIcon"(): $MutableComponent
static "icon"(character: $MutableComponent$$Type): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextIcons$$Type = ($TextIcons);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TextIcons$$Original = $TextIcons;}
declare module "dev.latvian.mods.kubejs.block.custom.ButtonOrPressurePlateBuilder" {
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"

export interface $ButtonOrPressurePlateBuilder$$Interface {
}

export class $ButtonOrPressurePlateBuilder implements $ButtonOrPressurePlateBuilder$$Interface {
 "behaviour"(behaviour: $BlockSetType$$Type): this
 "ticksToStayPressed"(ticks: $TickDuration$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ButtonOrPressurePlateBuilder$$Type = ($ButtonOrPressurePlateBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ButtonOrPressurePlateBuilder$$Original = $ButtonOrPressurePlateBuilder;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ItemTintFunction$$Type} from "dev.latvian.mods.kubejs.item.ItemTintFunction"
import {$JukeboxSong$$Type} from "net.minecraft.world.item.JukeboxSong"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$ItemBuilder$ReleaseUsingCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$ReleaseUsingCallback"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Function$$Type} from "java.util.function.Function"
import {$Item$Properties} from "net.minecraft.world.item.Item$Properties"
import {$ItemBuilder$HurtEnemyContext$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$HurtEnemyContext"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$FoodBuilder$$Type} from "dev.latvian.mods.kubejs.item.FoodBuilder"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$ItemBuilder$FinishUsingCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$FinishUsingCallback"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$ItemBuilder$NameCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$NameCallback"
import {$Collection$$Type} from "java.util.Collection"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$ToIntBiFunction$$Type} from "java.util.function.ToIntBiFunction"
import {$ModelledBuilderBase} from "dev.latvian.mods.kubejs.registry.ModelledBuilderBase"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$UseAnim$$Type} from "net.minecraft.world.item.UseAnim"
import {$ItemBuilder$UseCallback$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder$UseCallback"
import {$Registry} from "net.minecraft.core.Registry"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"

export class $ItemBuilder extends $ModelledBuilderBase<($Item)> {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

/**
 * Sets the item's max damage. Default is 0 (No durability).
 */
public "maxDamage"(v: integer): this
public "createItemProperties"(): $Item$Properties
/**
 * Sets the item's name dynamically.
 */
public "name"(name: $ItemBuilder$NameCallback$$Type): this
/**
 * 
 * @deprecated
 */
public "group"(g: StringJS): this
public "component"<T>(type: $DataComponentType$$Type<(T)>, value: T): this
/**
 * Determines if player will start using the item.
 * 
 * For example, when eating food, returning true will make the player start eating the food.
 */
public "use"(use: $ItemBuilder$UseCallback$$Type): this
/**
 * Colorizes item's texture of the given index. Index is used when you have multiple layers, e.g. a crushed ore (of rock + ore).
 */
public "color"(index: integer, color: $ItemTintFunction$$Type): this
/**
 * Colorizes item's texture of the given index. Useful for coloring items, like GT ores ore dusts.
 */
public "color"(callback: $ItemTintFunction$$Type): this
/**
 * Sets the item's max stack size. Default is 64.
 */
public "maxStackSize"(v: integer): this
/**
 * Adds subtypes to the item. The function should return a collection of item stacks, each with a different subtype.
 * 
 * Each subtype will appear as a separate item in JEI and the creative inventory.
 */
public "subtypes"(fn: $Function$$Type<($ItemStack), ($Collection$$Type<($ItemStack$$Type)>)>): this
/**
 * Sets the item's rarity.
 */
public "rarity"(v: $Rarity$$Type): this
/**
 * When players finish using the item.
 * 
 * This is called only when `useDuration` ticks have passed.
 * 
 * For example, when eating food, this is called when the player has finished eating the food, so hunger is restored.
 */
public "finishUsing"(finishUsing: $ItemBuilder$FinishUsingCallback$$Type): this
/**
 * Sets the item's burn time. Default is 0 (Not a fuel).
 */
public "burnTime"(v: $TickDuration$$Type): this
/**
 * Sets the item's container item, e.g. a bucket for a milk bucket.
 */
public "containerItem"(id: $ResourceLocation$$Type): this
public "transformObject"(obj: $Item$$Type): $Item
/**
 * Makes the item not stackable, equivalent to setting the item's max stack size to 1.
 */
public "unstackable"(): this
/**
 * Determines the animation of the item when used, e.g. eating food.
 */
public "useAnimation"(animation: $UseAnim$$Type): this
public "disableRepair"(): this
/**
 * Determines the width of the item's durability bar. Defaulted to vanilla behavior.
 * 
 * The function should return a value between 0 and 13 (max width of the bar).
 */
public "barWidth"(barWidth: $ToIntFunction$$Type<($ItemStack)>): this
/**
 * Determines the color of the item's durability bar. Defaulted to vanilla behavior.
 */
public "barColor"(barColor: $Function$$Type<($ItemStack), ($KubeColor$$Type)>): this
/**
 * Makes the item glow like enchanted, even if it's not enchanted.
 */
public "glow"(v: boolean): this
/**
 * The duration when the item is used.
 * 
 * For example, when eating food, this is the time it takes to eat the food.
 * This can change the eating speed, or be used for other things (like making a custom bow).
 */
public "useDuration"(useDuration: $ToIntBiFunction$$Type<($ItemStack), ($LivingEntity)>): this
/**
 * When players did not finish using the item but released the right mouse button halfway through.
 * 
 * An example is the bow, where the arrow is shot when the player releases the right mouse button.
 * 
 * To ensure the bow won't finish using, Minecraft sets the `useDuration` to a very high number (1h).
 */
public "releaseUsing"(releaseUsing: $ItemBuilder$ReleaseUsingCallback$$Type): this
/**
 * Set the food nutrition and saturation of the item.
 */
public "food"(nutrition: integer, saturation: float): this
/**
 * Set the food properties of the item.
 */
public "food"(b: $Consumer$$Type<($FoodBuilder)>): this
public "jukeboxPlayable"(song: $ResourceKey$$Type<($JukeboxSong)>): this
public "jukeboxPlayable"(song: $ResourceKey$$Type<($JukeboxSong)>, showInTooltip: boolean): this
/**
 * Adds a tooltip to the item.
 */
public "tooltip"(text: $Component$$Type): this
/**
 * Makes the item fire resistant like netherite tools (or not).
 */
public "fireResistant"(isFireResistant: boolean): this
/**
 * Makes the item fire resistant like netherite tools.
 */
public "fireResistant"(): this
/**
 * Gets called when the item is used to hurt an entity.
 * 
 * For example, when using a sword to hit a mob, this is called.
 */
public "hurtEnemy"(context: $Predicate$$Type<($ItemBuilder$HurtEnemyContext)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$$Type = ($ItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$$Original = $ItemBuilder;}
declare module "dev.latvian.mods.kubejs.util.MobEffectUtil" {
import {$MobEffectInstance, $MobEffectInstance$$Type} from "net.minecraft.world.effect.MobEffectInstance"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export class $MobEffectUtil {
constructor()

/**
 * Creates an instance for the given effect, duration and amplifier
 */
public static "of"(effect: $Holder$$Type<($MobEffect)>, duration: $TickDuration$$Type, amplifier: integer): $MobEffectInstance
/**
 * Creates an instance for the given effect, duration, amplifier, ambient, and visible to the HUD
 */
public static "of"(effect: $Holder$$Type<($MobEffect)>, duration: $TickDuration$$Type, amplifier: integer, ambient: boolean, visible: boolean): $MobEffectInstance
/**
 * Creates an instance for the given effect, duration, amplifier, ambient, visible to the HUD, and to show the icon on the sceen
 */
public static "of"(effect: $Holder$$Type<($MobEffect)>, duration: $TickDuration$$Type, amplifier: integer, ambient: boolean, visible: boolean, showIcon: boolean): $MobEffectInstance
/**
 * Creates an instance for the given effect and duration (in ticks)
 */
public static "of"(effect: $Holder$$Type<($MobEffect)>, duration: $TickDuration$$Type): $MobEffectInstance
/**
 * Creates an instance for the given effect. Default duration and amplifier is 0
 */
public static "of"(effect: $Holder$$Type<($MobEffect)>): $MobEffectInstance
/**
 * Copies an existing MobEffectInstance
 */
public static "of"(oldInstance: $MobEffectInstance$$Type): $MobEffectInstance
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectUtil$$Type = ($MobEffectUtil);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobEffectUtil$$Original = $MobEffectUtil;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$SequencedCollection$$Type} from "java.util.SequencedCollection"
import {$RegistryOps$$Type} from "net.minecraft.resources.RegistryOps"
import {$RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$KubeRecipeFactory, $KubeRecipeFactory$$Type} from "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory"
import {$RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RecipePostProcessor, $RecipePostProcessor$$Type} from "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessor"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeConstructor, $RecipeConstructor$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeConstructor"
import {$RecipeFunctionInstance, $RecipeFunctionInstance$$Type} from "dev.latvian.mods.kubejs.recipe.schema.function.RecipeFunctionInstance"
import {$RecipeOptional, $RecipeOptional$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Int2ObjectMap} from "it.unimi.dsi.fastutil.ints.Int2ObjectMap"

export class $RecipeSchema {
readonly "functions": $Map<(StringJS), ($RecipeFunctionInstance)>
 "recipeFactory": $KubeRecipeFactory
readonly "keys": $List<($RecipeKey<(never)>)>
readonly "keyOverrides": $Map<($RecipeKey<(never)>), ($RecipeOptional<(never)>)>
readonly "includedKeys": $List<($RecipeKey<(never)>)>

constructor(keyOverrides: $Map$$Type<($RecipeKey$$Type<(never)>), ($RecipeOptional$$Type<(never)>)>, keys: $List$$Type<($RecipeKey$$Type<(never)>)>)
constructor(...keys: ($RecipeKey$$Type<(never)>)[])

public "isHidden"(): boolean
public "getKey"<T>(id: StringJS): $RecipeKey<(T)>
public "factory"(factory: $KubeRecipeFactory$$Type): $RecipeSchema
public "addConstructor"(...keys: ($RecipeKey$$Type<(never)>)[]): $RecipeSchema
public "constructor"(arg0: $RecipeConstructor$$Type): $RecipeSchema
public "constructors"(): $Int2ObjectMap<($RecipeConstructor)>
public "function"(arg0: $RecipeFunctionInstance$$Type): $RecipeSchema
public "toJson"(storage: $RecipeSchemaStorage$$Type, schemaType: $RecipeSchemaType$$Type, ops: $RegistryOps$$Type<($JsonElement$$Type)>): $JsonObject
public "uniqueId"(key: $RecipeKey$$Type<(never)>): $RecipeSchema
public "postProcessors"(): $List<($RecipePostProcessor)>
public "postProcessor"(processor: $RecipePostProcessor$$Type): $RecipeSchema
public "minRequiredArguments"(): integer
public "addToListOpFunction"<T>(name: StringJS, key: $RecipeKey$$Type<($List$$Type<(T)>)>): $RecipeSchema
public "constructorsGenerated"(): boolean
public "deserialize"(sourceLine: $SourceLine$$Type, type: $RecipeTypeFunction$$Type, id: $ResourceLocation$$Type, json: $JsonObject$$Type): $KubeRecipe
public "outputCount"(): integer
public "buildUniqueId"(r: $KubeRecipe$$Type): StringJS
public "typeOverride"(id: $ResourceLocation$$Type): $RecipeSchema
public "getOptionalKey"<T>(id: StringJS): $RecipeKey<(T)>
public "setOpFunction"<T>(name: StringJS, key: $RecipeKey$$Type<(T)>, value: T): $RecipeSchema
public "inputCount"(): integer
public "uniqueIds"(keys: $SequencedCollection$$Type<($RecipeKey$$Type<(never)>)>): $RecipeSchema
public "uniqueIds"(): $List<($RecipeKey<(never)>)>
get "hidden"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchema$$Type = ($RecipeSchema);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeSchema$$Original = $RecipeSchema;}
declare module "dev.latvian.mods.kubejs.recipe.component.ComponentRole" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"

export class $ComponentRole extends $Enum<($ComponentRole)> implements $StringRepresentable$$Interface {
static readonly "OTHER": $ComponentRole
static readonly "INPUT": $ComponentRole
static readonly "CODEC": $Codec<($ComponentRole)>
static readonly "OUTPUT": $ComponentRole

public "isInput"(): boolean
public static "values"(): ($ComponentRole)[]
public static "valueOf"(name: StringJS): $ComponentRole
public "isOther"(): boolean
public "isOutput"(): boolean
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "input"(): boolean
get "other"(): boolean
get "output"(): boolean
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentRole$$Type = (("input") | ("output") | ("other"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComponentRole$$Original = $ComponentRole;}
declare module "dev.latvian.mods.kubejs.player.PlayerRespawnedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player respawns.
 * 
 * The reason of respawn can be either death or returning from the end.
 */
export class $PlayerRespawnedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $ServerPlayer$$Type, endConquered: boolean)

/**
 * Gets the player that respawned.
 */
public "getEntity"(): $Player
public "isEndConquered"(): boolean
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "entity"(): $Player
get "endConquered"(): boolean
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerRespawnedKubeEvent$$Type = ($PlayerRespawnedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerRespawnedKubeEvent$$Original = $PlayerRespawnedKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeSchemaType} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$LinkedHashMap} from "java.util.LinkedHashMap"
import {$RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$RecipeSchemaStorage, $RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RegistryAwareSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RegistryAwareSchema"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"

export class $RecipeNamespace extends $LinkedHashMap<(StringJS), ($RecipeSchemaType)> {
readonly "name": StringJS
readonly "storage": $RecipeSchemaStorage

constructor(storage: $RecipeSchemaStorage$$Type, name: StringJS)

public "special"(id: StringJS): $RecipeNamespace
public "toString"(): StringJS
public "register"(id: StringJS, type: $RegistryAwareSchema$$Type): $RecipeNamespace
public "register"(id: StringJS, type: $RecipeSchema$$Type): $RecipeNamespace
public "withExistingParent"(id: StringJS, parent: $ResourceLocation$$Type): $RecipeNamespace
public "getRegisteredOrThrow"(id: StringJS): $RecipeSchemaType
public "shapeless"(id: StringJS): $RecipeNamespace
public "shaped"(id: StringJS): $RecipeNamespace
public "registerBasic"(id: StringJS, ...keys: ($RecipeKey$$Type<(never)>)[]): $RecipeNamespace
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeNamespace$$Type = ($RecipeNamespace);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeNamespace$$Original = $RecipeNamespace;}
declare module "dev.latvian.mods.kubejs.item.custom.ShearsItemBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Registry} from "net.minecraft.core.Registry"
import {$ItemBuilder} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ShearsItemBuilder extends $ItemBuilder {
 "sourceLine": $SourceLine
static readonly "SHEAR_TAGS": ($ResourceLocation)[]
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public static "isCustomShears"(stack: $ItemStack$$Type): boolean
public "speedBaseline"(f: float): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShearsItemBuilder$$Type = ($ShearsItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShearsItemBuilder$$Original = $ShearsItemBuilder;}
declare module "dev.latvian.mods.kubejs.block.custom.PressurePlateBlockBuilder" {
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$Consumer} from "java.util.function.Consumer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ButtonOrPressurePlateBuilder$$Interface} from "dev.latvian.mods.kubejs.block.custom.ButtonOrPressurePlateBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"

export class $PressurePlateBlockBuilder extends $ShapedBlockBuilder implements $ButtonOrPressurePlateBuilder$$Interface {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
static readonly "PRESSURE_PLATE_TAGS": ($ResourceLocation)[]
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "behaviour"(behaviour: $BlockSetType$$Type): this
public "ticksToStayPressed"(ticks: $TickDuration$$Type): $BlockBuilder
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressurePlateBlockBuilder$$Type = ($PressurePlateBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PressurePlateBlockBuilder$$Original = $PressurePlateBlockBuilder;}
declare module "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer$ShaderChain" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$PostChain, $PostChain$$Type} from "net.minecraft.client.renderer.PostChain"
import {$Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$MutableBoolean, $MutableBoolean$$Type} from "org.apache.commons.lang3.mutable.MutableBoolean"
import {$RenderTarget, $RenderTarget$$Type} from "com.mojang.blaze3d.pipeline.RenderTarget"
import {$Record} from "java.lang.Record"

export class $HighlightRenderer$ShaderChain extends $Record {
constructor(postChain: $PostChain$$Type, renderInput: $RenderTarget$$Type, mcDepthInput: $RenderTarget$$Type, renderOutput: $RenderTarget$$Type, renderAnything: $MutableBoolean$$Type)

public "renderAnything"(): $MutableBoolean
public "clearDepth"(mc: $Minecraft$$Type, copy: boolean): void
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "load"(mc: $Minecraft$$Type, id: $ResourceLocation$$Type): $HighlightRenderer$ShaderChain
public "close"(): void
public "draw"(mc: $Minecraft$$Type, delta: float): void
public "mcDepthInput"(): $RenderTarget
public "renderInput"(): $RenderTarget
public "postChain"(): $PostChain
public "clearInput"(mc: $Minecraft$$Type): void
public "renderOutput"(): $RenderTarget
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HighlightRenderer$ShaderChain$$Type = ({"mcDepthInput"?: $RenderTarget$$Type, "renderOutput"?: $RenderTarget$$Type, "postChain"?: $PostChain$$Type, "renderAnything"?: $MutableBoolean$$Type, "renderInput"?: $RenderTarget$$Type}) | ([mcDepthInput?: $RenderTarget$$Type, renderOutput?: $RenderTarget$$Type, postChain?: $PostChain$$Type, renderAnything?: $MutableBoolean$$Type, renderInput?: $RenderTarget$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HighlightRenderer$ShaderChain$$Original = $HighlightRenderer$ShaderChain;}
declare module "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessor" {
import {$KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipePostProcessorType} from "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessorType"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"

export interface $RecipePostProcessor$$Interface {
}

export class $RecipePostProcessor implements $RecipePostProcessor$$Interface {
 "type"(): $RecipePostProcessorType<(never)>
 "process"(ctx: $RecipeValidationContext$$Type, recipe: $KubeRecipe$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipePostProcessor$$Type = ($RecipePostProcessor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipePostProcessor$$Original = $RecipePostProcessor;}
declare module "dev.latvian.mods.kubejs.text.action.TextActionBuilder" {
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"

export class $TextActionBuilder {
constructor()

public "insert"(line: integer, text: $List$$Type<($Component$$Type)>): void
public "clear"(): void
public "add"(text: $List$$Type<($Component$$Type)>): void
public "dynamic"(id: StringJS): void
public "removeLine"(line: integer): void
public "removeText"(match: $Component$$Type): void
public "removeExactText"(match: $Component$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextActionBuilder$$Type = ($TextActionBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TextActionBuilder$$Original = $TextActionBuilder;}
declare module "dev.latvian.mods.kubejs.server.tag.PreTagWrapper" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$List} from "java.util.List"
import {$PreTagKubeEvent, $PreTagKubeEvent$$Type} from "dev.latvian.mods.kubejs.server.tag.PreTagKubeEvent"
import {$TagLoader$EntryWithSource} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$TagWrapper} from "dev.latvian.mods.kubejs.server.tag.TagWrapper"
import {$TagKubeEvent} from "dev.latvian.mods.kubejs.server.tag.TagKubeEvent"

export class $PreTagWrapper extends $TagWrapper {
readonly "preEvent": $PreTagKubeEvent
readonly "entries": $List<($TagLoader$EntryWithSource)>
readonly "id": $ResourceLocation
readonly "event": $TagKubeEvent

constructor(e: $PreTagKubeEvent$$Type, i: $ResourceLocation$$Type)

public "remove"(...filters: (any)[]): $TagWrapper
public "add"(...filters: (any)[]): $TagWrapper
public "removeAll"(): $TagWrapper
public "getObjectIds"(): $List<($ResourceLocation)>
get "objectIds"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PreTagWrapper$$Type = ($PreTagWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PreTagWrapper$$Original = $PreTagWrapper;}
declare module "dev.latvian.mods.kubejs.misc.SoundEventBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$SoundsGenerator$SoundGen$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundGen"

export class $SoundEventBuilder extends $BuilderBase<($SoundEvent)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "sounds"(gen: $Consumer$$Type<($SoundsGenerator$SoundGen)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundEventBuilder$$Type = ($SoundEventBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoundEventBuilder$$Original = $SoundEventBuilder;}
declare module "dev.latvian.mods.kubejs.block.custom.ButtonBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ButtonOrPressurePlateBuilder$$Interface} from "dev.latvian.mods.kubejs.block.custom.ButtonOrPressurePlateBuilder"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $ButtonBlockBuilder extends $ShapedBlockBuilder implements $ButtonOrPressurePlateBuilder$$Interface {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "BUTTON_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "behaviour"(behaviour: $BlockSetType$$Type): this
public "ticksToStayPressed"(ticks: $TickDuration$$Type): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ButtonBlockBuilder$$Type = ($ButtonBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ButtonBlockBuilder$$Original = $ButtonBlockBuilder;}
declare module "dev.latvian.mods.kubejs.item.ItemModificationKubeEvent$ItemModifications" {
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ComponentFunctions} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID$$Type} from "java.util.UUID"
import {$ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$EquipmentSlotGroup$$Type} from "net.minecraft.world.entity.EquipmentSlotGroup"
import {$List$$Type} from "java.util.List"
import {$ItemAttributeModifiers} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$FireworkExplosion$$Type} from "net.minecraft.world.item.component.FireworkExplosion"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$MutableToolTier$$Type} from "dev.latvian.mods.kubejs.item.MutableToolTier"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$AttributeModifier, $AttributeModifier$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Instrument$$Type} from "net.minecraft.world.item.Instrument"
import {$Map$$Type} from "java.util.Map"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Tool$$Type} from "net.minecraft.world.item.component.Tool"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$ItemComponentFunctions$$Interface} from "dev.latvian.mods.kubejs.component.ItemComponentFunctions"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Record} from "java.lang.Record"
import {$Unit$$Type} from "net.minecraft.util.Unit"

export class $ItemModificationKubeEvent$ItemModifications extends $Record implements $ItemComponentFunctions$$Interface {
constructor(item: $Item$$Type)

public "setBurnTime"(i: $TickDuration$$Type): void
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "item"(): $Item
public "setNameKey"(key: StringJS): void
public "disableRepair"(): void
public "getComponentMap"(): $DataComponentMap
public "setTier"(builder: $Consumer$$Type<($MutableToolTier)>): void
public "setCraftingRemainder"(item: $Item$$Type): void
public "setUnbreakableWithTooltip"(): void
public "setMaxStackSize"(size: integer): void
public "setMapItemColor"(color: $KubeColor$$Type): void
public "setBundleContents"(items: $List$$Type<($ItemStack$$Type)>): void
public "setBucketEntityData"(tag: $CompoundTag$$Type): void
public "setFireworkExplosion"(explosion: $FireworkExplosion$$Type): void
public "setBlockEntityData"(tag: $CompoundTag$$Type): void
public "setFireResistant"(): void
public "setNoteBlockSound"(id: $ResourceLocation$$Type): void
public "getAttributeModifiers"(): $ItemAttributeModifiers
public "setChargedProjectiles"(items: $List$$Type<($ItemStack$$Type)>): void
public "setInstrument"(instrument: $Holder$$Type<($Instrument)>): void
public "setUnbreakable"(): void
public "setItemName"(component: $Component$$Type): void
public "setRepairCost"(repairCost: integer): void
public "setTool"(tool: $Tool$$Type): void
public "setFood"(foodProperties: $FoodProperties$$Type): void
public "setFood"(nutrition: integer, saturation: float): void
public "setFireworks"(fireworks: $Fireworks$$Type): void
public "setDamage"(damage: integer): void
public "setMaxDamage"(maxDamage: integer): void
public "setAdditionalTooltipHidden"(): void
public "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
public "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
public "resetComponents"(): $ComponentFunctions
public "getComponentString"(): StringJS
public "setCustomModelData"(data: integer): void
public "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
public "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
public "setTooltipHidden"(): void
public "setPotionContents"(contents: $PotionContents$$Type): void
public "setGlintOverride"(override: boolean): void
public "get"<T>(type: $DataComponentType$$Type<(T)>): T
public "remove"(type: $DataComponentType$$Type<(never)>): $ComponentFunctions
public "patch"(components: $DataComponentPatch$$Type): $ComponentFunctions
public "set"(component: $DataComponentType$$Type<(never)>, value: any): $ComponentFunctions
public "set"(components: $DataComponentMap$$Type): $ComponentFunctions
public "setDyedColor"(color: $KubeColor$$Type): void
public "setCustomData"(tag: $CompoundTag$$Type): void
public "setProfile"(profile: $GameProfile$$Type): void
public "setProfile"(name: StringJS, uuid: $UUID$$Type): void
public "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
public "setPotionId"(potion: $Holder$$Type<($Potion)>): void
public "getCustomData"(): $CompoundTag
public "setLockCode"(lock: StringJS): void
public "getCustomName"(): $Component
public "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
public "setLore"(lines: $List$$Type<($Component$$Type)>): void
public "setEntityData"(tag: $CompoundTag$$Type): void
public "setRarity"(rarity: $Rarity$$Type): void
public "setBaseColor"(color: $DyeColor$$Type): void
public "setCustomName"(name: $Component$$Type): void
public "getBaseAttackDamage"(): double
/**
 * Sets the attack damage of this item to the given value, **removing** all other modifiers to attack damage.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 * (In practice, this simply means that most weapons have this value set to 1 less than what you might think.)
 */
public "setAttackDamage"(dmg: double): void
public "hasAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): boolean
public "getBaseAttackSpeed"(): double
public "setAttributeModifiers"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Overrides the *base* attack speed of this item to be the given value, keeping other modifiers intact.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 */
public "setBaseAttackSpeed"(speed: double): void
/**
 * Overrides the *base* attack damage of this item to be the given value, keeping other modifiers intact.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 */
public "setBaseAttackDamage"(dmg: double): void
public "addAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, mod: $AttributeModifier$$Type, slot: $EquipmentSlotGroup$$Type): void
public "getAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): $AttributeModifier
public "getAttackDamage"(): double
public "setAttributeModifiersWithTooltip"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Sets the attack speed of this item to the given value, **removing** all other modifiers to attack speed.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 * (Example: Swords have an attack speed of -2.4, leading to a total value of 1.6 without any other changes.)
 */
public "setAttackSpeed"(speed: double): void
public "getAttackSpeed"(): double
set "burnTime"(value: $TickDuration$$Type)
set "nameKey"(value: StringJS)
get "componentMap"(): $DataComponentMap
set "tier"(value: $Consumer$$Type<($MutableToolTier)>)
set "craftingRemainder"(value: $Item$$Type)
get "unbreakableWithTooltip"(): void
set "maxStackSize"(value: integer)
set "mapItemColor"(value: $KubeColor$$Type)
set "bundleContents"(value: $List$$Type<($ItemStack$$Type)>)
set "bucketEntityData"(value: $CompoundTag$$Type)
set "fireworkExplosion"(value: $FireworkExplosion$$Type)
set "blockEntityData"(value: $CompoundTag$$Type)
get "fireResistant"(): void
set "noteBlockSound"(value: $ResourceLocation$$Type)
get "attributeModifiers"(): $ItemAttributeModifiers
set "chargedProjectiles"(value: $List$$Type<($ItemStack$$Type)>)
set "instrument"(value: $Holder$$Type<($Instrument)>)
get "unbreakable"(): void
set "itemName"(value: $Component$$Type)
set "repairCost"(value: integer)
set "tool"(value: $Tool$$Type)
set "food"(value: $FoodProperties$$Type)
set "fireworks"(value: $Fireworks$$Type)
set "damage"(value: integer)
set "maxDamage"(value: integer)
get "additionalTooltipHidden"(): void
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
get "componentString"(): StringJS
set "customModelData"(value: integer)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
get "tooltipHidden"(): void
set "potionContents"(value: $PotionContents$$Type)
set "glintOverride"(value: boolean)
set "dyedColor"(value: $KubeColor$$Type)
set "customData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
set "potionId"(value: $Holder$$Type<($Potion)>)
get "customData"(): $CompoundTag
set "lockCode"(value: StringJS)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "entityData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "customName"(value: $Component$$Type)
get "baseAttackDamage"(): double
set "attackDamage"(value: double)
get "baseAttackSpeed"(): double
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "baseAttackSpeed"(value: double)
set "baseAttackDamage"(value: double)
get "attackDamage"(): double
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "attackSpeed"(value: double)
get "attackSpeed"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModificationKubeEvent$ItemModifications$$Type = ({"item"?: $Item$$Type}) | ([item?: $Item$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemModificationKubeEvent$ItemModifications$$Original = $ItemModificationKubeEvent$ItemModifications;}
declare module "dev.latvian.mods.kubejs.script.data.ExportablePackResources" {
import {$PackLocationInfo} from "net.minecraft.server.packs.PackLocationInfo"
import {$KnownPack} from "net.minecraft.server.packs.repository.KnownPack"
import {$MetadataSectionSerializer$$Type} from "net.minecraft.server.packs.metadata.MetadataSectionSerializer"
import {$Optional} from "java.util.Optional"
import {$PackResources$$Interface} from "net.minecraft.server.packs.PackResources"
import {$IoSupplier} from "net.minecraft.server.packs.resources.IoSupplier"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$PackType$$Type} from "net.minecraft.server.packs.PackType"
import {$PackResources$ResourceOutput$$Type} from "net.minecraft.server.packs.PackResources$ResourceOutput"
import {$Set} from "java.util.Set"
import {$Path$$Type} from "java.nio.file.Path"
import {$InputStream} from "java.io.InputStream"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ExportablePackResources$$Interface extends $PackResources$$Interface {
get "hidden"(): boolean
}

export class $ExportablePackResources implements $ExportablePackResources$$Interface {
 "export"(root: $Path$$Type): void
 "exportPath"(): StringJS
 "getResource"(arg0: $PackType$$Type, arg1: $ResourceLocation$$Type): $IoSupplier<($InputStream)>
 "location"(): $PackLocationInfo
 "close"(): void
 "getNamespaces"(arg0: $PackType$$Type): $Set<(StringJS)>
 "listResources"(arg0: $PackType$$Type, arg1: StringJS, arg2: StringJS, arg3: $PackResources$ResourceOutput$$Type): void
 "packId"(): StringJS
 "getMetadataSection"<T>(arg0: $MetadataSectionSerializer$$Type<(T)>): T
 "getRootResource"(...arg0: (StringJS)[]): $IoSupplier<($InputStream)>
 "knownPackInfo"(): $Optional<($KnownPack)>
 "isHidden"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExportablePackResources$$Type = ($ExportablePackResources);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExportablePackResources$$Original = $ExportablePackResources;}
declare module "dev.latvian.mods.kubejs.core.InventoryKJS" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Container} from "net.minecraft.world.Container"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $InventoryKJS$$Interface {
get "height"(): integer
get "width"(): integer
get "changed"(): void
get "mutable"(): boolean
get "allItems"(): $List<($ItemStack)>
get "slots"(): integer
get "empty"(): boolean
}

export class $InventoryKJS implements $InventoryKJS$$Interface {
 "getBlock"(level: $Level$$Type): $LevelBlock
 "getHeight"(): integer
 "getWidth"(): integer
 "asContainer"(): $Container
 "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "setChanged"(): void
 "isMutable"(): boolean
 "getSlotLimit"(slot: integer): integer
 "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
 "getAllItems"(): $List<($ItemStack)>
 "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
 "countNonEmpty"(match: $ItemPredicate$$Type): integer
 "countNonEmpty"(): integer
 "getStackInSlot"(slot: integer): $ItemStack
 "getSlots"(): integer
 "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
 "isEmpty"(): boolean
 "count"(match: $ItemPredicate$$Type): integer
 "count"(): integer
 "clear"(match: $ItemPredicate$$Type): void
 "clear"(): void
 "find"(match: $ItemPredicate$$Type): integer
 "find"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryKJS$$Type = ($InventoryKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InventoryKJS$$Original = $InventoryKJS;}
declare module "dev.latvian.mods.kubejs.core.RecipeInputKJS" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$RecipeInput} from "net.minecraft.world.item.crafting.RecipeInput"
import {$List} from "java.util.List"
import {$SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RecipeInputKJS$$Interface {
}

export class $RecipeInputKJS implements $RecipeInputKJS$$Interface {
 "find"(filter: $SlotFilter$$Type): $ItemStack
 "find"(filter: $SlotFilter$$Type, skip: integer): $ItemStack
 "self"(): $RecipeInput
 "findAll"(filter: $SlotFilter$$Type): $List<($ItemStack)>
 "findAll"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeInputKJS$$Type = ($RecipeInputKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeInputKJS$$Original = $RecipeInputKJS;}
declare module "dev.latvian.mods.kubejs.util.NotificationToastData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$KubeIcon, $KubeIcon$$Type} from "dev.latvian.mods.kubejs.client.icon.KubeIcon"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Duration, $Duration$$Type} from "java.time.Duration"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $NotificationToastData extends $Record {
static readonly "CODEC": $MapCodec<($NotificationToastData)>
static readonly "DEFAULT_BORDER_COLOR": $KubeColor
static readonly "DEFAULT_BACKGROUND_COLOR": $KubeColor
static readonly "DEFAULT_DURATION": $Duration
static readonly "DEFAULT_OUTLINE_COLOR": $KubeColor
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($NotificationToastData)>

constructor(duration: $Duration$$Type, text: $Component$$Type, icon: ($KubeIcon$$Type)?, iconSize: integer, outlineColor: ($KubeColor$$Type)?, borderColor: ($KubeColor$$Type)?, backgroundColor: ($KubeColor$$Type)?, textShadow: boolean)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "duration"(): $Duration
public "text"(): $Component
public static "ofText"(text: $Component$$Type): $NotificationToastData
public "iconSize"(): integer
public "textShadow"(): boolean
public "backgroundColor"(): $Optional<($KubeColor)>
public "icon"(): $Optional<($KubeIcon)>
public "outlineColor"(): $Optional<($KubeColor)>
public static "ofTitle"(title: $Component$$Type, text: $Component$$Type): $NotificationToastData
public "borderColor"(): $Optional<($KubeColor)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotificationToastData$$Type = ({"text"?: $Component$$Type, "textShadow"?: boolean, "outlineColor"?: ($KubeColor$$Type)?, "duration"?: $Duration$$Type, "backgroundColor"?: ($KubeColor$$Type)?, "borderColor"?: ($KubeColor$$Type)?, "icon"?: ($KubeIcon$$Type)?, "iconSize"?: integer}) | ([text?: $Component$$Type, textShadow?: boolean, outlineColor?: ($KubeColor$$Type)?, duration?: $Duration$$Type, backgroundColor?: ($KubeColor$$Type)?, borderColor?: ($KubeColor$$Type)?, icon?: ($KubeIcon$$Type)?, iconSize?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NotificationToastData$$Original = $NotificationToastData;}
declare module "dev.latvian.mods.kubejs.util.WithCodec" {
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$JsonSerializable$$Interface} from "dev.latvian.mods.kubejs.util.JsonSerializable"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$NBTSerializable$$Interface} from "dev.latvian.mods.kubejs.util.NBTSerializable"

export interface $WithCodec$$Interface extends $NBTSerializable$$Interface, $JsonSerializable$$Interface {

(): $Codec$$Type<(never)>
get "codec"(): $Codec<(never)>
}

export class $WithCodec implements $WithCodec$$Interface {
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
 "getCodec"(): $Codec<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithCodec$$Type = (() => $Codec$$Type<(never)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WithCodec$$Original = $WithCodec;}
declare module "dev.latvian.mods.kubejs.core.PlayerSelector" {
import {$UUID$$Type} from "java.util.UUID"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $PlayerSelector$$Interface {

(server: $MinecraftServer): $ServerPlayer$$Type
}

export class $PlayerSelector implements $PlayerSelector$$Interface {
static "name"(name: StringJS): $PlayerSelector
static "wrap"(o: any): $PlayerSelector
static "identity"(player: $ServerPlayer$$Type): $PlayerSelector
 "or"(fallback: $PlayerSelector$$Type): $PlayerSelector
static "fuzzyName"(name: StringJS): $PlayerSelector
 "getPlayer"(server: $MinecraftServer$$Type): $ServerPlayer
static "uuid"(uuid: $UUID$$Type): $PlayerSelector
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerSelector$$Type = (StringJS) | ((server: $MinecraftServer) => $ServerPlayer$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerSelector$$Original = $PlayerSelector;}
declare module "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ItemBuilder} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$FluidBuilder, $FluidBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $FluidBucketItemBuilder extends $ItemBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
readonly "fluidBuilder": $FluidBuilder
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(b: $FluidBuilder$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBucketItemBuilder$$Type = ($FluidBucketItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidBucketItemBuilder$$Original = $FluidBucketItemBuilder;}
declare module "dev.latvian.mods.kubejs.core.IngredientKJS" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$ItemStackSet} from "dev.latvian.mods.kubejs.item.ItemStackSet"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$WithCodec$$Interface} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$ItemMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ItemMatch"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$ItemPredicate, $ItemPredicate$$Interface} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$Set} from "java.util.Set"
import {$Stream} from "java.util.stream.Stream"
import {$SizedIngredient} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IngredientKJS$$Interface extends $ItemPredicate$$Interface, $Replaceable$$Interface, $WithCodec$$Interface, $ItemMatch$$Interface {

(itemStack: $ItemStack): boolean
get "wildcard"(): boolean
get "stackArray"(): ($ItemStack)[]
get "tagKey"(): $TagKey<($Item)>
get "codec"(): $Codec<(never)>
get "displayStacks"(): $ItemStackSet
get "stacks"(): $ItemStackSet
get "itemTypes"(): $Set<($Item)>
get "first"(): $ItemStack
get "itemIds"(): $Set<(StringJS)>
get "itemStream"(): $Stream<($Item)>
}

export class $IngredientKJS implements $IngredientKJS$$Interface {
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $Ingredient$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, item: $ItemStack$$Type, exact: boolean): boolean
 "toIngredientString"(ops: $DynamicOps$$Type<($Tag$$Type)>): StringJS
 "isWildcard"(): boolean
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "containsAnyTag"(): boolean
 "getStackArray"(): ($ItemStack)[]
 "asStack"(): $SizedIngredient
 "getTagKey"(): $TagKey<($Item)>
 "self"(): $Ingredient
 "getCodec"(): $Codec<(never)>
 "asIngredient"(): $Ingredient
 "or"(ingredient: $Ingredient$$Type): $Ingredient
 "except"(subtracted: $Ingredient$$Type): $Ingredient
 "and"(ingredient: $Ingredient$$Type): $Ingredient
 "withCount"(count: integer): $SizedIngredient
 "test"(itemStack: any): boolean
 "test"(itemStack: $ItemStack$$Type): boolean
static "wrap"(from: any): $ItemPredicate
 "canBeUsedForMatching"(): boolean
 "getDisplayStacks"(): $ItemStackSet
 "getStacks"(): $ItemStackSet
 "testItem"(item: $Item$$Type): boolean
 "getItemTypes"(): $Set<($Item)>
 "getFirst"(): $ItemStack
 "getItemIds"(): $Set<(StringJS)>
 "getItemStream"(): $Stream<($Item)>
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
 "matchesAny"(cx: $RecipeMatchContext$$Type, itemLikes: $Iterable$$Type<($ItemLike$$Type)>, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, itemLike: $ItemLike$$Type, exact: boolean): boolean
 "or"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "not"<T>(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "isEqual"<T>(arg0: any): $Predicate<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientKJS$$Type = ((itemStack: $ItemStack) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientKJS$$Original = $IngredientKJS;}
declare module "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder" {
import {$BlockRenderType$$Type} from "dev.latvian.mods.kubejs.block.BlockRenderType"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$PathType$$Type} from "net.minecraft.world.level.pathfinder.PathType"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$FluidType} from "net.neoforged.neoforge.fluids.FluidType"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$SoundAction$$Type} from "net.neoforged.neoforge.common.SoundAction"

export class $FluidTypeBuilder extends $BuilderBase<($FluidType)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

public "sound"(action: $SoundAction$$Type, sound: $SoundEvent$$Type): this
public "canSwim"(canSwim: boolean): this
public "canHydrate"(canHydrate: boolean): this
public "fallDistanceModifier"(fallDistanceModifier: float): this
public "rarity"(rarity: $Rarity$$Type): this
public "addDripstoneDripping"(chance: float, dripParticle: $ParticleOptions$$Type, cauldron: $Block$$Type, fillSound: $SoundEvent$$Type): this
public "supportsBoating"(supportsBoating: boolean): this
public "canConvertToSource"(canConvertToSource: boolean): this
public "adjacentPathType"(adjacentPathType: $PathType$$Type): this
public "canExtinguish"(canExtinguish: boolean): this
public "canPushEntity"(canPushEntity: boolean): this
public "motionScale"(motionScale: double): this
public "lightLevel"(lightLevel: integer): this
public "canDrown"(canDrown: boolean): this
public "pathType"(pathType: $PathType$$Type): this
public "viscosity"(viscosity: integer): this
public "descriptionId"(descriptionId: StringJS): this
public "stillTexture"(stillTexture: $ResourceLocation$$Type): this
public "flowingTexture"(flowingTexture: $ResourceLocation$$Type): this
public "density"(density: integer): this
public "renderType"(renderType: $BlockRenderType$$Type): this
public "temperature"(temperature: integer): this
public "tint"(tint: $KubeColor$$Type): this
public "screenOverlayTexture"(screenOverlayTexture: $ResourceLocation$$Type): this
public "blockOverlayTexture"(blockOverlayTexture: $ResourceLocation$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidTypeBuilder$$Type = ($FluidTypeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidTypeBuilder$$Original = $FluidTypeBuilder;}
declare module "dev.latvian.mods.kubejs.core.RecipeManagerKJS" {
import {$ReloadableServerResourceHolderKJS$$Interface} from "dev.latvian.mods.kubejs.core.ReloadableServerResourceHolderKJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RecipeHolder, $RecipeHolder$$Type} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$ReloadableServerResourcesKJS, $ReloadableServerResourcesKJS$$Type} from "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RecipeManagerKJS$$Interface extends $ReloadableServerResourceHolderKJS$$Interface {
}

export class $RecipeManagerKJS implements $RecipeManagerKJS$$Interface {
 "kjs$replaceRecipes"(byName: $Map$$Type<($ResourceLocation$$Type), ($RecipeHolder$$Type<(never)>)>): void
 "kjs$getRecipeIdMap"(): $Map<($ResourceLocation), ($RecipeHolder<(never)>)>
 "kjs$setResources"(resources: $ReloadableServerResourcesKJS$$Type): void
 "kjs$getResources"(): $ReloadableServerResourcesKJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeManagerKJS$$Type = ($RecipeManagerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeManagerKJS$$Original = $RecipeManagerKJS;}
declare module "dev.latvian.mods.kubejs.registry.CustomBuilderObject" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $CustomBuilderObject extends $BuilderBase {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type, object: $Supplier$$Type<(any)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomBuilderObject$$Type = ($CustomBuilderObject);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomBuilderObject$$Original = $CustomBuilderObject;}
declare module "dev.latvian.mods.kubejs.script.WithScriptContext" {
import {$Context, $Context$$Type} from "dev.latvian.mods.rhino.Context"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $WithScriptContext$$Interface {

(): $Context$$Type
}

export class $WithScriptContext implements $WithScriptContext$$Interface {
 "cx"(): $Context
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithScriptContext$$Type = (() => $Context$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WithScriptContext$$Original = $WithScriptContext;}
declare module "dev.latvian.mods.kubejs.net.KubeServerData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$ItemTooltipData, $ItemTooltipData$$Type} from "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData"
import {$RecipeViewerData, $RecipeViewerData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.RecipeViewerData"
import {$Record} from "java.lang.Record"

export class $KubeServerData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($KubeServerData)>

constructor(recipeViewerData: ($RecipeViewerData$$Type)?, itemTooltipData: $List$$Type<($ItemTooltipData$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "collect"(): $KubeServerData
public "itemTooltipData"(): $List<($ItemTooltipData)>
public "recipeViewerData"(): $Optional<($RecipeViewerData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeServerData$$Type = ({"itemTooltipData"?: $List$$Type<($ItemTooltipData$$Type)>, "recipeViewerData"?: ($RecipeViewerData$$Type)?}) | ([itemTooltipData?: $List$$Type<($ItemTooltipData$$Type)>, recipeViewerData?: ($RecipeViewerData$$Type)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeServerData$$Original = $KubeServerData;}
declare module "dev.latvian.mods.kubejs.client.ModelGenerator$Face" {
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $ModelGenerator$Face {
readonly "side": $Direction

constructor(side: $Direction$$Type)

public "cull"(d: $Direction$$Type): $ModelGenerator$Face
public "cull"(): $ModelGenerator$Face
public "toJson"(): $JsonObject
public "uv"(u0: double, v0: double, u1: double, v1: double): $ModelGenerator$Face
public "tex"(t: StringJS): $ModelGenerator$Face
public "tintindex"(i: integer): $ModelGenerator$Face
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$Face$$Type = ($ModelGenerator$Face);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModelGenerator$Face$$Original = $ModelGenerator$Face;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaRegistry" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeNamespace} from "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace"
import {$RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RegistryAwareSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RegistryAwareSchema"

export class $RecipeSchemaRegistry implements $KubeEvent$$Interface {
constructor(storage: $RecipeSchemaStorage$$Type)

public "register"(id: $ResourceLocation$$Type, schema: $RegistryAwareSchema$$Type): void
public "register"(id: $ResourceLocation$$Type, schema: $RecipeSchema$$Type): void
public "namespace"(namespace: StringJS): $RecipeNamespace
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchemaRegistry$$Type = ($RecipeSchemaRegistry);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeSchemaRegistry$$Original = $RecipeSchemaRegistry;}
declare module "dev.latvian.mods.kubejs.util.AttachedData" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"
import {$HashMap} from "java.util.HashMap"

export class $AttachedData<T> extends $HashMap<(StringJS), (any)> {
constructor(p: T)

public "add"(key: StringJS, data: any): void
public "getParent"(): T
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
get "parent"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedData$$Type<T> = ($AttachedData<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttachedData$$Original<T> = $AttachedData<(T)>;}
declare module "dev.latvian.mods.kubejs.client.MenuScreenRegistryKubeEvent" {
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$MenuType$$Type} from "net.minecraft.world.inventory.MenuType"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$RegisterMenuScreensEvent$$Type} from "net.neoforged.neoforge.client.event.RegisterMenuScreensEvent"
import {$MenuScreens$ScreenConstructor$$Type} from "net.minecraft.client.gui.screens.MenuScreens$ScreenConstructor"

export class $MenuScreenRegistryKubeEvent implements $ClientKubeEvent$$Interface {
constructor(event: $RegisterMenuScreensEvent$$Type)

public "register"(type: $MenuType$$Type<(never)>, arg1: $MenuScreens$ScreenConstructor$$Type): void
public "getClient"(): $Minecraft
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MenuScreenRegistryKubeEvent$$Type = ($MenuScreenRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MenuScreenRegistryKubeEvent$$Original = $MenuScreenRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.item.ItemClickedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player right clicks with an item **without targeting anything**.
 * 
 * Not to be confused with `BlockEvents.rightClick` or `ItemEvents.entityInteracted`.
 */
export class $ItemClickedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, hand: $InteractionHand$$Type, item: $ItemStack$$Type)

/**
 * The ray trace result of the click.
 */
public "getTarget"(): $KubeRayTraceResult
/**
 * The item that was clicked with.
 */
public "getItem"(): $ItemStack
/**
 * The hand that the item was clicked with.
 */
public "getHand"(): $InteractionHand
/**
 * The player that clicked with the item.
 */
public "getEntity"(): $LivingEntity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "target"(): $KubeRayTraceResult
get "item"(): $ItemStack
get "hand"(): $InteractionHand
get "entity"(): $LivingEntity
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemClickedKubeEvent$$Type = ($ItemClickedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemClickedKubeEvent$$Original = $ItemClickedKubeEvent;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.HolderSetWrapper" {
import {$Iterator} from "java.util.Iterator"
import {$Iterable$$Interface} from "java.lang.Iterable"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Spliterator} from "java.util.Spliterator"
import {$List} from "java.util.List"
import {$HolderSet, $HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Set} from "java.util.Set"
import {$Record} from "java.lang.Record"
import {$Consumer$$Type} from "java.util.function.Consumer"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $HolderSetWrapper<T> extends $Record implements $Iterable$$Interface<(T)> {
constructor(registry: $Registry$$Type<(T)>, holders: $HolderSet$$Type<(T)>)

public "getRandom"(random: $RandomSource$$Type): T
public "getRandom"(): T
public "size"(): integer
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public "iterator"(): $Iterator<(T)>
public "contains"(id: $ResourceLocation$$Type): boolean
public "containsValue"(value: T): boolean
public "getKeys"(): $Set<($ResourceLocation)>
public "getValues"(): $List<(T)>
public "registry"(): $Registry<(T)>
public "holders"(): $HolderSet<(T)>
public "spliterator"(): $Spliterator<(T)>
public "forEach"(arg0: $Consumer$$Type<(T)>): void
[Symbol.iterator](): IterableIterator<T>;
get "random"(): T
get "empty"(): boolean
get "keys"(): $Set<($ResourceLocation)>
get "values"(): $List<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HolderSetWrapper$$Type<T> = ({"registry"?: $Registry$$Type<(T)>, "holders"?: $HolderSet$$Type<(T)>}) | ([registry?: $Registry$$Type<(T)>, holders?: $HolderSet$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HolderSetWrapper$$Original<T> = $HolderSetWrapper<(T)>;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.RecipeViewerData" {
import {$ItemData, $ItemData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CategoryData, $CategoryData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.CategoryData"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$FluidData, $FluidData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData"
import {$Record} from "java.lang.Record"

export class $RecipeViewerData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($RecipeViewerData)>

constructor(removedCategories: $List$$Type<($ResourceLocation$$Type)>, removedGlobalRecipes: $List$$Type<($ResourceLocation$$Type)>, categoryData: $List$$Type<($CategoryData$$Type)>, itemData: $ItemData$$Type, fluidData: $FluidData$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public static "collect"(): $RecipeViewerData
public "fluidData"(): $FluidData
public "itemData"(): $ItemData
public "categoryData"(): $List<($CategoryData)>
public "removedGlobalRecipes"(): $List<($ResourceLocation)>
public "removedCategories"(): $List<($ResourceLocation)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeViewerData$$Type = ({"removedGlobalRecipes"?: $List$$Type<($ResourceLocation$$Type)>, "removedCategories"?: $List$$Type<($ResourceLocation$$Type)>, "categoryData"?: $List$$Type<($CategoryData$$Type)>, "itemData"?: $ItemData$$Type, "fluidData"?: $FluidData$$Type}) | ([removedGlobalRecipes?: $List$$Type<($ResourceLocation$$Type)>, removedCategories?: $List$$Type<($ResourceLocation$$Type)>, categoryData?: $List$$Type<($CategoryData$$Type)>, itemData?: $ItemData$$Type, fluidData?: $FluidData$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeViewerData$$Original = $RecipeViewerData;}
declare module "dev.latvian.mods.kubejs.core.ItemEntityKJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$EntityKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityKJS"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ItemEntityKJS$$Interface extends $EntityKJS$$Interface {
get "ticksUntilDespawn"(): integer
get "noPickUpDelay"(): void
get "defaultPickUpDelay"(): void
get "infinitePickUpDelay"(): void
set "ticksUntilDespawn"(value: integer)
get "item"(): $ItemStack
get "lifespan"(): integer
get "noDespawn"(): void
set "lifespan"(value: integer)
get "nbt"(): $CompoundTag
set "z"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "x"(value: double)
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
get "living"(): boolean
get "level"(): $Level
get "type"(): StringJS
set "motionX"(value: double)
get "teamId"(): StringJS
set "motionY"(value: double)
get "profile"(): $GameProfile
get "server"(): $MinecraftServer
get "motionZ"(): double
get "motionX"(): double
get "passengers"(): $EntityArrayList
get "facing"(): $Direction
get "player"(): boolean
get "animal"(): boolean
set "position"(value: $LevelBlock$$Type)
set "motionZ"(value: double)
get "scriptType"(): $ScriptType
get "frame"(): boolean
get "motionY"(): double
get "block"(): $LevelBlock
get "monster"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $ItemEntityKJS implements $ItemEntityKJS$$Interface {
 "getTicksUntilDespawn"(): integer
 "setNoPickUpDelay"(): void
 "setDefaultPickUpDelay"(): void
 "setInfinitePickUpDelay"(): void
 "setTicksUntilDespawn"(ticks: integer): void
 "getItem"(): $ItemStack
 "getLifespan"(): integer
 "setNoDespawn"(): void
 "setLifespan"(lifespan: integer): void
 "self"(): $Entity
 "spawn"(): void
 "getNbt"(): $CompoundTag
 "attack"(hp: float): void
 "setZ"(z: double): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setX"(x: double): void
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "isAmbientCreature"(): boolean
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "isLiving"(): boolean
 "getLevel"(): $Level
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "getType"(): StringJS
 "setMotionX"(x: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getTeamId"(): StringJS
 "setMotionY"(y: double): void
 "getProfile"(): $GameProfile
 "getServer"(): $MinecraftServer
 "getMotionZ"(): double
 "getMotionX"(): double
 "getPassengers"(): $EntityArrayList
 "getFacing"(): $Direction
 "isPlayer"(): boolean
 "setRotation"(yaw: float, pitch: float): void
 "isAnimal"(): boolean
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "setPosition"(x: double, y: double, z: double): void
 "setPosition"(block: $LevelBlock$$Type): void
 "setMotionZ"(z: double): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getBlock"(): $LevelBlock
 "isMonster"(): boolean
 "runCommandSilent"(command: StringJS): void
 "tell"(message: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(command: StringJS): void
 "getDisplayName"(): $Component
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$$Type): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEntityKJS$$Type = ($ItemEntityKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemEntityKJS$$Original = $ItemEntityKJS;}
declare module "dev.latvian.mods.kubejs.core.RecipeHolderKJS" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$RecipeSchema} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeHolder} from "net.minecraft.world.item.crafting.RecipeHolder"
import {$Recipe} from "net.minecraft.world.item.crafting.Recipe"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RecipeLikeKJS$$Interface} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RecipeHolderKJS$$Interface extends $RecipeLikeKJS$$Interface {
set "group"(value: StringJS)
get "schema"(): $RecipeSchema
get "typeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
get "orCreateId"(): $ResourceLocation
get "recipe"(): $Recipe<(never)>
get "serializer"(): $RecipeSerializer<(never)>
get "group"(): StringJS
get "type"(): $ResourceLocation
get "mod"(): StringJS
}

export class $RecipeHolderKJS implements $RecipeHolderKJS$$Interface {
 "replaceInput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "setGroup"(group: StringJS): void
 "getSchema"(): $RecipeSchema
 "replaceOutput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
 "getTypeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
 "getOrCreateId"(): $ResourceLocation
 "getRecipe"(): $Recipe<(never)>
 "getSerializer"(): $RecipeSerializer<(never)>
 "getGroup"(): StringJS
 "hasInput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
 "hasOutput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
 "self"(): $RecipeHolder<(never)>
 "getType"(): $ResourceLocation
 "getMod"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeHolderKJS$$Type = ($RecipeHolderKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeHolderKJS$$Original = $RecipeHolderKJS;}
declare module "dev.latvian.mods.kubejs.block.BlockPlacedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$BlockEvent$EntityPlaceEvent$$Type} from "net.neoforged.neoforge.event.level.BlockEvent$EntityPlaceEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a block is placed.
 */
export class $BlockPlacedKubeEvent implements $KubeEntityEvent$$Interface {
constructor(event: $BlockEvent$EntityPlaceEvent$$Type)

/**
 * The level of the block that was placed.
 */
public "getLevel"(): $Level
/**
 * The block that is placed.
 */
public "getBlock"(): $LevelBlock
/**
 * The entity that placed the block. Can be `null`, e.g. when a block is placed by a dispenser.
 */
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "block"(): $LevelBlock
get "entity"(): $Entity
get "player"(): $Player
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPlacedKubeEvent$$Type = ($BlockPlacedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockPlacedKubeEvent$$Original = $BlockPlacedKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.LazyComponentKJS" {
import {$Supplier$$Interface} from "java.util.function.Supplier"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $LazyComponentKJS$$Interface extends $Supplier$$Interface<($Component)> {

(): $Component$$Type
}

export class $LazyComponentKJS implements $LazyComponentKJS$$Interface {
 "get"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LazyComponentKJS$$Type = (() => $Component$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LazyComponentKJS$$Original = $LazyComponentKJS;}
declare module "dev.latvian.mods.kubejs.level.KubeLevelEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export interface $KubeLevelEvent$$Interface extends $KubeEvent$$Interface {

(): $Level$$Type
get "server"(): $MinecraftServer
get "level"(): $Level
get "registries"(): $RegistryAccess
}

export class $KubeLevelEvent implements $KubeLevelEvent$$Interface {
 "getServer"(): $MinecraftServer
 "getLevel"(): $Level
 "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeLevelEvent$$Type = (() => $Level$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeLevelEvent$$Original = $KubeLevelEvent;}
declare module "dev.latvian.mods.kubejs.entity.AttributeBuilder" {
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$List} from "java.util.List"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$AttributeBuilder$Range} from "dev.latvian.mods.kubejs.entity.AttributeBuilder$Range"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$MobCategory$$Type} from "net.minecraft.world.entity.MobCategory"
import {$Registry} from "net.minecraft.core.Registry"
import {$Attribute$Sentiment$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute$Sentiment"
import {$Either} from "com.mojang.datafixers.util.Either"
import {$Attribute, $Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$EntityType, $EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $AttributeBuilder extends $BuilderBase<($Attribute)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "predicateList": $List<($Predicate<($EntityType<(never)>)>)>
 "defaultValue": $Either<($AttributeBuilder$Range), (boolean)>
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

public "syncable"(watch: boolean): this
public "sentiment"(sentiment: $Attribute$Sentiment$$Type): this
public "range"(defaultValue: double, min: double, max: double): this
public "attachTo"(entityType: $Predicate$$Type<($EntityType<(never)>)>): this
public "bool"(defaultValue: boolean): this
public "transformObject"(attribute: $Attribute$$Type): $Attribute
public "attachToPlayers"(): this
public "attachToMonsters"(): this
public "attachToCategory"(category: $MobCategory$$Type): this
public "neutralSentiment"(): this
public "negativeSentiment"(): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributeBuilder$$Type = ($AttributeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttributeBuilder$$Original = $AttributeBuilder;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.IngredientWrapper" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$DataResult} from "com.mojang.serialization.DataResult"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$HolderSet$$Type} from "net.minecraft.core.HolderSet"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$SizedIngredient} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

/**
 * Various Ingredient related helper methods
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IngredientWrapper$$Interface {
}

export class $IngredientWrapper implements $IngredientWrapper$$Interface {
/**
 * An ingredient that matches everything
 */
static readonly "all": $Ingredient
static readonly "TYPE_INFO": $TypeInfo
/**
 * A completely empty ingredient that will only match air
 */
static readonly "none": $Ingredient

/**
 * Returns an ingredient that accepts the given set of items under the given (optionally strict) component filter.
 */
static "withData"(base: $HolderSet$$Type<($Item)>, data: $DataComponentMap$$Type, strict: boolean): $Ingredient
/**
 * Returns an ingredient that accepts the given set of items under the given component filter.
 */
static "withData"(base: $HolderSet$$Type<($Item)>, data: $DataComponentMap$$Type): $Ingredient
/**
 * Checks if the passed in object is an Ingredient.
 * Note that this does not mean it will not function as an Ingredient if passed to something that requests one.
 */
static "isIngredient"(o: any): boolean
/**
 * Returns an ingredient of the input
 */
static "of"(ingredient: $Ingredient$$Type): $Ingredient
/**
 * Returns an ingredient of the input, with the specified count
 */
static "of"(ingredient: $Ingredient$$Type, count: integer): $SizedIngredient
static "first"(ingredient: $Ingredient$$Type): $ItemStack
static "read"(reader: $StringReader$$Type): $DataResult<($Ingredient)>
static "parseString"(s: StringJS): $DataResult<($Ingredient)>
static "isIngredientLike"(from: any): boolean
static "parseJson"(json: $JsonElement$$Type): $DataResult<($Ingredient)>
static "containsAnyTag"(arg0: $Ingredient$$Type): boolean
static "tagKeyOf"(arg0: $Ingredient$$Type): $TagKey<($Item)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientWrapper$$Type = ($IngredientWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientWrapper$$Original = $IngredientWrapper;}
declare module "dev.latvian.mods.kubejs.script.KubeJSFileWatcherThread" {
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Thread} from "java.lang.Thread"
import {$Runnable, $Runnable$$Type} from "java.lang.Runnable"
import {$ScriptFile, $ScriptFile$$Type} from "dev.latvian.mods.kubejs.script.ScriptFile"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $KubeJSFileWatcherThread extends $Thread {
readonly "reload": $Runnable
readonly "scriptType": $ScriptType
static readonly "MIN_PRIORITY": integer
readonly "files": ($ScriptFile)[]
static readonly "MAX_PRIORITY": integer
static readonly "NORM_PRIORITY": integer

constructor(scriptType: $ScriptType$$Type, files: ($ScriptFile$$Type)[], reload: $Runnable$$Type)

public "run"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSFileWatcherThread$$Type = ($KubeJSFileWatcherThread);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSFileWatcherThread$$Original = $KubeJSFileWatcherThread;}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate" {
import {$BlockIDPredicate$PropertyObject} from "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate$PropertyObject"
import {$BlockPredicate$$Interface} from "dev.latvian.mods.kubejs.block.predicate.BlockPredicate"
import {$LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$List} from "java.util.List"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockIDPredicate implements $BlockPredicate$$Interface {
constructor(i: $ResourceLocation$$Type)

public "toString"(): StringJS
public "with"(key: StringJS, value: StringJS): $BlockIDPredicate
public "check"(b: $LevelBlock$$Type): boolean
public "checkState"(state: $BlockState$$Type): boolean
public "getBlockState"(): $BlockState
public "getBlockProperties"(): $List<($BlockIDPredicate$PropertyObject)>
get "blockState"(): $BlockState
get "blockProperties"(): $List<($BlockIDPredicate$PropertyObject)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockIDPredicate$$Type = ($BlockIDPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockIDPredicate$$Original = $BlockIDPredicate;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickHandler" {
import {$ChestMenuClickEvent$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent"
import {$ChestMenuClickEvent$Callback, $ChestMenuClickEvent$Callback$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"
import {$Record} from "java.lang.Record"

export class $ChestMenuClickHandler extends $Record {
constructor(type: $ClickType$$Type, button: integer, callback: $ChestMenuClickEvent$Callback$$Type, autoHandle: boolean)

public "callback"(): $ChestMenuClickEvent$Callback
public "type"(): $ClickType
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "test"(event: $ChestMenuClickEvent$$Type): boolean
public "button"(): integer
public "autoHandle"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuClickHandler$$Type = ({"autoHandle"?: boolean, "button"?: integer, "type"?: $ClickType$$Type, "callback"?: $ChestMenuClickEvent$Callback$$Type}) | ([autoHandle?: boolean, button?: integer, type?: $ClickType$$Type, callback?: $ChestMenuClickEvent$Callback$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuClickHandler$$Original = $ChestMenuClickHandler;}
declare module "dev.latvian.mods.kubejs.player.StageChangedEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$Stages, $Stages$$Type} from "dev.latvian.mods.kubejs.stages.Stages"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $StageChangedEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, stages: $Stages$$Type, stage: StringJS)

public "getPlayer"(): $Player
public "getEntity"(): $LivingEntity
public "getStage"(): StringJS
public "getPlayerStages"(): $Stages
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "player"(): $Player
get "entity"(): $LivingEntity
get "stage"(): StringJS
get "playerStages"(): $Stages
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StageChangedEvent$$Type = ($StageChangedEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StageChangedEvent$$Original = $StageChangedEvent;}
declare module "dev.latvian.mods.kubejs.block.BlockStartedFallingKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$FallingBlockEntity$$Type} from "net.minecraft.world.entity.item.FallingBlockEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a falling block starts to fall.
 */
export class $BlockStartedFallingKubeEvent implements $KubeEntityEvent$$Interface {
constructor(level: $Level$$Type, pos: $BlockPos$$Type, state: $BlockState$$Type, entity: $FallingBlockEntity$$Type)

public "getLevel"(): $Level
public "getBlock"(): $LevelBlock
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "block"(): $LevelBlock
get "entity"(): $Entity
get "player"(): $Player
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStartedFallingKubeEvent$$Type = ($BlockStartedFallingKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStartedFallingKubeEvent$$Original = $BlockStartedFallingKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.custom.FenceBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $FenceBlockBuilder extends $ShapedBlockBuilder {
static readonly "FENCE_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FenceBlockBuilder$$Type = ($FenceBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FenceBlockBuilder$$Original = $FenceBlockBuilder;}
declare module "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder" {
import {$Pattern} from "java.util.regex.Pattern"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$StringBuilder, $StringBuilder$$Type} from "java.lang.StringBuilder"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Record} from "java.lang.Record"

export class $UniqueIdBuilder extends $Record {
static readonly "MULTIPLE_UNDERSCORES_PATTERN": $Pattern
static readonly "NON_W_PATTERN": $Pattern

constructor(builder: $StringBuilder$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "append"(string: StringJS): void
public "append"(id: $ResourceLocation$$Type): void
public "append"(key: $ResourceKey$$Type<(never)>): void
public "hashCode"(): integer
public "builder"(): $StringBuilder
public "build"(): StringJS
public "appendSeparator"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UniqueIdBuilder$$Type = ({"builder"?: $StringBuilder$$Type}) | ([builder?: $StringBuilder$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UniqueIdBuilder$$Original = $UniqueIdBuilder;}
declare module "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export interface $KubeLivingEntityEvent$$Interface extends $KubeEntityEvent$$Interface {

(): $LivingEntity$$Type
get "entity"(): $LivingEntity
get "level"(): $Level
get "player"(): $Player
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}

export class $KubeLivingEntityEvent implements $KubeLivingEntityEvent$$Interface {
 "getEntity"(): $LivingEntity
 "getLevel"(): $Level
 "getPlayer"(): $Player
 "getServer"(): $MinecraftServer
 "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeLivingEntityEvent$$Type = (() => $LivingEntity$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeLivingEntityEvent$$Original = $KubeLivingEntityEvent;}
declare module "dev.latvian.mods.kubejs.player.KubePlayerEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Level} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export interface $KubePlayerEvent$$Interface extends $KubeLivingEntityEvent$$Interface {
get "player"(): $Player
get "entity"(): $Entity
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}

export class $KubePlayerEvent implements $KubePlayerEvent$$Interface {
 "getPlayer"(): $Player
 "getEntity"(): $Entity
 "getLevel"(): $Level
 "getServer"(): $MinecraftServer
 "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubePlayerEvent$$Type = ($KubePlayerEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubePlayerEvent$$Original = $KubePlayerEvent;}
declare module "dev.latvian.mods.kubejs.block.callback.RandomTickCallback" {
import {$RandomSource, $RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Level} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"

export class $RandomTickCallback {
readonly "random": $RandomSource
readonly "block": $LevelBlock

constructor(block: $LevelBlock$$Type, random: $RandomSource$$Type)

public "getServer"(): $MinecraftServer
public "getLevel"(): $Level
get "server"(): $MinecraftServer
get "level"(): $Level
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomTickCallback$$Type = ($RandomTickCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RandomTickCallback$$Original = $RandomTickCallback;}
declare module "dev.latvian.mods.kubejs.recipe.component.ComponentValueMap" {
import {$Reference2ObjectOpenHashMap} from "it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Function} from "java.util.function.Function"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$Map$Entry, $Map$Entry$$Type} from "java.util.Map$Entry"

export class $ComponentValueMap extends $Reference2ObjectOpenHashMap<($RecipeKey<(never)>), (any)> {
constructor(init: integer)

public "getValue"<T>(cx: $RecipeScriptContext$$Type, key: $RecipeKey$$Type<(T)>): T
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$$Type<(K), (V)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$$Type<(K), (V)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentValueMap$$Type = ($ComponentValueMap);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComponentValueMap$$Original = $ComponentValueMap;}
declare module "dev.latvian.mods.kubejs.core.BlockProviderKJS" {
import {$Map} from "java.util.Map"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$Holder} from "net.minecraft.core.Holder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $BlockProviderKJS$$Interface extends $RegistryObjectKJS$$Interface<($Block)> {

(): $Block$$Type
get "id"(): StringJS
get "block"(): $Block
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "registry"(): $Registry<($Block)>
get "typeData"(): $Map<(StringJS), (any)>
get "key"(): $ResourceKey<($Block)>
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $BlockProviderKJS implements $BlockProviderKJS$$Interface {
 "getId"(): StringJS
 "getBlock"(): $Block
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "getRegistry"(): $Registry<($Block)>
 "asHolder"(): $Holder<($Block)>
 "getTypeData"(): $Map<(StringJS), (any)>
 "getKey"(): $ResourceKey<($Block)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getMod"(): StringJS
 "getIdLocation"(): $ResourceLocation
 "getTagKeys"(): $List<($TagKey<($Block)>)>
 "getTags"(): $List<($ResourceLocation)>
 "specialEquals"(o: any, shallow: boolean): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockProviderKJS$$Type = (() => $Block$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockProviderKJS$$Original = $BlockProviderKJS;}
declare module "dev.latvian.mods.kubejs.block.custom.FallingBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $FallingBlockBuilder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "dustColor"(color: $KubeColor$$Type): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FallingBlockBuilder$$Type = ($FallingBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FallingBlockBuilder$$Original = $FallingBlockBuilder;}
declare module "dev.latvian.mods.kubejs.item.custom.HandheldItemBuilder" {
import {$MutableToolTier$$Type} from "dev.latvian.mods.kubejs.item.MutableToolTier"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ItemBuilder} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier$$Type} from "net.minecraft.world.item.Tier"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $HandheldItemBuilder extends $ItemBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type, d: float, s: float)

/**
 * Sets the attack speed of the tool.
 */
public "speed"(f: float): this
/**
 * Sets the base attack speed of the tool. Different tools have different baselines.
 * 
 * For example, a sword has a baseline of -2.4, while an axe has a baseline of -3.1.
 * 
 * The actual speed is the sum of the baseline and the speed from tier + 4 (bare hand).
 */
public "speedBaseline"(f: float): this
/**
 * Sets the attack damage bonus of the tool.
 */
public "attackDamageBonus"(f: float): this
public "tier"(t: $Tier$$Type): this
/**
 * Modifies the tool tier.
 */
public "modifyTier"(callback: $Consumer$$Type<($MutableToolTier)>): this
/**
 * Sets the base attack damage of the tool. Different tools have different baselines.
 * 
 * For example, a sword has a baseline of 3, while an axe has a baseline of 6.
 * 
 * The actual damage is the sum of the baseline and the attackDamageBonus from tier.
 */
public "attackDamageBaseline"(f: float): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandheldItemBuilder$$Type = ($HandheldItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HandheldItemBuilder$$Original = $HandheldItemBuilder;}
declare module "dev.latvian.mods.kubejs.core.BlockKJS" {
import {$Map} from "java.util.Map"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$BlockBuilderProvider$$Interface} from "dev.latvian.mods.kubejs.core.BlockBuilderProvider"
import {$BlockBuilder, $BlockBuilder$$Type} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$List} from "java.util.List"
import {$SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Holder} from "net.minecraft.core.Holder"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBehaviourKJS$$Interface} from "dev.latvian.mods.kubejs.core.BlockBehaviourKJS"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RandomTickCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$BlockState} from "net.minecraft.world.level.block.state.BlockState"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $BlockKJS$$Interface extends $BlockBuilderProvider$$Interface, $BlockBehaviourKJS$$Interface, $Replaceable$$Interface {
set "blockBuilder"(value: $BlockBuilder$$Type)
get "block"(): $Block
get "blockStates"(): $List<($BlockState)>
set "nameKey"(value: StringJS)
set "destroySpeed"(value: float)
set "requiresTool"(value: boolean)
set "lightEmission"(value: integer)
get "blockBuilder"(): $BlockBuilder
set "speedFactor"(value: float)
set "soundType"(value: $SoundType$$Type)
set "friction"(value: float)
set "jumpFactor"(value: float)
set "explosionResistance"(value: float)
set "randomTickCallback"(value: $Consumer$$Type<($RandomTickCallback)>)
set "hasCollision"(value: boolean)
set "isRandomlyTicking"(value: boolean)
get "id"(): StringJS
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "registry"(): $Registry<($Block)>
get "typeData"(): $Map<(StringJS), (any)>
get "key"(): $ResourceKey<($Block)>
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $BlockKJS implements $BlockKJS$$Interface {
 "setBlockBuilder"(b: $BlockBuilder$$Type): void
 "getBlock"(): $Block
 "getBlockStates"(): $List<($BlockState)>
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "setNameKey"(key: StringJS): void
 "setDestroySpeed"(v: float): void
 "setRequiresTool"(v: boolean): void
 "setLightEmission"(v: integer): void
 "getBlockBuilder"(): $BlockBuilder
 "setSpeedFactor"(v: float): void
 "setSoundType"(v: $SoundType$$Type): void
 "setFriction"(v: float): void
 "setJumpFactor"(v: float): void
 "setExplosionResistance"(v: float): void
 "setRandomTickCallback"(callback: $Consumer$$Type<($RandomTickCallback)>): void
 "setHasCollision"(v: boolean): void
 "setIsRandomlyTicking"(v: boolean): void
 "getId"(): StringJS
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "getRegistry"(): $Registry<($Block)>
 "asHolder"(): $Holder<($Block)>
 "getTypeData"(): $Map<(StringJS), (any)>
 "getKey"(): $ResourceKey<($Block)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getMod"(): StringJS
 "getIdLocation"(): $ResourceLocation
 "getTagKeys"(): $List<($TagKey<($Block)>)>
 "getTags"(): $List<($ResourceLocation)>
 "specialEquals"(o: any, shallow: boolean): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockKJS$$Type = ($BlockKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockKJS$$Original = $BlockKJS;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$DataComponentSubtypes" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Record} from "java.lang.Record"

export class $ItemData$DataComponentSubtypes extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData$DataComponentSubtypes)>

constructor(filter: $Ingredient$$Type, components: $List$$Type<($DataComponentType$$Type<(never)>)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $Ingredient
public "components"(): $List<($DataComponentType<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$DataComponentSubtypes$$Type = ({"filter"?: $Ingredient$$Type, "components"?: $List$$Type<($DataComponentType$$Type<(never)>)>}) | ([filter?: $Ingredient$$Type, components?: $List$$Type<($DataComponentType$$Type<(never)>)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemData$DataComponentSubtypes$$Original = $ItemData$DataComponentSubtypes;}
declare module "dev.latvian.mods.kubejs.player.KubeJSInventoryListener" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ContainerListener$$Interface} from "net.minecraft.world.inventory.ContainerListener"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"

export class $KubeJSInventoryListener implements $ContainerListener$$Interface {
readonly "player": $Player

constructor(p: $Player$$Type)

public "slotChanged"(container: $AbstractContainerMenu$$Type, index: integer, stack: $ItemStack$$Type): void
public "dataChanged"(container: $AbstractContainerMenu$$Type, id: integer, value: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSInventoryListener$$Type = ($KubeJSInventoryListener);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSInventoryListener$$Original = $KubeJSInventoryListener;}
declare module "dev.latvian.mods.kubejs.entity.CheckLivingEntitySpawnKubeEvent" {
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MobSpawnType, $MobSpawnType$$Type} from "net.minecraft.world.entity.MobSpawnType"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Either$$Type} from "com.mojang.datafixers.util.Either"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$WrappedSpawner} from "dev.latvian.mods.kubejs.level.WrappedSpawner"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked before an entity is spawned into the world.
 * 
 * Only entities from a `BaseSpawner` or world generation will trigger this event.
 */
export class $CheckLivingEntitySpawnKubeEvent implements $KubeLivingEntityEvent$$Interface {
readonly "x": double
readonly "y": double
readonly "z": double

constructor(entity: $LivingEntity$$Type, level: $Level$$Type, x: double, y: double, z: double, type: $MobSpawnType$$Type, spawnerEither: $Either$$Type<($BlockEntity$$Type), ($Entity$$Type)>)

/**
 * The type of spawn.
 */
public "getType"(): $MobSpawnType
/**
 * The level the entity is being spawned into.
 */
public "getLevel"(): $Level
/**
 * The spawner that spawned the entity.
 */
public "getSpawner"(): $WrappedSpawner
/**
 * The block the entity is being spawned on.
 */
public "getBlock"(): $LevelBlock
/**
 * The entity being spawned.
 */
public "getEntity"(): $LivingEntity
public "getPlayer"(): $Player
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "type"(): $MobSpawnType
get "level"(): $Level
get "spawner"(): $WrappedSpawner
get "block"(): $LevelBlock
get "entity"(): $LivingEntity
get "player"(): $Player
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CheckLivingEntitySpawnKubeEvent$$Type = ($CheckLivingEntitySpawnKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CheckLivingEntitySpawnKubeEvent$$Original = $CheckLivingEntitySpawnKubeEvent;}
declare module "dev.latvian.mods.kubejs.util.RegistryOpsContainer" {
import {$OpsContainer} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$DynamicOps} from "com.mojang.serialization.DynamicOps"
import {$RegistryOps, $RegistryOps$$Type} from "net.minecraft.resources.RegistryOps"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"

export class $RegistryOpsContainer extends $OpsContainer {
static readonly "DEFAULT": $OpsContainer

constructor(nbt: $RegistryOps$$Type<($Tag$$Type)>, json: $RegistryOps$$Type<($JsonElement$$Type)>, java: $RegistryOps$$Type<(any)>)

public "java"(): $DynamicOps
public "json"(): $DynamicOps
public "nbt"(): $RegistryOps<($Tag)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryOpsContainer$$Type = ($RegistryOpsContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryOpsContainer$$Original = $RegistryOpsContainer;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.SubtypeInterpreter" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $SubtypeInterpreter$$Interface {

(entry: any): any
}

export class $SubtypeInterpreter implements $SubtypeInterpreter$$Interface {
 "apply"(entry: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SubtypeInterpreter$$Type = ((entry: any) => any);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SubtypeInterpreter$$Original = $SubtypeInterpreter;}
declare module "dev.latvian.mods.kubejs.core.MinecraftServerKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$EntityCollectionKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityCollectionKJS"
import {$AdvancementNode} from "net.minecraft.advancements.AdvancementNode"
import {$WithAttachedData$$Interface} from "dev.latvian.mods.kubejs.core.WithAttachedData"
import {$UUID, $UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$ScheduledEvents} from "dev.latvian.mods.kubejs.util.ScheduledEvents"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$WithPersistentData$$Interface} from "dev.latvian.mods.kubejs.core.WithPersistentData"
import {$MinecraftEnvironmentKJS$$Interface} from "dev.latvian.mods.kubejs.core.MinecraftEnvironmentKJS"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$TemporalAmount$$Type} from "java.time.temporal.TemporalAmount"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$ScheduledEvents$ScheduledEvent} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$AttachedData} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$PlayerSelector$$Type} from "dev.latvian.mods.kubejs.core.PlayerSelector"
import {$ScheduledEvents$Callback$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback"
import {$ServerLevel} from "net.minecraft.server.level.ServerLevel"
import {$ServerPlayer} from "net.minecraft.server.level.ServerPlayer"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$DataSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.DataSenderKJS"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $MinecraftServerKJS$$Interface extends $WithAttachedData$$Interface<($MinecraftServer)>, $WithPersistentData$$Interface, $DataSenderKJS$$Interface, $MinecraftEnvironmentKJS$$Interface, $EntityCollectionKJS$$Interface {
get "overworld"(): $ServerLevel
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "players"(): $EntityArrayList
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "name"(): $Component
get "data"(): $AttachedData<($MinecraftServer)>
get "persistentData"(): $CompoundTag
get "scheduledEvents"(): $ScheduledEvents
get "entities"(): $EntityArrayList
get "displayName"(): $Component
}

export class $MinecraftServerKJS implements $MinecraftServerKJS$$Interface {
 "getOverworld"(): $ServerLevel
 "restoreInventories"(): $Map<($UUID), ($Map<(integer), ($ItemStack)>)>
 "getAdvancement"(id: $ResourceLocation$$Type): $AdvancementNode
 "getLevel"(dimension: $ResourceLocation$$Type): $ServerLevel
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "getPlayer"(selector: $PlayerSelector$$Type): $ServerPlayer
 "tell"(message: $Component$$Type): void
 "self"(): $MinecraftServer
 "getPlayers"(): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getMcPlayers"(): $List<($Player)>
 "getName"(): $Component
 "runCommand"(command: StringJS): void
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
 "getData"(): $AttachedData<($MinecraftServer)>
 "getPersistentData"(): $CompoundTag
 "sendData"(channel: StringJS): void
 "scheduleRepeating"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeatingInTicks"(ticks: $TickDuration$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "schedule"(timer: $TemporalAmount$$Type, callback: $ScheduledEvents$Callback$$Type): $ScheduledEvents$ScheduledEvent
 "getScheduledEvents"(): $ScheduledEvents
 "getEntities"(): $EntityArrayList
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftServerKJS$$Type = ($MinecraftServerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MinecraftServerKJS$$Original = $MinecraftServerKJS;}
declare module "dev.latvian.mods.kubejs.item.JukeboxSongBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$JukeboxSong} from "net.minecraft.world.item.JukeboxSong"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export class $JukeboxSongBuilder extends $BuilderBase<($JukeboxSong)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

public "comparatorOutput"(comparatorOutput: integer): this
public "description"(description: $Component$$Type): this
public "song"(sound: $Holder$$Type<($SoundEvent)>, length: float): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JukeboxSongBuilder$$Type = ($JukeboxSongBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JukeboxSongBuilder$$Original = $JukeboxSongBuilder;}
declare module "dev.latvian.mods.kubejs.entity.AttributeBuilder$Range" {
import {$Record} from "java.lang.Record"

export class $AttributeBuilder$Range extends $Record {
constructor(defaultValue: double, min: double, max: double)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "min"(): double
public "max"(): double
public "defaultValue"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributeBuilder$Range$$Type = ({"min"?: double, "max"?: double, "defaultValue"?: double}) | ([min?: double, max?: double, defaultValue?: double]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttributeBuilder$Range$$Original = $AttributeBuilder$Range;}
declare module "dev.latvian.mods.kubejs.recipe.component.ListRecipeComponent" {
import {$TinyMap} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$IntBounds, $IntBounds$$Type} from "dev.latvian.mods.kubejs.util.IntBounds"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$List, $List$$Type} from "java.util.List"
import {$ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$RecipeComponent, $RecipeComponent$$Type, $RecipeComponent$$Interface} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeKey} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$RecipeComponentType} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"
import {$OpsContainer$$Type} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$CustomObjectRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent"
import {$EitherRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent"
import {$CustomObjectRecipeComponent$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$RecipeComponentBuilder} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder"
import {$KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$Record} from "java.lang.Record"

export class $ListRecipeComponent<T> extends $Record implements $RecipeComponent$$Interface<($List<(T)>)> {
static readonly "TYPE": $RecipeComponentType<(never)>

constructor(component: $RecipeComponent$$Type<(T)>, canWriteSelf: boolean, listTypeInfo: $TypeInfo$$Type, listCodec: $Codec$$Type<($List$$Type<(T)>)>, conditional: boolean, bounds: $IntBounds$$Type, spread: ($RecipeComponent$$Type<(never)>)?, spreadWrap: ($RecipeComponent$$Type<(never)>)?)

public "type"(): $RecipeComponentType<(never)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "wrap"(cx: $RecipeScriptContext$$Type, from: any): $List<(T)>
public "isEmpty"(value: any): boolean
public "isEmpty"(value: $List$$Type<(T)>): boolean
public "replace"(cx: $RecipeScriptContext$$Type, original: $List$$Type<(T)>, match: $ReplacementMatchInfo$$Type, arg3: any): $List<(T)>
public "replace"(cx: $RecipeScriptContext$$Type, original: any, match: $ReplacementMatchInfo$$Type, arg3: any): any
public "matches"(cx: $RecipeMatchContext$$Type, value: $List$$Type<(T)>, match: $ReplacementMatchInfo$$Type): boolean
public "matches"(cx: $RecipeMatchContext$$Type, value: any, match: $ReplacementMatchInfo$$Type): boolean
public "validate"(ctx: $RecipeValidationContext$$Type, value: $List$$Type<(T)>): void
public "validate"(ctx: $RecipeValidationContext$$Type, value: any): void
public "component"(): $RecipeComponent<(T)>
public "bounds"(): $IntBounds
public "typeInfo"(): $TypeInfo
public static "create"<L>(component: $RecipeComponent$$Type<(L)>, canWriteSelf: boolean, conditional: boolean, bounds: $IntBounds$$Type, spread: ($RecipeComponent$$Type<(never)>)?): $ListRecipeComponent<(L)>
public static "create"<L>(component: $RecipeComponent$$Type<(L)>, canWriteSelf: boolean, conditional: boolean): $ListRecipeComponent<(L)>
public "spread"(): $Optional<($RecipeComponent<(never)>)>
public "spread"(value: $List$$Type<(T)>): $List<(never)>
public "spread"(value: any): $List
public "allowEmpty"(): boolean
public "listCodec"(): $Codec<($List<(T)>)>
public "orSelf"(): $RecipeComponent
public "codec"(): $Codec<($List<(T)>)>
public "conditional"(): boolean
public "withBounds"(bounds: $IntBounds$$Type): $ListRecipeComponent<(T)>
public "hasPriority"(cx: $RecipeMatchContext$$Type, from: any): boolean
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, value: $List$$Type<(T)>): void
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, value: any): void
public "listTypeInfo"(): $TypeInfo
public "canWriteSelf"(): boolean
public "asConditional"(): $ListRecipeComponent<(T)>
public static "wrap0"<T>(cx: $RecipeScriptContext$$Type, component: $RecipeComponent$$Type<(T)>, from: any): $List<(T)>
public "withSpread"(spread: ($RecipeComponent$$Type<(never)>)?): $ListRecipeComponent<(T)>
public "spreadWrap"(): $Optional<($RecipeComponent<(never)>)>
public "toString"(ops: $OpsContainer$$Type, value: $List$$Type<(T)>): StringJS
public static "builder"(keys: $List$$Type<($CustomObjectRecipeComponent$Key$$Type)>): $CustomObjectRecipeComponent
public static "builder"(...keys: ($CustomObjectRecipeComponent$Key$$Type)[]): $CustomObjectRecipeComponent
public "key"(name: StringJS, role: $ComponentRole$$Type): $RecipeKey<($List<(T)>)>
public "asList"(): $ListRecipeComponent<($List<(T)>)>
public "or"<O>(other: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<($List<(T)>), (O)>
public "createBuilder"(): $RecipeComponentBuilder
public "asConditionalListOrSelf"(): $ListRecipeComponent<($List<(T)>)>
public "asMap"<K>(key: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($List<(T)>)>)>
public "otherKey"(name: StringJS): $RecipeKey<($List<(T)>)>
public "inputKey"(name: StringJS): $RecipeKey<($List<(T)>)>
public "outputKey"(name: StringJS): $RecipeKey<($List<(T)>)>
public "readFromJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($List$$Type<(T)>)>, json: $JsonObject$$Type): void
public "writeToJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($List$$Type<(T)>)>, json: $JsonObject$$Type): void
public "asListOrSelf"(): $ListRecipeComponent<($List<(T)>)>
public "asConditionalList"(): $ListRecipeComponent<($List<(T)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($List<(T)>)>)>
public "isIgnored"(): boolean
public "withCodec"(codec: $Codec$$Type<($List$$Type<(T)>)>): $RecipeComponent<($List<(T)>)>
get "ignored"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListRecipeComponent$$Type<T> = ({"component"?: $RecipeComponent$$Type<(T)>, "spreadWrap"?: ($RecipeComponent$$Type<(never)>)?, "spread"?: ($RecipeComponent$$Type<(never)>)?, "bounds"?: $IntBounds$$Type, "listTypeInfo"?: $TypeInfo$$Type, "conditional"?: boolean, "listCodec"?: $Codec$$Type<($List$$Type<(T)>)>, "canWriteSelf"?: boolean}) | ([component?: $RecipeComponent$$Type<(T)>, spreadWrap?: ($RecipeComponent$$Type<(never)>)?, spread?: ($RecipeComponent$$Type<(never)>)?, bounds?: $IntBounds$$Type, listTypeInfo?: $TypeInfo$$Type, conditional?: boolean, listCodec?: $Codec$$Type<($List$$Type<(T)>)>, canWriteSelf?: boolean]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ListRecipeComponent$$Original<T> = $ListRecipeComponent<(T)>;}
declare module "dev.latvian.mods.kubejs.core.ContainerKJS" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Container} from "net.minecraft.world.Container"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$List} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$InventoryKJS$$Interface} from "dev.latvian.mods.kubejs.core.InventoryKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ContainerKJS$$Interface extends $InventoryKJS$$Interface {
get "height"(): integer
get "width"(): integer
get "changed"(): void
get "mutable"(): boolean
get "slots"(): integer
get "allItems"(): $List<($ItemStack)>
get "empty"(): boolean
}

export class $ContainerKJS implements $ContainerKJS$$Interface {
 "getBlock"(level: $Level$$Type): $LevelBlock
 "getHeight"(): integer
 "getWidth"(): integer
 "asContainer"(): $Container
 "insertItem"(slot: integer, stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "setChanged"(): void
 "isMutable"(): boolean
 "getSlotLimit"(slot: integer): integer
 "isItemValid"(slot: integer, stack: $ItemStack$$Type): boolean
 "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
 "getStackInSlot"(slot: integer): $ItemStack
 "getSlots"(): integer
 "setStackInSlot"(slot: integer, stack: $ItemStack$$Type): void
 "self"(): $Container
 "clear"(): void
 "insertItem"(stack: $ItemStack$$Type, simulate: boolean): $ItemStack
 "getAllItems"(): $List<($ItemStack)>
 "countNonEmpty"(match: $ItemPredicate$$Type): integer
 "countNonEmpty"(): integer
 "isEmpty"(): boolean
 "count"(match: $ItemPredicate$$Type): integer
 "count"(): integer
 "clear"(match: $ItemPredicate$$Type): void
 "find"(match: $ItemPredicate$$Type): integer
 "find"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContainerKJS$$Type = ($ContainerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ContainerKJS$$Original = $ContainerKJS;}
declare module "dev.latvian.mods.kubejs.client.KubeAnimatedParticle" {
import {$Float2IntFunction$$Type} from "it.unimi.dsi.fastutil.floats.Float2IntFunction"
import {$ClientLevel, $ClientLevel$$Type} from "net.minecraft.client.multiplayer.ClientLevel"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$SimpleAnimatedParticle} from "net.minecraft.client.particle.SimpleAnimatedParticle"
import {$SpriteSet, $SpriteSet$$Type} from "net.minecraft.client.particle.SpriteSet"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $KubeAnimatedParticle extends $SimpleAnimatedParticle {
 "bCol": float
 "gCol": float
 "x": double
 "y": double
 "z": double
 "zd": double
 "rCol": float
 "yd": double
 "xd": double
 "age": integer

constructor(level: $ClientLevel$$Type, x: double, y: double, z: double, sprites: $SpriteSet$$Type)

public "getX"(): double
public "getZ"(): double
public "getRandom"(): $RandomSource
public "setSpeed"(speed: $Vec3$$Type): void
public "tick"(): void
public "setColor"(color: $KubeColor$$Type): void
public "setColor"(color: $KubeColor$$Type, alpha: boolean): void
public "getLevel"(): $ClientLevel
public "getY"(): double
public "onTick"(tick: $Consumer$$Type<($KubeAnimatedParticle)>): void
public "getLightColor"(partialTick: float): integer
public "getXSpeed"(): double
public "setGravity"(g: float): void
public "getYSpeed"(): double
public "getZSpeed"(): double
public "getSpriteSet"(): $SpriteSet
public "setFasterWhenYMotionBlocked"(b: boolean): void
/**
 * Sets teh friction of the particle, the particle's motion is multiplied by this value every tick
 */
public "setFriction"(f: float): void
public "setLightColor"(arg0: $Float2IntFunction$$Type): void
public "setPhysicality"(hasPhysics: boolean): void
get "random"(): $RandomSource
set "speed"(value: $Vec3$$Type)
set "color"(value: $KubeColor$$Type)
get "level"(): $ClientLevel
get "XSpeed"(): double
set "gravity"(value: float)
get "YSpeed"(): double
get "ZSpeed"(): double
get "spriteSet"(): $SpriteSet
set "fasterWhenYMotionBlocked"(value: boolean)
set "friction"(value: float)
set "lightColor"(value: $Float2IntFunction$$Type)
set "physicality"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeAnimatedParticle$$Type = ($KubeAnimatedParticle);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeAnimatedParticle$$Original = $KubeAnimatedParticle;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Leggings" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ArmorItemBuilder} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ArmorItemBuilder$Leggings extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "LEGGING_TAGS": ($ResourceLocation)[]
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Leggings$$Type = ($ArmorItemBuilder$Leggings);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$Leggings$$Original = $ArmorItemBuilder$Leggings;}
declare module "dev.latvian.mods.kubejs.core.AdvancementNodeKJS" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$DisplayInfo} from "net.minecraft.advancements.DisplayInfo"
import {$AdvancementNode, $AdvancementNode$$Type} from "net.minecraft.advancements.AdvancementNode"
import {$Set} from "java.util.Set"
import {$Component} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $AdvancementNodeKJS$$Interface {
get "id"(): $ResourceLocation
get "children"(): $Set<($AdvancementNode)>
get "description"(): $Component
get "parent"(): $AdvancementNode
get "displayText"(): $Component
get "display"(): $DisplayInfo
get "title"(): $Component
}

export class $AdvancementNodeKJS implements $AdvancementNodeKJS$$Interface {
 "getId"(): $ResourceLocation
 "self"(): $AdvancementNode
 "getChildren"(): $Set<($AdvancementNode)>
 "getDescription"(): $Component
 "hasDisplay"(): boolean
 "getParent"(): $AdvancementNode
 "getDisplayText"(): $Component
 "getDisplay"(): $DisplayInfo
 "addChild"(a: $AdvancementNode$$Type): void
 "getTitle"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdvancementNodeKJS$$Type = ($AdvancementNodeKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AdvancementNodeKJS$$Original = $AdvancementNodeKJS;}
declare module "dev.latvian.mods.kubejs.client.BlockEntityRendererRegistryKubeEvent" {
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$BlockEntityType$$Type} from "net.minecraft.world.level.block.entity.BlockEntityType"
import {$BlockEntityRendererProvider$$Type} from "net.minecraft.client.renderer.blockentity.BlockEntityRendererProvider"
import {$EntityRenderersEvent$RegisterRenderers$$Type} from "net.neoforged.neoforge.client.event.EntityRenderersEvent$RegisterRenderers"
import {$Minecraft} from "net.minecraft.client.Minecraft"

export class $BlockEntityRendererRegistryKubeEvent implements $ClientKubeEvent$$Interface {
constructor(event: $EntityRenderersEvent$RegisterRenderers$$Type)

public "register"(type: $BlockEntityType$$Type<(never)>, renderer: $BlockEntityRendererProvider$$Type): void
public "getClient"(): $Minecraft
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityRendererRegistryKubeEvent$$Type = ($BlockEntityRendererRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityRendererRegistryKubeEvent$$Original = $BlockEntityRendererRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.drop.BlockDropSupplier" {
import {$BlockDrops, $BlockDrops$$Type} from "dev.latvian.mods.kubejs.block.drop.BlockDrops"

export interface $BlockDropSupplier$$Interface {

(): $BlockDrops$$Type
}

export class $BlockDropSupplier implements $BlockDropSupplier$$Interface {
static readonly "NO_DROPS": $BlockDropSupplier

 "get"(): $BlockDrops
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockDropSupplier$$Type = (() => $BlockDrops$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockDropSupplier$$Original = $BlockDropSupplier;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.RegistryWrapper" {
import {$Iterator} from "java.util.Iterator"
import {$Iterable$$Interface} from "java.lang.Iterable"
import {$Map} from "java.util.Map"
import {$Spliterator} from "java.util.Spliterator"
import {$List} from "java.util.List"
import {$DataMapWrapper} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.DataMapWrapper"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Map$Entry} from "java.util.Map$Entry"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$RandomSource$$Type} from "net.minecraft.util.RandomSource"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$HolderSetWrapper} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.HolderSetWrapper"
import {$Set} from "java.util.Set"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $RegistryWrapper<T> extends $Record implements $Iterable$$Interface<(T)> {
constructor(registry: $Registry$$Type<(T)>, unknownKey: $ResourceKey$$Type<(T)>)

public "getRandom"(): T
public "getRandom"(random: $RandomSource$$Type): T
public "get"(id: $ResourceLocation$$Type): T
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "iterator"(): $Iterator
public static "of"(id: $ResourceLocation$$Type): $RegistryWrapper<(never)>
public "contains"(id: $ResourceLocation$$Type): boolean
public "getKey"(value: T): $ResourceKey<(T)>
public static "access"(): $RegistryAccessContainer
public "getId"(value: T): $ResourceLocation
public "containsValue"(value: T): boolean
public "getKeys"(): $Set<($ResourceLocation)>
public "getDataMap"(id: $ResourceLocation$$Type): $DataMapWrapper<(T), (never)>
public "getValues"(): $List<(T)>
public "getValues"(filter: any): $HolderSetWrapper<(T)>
public "registry"(): $Registry<(T)>
public "unknownKey"(): $ResourceKey<(T)>
public "getEntrySet"(): $Set<($Map$Entry<($ResourceLocation), (T)>)>
public "getValueMap"(): $Map<($ResourceLocation), (T)>
public "spliterator"(): $Spliterator<(T)>
public "forEach"(arg0: $Consumer$$Type<(T)>): void
get "random"(): T
get "keys"(): $Set<($ResourceLocation)>
get "values"(): $List<(T)>
get "entrySet"(): $Set<($Map$Entry<($ResourceLocation), (T)>)>
get "valueMap"(): $Map<($ResourceLocation), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryWrapper$$Type<T> = ({"registry"?: $Registry$$Type<(T)>, "unknownKey"?: $ResourceKey$$Type<(T)>}) | ([registry?: $Registry$$Type<(T)>, unknownKey?: $ResourceKey$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryWrapper$$Original<T> = $RegistryWrapper<(T)>;}
declare module "dev.latvian.mods.kubejs.item.ItemModificationKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemModificationKubeEvent$ItemModifications$$Type} from "dev.latvian.mods.kubejs.item.ItemModificationKubeEvent$ItemModifications"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Consumer$$Type} from "java.util.function.Consumer"

/**
 * Invoked after all items are registered to modify them.
 */
export class $ItemModificationKubeEvent implements $KubeEvent$$Interface {
constructor()

/**
 * Modifies items matching the given ingredient.
 * 
 * **NOTE**: tag ingredients are not supported at this time.
 */
public "modify"(arg0: $ItemPredicate$$Type, c: $Consumer$$Type<($ItemModificationKubeEvent$ItemModifications)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModificationKubeEvent$$Type = ($ItemModificationKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemModificationKubeEvent$$Original = $ItemModificationKubeEvent;}
declare module "dev.latvian.mods.kubejs.generator.KubeResourceGenerator" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $KubeResourceGenerator$$Interface extends $KubeEvent$$Interface {
get "registries"(): $RegistryAccessContainer
}

export class $KubeResourceGenerator implements $KubeResourceGenerator$$Interface {
 "flush"(): void
 "add"(data: $GeneratedData$$Type): void
 "text"(id: $ResourceLocation$$Type, content: StringJS): void
 "json"(id: $ResourceLocation$$Type, json: $JsonElement$$Type): void
 "getRegistries"(): $RegistryAccessContainer
 "getGenerated"(id: $ResourceLocation$$Type): $GeneratedData
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeResourceGenerator$$Type = ($KubeResourceGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeResourceGenerator$$Original = $KubeResourceGenerator;}
declare module "dev.latvian.mods.kubejs.script.ScriptPack" {
import {$List} from "java.util.List"
import {$ScriptFile} from "dev.latvian.mods.kubejs.script.ScriptFile"
import {$ScriptPackInfo, $ScriptPackInfo$$Type} from "dev.latvian.mods.kubejs.script.ScriptPackInfo"
import {$ScriptManager, $ScriptManager$$Type} from "dev.latvian.mods.kubejs.script.ScriptManager"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptPack {
readonly "manager": $ScriptManager
readonly "scripts": $List<($ScriptFile)>
readonly "info": $ScriptPackInfo

constructor(m: $ScriptManager$$Type, i: $ScriptPackInfo$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptPack$$Type = ($ScriptPack);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptPack$$Original = $ScriptPack;}
declare module "dev.latvian.mods.kubejs.core.PlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$WithAttachedData$$Interface} from "dev.latvian.mods.kubejs.core.WithAttachedData"
import {$KubeJSInventoryListener} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Stages} from "dev.latvian.mods.kubejs.stages.Stages"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$LivingEntityKJS$$Interface} from "dev.latvian.mods.kubejs.core.LivingEntityKJS"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$EntityPotionEffectsJS} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$DataSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.DataSenderKJS"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $PlayerKJS$$Interface extends $LivingEntityKJS$$Interface, $DataSenderKJS$$Interface, $WithAttachedData$$Interface<($Player)> {

(): $AttachedData$$Type<($Player$$Type)>
get "openInventory"(): $AbstractContainerMenu
get "selectedSlot"(): integer
get "craftingGrid"(): $InventoryKJS
set "selectedSlot"(value: integer)
get "profile"(): $GameProfile
get "player"(): boolean
get "foodLevel"(): integer
set "foodLevel"(value: integer)
get "saturation"(): float
get "stats"(): $PlayerStatsJS
set "saturation"(value: float)
set "xpLevel"(value: integer)
get "xpLevel"(): integer
get "stages"(): $Stages
get "miningBlock"(): boolean
get "inventory"(): $InventoryKJS
get "mouseItem"(): $ItemStack
set "mouseItem"(value: $ItemStack$$Type)
set "statusMessage"(value: $Component$$Type)
get "inventoryChangeListener"(): $KubeJSInventoryListener
get "fake"(): boolean
set "xp"(value: integer)
get "xp"(): integer
set "headArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
get "legsArmorItem"(): $ItemStack
set "mainHandItem"(value: $ItemStack$$Type)
set "chestArmorItem"(value: $ItemStack$$Type)
set "legsArmorItem"(value: $ItemStack$$Type)
get "mainHandItem"(): $ItemStack
get "headArmorItem"(): $ItemStack
get "feetArmorItem"(): $ItemStack
get "potionEffects"(): $EntityPotionEffectsJS
set "feetArmorItem"(value: $ItemStack$$Type)
get "totalMovementSpeed"(): double
get "reachDistance"(): double
get "living"(): boolean
get "undead"(): boolean
set "maxHealth"(value: float)
get "offHandItem"(): $ItemStack
set "offHandItem"(value: $ItemStack$$Type)
set "defaultMovementSpeed"(value: double)
set "movementSpeedAddition"(value: double)
get "defaultMovementSpeed"(): double
set "totalMovementSpeedMultiplier"(value: double)
set "defaultMovementSpeedMultiplier"(value: double)
get "data"(): $AttachedData<($Player)>
get "nbt"(): $CompoundTag
set "z"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "x"(value: double)
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
get "level"(): $Level
get "type"(): StringJS
set "motionX"(value: double)
get "teamId"(): StringJS
set "motionY"(value: double)
get "server"(): $MinecraftServer
get "motionZ"(): double
get "motionX"(): double
get "passengers"(): $EntityArrayList
get "facing"(): $Direction
get "animal"(): boolean
get "item"(): $ItemStack
set "position"(value: $LevelBlock$$Type)
set "motionZ"(value: double)
get "scriptType"(): $ScriptType
get "frame"(): boolean
get "motionY"(): double
get "block"(): $LevelBlock
get "monster"(): boolean
get "name"(): $Component
get "displayName"(): $Component
set "activePostShader"(value: $ResourceLocation$$Type)
get "persistentData"(): $CompoundTag
}

export class $PlayerKJS implements $PlayerKJS$$Interface {
 "spawn"(): void
 "boostElytraFlight"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "getSelectedSlot"(): integer
 "sendInventoryUpdate"(): void
 "getCraftingGrid"(): $InventoryKJS
 "setSelectedSlot"(index: integer): void
 "addItemCooldown"(item: $Item$$Type, ticks: integer): void
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "getFoodLevel"(): integer
 "setFoodLevel"(foodLevel: integer): void
 "getSaturation"(): float
 "getStats"(): $PlayerStatsJS
 "setSaturation"(saturation: float): void
 "addExhaustion"(exhaustion: float): void
 "addXPLevels"(l: integer): void
 "setXpLevel"(l: integer): void
 "getXpLevel"(): integer
 "getStages"(): $Stages
 "isMiningBlock"(): boolean
 "addFood"(f: integer, m: float): void
 "getInventory"(): $InventoryKJS
 "giveInHand"(item: $ItemStack$$Type): void
 "getMouseItem"(): $ItemStack
 "setMouseItem"(item: $ItemStack$$Type): void
 "setStatusMessage"(message: $Component$$Type): void
 "self"(): $Entity
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "isFake"(): boolean
 "setXp"(xp: integer): void
 "addXP"(xp: integer): void
 "give"(item: $ItemStack$$Type): void
 "getXp"(): integer
 "notify"(builder: $NotificationToastData$$Type): void
 "notify"(title: $Component$$Type, text: $Component$$Type): void
 "swing"(hand: $InteractionHand$$Type): void
 "swing"(): void
 "setHeadArmorItem"(item: $ItemStack$$Type): void
 "getChestArmorItem"(): $ItemStack
 "getLegsArmorItem"(): $ItemStack
 "isHoldingInAnyHand"(i: $ItemPredicate$$Type): boolean
 "setMainHandItem"(item: $ItemStack$$Type): void
 "setChestArmorItem"(item: $ItemStack$$Type): void
 "setLegsArmorItem"(item: $ItemStack$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$$Type): void
 "getMainHandItem"(): $ItemStack
 "getHeadArmorItem"(): $ItemStack
 "getFeetArmorItem"(): $ItemStack
 "getPotionEffects"(): $EntityPotionEffectsJS
 "setFeetArmorItem"(item: $ItemStack$$Type): void
 "getTotalMovementSpeed"(): double
 "canEntityBeSeen"(entity: $LivingEntity$$Type): boolean
 "getAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>): double
 "getAttributeTotalValue"(attribute: $Holder$$Type<($Attribute)>): double
 "setAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>, value: double): void
 "getReachDistance"(): double
 "modifyAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): void
 "removeAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): void
 "foodEaten"(is: $ItemStack$$Type, food: $FoodProperties$$Type): void
 "setEquipment"(slot: $EquipmentSlot$$Type, item: $ItemStack$$Type): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer): void
 "rayTrace"(): $KubeRayTraceResult
 "isLiving"(): boolean
 "isUndead"(): boolean
 "setMaxHealth"(hp: float): void
 "getHeldItem"(hand: $InteractionHand$$Type): $ItemStack
 "getOffHandItem"(): $ItemStack
 "setHeldItem"(hand: $InteractionHand$$Type, item: $ItemStack$$Type): void
 "setOffHandItem"(item: $ItemStack$$Type): void
 "rayTraceEntity"(filter: $Predicate$$Type<($Entity)>): $Entity
 "getEquipment"(slot: $EquipmentSlot$$Type): $ItemStack
 "setDefaultMovementSpeed"(speed: double): void
 "setMovementSpeedAddition"(speed: double): void
 "getDefaultMovementSpeed"(): double
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "sendData"(channel: StringJS): void
 "getData"(): $AttachedData<($Player)>
 "getNbt"(): $CompoundTag
 "attack"(hp: float): void
 "setZ"(z: double): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setX"(x: double): void
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "isAmbientCreature"(): boolean
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "getLevel"(): $Level
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "getType"(): StringJS
 "setMotionX"(x: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getTeamId"(): StringJS
 "setMotionY"(y: double): void
 "getServer"(): $MinecraftServer
 "getMotionZ"(): double
 "getMotionX"(): double
 "getPassengers"(): $EntityArrayList
 "getFacing"(): $Direction
 "setRotation"(yaw: float, pitch: float): void
 "isAnimal"(): boolean
 "getItem"(): $ItemStack
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "setPosition"(x: double, y: double, z: double): void
 "setPosition"(block: $LevelBlock$$Type): void
 "setMotionZ"(z: double): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getBlock"(): $LevelBlock
 "isMonster"(): boolean
 "runCommandSilent"(command: StringJS): void
 "tell"(message: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(command: StringJS): void
 "getDisplayName"(): $Component
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerKJS$$Original = $PlayerKJS;}
declare module "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Value" {
import {$CustomObjectRecipeComponent$Key, $CustomObjectRecipeComponent$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key"
import {$Comparable, $Comparable$$Interface} from "java.lang.Comparable"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$Map$Entry, $Map$Entry$$Type, $Map$Entry$$Interface} from "java.util.Map$Entry"
import {$Record} from "java.lang.Record"

export class $CustomObjectRecipeComponent$Value extends $Record implements $Map$Entry$$Interface<($CustomObjectRecipeComponent$Key), (any)>, $Comparable$$Interface<($CustomObjectRecipeComponent$Value)> {
constructor(key: $CustomObjectRecipeComponent$Key$$Type, index: integer, value: any)

public "index"(): integer
public "value"(): any
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "compareTo"(value: any): integer
public "compareTo"(value: $CustomObjectRecipeComponent$Value$$Type): integer
public "getValue"(): any
public "getKey"(): any
public "key"(): $CustomObjectRecipeComponent$Key
public "setValue"(object: any): any
public static "copyOf"<K, V>(arg0: $Map$Entry$$Type<($CustomObjectRecipeComponent$Key$$Type), (any)>): $Map$Entry<($CustomObjectRecipeComponent$Key), (any)>
public static "comparingByKey"<K, V>(arg0: $Comparator$$Type<($CustomObjectRecipeComponent$Key)>): $Comparator<($Map$Entry<($CustomObjectRecipeComponent$Key), (any)>)>
public static "comparingByKey"<K extends $Comparable<(object)>, V>(): $Comparator<($Map$Entry<($CustomObjectRecipeComponent$Key), (any)>)>
public static "comparingByValue"<K, V extends $Comparable<(object)>>(): $Comparator<($Map$Entry<($CustomObjectRecipeComponent$Key), (any)>)>
public static "comparingByValue"<K, V>(arg0: $Comparator$$Type<(any)>): $Comparator<($Map$Entry<($CustomObjectRecipeComponent$Key), (any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomObjectRecipeComponent$Value$$Type = ({"key"?: $CustomObjectRecipeComponent$Key$$Type, "value"?: any, "index"?: integer}) | ([key?: $CustomObjectRecipeComponent$Key$$Type, value?: any, index?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomObjectRecipeComponent$Value$$Original = $CustomObjectRecipeComponent$Value;}
declare module "dev.latvian.mods.kubejs.core.CustomIngredientKJS" {
import {$ItemStackSet} from "dev.latvian.mods.kubejs.item.ItemStackSet"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$ItemPredicate, $ItemPredicate$$Interface} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Set} from "java.util.Set"
import {$Stream} from "java.util.stream.Stream"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $CustomIngredientKJS$$Interface extends $ItemPredicate$$Interface {

(itemStack: $ItemStack): boolean
get "displayStacks"(): $ItemStackSet
get "items"(): $Stream<($ItemStack)>
get "stackArray"(): ($ItemStack)[]
get "wildcard"(): boolean
get "stacks"(): $ItemStackSet
get "itemTypes"(): $Set<($Item)>
get "first"(): $ItemStack
get "itemIds"(): $Set<(StringJS)>
get "itemStream"(): $Stream<($Item)>
}

export class $CustomIngredientKJS implements $CustomIngredientKJS$$Interface {
 "canBeUsedForMatching"(): boolean
 "getDisplayStacks"(): $ItemStackSet
 "getItems"(): $Stream<($ItemStack)>
 "getStackArray"(): ($ItemStack)[]
 "asIngredient"(): $Ingredient
 "test"(itemStack: any): boolean
 "test"(itemStack: $ItemStack$$Type): boolean
static "wrap"(from: any): $ItemPredicate
 "isWildcard"(): boolean
 "getStacks"(): $ItemStackSet
 "testItem"(item: $Item$$Type): boolean
 "getItemTypes"(): $Set<($Item)>
 "getFirst"(): $ItemStack
 "getItemIds"(): $Set<(StringJS)>
 "getItemStream"(): $Stream<($Item)>
 "or"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "not"<T>(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "isEqual"<T>(arg0: any): $Predicate<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomIngredientKJS$$Type = ((itemStack: $ItemStack) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomIngredientKJS$$Original = $CustomIngredientKJS;}
declare module "dev.latvian.mods.kubejs.block.BlockRightClickedKubeEvent" {
import {$BlockHitResult, $BlockHitResult$$Type} from "net.minecraft.world.phys.BlockHitResult"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player right clicks on a block.
 */
export class $BlockRightClickedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(item: $ItemStack$$Type, player: $Player$$Type, hand: $InteractionHand$$Type, pos: $BlockPos$$Type, direction: $Direction$$Type, hitResult: $BlockHitResult$$Type)

public "getHitResult"(): $BlockHitResult
/**
 * The position of the block that was right clicked.
 */
public "getItem"(): $ItemStack
/**
 * The hand that was used to right click the block.
 */
public "getHand"(): $InteractionHand
/**
 * The block that was right clicked.
 */
public "getBlock"(): $LevelBlock
/**
 * The player that right clicked the block.
 */
public "getEntity"(): $LivingEntity
/**
 * The face of the block being right clicked.
 */
public "getFacing"(): $Direction
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "hitResult"(): $BlockHitResult
get "item"(): $ItemStack
get "hand"(): $InteractionHand
get "block"(): $LevelBlock
get "entity"(): $LivingEntity
get "facing"(): $Direction
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRightClickedKubeEvent$$Type = ($BlockRightClickedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockRightClickedKubeEvent$$Original = $BlockRightClickedKubeEvent;}
declare module "dev.latvian.mods.kubejs.item.custom.SmithingTemplateItemBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$ItemBuilder} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $SmithingTemplateItemBuilder extends $ItemBuilder {
 "ingredientsText": $Component
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "appliesToText": $Component
readonly "ingredientsSlotEmptyIcons": $List<($ResourceLocation)>
 "appliesToSlotDescriptionText": $Component
readonly "appliesToEmptyIcons": $List<($ResourceLocation)>
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "ingredientSlotDescriptionText": $Component

constructor(i: $ResourceLocation$$Type)

/**
 * Sets the name for this smithing template.
 * Note that the normal display name for all smithing templates is the same and cannot be changed, this instead sets the name in the tooltip (see vanilla smithing templates for what this looks like).
 * 
 * This will be overridden by a lang file if it exists.
 */
public "displayName"(name: $Component$$Type): $BuilderBase
/**
 * Sets the description text that shows in the item tooltip to describe what ingredients can be added.
 * Using 'Ingots & Crystals' or 'Netherite Ingot' will use the vanilla language keys so it is translated into other languages automatically.
 * THIS IS PURELY VISUAL
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `ingredientsText` field.
 */
public "ingredients"(text: StringJS): this
/**
 * Sets the description text that shows in the item tooltip to describe what it can be applied to.
 * Using 'Armor' or 'Diamond Equipment' will use the vanilla language keys so it is translated into other languages automatically.
 * THIS IS PURELY VISUAL
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `ingredientsText` field.
 */
public "appliesTo"(text: StringJS): this
/**
 * Adds a dust, diamond, emerald, quartz, lapis lazuli and amethyst shard icons to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "crystalIcons"(): this
/**
 * Adds a chestplate to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "chestplateIcon"(): this
/**
 * Adds all armor and basic tool icons to the list of base slot icons that the smithing table cycles through when this smithing template is put in
 */
public "equipmentIcons"(): this
/**
 * Adds leggings to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "leggingsIcon"(): this
/**
 * Adds an emerald to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "emeraldIcon"(): this
/**
 * Adds a pickaxe to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "pickaxeIcon"(): this
/**
 * Adds a diamond to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "diamondIcon"(): this
/**
 * Adds all basic tool icons to the list of base slot icons that the smithing table cycles through when this smithing template is put in
 */
public "toolIcons"(): this
/**
 * Adds a dust to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "dustIcon"(): this
/**
 * Adds a sword to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "swordIcon"(): this
/**
 * Adds a quartz to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "quartzIcon"(): this
/**
 * Adds a helmet to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "helmetIcon"(): this
/**
 * Adds a axe to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "axeIcon"(): this
/**
 * Adds an ingot to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "ingotIcon"(): this
/**
 * Adds a lapis lazuli to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "lapisIcon"(): this
/**
 * Adds an amethyst shard to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "shardIcon"(): this
/**
 * Adds all armor icons to the list of base slot icons that the smithing table cycles through when this smithing template is put in
 */
public "armorIcons"(): this
/**
 * Adds a shovel to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "shovelIcon"(): this
/**
 * Adds boots to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "bootsIcon"(): this
/**
 * Adds a hoe to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "hoeIcon"(): this
/**
 * Adds the specified texture location to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "addIngredientsSlotIcon"(location: $ResourceLocation$$Type): this
/**
 * Adds the specified texture location to the list of base slot icons that the smithing table cycles through when this smithing template is put in.
 */
public "addAppliesToSlotIcon"(location: $ResourceLocation$$Type): this
/**
 * Adds an ingot, dust, diamond, emerald, quartz, lapis lazuli and amethyst shard icons to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "ingotAndCrystalIcons"(): this
/**
 * Sets the description text that shows when you hover over the ingredient slot when this item is put in smithing table as a template.
 * Using 'Add ingot or crystal' or 'Add Netherite Ingot' will use the vanilla language keys so it is translated into other languages automatically.
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `ingredientSlotDescriptionText` field.
 */
public "ingredientsSlotDescription"(text: StringJS): this
/**
 * Sets the description text that shows when you hover over the base item slot when this item is put in smithing table as a template.
 * Using 'Add a piece of armor' or 'Add diamond armor, weapon, or tool' will use the vanilla language keys so it is translated into other languages automatically.
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `appliesToSlotDescriptionText` field.
 */
public "appliesToSlotDescription"(text: StringJS): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmithingTemplateItemBuilder$$Type = ($SmithingTemplateItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SmithingTemplateItemBuilder$$Original = $SmithingTemplateItemBuilder;}
declare module "dev.latvian.mods.kubejs.item.DynamicItemTooltipsKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$TooltipFlag$$Type} from "net.minecraft.world.item.TooltipFlag"

export class $DynamicItemTooltipsKubeEvent implements $KubeEvent$$Interface {
readonly "item": $ItemStack
readonly "advanced": boolean
readonly "ctrl": boolean
readonly "startup": boolean
readonly "shift": boolean
readonly "alt": boolean
readonly "lines": $List<($Component)>
readonly "creative": boolean

constructor(item: $ItemStack$$Type, flags: $TooltipFlag$$Type, lines: $List$$Type<($Component$$Type)>, startup: boolean)

public "add"(text: $List$$Type<($Component$$Type)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicItemTooltipsKubeEvent$$Type = ($DynamicItemTooltipsKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DynamicItemTooltipsKubeEvent$$Original = $DynamicItemTooltipsKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.KeybindRegistryKubeEvent$Builder" {
import {$KeyModifier$$Type} from "net.neoforged.neoforge.client.settings.KeyModifier"
import {$KeyConflictContext$$Type} from "net.neoforged.neoforge.client.settings.KeyConflictContext"
import {$InputConstants$Type$$Type} from "com.mojang.blaze3d.platform.InputConstants$Type"

export class $KeybindRegistryKubeEvent$Builder {
public "scanCodeInputType"(): $KeybindRegistryKubeEvent$Builder
public "mouseInputType"(): $KeybindRegistryKubeEvent$Builder
public "gui"(): $KeybindRegistryKubeEvent$Builder
public "modifier"(modifier: $KeyModifier$$Type): $KeybindRegistryKubeEvent$Builder
public "category"(category: StringJS): $KeybindRegistryKubeEvent$Builder
public "inputType"(inputType: $InputConstants$Type$$Type): $KeybindRegistryKubeEvent$Builder
public "inGame"(): $KeybindRegistryKubeEvent$Builder
public "defaultKey"(keyName: StringJS): $KeybindRegistryKubeEvent$Builder
public "conflictContext"(keyConflictContext: $KeyConflictContext$$Type): $KeybindRegistryKubeEvent$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeybindRegistryKubeEvent$Builder$$Type = ($KeybindRegistryKubeEvent$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KeybindRegistryKubeEvent$Builder$$Original = $KeybindRegistryKubeEvent$Builder;}
declare module "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Variant" {
import {$VariantBlockStateGenerator$Model} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Model"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonElement} from "com.google.gson.JsonElement"

export class $VariantBlockStateGenerator$Variant {
constructor()

public "toJson"(): $JsonElement
public "model"(s: $ResourceLocation$$Type): $VariantBlockStateGenerator$Model
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateGenerator$Variant$$Type = ($VariantBlockStateGenerator$Variant);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VariantBlockStateGenerator$Variant$$Original = $VariantBlockStateGenerator$Variant;}
declare module "dev.latvian.mods.kubejs.core.EntityKJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$WithPersistentData$$Interface} from "dev.latvian.mods.kubejs.core.WithPersistentData"
import {$MessageSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$ScriptTypeHolder$$Interface} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $EntityKJS$$Interface extends $WithPersistentData$$Interface, $MessageSenderKJS$$Interface, $ScriptTypeHolder$$Interface {
get "nbt"(): $CompoundTag
set "z"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "x"(value: double)
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
get "living"(): boolean
get "level"(): $Level
get "type"(): StringJS
set "motionX"(value: double)
get "teamId"(): StringJS
set "motionY"(value: double)
get "profile"(): $GameProfile
get "server"(): $MinecraftServer
get "motionZ"(): double
get "motionX"(): double
get "passengers"(): $EntityArrayList
get "facing"(): $Direction
get "player"(): boolean
get "animal"(): boolean
get "item"(): $ItemStack
set "position"(value: $LevelBlock$$Type)
set "motionZ"(value: double)
get "scriptType"(): $ScriptType
get "frame"(): boolean
get "motionY"(): double
get "block"(): $LevelBlock
get "monster"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $EntityKJS implements $EntityKJS$$Interface {
 "spawn"(): void
 "getNbt"(): $CompoundTag
 "attack"(hp: float): void
 "setZ"(z: double): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setX"(x: double): void
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "isAmbientCreature"(): boolean
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "isLiving"(): boolean
 "getLevel"(): $Level
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "getType"(): StringJS
 "setMotionX"(x: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getTeamId"(): StringJS
 "setMotionY"(y: double): void
 "getProfile"(): $GameProfile
 "getServer"(): $MinecraftServer
 "getMotionZ"(): double
 "getMotionX"(): double
 "getPassengers"(): $EntityArrayList
 "getFacing"(): $Direction
 "isPlayer"(): boolean
 "setRotation"(yaw: float, pitch: float): void
 "isAnimal"(): boolean
 "getItem"(): $ItemStack
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "setPosition"(x: double, y: double, z: double): void
 "setPosition"(block: $LevelBlock$$Type): void
 "setMotionZ"(z: double): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getBlock"(): $LevelBlock
 "isMonster"(): boolean
 "runCommandSilent"(command: StringJS): void
 "tell"(message: $Component$$Type): void
 "self"(): $Entity
 "getName"(): $Component
 "runCommand"(command: StringJS): void
 "getDisplayName"(): $Component
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$$Type): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityKJS$$Type = ($EntityKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityKJS$$Original = $EntityKJS;}
declare module "dev.latvian.mods.kubejs.item.ItemTintFunction" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"

export interface $ItemTintFunction$$Interface {

(stack: $ItemStack, index: integer): $KubeColor$$Type
}

export class $ItemTintFunction implements $ItemTintFunction$$Interface {
static readonly "POTION": $ItemTintFunction
static readonly "TYPE_INFO": $TypeInfo
static readonly "BLOCK": $ItemTintFunction
static readonly "DISPLAY_COLOR_NBT": $ItemTintFunction
static readonly "MAP": $ItemTintFunction

 "getColor"(stack: $ItemStack$$Type, index: integer): $KubeColor
static "wrap"(o: any): $ItemTintFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTintFunction$$Type = (($ItemTintFunction$$Type)[]) | (StringJS) | ((stack: $ItemStack, index: integer) => void) | ((stack: $ItemStack, index: integer) => $KubeColor$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemTintFunction$$Original = $ItemTintFunction;}
declare module "dev.latvian.mods.kubejs.client.ModelGenerator$Override" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $ModelGenerator$Override {
constructor(model: $ResourceLocation$$Type)

public "predicate"(property: $ResourceLocation$$Type, value: float): void
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$Override$$Type = ($ModelGenerator$Override);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModelGenerator$Override$$Original = $ModelGenerator$Override;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent" {
import {$Slot$$Type} from "net.minecraft.world.inventory.Slot"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ClickType, $ClickType$$Type} from "net.minecraft.world.inventory.ClickType"

export class $ChestMenuInventoryClickEvent {
readonly "button": integer
readonly "type": $ClickType

constructor(slot: $Slot$$Type, type: $ClickType$$Type, button: integer)

public "getIndex"(): integer
public "getItem"(): $ItemStack
public "setItem"(item: $ItemStack$$Type): void
get "index"(): integer
get "item"(): $ItemStack
set "item"(value: $ItemStack$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuInventoryClickEvent$$Type = ($ChestMenuInventoryClickEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuInventoryClickEvent$$Original = $ChestMenuInventoryClickEvent;}
declare module "dev.latvian.mods.kubejs.block.BlockRenderType" {
import {$Enum} from "java.lang.Enum"

export class $BlockRenderType extends $Enum<($BlockRenderType)> {
static readonly "CUTOUT": $BlockRenderType
static readonly "TRANSLUCENT": $BlockRenderType
static readonly "CUTOUT_MIPPED": $BlockRenderType
static readonly "SOLID": $BlockRenderType

public static "values"(): ($BlockRenderType)[]
public static "valueOf"(name: StringJS): $BlockRenderType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRenderType$$Type = (("solid") | ("cutout") | ("cutout_mipped") | ("translucent"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockRenderType$$Original = $BlockRenderType;}
declare module "dev.latvian.mods.kubejs.recipe.CachedItemTagLookup" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List, $List$$Type} from "java.util.List"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$CachedTagLookup} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup"

export class $CachedItemTagLookup extends $CachedTagLookup<($Item)> {
readonly "registry": $Registry<(T)>
readonly "originalMap": $Map<($ResourceLocation), ($List<($TagLoader$EntryWithSource)>)>

constructor(registry: $Registry$$Type<($Item$$Type)>, originalMap: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>)

public "isEmpty"(key: $TagKey$$Type<($Item)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedItemTagLookup$$Type = ($CachedItemTagLookup);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CachedItemTagLookup$$Original = $CachedItemTagLookup;}
declare module "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$IngredientActionHolder$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionHolder"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$IngredientActionType} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionType"

export interface $IngredientAction$$Interface {
get "type"(): $IngredientActionType<(never)>
}

export class $IngredientAction implements $IngredientAction$$Interface {
static readonly "CODEC": $Codec<($IngredientAction)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IngredientAction)>

 "transform"(old: $ItemStack$$Type, index: integer, input: $CraftingInput$$Type): $ItemStack
 "getType"(): $IngredientActionType<(never)>
static "getRemaining"(input: $CraftingInput$$Type, index: integer, ingredientActions: $List$$Type<($IngredientActionHolder$$Type)>): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientAction$$Type = ($IngredientAction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientAction$$Original = $IngredientAction;}
declare module "dev.latvian.mods.kubejs.item.ItemPickedUpKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$ItemEntity, $ItemEntity$$Type} from "net.minecraft.world.entity.item.ItemEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player picks up an item. Cancelling (in `ItemEvents.canPickUp`) will prevent the item from being picked up.
 */
export class $ItemPickedUpKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, entity: $ItemEntity$$Type, stack: $ItemStack$$Type)

/**
 * The item entity that was picked up.
 */
public "getItemEntity"(): $ItemEntity
/**
 * The item that was picked up.
 */
public "getItem"(): $ItemStack
/**
 * The player that picked up the item.
 */
public "getEntity"(): $Player
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "itemEntity"(): $ItemEntity
get "item"(): $ItemStack
get "entity"(): $Player
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPickedUpKubeEvent$$Type = ($ItemPickedUpKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemPickedUpKubeEvent$$Original = $ItemPickedUpKubeEvent;}
declare module "dev.latvian.mods.kubejs.text.action.TextAction" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Map} from "java.util.Map"
import {$TooltipActionType} from "dev.latvian.mods.kubejs.text.action.TooltipActionType"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"

export interface $TextAction$$Interface {
}

export class $TextAction implements $TextAction$$Interface {
static readonly "MAP": $Map<(integer), ($TooltipActionType<(never)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($TextAction)>

 "type"(): $TooltipActionType<(never)>
 "apply"(lines: $List$$Type<($Component$$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextAction$$Type = ($TextAction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TextAction$$Original = $TextAction;}
declare module "dev.latvian.mods.kubejs.level.ExplosionKubeEvent$Before" {
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$ExplosionKubeEvent} from "dev.latvian.mods.kubejs.level.ExplosionKubeEvent"

/**
 * Invoked right before an explosion happens.
 */
export class $ExplosionKubeEvent$Before extends $ExplosionKubeEvent {
constructor(level: $Level$$Type, explosion: $Explosion$$Type)

/**
 * Returns the size of the explosion.
 */
public "getSize"(): float
/**
 * Sets the size of the explosion.
 */
public "setSize"(s: float): void
get "size"(): float
set "size"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionKubeEvent$Before$$Type = ($ExplosionKubeEvent$Before);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExplosionKubeEvent$Before$$Original = $ExplosionKubeEvent$Before;}
declare module "dev.latvian.mods.kubejs.server.ServerKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$MinecraftServer, $MinecraftServer$$Type} from "net.minecraft.server.MinecraftServer"

export class $ServerKubeEvent implements $KubeEvent$$Interface {
readonly "server": $MinecraftServer

constructor(s: $MinecraftServer$$Type)

public "getServer"(): $MinecraftServer
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerKubeEvent$$Type = ($ServerKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerKubeEvent$$Original = $ServerKubeEvent;}
declare module "dev.latvian.mods.kubejs.fluid.FluidBuilder" {
import {$BlockRenderType$$Type} from "dev.latvian.mods.kubejs.block.BlockRenderType"
import {$FluidBucketItemBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder"
import {$FlowingFluid} from "net.minecraft.world.level.material.FlowingFluid"
import {$FluidBlockBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder"
import {$FluidTypeBuilder, $FluidTypeBuilder$$Type} from "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$FlowingFluidBuilder} from "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$BaseFlowingFluid$Properties} from "net.neoforged.neoforge.fluids.BaseFlowingFluid$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $FluidBuilder extends $BuilderBase<($FlowingFluid)> {
static readonly "WATER_COLOR": $KubeColor
 "bucketItem": $FluidBucketItemBuilder
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "flowingFluid": $FlowingFluidBuilder
 "sourceLine": $SourceLine
 "fluidType": $FluidTypeBuilder
 "block": $FluidBlockBuilder
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "levelDecreasePerBlock"(levelDecreasePerBlock: integer): this
public "type"(builder: $Consumer$$Type<($FluidTypeBuilder)>): this
public "createProperties"(): $BaseFlowingFluid$Properties
public "displayName"(name: $Component$$Type): $BuilderBase<($FlowingFluid)>
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase<($FlowingFluid)>
public "explosionResistance"(explosionResistance: float): this
public "noBlock"(): this
public "noBucket"(): this
public "stillTexture"(id: $ResourceLocation$$Type): this
public "flowingTexture"(id: $ResourceLocation$$Type): this
public "renderType"(l: $BlockRenderType$$Type): this
public "slopeFindDistance"(slopeFindDistance: integer): this
public "tint"(c: $KubeColor$$Type): this
public "tickRate"(tickRate: integer): this
public "translucent"(): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBuilder$$Type = ($FluidBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidBuilder$$Original = $FluidBuilder;}
declare module "dev.latvian.mods.kubejs.core.EntityTypeKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$Holder} from "net.minecraft.core.Holder"
import {$EntityType} from "net.minecraft.world.entity.EntityType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $EntityTypeKJS$$Interface extends $RegistryObjectKJS$$Interface<($EntityType<(never)>)> {
get "registryId"(): $ResourceKey<($Registry<($EntityType<(never)>)>)>
get "registry"(): $Registry<($EntityType<(never)>)>
get "id"(): StringJS
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($EntityType<(never)>)>)>
get "tags"(): $List<($ResourceLocation)>
get "key"(): $ResourceKey<($EntityType<(never)>)>
}

export class $EntityTypeKJS implements $EntityTypeKJS$$Interface {
 "getRegistryId"(): $ResourceKey<($Registry<($EntityType<(never)>)>)>
 "getRegistry"(): $Registry<($EntityType<(never)>)>
 "getId"(): StringJS
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getMod"(): StringJS
 "getIdLocation"(): $ResourceLocation
 "getTagKeys"(): $List<($TagKey<($EntityType<(never)>)>)>
 "asHolder"(): $Holder<($EntityType<(never)>)>
 "getTags"(): $List<($ResourceLocation)>
 "getKey"(): $ResourceKey<($EntityType<(never)>)>
 "specialEquals"(o: any, shallow: boolean): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityTypeKJS$$Type = ($EntityTypeKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityTypeKJS$$Original = $EntityTypeKJS;}
declare module "dev.latvian.mods.kubejs.script.PlatformWrapper$ModInfo" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $PlatformWrapper$ModInfo {
constructor(i: StringJS)

public "getName"(): StringJS
public "setName"(n: StringJS): void
public "getId"(): StringJS
public "getVersion"(): StringJS
public "getCustomName"(): StringJS
get "name"(): StringJS
set "name"(value: StringJS)
get "id"(): StringJS
get "version"(): StringJS
get "customName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformWrapper$ModInfo$$Type = ($PlatformWrapper$ModInfo);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlatformWrapper$ModInfo$$Original = $PlatformWrapper$ModInfo;}
declare module "dev.latvian.mods.kubejs.player.ChestKubeEvent" {
import {$Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Container} from "net.minecraft.world.Container"
import {$InventoryKubeEvent} from "dev.latvian.mods.kubejs.player.InventoryKubeEvent"
import {$AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"

/**
 * Invoked when a player opens a chest.
 * 
 * Same as `PlayerEvents.inventoryOpened`, but only for chests.
 */
export class $ChestKubeEvent extends $InventoryKubeEvent {
constructor(player: $Player$$Type, menu: $AbstractContainerMenu$$Type)

/**
 * Gets the chest block.
 */
public "getBlock"(): $LevelBlock
/**
 * Gets the chest inventory.
 */
public "getInventory"(): $Container
/**
 * Gets the player that opened or closed the container.
 */
public "getEntity"(): $LivingEntity
get "block"(): $LevelBlock
get "inventory"(): $Container
get "entity"(): $LivingEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestKubeEvent$$Type = ($ChestKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestKubeEvent$$Original = $ChestKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment" {
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$ServerLevel$$Type} from "net.minecraft.server.level.ServerLevel"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockEntityAttachment$$Interface {
get "wrappedObject"(): any
}

export class $BlockEntityAttachment implements $BlockEntityAttachment$$Interface {
 "serialize"(registries: $HolderLookup$Provider$$Type): $Tag
 "deserialize"(registries: $HolderLookup$Provider$$Type, tag: $Tag$$Type): void
 "serverTick"(): void
 "onRemove"(level: $ServerLevel$$Type, blockEntity: $KubeBlockEntity$$Type, newState: $BlockState$$Type): void
 "getCapability"<CAP, SRC>(capability: $BlockCapability$$Type<(CAP), (SRC)>): CAP
 "getWrappedObject"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachment$$Type = ($BlockEntityAttachment);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityAttachment$$Original = $BlockEntityAttachment;}
declare module "dev.latvian.mods.kubejs.client.LangKubeEvent$Key" {
import {$Record} from "java.lang.Record"

export class $LangKubeEvent$Key extends $Record {
constructor(namespace: StringJS, lang: StringJS, key: StringJS)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "key"(): StringJS
public "lang"(): StringJS
public "namespace"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LangKubeEvent$Key$$Type = ({"namespace"?: StringJS, "key"?: StringJS, "lang"?: StringJS}) | ([namespace?: StringJS, key?: StringJS, lang?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LangKubeEvent$Key$$Original = $LangKubeEvent$Key;}
declare module "dev.latvian.mods.kubejs.fluid.ThickFluidBuilder" {
import {$FluidBucketItemBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder"
import {$FlowingFluidBuilder} from "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$FluidBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$FluidTypeBuilder} from "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder"
import {$FluidBlockBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder"
import {$KubeColor} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ThickFluidBuilder extends $FluidBuilder {
static readonly "WATER_COLOR": $KubeColor
 "bucketItem": $FluidBucketItemBuilder
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "flowingFluid": $FlowingFluidBuilder
 "sourceLine": $SourceLine
 "fluidType": $FluidTypeBuilder
 "block": $FluidBlockBuilder
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThickFluidBuilder$$Type = ($ThickFluidBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ThickFluidBuilder$$Original = $ThickFluidBuilder;}
declare module "dev.latvian.mods.kubejs.util.JsonIO" {
import {$Map} from "java.util.Map"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$DataOutputStream$$Type} from "java.io.DataOutputStream"
import {$Path$$Type} from "java.nio.file.Path"
import {$JsonArray} from "com.google.gson.JsonArray"

export class $JsonIO {
constructor()

public static "toString"(json: $JsonElement$$Type): StringJS
public static "toArray"(element: $JsonElement$$Type): $JsonArray
public static "write"(path: $Path$$Type, json: $JsonElement$$Type): void
public static "read"(path: $Path$$Type): $Map<(never), (never)>
public static "parse"(string: StringJS): any
public static "readString"(path: $Path$$Type): StringJS
public static "toPrettyString"(json: $JsonElement$$Type): StringJS
public static "getJsonHashString"(json: $JsonElement$$Type): StringJS
public static "toObject"(json: $JsonElement$$Type): any
public static "toPrimitive"(element: $JsonElement$$Type): any
public static "readJson"(path: $Path$$Type): $JsonElement
public static "writeJsonHash"(stream: $DataOutputStream$$Type, element: $JsonElement$$Type): void
public static "getJsonHashBytes"(json: $JsonElement$$Type): (byte)[]
public static "parseRaw"(string: StringJS): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonIO$$Type = ($JsonIO);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JsonIO$$Original = $JsonIO;}
declare module "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$MultipartBlockStateGenerator$Part$$Type} from "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator$Part"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $MultipartBlockStateGenerator {
constructor()

public "part"(when: StringJS, model: $ResourceLocation$$Type): void
public "part"(when: StringJS, consumer: $Consumer$$Type<($MultipartBlockStateGenerator$Part)>): void
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultipartBlockStateGenerator$$Type = ($MultipartBlockStateGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MultipartBlockStateGenerator$$Original = $MultipartBlockStateGenerator;}
declare module "dev.latvian.mods.kubejs.client.LoadedTexture" {
import {$BufferedImage$$Type} from "java.awt.image.BufferedImage"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map$$Type} from "java.util.Map"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"

export class $LoadedTexture {
readonly "pixels": (integer)[]
readonly "width": integer
static readonly "EMPTY": $LoadedTexture
readonly "mcmeta": (byte)[]
readonly "height": integer

constructor(img: $BufferedImage$$Type, mcmeta: (byte)[])
constructor(width: integer, height: integer, pixels: (integer)[], mcmeta: (byte)[])

public "toBytes"(): (byte)[]
public static "load"(id: $ResourceLocation$$Type): $LoadedTexture
public "copy"(): $LoadedTexture
public "resize"(newWidth: integer, newHeight: integer): $LoadedTexture
public "tint"(tint: $KubeColor$$Type): $LoadedTexture
public "remap"(remap: $Map$$Type<($KubeColor$$Type), ($KubeColor$$Type)>): $LoadedTexture
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LoadedTexture$$Type = ($LoadedTexture);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LoadedTexture$$Original = $LoadedTexture;}
declare module "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientActionType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$IngredientAction} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $IngredientActionType<T extends $IngredientAction> extends $Record {
static readonly "TYPES": $Lazy<($Map<($ResourceLocation), ($IngredientActionType<(never)>)>)>
static readonly "CODEC": $Codec<($IngredientActionType<(never)>)>
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($IngredientActionType<(never)>)>

constructor(id: $ResourceLocation$$Type, codec: $MapCodec$$Type<(T)>)
constructor(id: $ResourceLocation$$Type, codec: $MapCodec$$Type<(T)>, streamCodec: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): $ResourceLocation
public "codec"(): $MapCodec<(T)>
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientActionType$$Type<T> = ({"codec"?: $MapCodec$$Type<(T)>, "id"?: $ResourceLocation$$Type, "streamCodec"?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>}) | ([codec?: $MapCodec$$Type<(T)>, id?: $ResourceLocation$$Type, streamCodec?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientActionType$$Original<T> = $IngredientActionType<(T)>;}
declare module "dev.latvian.mods.kubejs.event.EventGroup" {
import {$EventHandler} from "dev.latvian.mods.kubejs.event.EventHandler"
import {$KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Map} from "java.util.Map"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Class$$Type} from "java.lang.Class"
import {$ScriptTypePredicate$$Type} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"

export class $EventGroup {
readonly "name": StringJS

public "equals"(obj: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "add"(name: StringJS, scriptType: $ScriptTypePredicate$$Type, eventType: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public static "of"(name: StringJS): $EventGroup
public "common"(name: StringJS, eventType: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public "getHandlers"(): $Map<(StringJS), ($EventHandler)>
public "client"(name: StringJS, eventType: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public "server"(name: StringJS, eventType: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
public "startup"(name: StringJS, eventType: $Supplier$$Type<($Class$$Type<($KubeEvent$$Type)>)>): $EventHandler
get "handlers"(): $Map<(StringJS), ($EventHandler)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventGroup$$Type = ($EventGroup);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventGroup$$Original = $EventGroup;}
declare module "dev.latvian.mods.kubejs.core.RegistryObjectKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$SpecialEquality$$Interface} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Holder} from "net.minecraft.core.Holder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RegistryObjectKJS$$Interface<T> extends $SpecialEquality$$Interface {
get "id"(): StringJS
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "registryId"(): $ResourceKey<($Registry<(T)>)>
get "tagKeys"(): $List<($TagKey<(T)>)>
get "registry"(): $Registry<(T)>
get "tags"(): $List<($ResourceLocation)>
get "key"(): $ResourceKey<(T)>
}

export class $RegistryObjectKJS<T> implements $RegistryObjectKJS$$Interface {
 "getId"(): StringJS
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getMod"(): StringJS
 "getIdLocation"(): $ResourceLocation
 "getRegistryId"(): $ResourceKey<($Registry<(T)>)>
 "getTagKeys"(): $List<($TagKey<(T)>)>
 "getRegistry"(): $Registry<(T)>
 "asHolder"(): $Holder<(T)>
 "getTags"(): $List<($ResourceLocation)>
 "getKey"(): $ResourceKey<(T)>
 "specialEquals"(o: any, shallow: boolean): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryObjectKJS$$Type<T> = ($RegistryObjectKJS<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryObjectKJS$$Original<T> = $RegistryObjectKJS<(T)>;}
declare module "dev.latvian.mods.kubejs.block.callback.BlockStateModifyPlacementCallback" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$InteractionHand} from "net.minecraft.world.InteractionHand"
import {$Direction} from "net.minecraft.core.Direction"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Level} from "net.minecraft.world.level.Level"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockStateModifyCallback} from "dev.latvian.mods.kubejs.block.callback.BlockStateModifyCallback"
import {$BlockPlaceContext, $BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"

export class $BlockStateModifyPlacementCallback extends $BlockStateModifyCallback {
readonly "minecraftBlock": $Block
readonly "context": $BlockPlaceContext
 "block": $LevelBlock

constructor(context: $BlockPlaceContext$$Type, block: $Block$$Type)

/**
 * Checks if this block is in water
 */
public "isInWater"(): boolean
/**
 * Gets the direction closes to where the player is currently looking
 */
public "getNearestLookingDirection"(): $Direction
/**
 * Returns if the block being placed is replacing the block clicked
 */
public "replacingClickedOnBlock"(): boolean
/**
 * Gets the nearest horizontal direction to where the player is looking. NORTH if there is no player
 */
public "getHorizontalDirection"(): $Direction
/**
 * Gets an array of all directions, ordered by which the player is looking closest to
 */
public "getNearestLookingDirections"(): ($Direction)[]
/**
 * Gets the vertical direction (UP/DOWN) closest to where the player is currently looking
 */
public "getNearestLookingVerticalDirection"(): $Direction
/**
 * Gets the level
 */
public "getLevel"(): $Level
/**
 * Gets the item being placed
 */
public "getItem"(): $ItemStack
/**
 * Returns if the player is using the 'secondary' function of this item. Basically checks if they are holding shift
 */
public "isSecondaryUseActive"(): boolean
/**
 * Gets the position in the block-space of where it was clicked
 */
public "getClickLocation"(): $Vec3
/**
 * Returns if the block being placed thinks it can be placed here. This is used for replacement checks, like placing blocks in water or tall grass
 */
public "canPlace"(): boolean
/**
 * Gets the hand that is placing the block
 */
public "getHand"(): $InteractionHand
/**
 * Gets the player placing the block, if available
 */
public "getPlayer"(): $Player
/**
 * Gets the clicked position in world
 */
public "getClickedPos"(): $BlockPos
/**
 * Gets the facing direction of the clicked block face
 */
public "getClickedFace"(): $Direction
/**
 * Returns if the hit posiiton in the block-space is inside the 1x1x1 cube of the block
 */
public "isInside"(): boolean
/**
 * Set if this block is waterlogged or not
 */
public "waterlogged"(waterlogged: boolean): $BlockStateModifyPlacementCallback
/**
 * Set this block as waterlogged if it is in water
 */
public "waterlogged"(): $BlockStateModifyPlacementCallback
/**
 * Get the horizontal rotation of the player
 */
public "getRotation"(): float
/**
 * Gets the FluidSate at the clicked position
 */
public "getFluidStateAtClickedPos"(): $FluidState
/**
 * Gets the clicked block
 */
public "getClickedBlock"(): $LevelBlock
/**
 * Checks if the position clicked has a specified fluid there
 */
public "isClickedPosIn"(fluid: $Fluid$$Type): boolean
/**
 * Checks if the block currently occupying the position this is being placed in is the same block type.
 * Used for things like candles, where multiple can be in the same block-space.
 */
public "isReplacingSelf"(): boolean
get "inWater"(): boolean
get "nearestLookingDirection"(): $Direction
get "horizontalDirection"(): $Direction
get "nearestLookingDirections"(): ($Direction)[]
get "nearestLookingVerticalDirection"(): $Direction
get "level"(): $Level
get "item"(): $ItemStack
get "secondaryUseActive"(): boolean
get "clickLocation"(): $Vec3
get "hand"(): $InteractionHand
get "player"(): $Player
get "clickedPos"(): $BlockPos
get "clickedFace"(): $Direction
get "inside"(): boolean
get "rotation"(): float
get "fluidStateAtClickedPos"(): $FluidState
get "clickedBlock"(): $LevelBlock
get "replacingSelf"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateModifyPlacementCallback$$Type = ($BlockStateModifyPlacementCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateModifyPlacementCallback$$Original = $BlockStateModifyPlacementCallback;}
declare module "dev.latvian.mods.kubejs.client.KubeSessionData" {
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$List} from "java.util.List"
import {$KubeServerData$$Type} from "dev.latvian.mods.kubejs.net.KubeServerData"
import {$ClientPacketListener$$Type} from "net.minecraft.client.multiplayer.ClientPacketListener"
import {$Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$ItemTooltipData} from "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData"
import {$RecipeViewerData} from "dev.latvian.mods.kubejs.recipe.viewer.server.RecipeViewerData"

export class $KubeSessionData {
 "activePostShader": $ResourceLocation
 "itemTooltips": $List<($ItemTooltipData)>
 "recipeViewerData": $RecipeViewerData

constructor()

public static "of"(mc: $Minecraft$$Type): $KubeSessionData
public static "of"(listener: $ClientPacketListener$$Type): $KubeSessionData
public "sync"(data: $KubeServerData$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeSessionData$$Type = ($KubeSessionData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeSessionData$$Original = $KubeSessionData;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$DataComponentSubtypes" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$DataComponentType, $DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Record} from "java.lang.Record"

export class $FluidData$DataComponentSubtypes extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData$DataComponentSubtypes)>

constructor(filter: $FluidIngredient$$Type, components: $List$$Type<($DataComponentType$$Type<(never)>)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $FluidIngredient
public "components"(): $List<($DataComponentType<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$DataComponentSubtypes$$Type = ({"filter"?: $FluidIngredient$$Type, "components"?: $List$$Type<($DataComponentType$$Type<(never)>)>}) | ([filter?: $FluidIngredient$$Type, components?: $List$$Type<($DataComponentType$$Type<(never)>)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidData$DataComponentSubtypes$$Original = $FluidData$DataComponentSubtypes;}
declare module "dev.latvian.mods.kubejs.recipe.KubeRecipe" {
import {$CustomJavaToJsWrapper$$Interface} from "dev.latvian.mods.rhino.util.CustomJavaToJsWrapper"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RecipeSchema} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$List} from "java.util.List"
import {$RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$RecipeLikeKJS$$Interface} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$RecipeComponentValue} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ErrorStack$$Type} from "dev.latvian.mods.kubejs.util.ErrorStack"
import {$RecipeTypeFunction} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$IngredientAction$$Type} from "dev.latvian.mods.kubejs.recipe.ingredientaction.IngredientAction"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Recipe} from "net.minecraft.world.item.crafting.Recipe"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $KubeRecipe implements $RecipeLikeKJS$$Interface, $CustomJavaToJsWrapper$$Interface {
 "newRecipe": boolean
 "sourceLine": $SourceLine
 "originalJson": $JsonObject
 "removed": boolean
 "creationError": boolean
static readonly "TYPE_INFO": $TypeInfo
 "json": $JsonObject
static readonly "CHANGED_MARKER": StringJS
 "type": $RecipeTypeFunction
 "changed": boolean

constructor()

public "hasChanged"(): boolean
public "group"(g: StringJS): $KubeRecipe
public "remove"(): void
public "get"(key: StringJS): any
public "toString"(): StringJS
public "getValue"<T>(key: $RecipeKey$$Type<(T)>): T
public "validate"(cx: $RecipeValidationContext$$Type): void
public "merge"(j: $JsonObject$$Type): $KubeRecipe
public "id"(id: $ResourceLocation$$Type): $KubeRecipe
public "set"(key: StringJS, value: any): $KubeRecipe
public "getId"(): StringJS
public "save"(): void
public "setValue"<T>(key: $RecipeKey$$Type<(T)>, value: T): $KubeRecipe
public "getPath"(): StringJS
public "stage"(s: StringJS): $KubeRecipe
public "customIngredientAction"(filter: $SlotFilter$$Type, id: StringJS): $KubeRecipe
public "getOriginalRecipeResult"(): $ItemStack
public "serialize"(): void
public "replaceInput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
/**
 * 
 * @deprecated
 */
public "getSchema"(): $RecipeSchema
public "replaceOutput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "getTypeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
/**
 * 
 * @deprecated
 */
public "getOrCreateId"(): $ResourceLocation
public "getSerializer"(): $RecipeSerializer<(never)>
/**
 * 
 * @deprecated
 */
public "getGroup"(): StringJS
public "deserialize"(merge: boolean): void
public "hasInput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
public "hasOutput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
public "convertJavaToJs"(scope: $Scriptable$$Type, staticType: $TypeInfo$$Type): $Scriptable
public "modifyResult"(id: StringJS): $KubeRecipe
public "getFromToString"(): StringJS
public "damageIngredient"(filter: $SlotFilter$$Type): $KubeRecipe
public "damageIngredient"(filter: $SlotFilter$$Type, damage: integer): $KubeRecipe
public "ingredientAction"(filter: $SlotFilter$$Type, action: $IngredientAction$$Type): $KubeRecipe
public "replaceIngredient"(filter: $SlotFilter$$Type, item: $ItemStack$$Type): $KubeRecipe
public "keepIngredient"(filter: $SlotFilter$$Type): $KubeRecipe
public "getOriginalRecipe"(): $Recipe<(never)>
public "serializeChanges"(): $KubeRecipe
public "afterLoaded"(stack: $ErrorStack$$Type): void
public "afterLoaded"(cx: $RecipeValidationContext$$Type): void
public "inputValues"(): ($RecipeComponentValue<(never)>)[]
public "outputValues"(): ($RecipeComponentValue<(never)>)[]
public "consumeIngredient"(filter: $SlotFilter$$Type): $KubeRecipe
public "getSerializationTypeFunction"(): $RecipeTypeFunction
public "getOriginalRecipeIngredients"(): $List<($Ingredient)>
public "initValues"(save: boolean): void
public "getType"(): $ResourceLocation
public "getMod"(): StringJS
get "path"(): StringJS
get "originalRecipeResult"(): $ItemStack
get "schema"(): $RecipeSchema
get "typeKey"(): $ResourceKey<($RecipeSerializer<(never)>)>
get "orCreateId"(): $ResourceLocation
get "serializer"(): $RecipeSerializer<(never)>
get "fromToString"(): StringJS
get "originalRecipe"(): $Recipe<(never)>
get "serializationTypeFunction"(): $RecipeTypeFunction
get "originalRecipeIngredients"(): $List<($Ingredient)>
get "mod"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeRecipe$$Type = ($KubeRecipe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeRecipe$$Original = $KubeRecipe;}
declare module "dev.latvian.mods.kubejs.block.callback.BlockStateModifyCallback" {
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Enum} from "java.lang.Enum"
import {$Optional} from "java.util.Optional"
import {$Comparable, $Comparable$$Type} from "java.lang.Comparable"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$IntegerProperty$$Type} from "net.minecraft.world.level.block.state.properties.IntegerProperty"
import {$Rotation$$Type} from "net.minecraft.world.level.block.Rotation"
import {$BooleanProperty$$Type} from "net.minecraft.world.level.block.state.properties.BooleanProperty"
import {$EnumProperty$$Type} from "net.minecraft.world.level.block.state.properties.EnumProperty"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$LevelAccessor$$Type} from "net.minecraft.world.level.LevelAccessor"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $BlockStateModifyCallback {
constructor(state: $BlockState$$Type)

/**
 * Gets the value of the pased in property
 */
public "get"<T extends $Comparable<(object)>>(property: $Property$$Type<(T)>): T
public "toString"(): StringJS
/**
 * Gets the value of the passed in property
 */
public "getValue"<T extends $Comparable<(object)>>(property: $Property$$Type<(T)>): T
/**
 * Sets the value of the specified boolean property
 */
public "set"(property: $BooleanProperty$$Type, value: boolean): $BlockStateModifyCallback
/**
 * Sets the value of the specified integer property
 */
public "set"(property: $IntegerProperty$$Type, value: integer): $BlockStateModifyCallback
/**
 * Sets the value of the specified enum property
 */
public "set"<T extends $Enum<(object)>>(property: $EnumProperty$$Type<(T)>, value: StringJS): $BlockStateModifyCallback
/**
 * Get the properties this block has that can be changed
 */
public "getProperties"(): $Collection<($Property<(never)>)>
/**
 * Gets the state. If it has been modified, gets the new state
 */
public "getState"(): $BlockState
/**
 * Sets the value of the specified property
 */
public "setValue"<T extends $Comparable<(object)>, V extends $Comparable<(object)>>(property: $Property$$Type<(T)>, comparable: V): $BlockStateModifyCallback
/**
 * Rotate the block using the specified Rotation
 */
public "rotate"(rotation: $Rotation$$Type): $BlockStateModifyCallback
/**
 * Get a map of this blocks properties to it's value
 */
public "getValues"(): $Map<($Property<(never)>), ($Comparable<(never)>)>
/**
 * Gets the value of the passed in property as an Optional. If the property does not exist in this block the Optional will be empty
 */
public "getOptionalValue"<T extends $Comparable<(object)>>(property: $Property$$Type<(T)>): $Optional<(T)>
public "populateNeighbours"(map: $Map$$Type<($Map$$Type<($Property$$Type<(never)>), ($Comparable$$Type<(never)>)>), ($BlockState$$Type)>): $BlockStateModifyCallback
/**
 * Mirror the block using the specified Mirror
 */
public "mirror"(mirror: $Mirror$$Type): $BlockStateModifyCallback
/**
 * Checks if this block has the specified property
 */
public "hasProperty"<T extends $Comparable<(object)>>(property: $Property$$Type<(T)>): boolean
/**
 * Updates the shape of this block. Mostly used in waterloggable blocks to update the water flow
 */
public "updateShape"(direction: $Direction$$Type, blockState: $BlockState$$Type, levelAccessor: $LevelAccessor$$Type, blockPos: $BlockPos$$Type, blockPos2: $BlockPos$$Type): $BlockStateModifyCallback
/**
 * Cycles the property
 */
public "cycle"<T extends $Comparable<(object)>>(property: $Property$$Type<(T)>): $BlockStateModifyCallback
get "properties"(): $Collection<($Property<(never)>)>
get "state"(): $BlockState
get "values"(): $Map<($Property<(never)>), ($Comparable<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateModifyCallback$$Type = ($BlockStateModifyCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateModifyCallback$$Original = $BlockStateModifyCallback;}
declare module "dev.latvian.mods.kubejs.script.data.VirtualDataPack" {
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$GeneratedDataStage, $GeneratedDataStage$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedDataStage"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component} from "net.minecraft.network.chat.Component"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$VirtualResourcePack} from "dev.latvian.mods.kubejs.script.data.VirtualResourcePack"
import {$RegistryAccessContainer, $RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$VillagerProfession$$Type} from "net.minecraft.world.entity.npc.VillagerProfession"
import {$KubeDataGenerator$$Interface} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$PackType} from "net.minecraft.server.packs.PackType"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$VirtualDataMapFile$$Type} from "dev.latvian.mods.kubejs.script.data.VirtualDataMapFile"
import {$DataMapType$$Type} from "net.neoforged.neoforge.registries.datamaps.DataMapType"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$VillagerType$$Type} from "net.minecraft.world.entity.npc.VillagerType"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $VirtualDataPack extends $VirtualResourcePack implements $KubeDataGenerator$$Interface {
readonly "component": $Component
readonly "stage": $GeneratedDataStage
readonly "scriptType": $ScriptType
readonly "packType": $PackType
readonly "registries": $Supplier<($RegistryAccessContainer)>
readonly "info": StringJS

constructor(stage: $GeneratedDataStage$$Type, registries: $Supplier$$Type<($RegistryAccessContainer$$Type)>)

public "reset"(): void
public "flush"(): void
public "dataMap"<R, T>(type: $DataMapType$$Type<(R), (T)>, consumer: $Consumer$$Type<($VirtualDataMapFile<(R), (T)>)>): void
public "setMonsterRoomMobs"(entityType: $EntityType$$Type<(never)>, weight: integer): void
public "setOxidizable"(from: $Block$$Type, to: $Block$$Type): void
public "setParrotImitation"(type: $EntityType$$Type<(never)>, sound: $SoundEvent$$Type): void
public "setCompostable"(items: $ItemPredicate$$Type, chance: float, canVillagerCompost: boolean): void
public "setVillagerType"(biome: $ResourceKey$$Type<($Biome)>, villagerType: $VillagerType$$Type): void
public "setFurnaceFuel"(items: $ItemPredicate$$Type, ticks: $TickDuration$$Type): void
public "removeCompostable"(items: $ItemPredicate$$Type): void
public "removeFurnaceFuel"(items: $ItemPredicate$$Type): void
public "setRaidHeroGifts"(profession: $VillagerProfession$$Type, lootTable: $ResourceKey$$Type<($LootTable)>): void
public "setWaxable"(from: $Block$$Type, to: $Block$$Type): void
public "setVibrationFrequency"(gameEvent: $GameEvent$$Type, frequency: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualDataPack$$Type = ($VirtualDataPack);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VirtualDataPack$$Original = $VirtualDataPack;}
declare module "dev.latvian.mods.kubejs.block.entity.InventoryAttachment$Factory" {
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockCapability} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$BlockEntityAttachmentFactory$$Interface} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$List} from "java.util.List"
import {$BlockEntityAttachment} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record} from "java.lang.Record"

export class $InventoryAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory$$Interface {
constructor(width: integer, height: integer, inputFilter: ($ItemPredicate$$Type)?)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "create"(info: $BlockEntityAttachmentInfo$$Type, entity: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "width"(): integer
public "height"(): integer
public "getCapabilities"(): $List<($BlockCapability<(never), (never)>)>
public "inputFilter"(): $Optional<($ItemPredicate)>
public "isTicking"(): boolean
get "capabilities"(): $List<($BlockCapability<(never), (never)>)>
get "ticking"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryAttachment$Factory$$Type = ({"height"?: integer, "inputFilter"?: ($ItemPredicate$$Type)?, "width"?: integer}) | ([height?: integer, inputFilter?: ($ItemPredicate$$Type)?, width?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InventoryAttachment$Factory$$Original = $InventoryAttachment$Factory;}
declare module "dev.latvian.mods.kubejs.web.KJSWSSession" {
import {$WSSession} from "dev.latvian.apps.tinyserver.ws.WSSession"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$SessionInfo} from "dev.latvian.mods.kubejs.web.SessionInfo"
import {$KJSHTTPRequest} from "dev.latvian.mods.kubejs.web.KJSHTTPRequest"

export class $KJSWSSession extends $WSSession<($KJSHTTPRequest)> {
 "info": $SessionInfo

constructor()

public "onEvent"(type: StringJS, payload: $JsonElement$$Type): void
public "onTextMessage"(message: StringJS): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KJSWSSession$$Type = ($KJSWSSession);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KJSWSSession$$Original = $KJSWSSession;}
declare module "dev.latvian.mods.kubejs.block.custom.DoorBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$KubeDataGenerator$$Type} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $DoorBlockBuilder extends $ShapedBlockBuilder {
static readonly "DOOR_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "WOODEN_DOOR_TAGS": ($ResourceLocation)[]

constructor(i: $ResourceLocation$$Type)

public "behaviour"(wt: $BlockSetType$$Type): this
public "generateLootTable"(generator: $KubeDataGenerator$$Type): $LootTable
public "wooden"(): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoorBlockBuilder$$Type = ($DoorBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DoorBlockBuilder$$Original = $DoorBlockBuilder;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback" {
import {$ChestMenuClickEvent, $ChestMenuClickEvent$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent"

export interface $ChestMenuClickEvent$Callback$$Interface {

(event: $ChestMenuClickEvent): void
}

export class $ChestMenuClickEvent$Callback implements $ChestMenuClickEvent$Callback$$Interface {
 "onClick"(event: $ChestMenuClickEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuClickEvent$Callback$$Type = ((event: $ChestMenuClickEvent) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuClickEvent$Callback$$Original = $ChestMenuClickEvent$Callback;}
declare module "dev.latvian.mods.kubejs.block.DetectorBlock$Builder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $DetectorBlock$Builder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "detectorId"(id: StringJS): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DetectorBlock$Builder$$Type = ($DetectorBlock$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DetectorBlock$Builder$$Original = $DetectorBlock$Builder;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.BuildingMaterialProperties$Blocks" {
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $BuildingMaterialProperties$Blocks extends $Record {
constructor(slab: (boolean)?, stairs: (boolean)?, fence: (boolean)?, fenceGate: (boolean)?, wall: (boolean)?, pressurePlate: (boolean)?, button: (boolean)?, trapdoor: (boolean)?, door: (boolean)?)

public "door"(): $Optional<(boolean)>
public "slab"(): $Optional<(boolean)>
public "trapdoor"(): $Optional<(boolean)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "fence"(): $Optional<(boolean)>
public "wall"(): $Optional<(boolean)>
public "button"(): $Optional<(boolean)>
public "pressurePlate"(): $Optional<(boolean)>
public "stairs"(): $Optional<(boolean)>
public "fenceGate"(): $Optional<(boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuildingMaterialProperties$Blocks$$Type = ({"slab"?: (boolean)?, "pressurePlate"?: (boolean)?, "fence"?: (boolean)?, "button"?: (boolean)?, "door"?: (boolean)?, "fenceGate"?: (boolean)?, "stairs"?: (boolean)?, "wall"?: (boolean)?, "trapdoor"?: (boolean)?}) | ([slab?: (boolean)?, pressurePlate?: (boolean)?, fence?: (boolean)?, button?: (boolean)?, door?: (boolean)?, fenceGate?: (boolean)?, stairs?: (boolean)?, wall?: (boolean)?, trapdoor?: (boolean)?]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BuildingMaterialProperties$Blocks$$Original = $BuildingMaterialProperties$Blocks;}
declare module "dev.latvian.mods.kubejs.net.SyncServerDataPayload" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$PacketFlow$$Type} from "net.minecraft.network.protocol.PacketFlow"
import {$FriendlyByteBuf} from "net.minecraft.network.FriendlyByteBuf"
import {$List$$Type} from "java.util.List"
import {$CustomPacketPayload$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$Type"
import {$KubeServerData, $KubeServerData$$Type} from "dev.latvian.mods.kubejs.net.KubeServerData"
import {$StreamDecoder$$Type} from "net.minecraft.network.codec.StreamDecoder"
import {$CustomPacketPayload, $CustomPacketPayload$$Interface} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload"
import {$IPayloadContext$$Type} from "net.neoforged.neoforge.network.handling.IPayloadContext"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$StreamMemberEncoder$$Type} from "net.minecraft.network.codec.StreamMemberEncoder"
import {$ServerboundCustomPayloadPacket} from "net.minecraft.network.protocol.common.ServerboundCustomPayloadPacket"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$ClientboundCustomPayloadPacket} from "net.minecraft.network.protocol.common.ClientboundCustomPayloadPacket"
import {$ConnectionProtocol$$Type} from "net.minecraft.network.ConnectionProtocol"
import {$CustomPacketPayload$TypeAndCodec$$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$TypeAndCodec"
import {$CustomPacketPayload$FallbackProvider$$Type} from "net.minecraft.network.protocol.common.custom.CustomPacketPayload$FallbackProvider"
import {$Record} from "java.lang.Record"

export class $SyncServerDataPayload extends $Record implements $CustomPacketPayload$$Interface {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($SyncServerDataPayload)>

constructor(data: $KubeServerData$$Type)

public "type"(): $CustomPacketPayload$Type<(never)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "data"(): $KubeServerData
public "handle"(ctx: $IPayloadContext$$Type): void
public static "codec"<B extends $FriendlyByteBuf>(arg0: $CustomPacketPayload$FallbackProvider$$Type<(B)>, arg1: $List$$Type<($CustomPacketPayload$TypeAndCodec$$Type<(B), (never)>)>, arg2: $ConnectionProtocol$$Type, arg3: $PacketFlow$$Type): $StreamCodec<(B), ($CustomPacketPayload)>
public static "codec"<B extends $ByteBuf, T extends $CustomPacketPayload>(arg0: $StreamMemberEncoder$$Type<(B), (T)>, arg1: $StreamDecoder$$Type<(B), (T)>): $StreamCodec<(B), (T)>
public static "createType"<T extends $CustomPacketPayload>(arg0: StringJS): $CustomPacketPayload$Type<(T)>
public "toVanillaClientbound"(): $ClientboundCustomPayloadPacket
public "toVanillaServerbound"(): $ServerboundCustomPayloadPacket
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SyncServerDataPayload$$Type = ({"data"?: $KubeServerData$$Type}) | ([data?: $KubeServerData$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SyncServerDataPayload$$Original = $SyncServerDataPayload;}
declare module "dev.latvian.mods.kubejs.generator.KubeDataGenerator" {
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$KubeResourceGenerator$$Interface} from "dev.latvian.mods.kubejs.generator.KubeResourceGenerator"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$VillagerProfession$$Type} from "net.minecraft.world.entity.npc.VillagerProfession"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$GameEvent$$Type} from "net.minecraft.world.level.gameevent.GameEvent"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$VirtualDataMapFile$$Type} from "dev.latvian.mods.kubejs.script.data.VirtualDataMapFile"
import {$DataMapType$$Type} from "net.neoforged.neoforge.registries.datamaps.DataMapType"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$Biome$$Type} from "net.minecraft.world.level.biome.Biome"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$VillagerType$$Type} from "net.minecraft.world.entity.npc.VillagerType"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export interface $KubeDataGenerator$$Interface extends $KubeResourceGenerator$$Interface {
get "registries"(): $RegistryAccessContainer
}

export class $KubeDataGenerator implements $KubeDataGenerator$$Interface {
 "dataMap"<R, T>(type: $DataMapType$$Type<(R), (T)>, consumer: $Consumer$$Type<($VirtualDataMapFile<(R), (T)>)>): void
 "setMonsterRoomMobs"(entityType: $EntityType$$Type<(never)>, weight: integer): void
 "setOxidizable"(from: $Block$$Type, to: $Block$$Type): void
 "setParrotImitation"(type: $EntityType$$Type<(never)>, sound: $SoundEvent$$Type): void
 "setCompostable"(items: $ItemPredicate$$Type, chance: float, canVillagerCompost: boolean): void
 "setVillagerType"(biome: $ResourceKey$$Type<($Biome)>, villagerType: $VillagerType$$Type): void
 "setFurnaceFuel"(items: $ItemPredicate$$Type, ticks: $TickDuration$$Type): void
 "removeCompostable"(items: $ItemPredicate$$Type): void
 "removeFurnaceFuel"(items: $ItemPredicate$$Type): void
 "setRaidHeroGifts"(profession: $VillagerProfession$$Type, lootTable: $ResourceKey$$Type<($LootTable)>): void
 "setWaxable"(from: $Block$$Type, to: $Block$$Type): void
 "setVibrationFrequency"(gameEvent: $GameEvent$$Type, frequency: integer): void
 "flush"(): void
 "add"(data: $GeneratedData$$Type): void
 "text"(id: $ResourceLocation$$Type, content: StringJS): void
 "json"(id: $ResourceLocation$$Type, json: $JsonElement$$Type): void
 "getRegistries"(): $RegistryAccessContainer
 "getGenerated"(id: $ResourceLocation$$Type): $GeneratedData
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeDataGenerator$$Type = ($KubeDataGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeDataGenerator$$Original = $KubeDataGenerator;}
declare module "dev.latvian.mods.kubejs.misc.PoiTypeBuilder" {
import {$PoiType} from "net.minecraft.world.entity.ai.village.poi.PoiType"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $PoiTypeBuilder extends $BuilderBase<($PoiType)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "block"(r: $Block$$Type): this
public "blocks"(r: ($BlockState$$Type)[]): this
public "validRange"(i: integer): this
public "maxTickets"(i: integer): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PoiTypeBuilder$$Type = ($PoiTypeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PoiTypeBuilder$$Original = $PoiTypeBuilder;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.TextWrapper" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Iterable$$Type} from "java.lang.Iterable"
import {$ItemLore} from "net.minecraft.world.item.component.ItemLore"
import {$List$$Type} from "java.util.List"
import {$MutableComponent, $MutableComponent$$Type} from "net.minecraft.network.chat.MutableComponent"
import {$Tag$$Type} from "net.minecraft.nbt.Tag"
import {$ClickEvent, $ClickEvent$$Type} from "net.minecraft.network.chat.ClickEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

/**
 * The hub for all things text components. Format text to your hearts content!
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $TextWrapper$$Interface {
}

export class $TextWrapper implements $TextWrapper$$Interface {
static readonly "TYPE_INFO": $TypeInfo

/**
 * Checks if the passed in component, and all its children are empty
 */
static "isEmpty"(component: $Component$$Type): boolean
/**
 * Joins all components in the list with the separator component
 */
static "join"(separator: $MutableComponent$$Type, texts: $Iterable$$Type<($Component$$Type)>): $MutableComponent
/**
 * Joins all components
 */
static "join"(...texts: ($Component$$Type)[]): $MutableComponent
/**
 * Returns a Component of the input
 */
static "of"(component: $MutableComponent$$Type): $MutableComponent
/**
 * Returns an empty component
 */
static "empty"(): $MutableComponent
static "info"(text: $Component$$Type): $MutableComponent
/**
 * Returns a component of the input, colored red
 */
static "red"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a plain component of the passed in string, even if empty
 */
static "string"(text: StringJS): $MutableComponent
/**
 * Returns a plain component of the input
 */
static "literal"(text: StringJS): $MutableComponent
static "warn"(text: $Component$$Type): $MutableComponent
/**
 * Returns a component displaying all entities matching the input selector
 */
static "selector"(selector: StringJS): $MutableComponent
/**
 * Returns a component displaying all entities matching the input selector, with a custom separator
 */
static "selector"(selector: StringJS, separator: $Component$$Type): $MutableComponent
static "lore"(lore: $List$$Type<($Component$$Type)>): $ItemLore
/**
 * Returns a score component of the input objective, for the provided selector
 */
static "score"(selector: StringJS, objective: StringJS): $MutableComponent
/**
 * Returns a component of the input, colored dark green
 */
static "darkGreen"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark blue
 */
static "darkBlue"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark aqua
 */
static "darkAqua"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark purple
 */
static "darkPurple"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark red
 */
static "darkRed"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored dark gray
 */
static "darkGray"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored aqua
 */
static "aqua"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored gold
 */
static "gold"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a plain component of the string, or empty if it is an empty string
 */
static "ofString"(s: StringJS): $MutableComponent
/**
 * Returns a keybinding component of the input keybinding descriptor
 */
static "keybind"(keybind: StringJS): $MutableComponent
/**
 * Returns a colorful representation of the input nbt. Useful for displaying NBT to the player
 */
static "prettyPrintNbt"(tag: $Tag$$Type): $Component
/**
 * Returns a ClickEvent of the input
 */
static "clickEventOf"(event: $ClickEvent$$Type): $ClickEvent
/**
 * Returns a component of the input, colored light purple
 */
static "lightPurple"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored green
 */
static "green"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored white
 */
static "white"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored yellow
 */
static "yellow"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored black
 */
static "black"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a component of the input, colored blue
 */
static "blue"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects
 */
static "translatable"(key: Special.LangKey, ...objects: (any)[]): $MutableComponent
/**
 * Returns a translatable component of the input key
 */
static "translatable"(key: Special.LangKey): $MutableComponent
/**
 * Returns a translatable component of the input key
 */
static "translate"(key: Special.LangKey): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects
 */
static "translate"(key: Special.LangKey, ...objects: (any)[]): $MutableComponent
/**
 * Returns a component of the input, colored gray
 */
static "gray"(text: $MutableComponent$$Type): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects and a fallback translation in case the client does not have one
 */
static "translatableWithFallback"(key: StringJS, fallback: StringJS, ...objects: (any)[]): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects and a fallback translation in case the client does not have one
 */
static "translatableWithFallback"(key: StringJS, fallback: StringJS): $MutableComponent
static "ofTag"(tag: $Tag$$Type): $Component
/**
 * Returns a translatable component of the input key, with args of the objects and a fallback translation in case the client does not have one
 */
static "translateWithFallback"(key: StringJS, fallback: StringJS): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects and a fallback translation in case the client does not have one
 */
static "translateWithFallback"(key: StringJS, fallback: StringJS, ...objects: (any)[]): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextWrapper$$Type = ($TextWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TextWrapper$$Original = $TextWrapper;}
declare module "dev.latvian.mods.kubejs.event.KubeEvent" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $KubeEvent$$Interface {
}

export class $KubeEvent implements $KubeEvent$$Interface {
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeEvent$$Type = ($KubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeEvent$$Original = $KubeEvent;}
declare module "dev.latvian.mods.kubejs.server.ServerScriptManager" {
import {$VirtualDataPack} from "dev.latvian.mods.kubejs.script.data.VirtualDataPack"
import {$Map} from "java.util.Map"
import {$List, $List$$Type} from "java.util.List"
import {$GeneratedDataStage} from "dev.latvian.mods.kubejs.script.data.GeneratedDataStage"
import {$PackResources, $PackResources$$Type} from "net.minecraft.server.packs.PackResources"
import {$PreTagKubeEvent} from "dev.latvian.mods.kubejs.server.tag.PreTagKubeEvent"
import {$RecipeSchemaStorage} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$KubeJSContextFactory} from "dev.latvian.mods.kubejs.script.KubeJSContextFactory"
import {$SyncServerDataPayload} from "dev.latvian.mods.kubejs.net.SyncServerDataPayload"
import {$ScriptPack} from "dev.latvian.mods.kubejs.script.ScriptPack"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$ScriptManager} from "dev.latvian.mods.kubejs.script.ScriptManager"

export class $ServerScriptManager extends $ScriptManager {
readonly "virtualPacks": $Map<($GeneratedDataStage), ($VirtualDataPack)>
readonly "scriptType": $ScriptType
readonly "registriesDataPack": $VirtualDataPack
readonly "internalDataPack": $VirtualDataPack
 "canListenEvents": boolean
readonly "recipeSchemaStorage": $RecipeSchemaStorage
 "firstLoad": boolean
readonly "packs": $Map<(StringJS), ($ScriptPack)>
readonly "preTagEvents": $Map<($ResourceKey<(never)>), ($PreTagKubeEvent)>
 "serverData": $SyncServerDataPayload
 "contextFactory": $KubeJSContextFactory

public static "release"(): $ServerScriptManager
public "reload"(): void
public static "createPackResources"(original: $List$$Type<($PackResources$$Type)>): $List<($PackResources)>
public "loadFromDirectory"(): void
public "loadAdditional"(): void
public static "createForDataGen"(): $ServerScriptManager
public "reloadAndCapture"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerScriptManager$$Type = ($ServerScriptManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerScriptManager$$Original = $ServerScriptManager;}
declare module "dev.latvian.mods.kubejs.client.ModelGenerator$Element" {
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$ModelGenerator$Face$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator$Face"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ModelGenerator$Element {
constructor()

public "size"(b: $AABB$$Type): $ModelGenerator$Element
public "toJson"(): $JsonObject
public "faces"(sides: ($Direction$$Type)[], face: $Consumer$$Type<($ModelGenerator$Face)>): void
public "allFaces"(face: $Consumer$$Type<($ModelGenerator$Face)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$Element$$Type = ($ModelGenerator$Element);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModelGenerator$Element$$Original = $ModelGenerator$Element;}
declare module "dev.latvian.mods.kubejs.util.ScheduledEvents$Callback" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$$Type} from "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent"

export interface $ScheduledEvents$Callback$$Interface {

(event: $ScheduledEvents$ScheduledEvent): void
}

export class $ScheduledEvents$Callback implements $ScheduledEvents$Callback$$Interface {
static readonly "TYPE_INFO": $TypeInfo

 "onCallback"(event: $ScheduledEvents$ScheduledEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledEvents$Callback$$Type = ((event: $ScheduledEvents$ScheduledEvent) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduledEvents$Callback$$Original = $ScheduledEvents$Callback;}
declare module "dev.latvian.mods.kubejs.fluid.ThinFluidBuilder" {
import {$FluidBucketItemBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBucketItemBuilder"
import {$FlowingFluidBuilder} from "dev.latvian.mods.kubejs.fluid.FlowingFluidBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$FluidBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBuilder"
import {$FluidTypeBuilder} from "dev.latvian.mods.kubejs.fluid.FluidTypeBuilder"
import {$FluidBlockBuilder} from "dev.latvian.mods.kubejs.fluid.FluidBlockBuilder"
import {$KubeColor} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ThinFluidBuilder extends $FluidBuilder {
static readonly "WATER_COLOR": $KubeColor
 "bucketItem": $FluidBucketItemBuilder
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "flowingFluid": $FlowingFluidBuilder
 "sourceLine": $SourceLine
 "fluidType": $FluidTypeBuilder
 "block": $FluidBlockBuilder
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThinFluidBuilder$$Type = ($ThinFluidBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ThinFluidBuilder$$Original = $ThinFluidBuilder;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponent" {
import {$TinyMap} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$OpsContainer$$Type} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$List, $List$$Type} from "java.util.List"
import {$ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$CustomObjectRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent"
import {$RecipeKey} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$EitherRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent"
import {$CustomObjectRecipeComponent$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$RecipeComponentBuilder} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder"
import {$RecipeComponentType} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$ListRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.ListRecipeComponent"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"

export interface $RecipeComponent$$Interface<T> {
get "ignored"(): boolean
}

export class $RecipeComponent<T> implements $RecipeComponent$$Interface {
 "type"(): $RecipeComponentType<(never)>
 "toString"(ops: $OpsContainer$$Type, value: T): StringJS
 "wrap"(cx: $RecipeScriptContext$$Type, from: any): T
 "isEmpty"(value: T): boolean
 "replace"(cx: $RecipeScriptContext$$Type, original: T, match: $ReplacementMatchInfo$$Type, arg3: any): T
 "matches"(cx: $RecipeMatchContext$$Type, value: T, match: $ReplacementMatchInfo$$Type): boolean
static "builder"(keys: $List$$Type<($CustomObjectRecipeComponent$Key$$Type)>): $CustomObjectRecipeComponent
static "builder"(...keys: ($CustomObjectRecipeComponent$Key$$Type)[]): $CustomObjectRecipeComponent
 "validate"(ctx: $RecipeValidationContext$$Type, value: T): void
 "typeInfo"(): $TypeInfo
 "key"(name: StringJS, role: $ComponentRole$$Type): $RecipeKey<(T)>
 "asList"(): $ListRecipeComponent<(T)>
 "spread"(value: T): $List<(never)>
 "or"<O>(other: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<(T), (O)>
 "allowEmpty"(): boolean
 "orSelf"(): $RecipeComponent<(T)>
 "createBuilder"(): $RecipeComponentBuilder
 "asConditionalListOrSelf"(): $ListRecipeComponent<(T)>
 "asMap"<K>(key: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), (T)>)>
 "codec"(): $Codec<(T)>
 "otherKey"(name: StringJS): $RecipeKey<(T)>
 "inputKey"(name: StringJS): $RecipeKey<(T)>
 "hasPriority"(cx: $RecipeMatchContext$$Type, from: any): boolean
 "outputKey"(name: StringJS): $RecipeKey<(T)>
 "readFromJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<(T)>, json: $JsonObject$$Type): void
 "writeToJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<(T)>, json: $JsonObject$$Type): void
 "buildUniqueId"(builder: $UniqueIdBuilder$$Type, value: T): void
 "asListOrSelf"(): $ListRecipeComponent<(T)>
 "asConditionalList"(): $ListRecipeComponent<(T)>
 "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (T)>)>
 "isIgnored"(): boolean
 "withCodec"(codec: $Codec$$Type<(T)>): $RecipeComponent<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponent$$Type<T> = ($RecipeComponent<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponent$$Original<T> = $RecipeComponent<(T)>;}
declare module "dev.latvian.mods.kubejs.plugin.ClassFilter" {
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Class$$Type} from "java.lang.Class"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ClassFilter {
readonly "scriptType": $ScriptType

constructor(scriptType: $ScriptType$$Type)

public "allow"(c: $Class$$Type<(never)>): void
public "allow"(s: StringJS): void
public "deny"(c: $Class$$Type<(never)>): void
public "deny"(s: StringJS): void
public "isAllowed"(s: StringJS): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassFilter$$Type = ($ClassFilter);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClassFilter$$Original = $ClassFilter;}
declare module "dev.latvian.mods.kubejs.core.ClientLevelKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$SpriteSet$$Type} from "net.minecraft.client.particle.SpriteSet"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$LevelKJS$$Interface} from "dev.latvian.mods.kubejs.core.LevelKJS"
import {$ExplosionProperties$$Type} from "dev.latvian.mods.kubejs.level.ExplosionProperties"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$KubeAnimatedParticle} from "dev.latvian.mods.kubejs.client.KubeAnimatedParticle"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ClientLevelKJS$$Interface extends $LevelKJS$$Interface {

(): $AttachedData$$Type<($Level$$Type)>
get "side"(): $ScriptType
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "dimension"(): $ResourceLocation
set "time"(value: long)
get "overworld"(): boolean
get "data"(): $AttachedData<($Level)>
get "players"(): $EntityArrayList
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "displayName"(): $Component
get "entities"(): $EntityArrayList
}

export class $ClientLevelKJS implements $ClientLevelKJS$$Interface {
 "self"(): $EntityGetter
 "kubeParticle"(x: double, y: double, z: double, spriteSet: $SpriteSet$$Type): $KubeAnimatedParticle
 "getSide"(): $ScriptType
 "getBlock"(pos: $BlockPos$$Type): $LevelBlock
 "getBlock"(entity: $BlockEntity$$Type): $LevelBlock
 "getBlock"(x: integer, y: integer, z: integer): $LevelBlock
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "tell"(message: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(command: StringJS): void
 "getDimension"(): $ResourceLocation
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean, cause: $ServerPlayer$$Type): void
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean): void
 "setTime"(time: long): void
 "spawnFireworks"(x: double, y: double, z: double, fireworks: $Fireworks$$Type, lifetime: integer): void
 "createEntity"(type: $EntityType$$Type<(never)>): $Entity
 "spawnParticles"(options: $ParticleOptions$$Type, overrideLimiter: boolean, x: double, y: double, z: double, vx: double, vy: double, vz: double, count: integer, speed: double): void
 "spawnEntity"(type: $EntityType$$Type<(never)>, callback: $Consumer$$Type<($Entity)>): void
 "isOverworld"(): boolean
 "explode"(x: double, y: double, z: double, properties: $ExplosionProperties$$Type): $Explosion
 "getData"(): $AttachedData<($Level)>
 "getPlayers"(): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getMcPlayers"(): $List<($Player)>
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getDisplayName"(): $Component
 "getEntities"(): $EntityArrayList
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientLevelKJS$$Type = (() => $AttachedData$$Type<($Level$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientLevelKJS$$Original = $ClientLevelKJS;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType" {
import {$RecipeTypeRegistryContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$Function$$Type} from "java.util.function.Function"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeKey} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$RecipeComponentCodecFactory$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentCodecFactory"
import {$RecipeComponentType$Unit} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType$Unit"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $RecipeComponentType<T> {
constructor(id: $ResourceLocation$$Type)

public "equals"(obj: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): $ResourceLocation
public "key"(name: StringJS, role: $ComponentRole$$Type): $RecipeKey<(T)>
public static "dynamic"<CT extends $RecipeComponent<(object)>>(id: $ResourceLocation$$Type, mapCodec: $MapCodec$$Type<(CT)>): $RecipeComponentType<(never)>
public static "dynamic"<CT extends $RecipeComponent<(object)>>(id: $ResourceLocation$$Type, codecFactory: $RecipeComponentCodecFactory$$Type<(CT)>): $RecipeComponentType<(never)>
public "instance"(): $RecipeComponent<(T)>
public static "unit"<T>(id: $ResourceLocation$$Type, instance: $RecipeComponent$$Type<(T)>): $RecipeComponentType$Unit<(T)>
public static "unit"<T>(id: $ResourceLocation$$Type, instanceGetter: $Function$$Type<($RecipeComponentType<(T)>), ($RecipeComponent$$Type<(T)>)>): $RecipeComponentType$Unit<(T)>
public "otherKey"(name: StringJS): $RecipeKey<(T)>
public "mapCodec"(ctx: $RecipeTypeRegistryContext$$Type): $MapCodec<($RecipeComponent<(never)>)>
public "inputKey"(name: StringJS): $RecipeKey<(T)>
public "isUnit"(): boolean
public "outputKey"(name: StringJS): $RecipeKey<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentType$$Type<T> = ($RecipeComponentType<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponentType$$Original<T> = $RecipeComponentType<(T)>;}
declare module "dev.latvian.mods.kubejs.util.NBTIOWrapper" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Path$$Type} from "java.nio.file.Path"

export interface $NBTIOWrapper$$Interface {
}

export class $NBTIOWrapper implements $NBTIOWrapper$$Interface {
static "write"(path: $Path$$Type, nbt: $CompoundTag$$Type): void
static "read"(path: $Path$$Type): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTIOWrapper$$Type = ($NBTIOWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NBTIOWrapper$$Original = $NBTIOWrapper;}
declare module "dev.latvian.mods.kubejs.core.ItemKJS" {
import {$Map} from "java.util.Map"
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"
import {$List} from "java.util.List"
import {$Holder} from "net.minecraft.core.Holder"
import {$ItemStackKey} from "dev.latvian.mods.kubejs.item.ItemStackKey"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$IngredientSupplierKJS$$Interface} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$ItemBuilder, $ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ItemKJS$$Interface extends $IngredientSupplierKJS$$Interface, $RegistryObjectKJS$$Interface<($Item)> {
set "canRepair"(value: boolean)
set "itemBuilder"(value: $ItemBuilder$$Type)
get "typeItemStackKey"(): $ItemStackKey
set "craftingRemainder"(value: $Item$$Type)
get "itemBuilder"(): $ItemBuilder
get "registryId"(): $ResourceKey<($Registry<($Item)>)>
get "registry"(): $Registry<($Item)>
get "typeData"(): $Map<(StringJS), (any)>
set "nameKey"(value: StringJS)
get "item"(): $Item
get "id"(): StringJS
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Item)>)>
get "tags"(): $List<($ResourceLocation)>
get "key"(): $ResourceKey<($Item)>
}

export class $ItemKJS implements $ItemKJS$$Interface {
 "setCanRepair"(repairable: boolean): void
 "setItemBuilder"(b: $ItemBuilder$$Type): void
 "getTypeItemStackKey"(): $ItemStackKey
 "setCraftingRemainder"(i: $Item$$Type): void
 "getItemBuilder"(): $ItemBuilder
 "getRegistryId"(): $ResourceKey<($Registry<($Item)>)>
 "getRegistry"(): $Registry<($Item)>
 "getTypeData"(): $Map<(StringJS), (any)>
 "setNameKey"(key: StringJS): void
 "getItem"(): $Item
 "kjs$asIngredient"(): $Ingredient
 "getId"(): StringJS
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getMod"(): StringJS
 "getIdLocation"(): $ResourceLocation
 "getTagKeys"(): $List<($TagKey<($Item)>)>
 "asHolder"(): $Holder<($Item)>
 "getTags"(): $List<($ResourceLocation)>
 "getKey"(): $ResourceKey<($Item)>
 "specialEquals"(o: any, shallow: boolean): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemKJS$$Type = ($ItemKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemKJS$$Original = $ItemKJS;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$HurtEnemyContext" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Record} from "java.lang.Record"

export class $ItemBuilder$HurtEnemyContext extends $Record {
constructor(getItem: $ItemStack$$Type, getTarget: $LivingEntity$$Type, getAttacker: $LivingEntity$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getTarget"(): $LivingEntity
public "getItem"(): $ItemStack
public "getAttacker"(): $LivingEntity
get "target"(): $LivingEntity
get "item"(): $ItemStack
get "attacker"(): $LivingEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$HurtEnemyContext$$Type = ({"getItem"?: $ItemStack$$Type, "getTarget"?: $LivingEntity$$Type, "getAttacker"?: $LivingEntity$$Type}) | ([getItem?: $ItemStack$$Type, getTarget?: $LivingEntity$$Type, getAttacker?: $LivingEntity$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$HurtEnemyContext$$Original = $ItemBuilder$HurtEnemyContext;}
declare module "dev.latvian.mods.kubejs.player.InventoryKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$AbstractContainerMenu, $AbstractContainerMenu$$Type} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player opens or closes a container.
 */
export class $InventoryKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, menu: $AbstractContainerMenu$$Type)

/**
 * Gets the player that opened or closed the container.
 */
public "getEntity"(): $LivingEntity
/**
 * Gets the container that was opened or closed.
 */
public "getInventoryContainer"(): $AbstractContainerMenu
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "entity"(): $LivingEntity
get "inventoryContainer"(): $AbstractContainerMenu
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryKubeEvent$$Type = ($InventoryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $InventoryKubeEvent$$Original = $InventoryKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction" {
import {$Pattern} from "java.util.regex.Pattern"
import {$RecipeSchemaType, $RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$BaseFunction} from "dev.latvian.mods.rhino.BaseFunction"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$WrappedJS$$Interface} from "dev.latvian.mods.kubejs.util.WrappedJS"
import {$KubeRecipe} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$ErrorStack$$Type} from "dev.latvian.mods.kubejs.util.ErrorStack"
import {$RecipesKubeEvent, $RecipesKubeEvent$$Type} from "dev.latvian.mods.kubejs.recipe.RecipesKubeEvent"
import {$DefaultValueTypeHint$$Type} from "dev.latvian.mods.rhino.util.DefaultValueTypeHint"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $RecipeTypeFunction extends $BaseFunction implements $WrappedJS$$Interface {
static readonly "DONTENUM": integer
static readonly "CONST": integer
readonly "idString": StringJS
readonly "schemaType": $RecipeSchemaType
static readonly "UNINITIALIZED_CONST": integer
readonly "serializerKey": $ResourceKey<($RecipeSerializer<(never)>)>
static readonly "SKIP_ERROR": $Pattern
readonly "id": $ResourceLocation
readonly "event": $RecipesKubeEvent
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "PERMANENT": integer

constructor(event: $RecipesKubeEvent$$Type, schemaType: $RecipeSchemaType$$Type)

public "equals"(obj: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "call"(scope: $Scriptable$$Type, thisObj: $Scriptable$$Type, args0: (any)[]): $KubeRecipe
public "createRecipe"(sourceLine: $SourceLine$$Type, stack: $ErrorStack$$Type, args: (any)[]): $KubeRecipe
public "getIds"(): (any)[]
public "getAllIds"(): (any)[]
public "get"(arg1: integer, arg2: $Scriptable$$Type): any
public "put"(arg1: integer, arg2: $Scriptable$$Type, arg3: any): void
public "delete"(arg1: integer): void
public "getDefaultValue"(arg1: $DefaultValueTypeHint$$Type): any
public "has"(arg1: integer, arg2: $Scriptable$$Type): boolean
public "setPrototype"(arg0: $Scriptable$$Type): void
public "getPrototype"(): $Scriptable
public "getParentScope"(): $Scriptable
public "setParentScope"(arg0: $Scriptable$$Type): void
get "ids"(): (any)[]
get "allIds"(): (any)[]
set "prototype"(value: $Scriptable$$Type)
get "prototype"(): $Scriptable
get "parentScope"(): $Scriptable
set "parentScope"(value: $Scriptable$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeTypeFunction$$Type = ($RecipeTypeFunction);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeTypeFunction$$Original = $RecipeTypeFunction;}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicateDataCheck" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"

export interface $BlockEntityPredicateDataCheck$$Interface {

(data: $CompoundTag): boolean
}

export class $BlockEntityPredicateDataCheck implements $BlockEntityPredicateDataCheck$$Interface {
 "checkData"(data: $CompoundTag$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityPredicateDataCheck$$Type = ((data: $CompoundTag) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityPredicateDataCheck$$Original = $BlockEntityPredicateDataCheck;}
declare module "dev.latvian.mods.kubejs.gui.KubeJSGUI" {
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$InventoryKJS, $InventoryKJS$$Type} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$Component} from "net.minecraft.network.chat.Component"
import {$SimpleContainer} from "net.minecraft.world.SimpleContainer"

export class $KubeJSGUI {
 "playerSlotsY": integer
 "playerSlotsX": integer
 "inventoryHeight": integer
 "width": integer
 "inventoryLabelY": integer
 "inventoryWidth": integer
 "inventoryLabelX": integer
 "title": $Component
 "inventory": $InventoryKJS
static readonly "EMPTY_CONTAINER": $SimpleContainer
 "height": integer

constructor()
constructor(buf: $FriendlyByteBuf$$Type)

public "write"(buf: $FriendlyByteBuf$$Type): void
public "setInventory"(inv: $InventoryKJS$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSGUI$$Type = ($KubeJSGUI);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSGUI$$Original = $KubeJSGUI;}
declare module "dev.latvian.mods.kubejs.block.entity.CustomCapabilityAttachment$Factory" {
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockCapability, $BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$BlockEntityAttachmentFactory$$Interface} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$List} from "java.util.List"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$BlockEntityAttachment} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"
import {$Record} from "java.lang.Record"

export class $CustomCapabilityAttachment$Factory extends $Record implements $BlockEntityAttachmentFactory$$Interface {
constructor(type: $BlockCapability$$Type<(never), (never)>, dataFactory: $Supplier$$Type<(never)>)

public "type"(): $BlockCapability<(never), (never)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "create"(info: $BlockEntityAttachmentInfo$$Type, entity: $KubeBlockEntity$$Type): $BlockEntityAttachment
public "getCapabilities"(): $List<($BlockCapability<(never), (never)>)>
public "dataFactory"(): $Supplier<(never)>
public "isTicking"(): boolean
get "capabilities"(): $List<($BlockCapability<(never), (never)>)>
get "ticking"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomCapabilityAttachment$Factory$$Type = ({"dataFactory"?: $Supplier$$Type<(never)>, "type"?: $BlockCapability$$Type<(never), (never)>}) | ([dataFactory?: $Supplier$$Type<(never)>, type?: $BlockCapability$$Type<(never), (never)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomCapabilityAttachment$Factory$$Original = $CustomCapabilityAttachment$Factory;}
declare module "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key" {
import {$RecipeTypeRegistryContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$Record} from "java.lang.Record"

export class $CustomObjectRecipeComponent$Key extends $Record {
constructor(name: StringJS, component: $RecipeComponent$$Type<(never)>, optional: boolean, alwaysWrite: boolean)
constructor(name: StringJS, component: $RecipeComponent$$Type<(never)>)
constructor(name: StringJS, component: $RecipeComponent$$Type<(never)>, optional: boolean)

public "name"(): StringJS
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "component"(): $RecipeComponent<(never)>
public "optional"(): boolean
public static "createCodec"(ctx: $RecipeTypeRegistryContext$$Type): $Codec<($CustomObjectRecipeComponent$Key)>
public "alwaysWrite"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomObjectRecipeComponent$Key$$Type = ({"alwaysWrite"?: boolean, "optional"?: boolean, "name"?: StringJS, "component"?: $RecipeComponent$$Type<(never)>}) | ([alwaysWrite?: boolean, optional?: boolean, name?: StringJS, component?: $RecipeComponent$$Type<(never)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomObjectRecipeComponent$Key$$Original = $CustomObjectRecipeComponent$Key;}
declare module "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer$Mode" {
import {$Enum} from "java.lang.Enum"

export class $HighlightRenderer$Mode extends $Enum<($HighlightRenderer$Mode)> {
static readonly "SCREEN": $HighlightRenderer$Mode
static readonly "NONE": $HighlightRenderer$Mode
static readonly "WORLD": $HighlightRenderer$Mode

public static "values"(): ($HighlightRenderer$Mode)[]
public static "valueOf"(name: StringJS): $HighlightRenderer$Mode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HighlightRenderer$Mode$$Type = (("none") | ("screen") | ("world"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HighlightRenderer$Mode$$Original = $HighlightRenderer$Mode;}
declare module "dev.latvian.mods.kubejs.block.BlockTintFunction" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$BlockAndTintGetter, $BlockAndTintGetter$$Type} from "net.minecraft.world.level.BlockAndTintGetter"
import {$KubeColor, $KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockTintFunction$Fixed} from "dev.latvian.mods.kubejs.block.BlockTintFunction$Fixed"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockTintFunction$$Interface {

(state: $BlockState, level: $BlockAndTintGetter, pos: $BlockPos, index: integer): $KubeColor$$Type
}

export class $BlockTintFunction implements $BlockTintFunction$$Interface {
static readonly "REDSTONE": $BlockTintFunction
static readonly "BIRCH_FOLIAGE": $BlockTintFunction$Fixed
static readonly "TYPE_INFO": $TypeInfo
static readonly "GRASS": $BlockTintFunction
static readonly "MANGROVE_FOLIAGE": $BlockTintFunction$Fixed
static readonly "FOLIAGE": $BlockTintFunction
static readonly "EVERGREEN_FOLIAGE": $BlockTintFunction$Fixed
static readonly "REDSTONE_COLORS": ($KubeColor)[]
static readonly "DEFAULT_FOLIAGE_COLOR": $KubeColor
static readonly "WATER": $BlockTintFunction

 "getColor"(state: $BlockState$$Type, level: $BlockAndTintGetter$$Type, pos: $BlockPos$$Type, index: integer): $KubeColor
static "wrap"(o: any): $BlockTintFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTintFunction$$Type = (($BlockTintFunction$$Type)[]) | (StringJS) | ((state: $BlockState, level: $BlockAndTintGetter, pos: $BlockPos, index: integer) => $KubeColor$$Type) | ((state: $BlockState, level: $BlockAndTintGetter, pos: $BlockPos, index: integer) => $KubeColor$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockTintFunction$$Original = $BlockTintFunction;}
declare module "dev.latvian.mods.kubejs.block.custom.CardinalBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $CardinalBlockBuilder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CardinalBlockBuilder$$Type = ($CardinalBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CardinalBlockBuilder$$Original = $CardinalBlockBuilder;}
declare module "dev.latvian.mods.kubejs.recipe.filter.RecipeFilterParseEvent" {
import {$Context} from "dev.latvian.mods.rhino.Context"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RecipeFilter, $RecipeFilter$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeFilter"
import {$List, $List$$Type} from "java.util.List"
import {$Event} from "net.neoforged.bus.api.Event"

export class $RecipeFilterParseEvent extends $Event {
readonly "cx": $Context
readonly "filters": $List<($RecipeFilter)>
readonly "map": $Map<(never), (never)>

constructor(filters: $List$$Type<($RecipeFilter$$Type)>, map: $Map$$Type<(never), (never)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeFilterParseEvent$$Type = ($RecipeFilterParseEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeFilterParseEvent$$Original = $RecipeFilterParseEvent;}
declare module "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator" {
import {$VariantBlockStateGenerator$Variant$$Type} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator$Variant"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $VariantBlockStateGenerator {
constructor()

public "variant"(key: StringJS, consumer: $Consumer$$Type<($VariantBlockStateGenerator$Variant)>): void
public "toJson"(): $JsonObject
public "simpleVariant"(key: StringJS, model: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateGenerator$$Type = ($VariantBlockStateGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $VariantBlockStateGenerator$$Original = $VariantBlockStateGenerator;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder" {
import {$ArmorMaterial$$Type} from "net.minecraft.world.item.ArmorMaterial"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ItemBuilder} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export class $ArmorItemBuilder extends $ItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

public "material"(material: $Holder$$Type<($ArmorMaterial)>): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$$Type = ($ArmorItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$$Original = $ArmorItemBuilder;}
declare module "dev.latvian.mods.kubejs.misc.PotionBuilder" {
import {$MobEffectInstance$$Type} from "net.minecraft.world.effect.MobEffectInstance"
import {$Potion} from "net.minecraft.world.item.alchemy.Potion"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export class $PotionBuilder extends $BuilderBase<($Potion)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "effect"(effect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer, ambient: boolean, visible: boolean): this
public "effect"(effect: $Holder$$Type<($MobEffect)>, duration: integer): this
public "effect"(effect: $Holder$$Type<($MobEffect)>): this
public "effect"(effect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer, ambient: boolean, visible: boolean, showIcon: boolean): this
public "effect"(effect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer, ambient: boolean, visible: boolean, showIcon: boolean, hiddenEffect: $MobEffectInstance$$Type): this
public "effect"(effect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer): this
public "addEffect"(effect: $MobEffectInstance$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotionBuilder$$Type = ($PotionBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PotionBuilder$$Original = $PotionBuilder;}
declare module "dev.latvian.mods.kubejs.util.OpsContainer" {
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Codec$$Type} from "com.mojang.serialization.Codec"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export class $OpsContainer {
static readonly "DEFAULT": $OpsContainer

constructor(nbt: $DynamicOps$$Type<($Tag$$Type)>, json: $DynamicOps$$Type<($JsonElement$$Type)>, java: $DynamicOps$$Type<(any)>)

public "decode"<T>(codec: $Codec$$Type<(T)>, o: any): T
public "java"(): $DynamicOps<(any)>
public "json"(): $DynamicOps<($JsonElement)>
public "nbt"(): $DynamicOps<($Tag)>
public "decodeMap"<T>(codec: $MapCodec$$Type<(T)>, o: any): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpsContainer$$Type = ($OpsContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $OpsContainer$$Original = $OpsContainer;}
declare module "dev.latvian.mods.kubejs.server.tag.TagKubeEvent" {
import {$EventExceptionHandler} from "dev.latvian.mods.kubejs.event.EventExceptionHandler"
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Map} from "java.util.Map"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Set} from "java.util.Set"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$TagWrapper} from "dev.latvian.mods.kubejs.server.tag.TagWrapper"

export class $TagKubeEvent implements $KubeEvent$$Interface {
readonly "registryKey": $ResourceKey<(never)>
 "totalRemoved": integer
static readonly "SOURCE": StringJS
readonly "vanillaRegistry": $Registry<(never)>
 "totalAdded": integer
static readonly "TAG_EVENT_HANDLER": $EventExceptionHandler
readonly "tags": $Map<($ResourceLocation), ($TagWrapper)>

constructor(registryKey: $ResourceKey$$Type<(never)>, vr: $Registry$$Type<(never)>)

public "remove"(tag: $ResourceLocation$$Type, ...filters: (any)[]): $TagWrapper
public "get"(id: $ResourceLocation$$Type): $TagWrapper
public "add"(tag: $ResourceLocation$$Type, ...filters: (any)[]): $TagWrapper
public "getType"(): $ResourceLocation
public "removeAll"(tag: $ResourceLocation$$Type): $TagWrapper
public "getElementIds"(): $Set<($ResourceLocation)>
public "removeAllTagsFrom"(...ids: (any)[]): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "type"(): $ResourceLocation
get "elementIds"(): $Set<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagKubeEvent$$Type = ($TagKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TagKubeEvent$$Original = $TagKubeEvent;}
declare module "dev.latvian.mods.kubejs.item.ModifyItemTooltipsKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$TooltipRequirements$$Type} from "dev.latvian.mods.kubejs.text.tooltip.TooltipRequirements"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$ItemTooltipData$$Type} from "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData"
import {$TextActionBuilder$$Type} from "dev.latvian.mods.kubejs.text.action.TextActionBuilder"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ModifyItemTooltipsKubeEvent implements $KubeEvent$$Interface {
constructor(callback: $Consumer$$Type<($ItemTooltipData)>)

public "modify"(filter: $Ingredient$$Type, requirements: $TooltipRequirements$$Type, consumer: $Consumer$$Type<($TextActionBuilder)>): void
public "modify"(filter: $Ingredient$$Type, consumer: $Consumer$$Type<($TextActionBuilder)>): void
public "add"(filter: $Ingredient$$Type, requirements: $TooltipRequirements$$Type, text: $List$$Type<($Component$$Type)>): void
public "add"(filter: $Ingredient$$Type, text: $List$$Type<($Component$$Type)>): void
public "modifyAll"(requirements: $TooltipRequirements$$Type, consumer: $Consumer$$Type<($TextActionBuilder)>): void
public "modifyAll"(consumer: $Consumer$$Type<($TextActionBuilder)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifyItemTooltipsKubeEvent$$Type = ($ModifyItemTooltipsKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModifyItemTooltipsKubeEvent$$Original = $ModifyItemTooltipsKubeEvent;}
declare module "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS" {
import {$MobEffectInstance, $MobEffectInstance$$Type} from "net.minecraft.world.effect.MobEffectInstance"
import {$Map} from "java.util.Map"
import {$Collection} from "java.util.Collection"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$MobEffect, $MobEffect$$Type} from "net.minecraft.world.effect.MobEffect"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"

export class $EntityPotionEffectsJS {
constructor(e: $LivingEntity$$Type)

public "clear"(): void
public "add"(mobEffect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer): void
public "add"(mobEffect: $Holder$$Type<($MobEffect)>, duration: integer): void
public "add"(mobEffect: $Holder$$Type<($MobEffect)>): void
public "add"(mobEffect: $Holder$$Type<($MobEffect)>, duration: integer, amplifier: integer, ambient: boolean, showParticles: boolean): void
public "isActive"(mobEffect: $Holder$$Type<($MobEffect)>): boolean
public "getMap"(): $Map<($Holder<($MobEffect)>), ($MobEffectInstance)>
public "getDuration"(mobEffect: $Holder$$Type<($MobEffect)>): integer
public "getActive"(mobEffect: $Holder$$Type<($MobEffect)>): $MobEffectInstance
public "getActive"(): $Collection<($MobEffectInstance)>
public "isApplicable"(effect: $MobEffectInstance$$Type): boolean
get "map"(): $Map<($Holder<($MobEffect)>), ($MobEffectInstance)>
get "active"(): $Collection<($MobEffectInstance)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityPotionEffectsJS$$Type = ($EntityPotionEffectsJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityPotionEffectsJS$$Original = $EntityPotionEffectsJS;}
declare module "dev.latvian.mods.kubejs.core.IngredientSupplierKJS" {
import {$Ingredient} from "net.minecraft.world.item.crafting.Ingredient"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $IngredientSupplierKJS$$Interface {
}

export class $IngredientSupplierKJS implements $IngredientSupplierKJS$$Interface {
 "kjs$asIngredient"(): $Ingredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientSupplierKJS$$Type = ($IngredientSupplierKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IngredientSupplierKJS$$Original = $IngredientSupplierKJS;}
declare module "dev.latvian.mods.kubejs.web.RelativeURL" {
import {$Map, $Map$$Type} from "java.util.Map"
import {$Record} from "java.lang.Record"

export class $RelativeURL extends $Record {
constructor(path: StringJS)
constructor(path: StringJS, query: $Map$$Type<(StringJS), (StringJS)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "query"(): $Map<(StringJS), (StringJS)>
public "path"(): StringJS
public "fullString"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RelativeURL$$Type = ({"query"?: $Map$$Type<(StringJS), (StringJS)>, "path"?: StringJS}) | ([query?: $Map$$Type<(StringJS), (StringJS)>, path?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RelativeURL$$Original = $RelativeURL;}
declare module "dev.latvian.mods.kubejs.player.PlayerAdvancementKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$AdvancementNode, $AdvancementNode$$Type} from "net.minecraft.advancements.AdvancementNode"
import {$Level} from "net.minecraft.world.level.Level"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player gets an advancement.
 */
export class $PlayerAdvancementKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $ServerPlayer$$Type, advancementNode: $AdvancementNode$$Type)

/**
 * Returns the player that got the advancement.
 */
public "getEntity"(): $Player
/**
 * Returns the advancement that was obtained.
 */
public "getAdvancement"(): $AdvancementNode
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "entity"(): $Player
get "advancement"(): $AdvancementNode
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerAdvancementKubeEvent$$Type = ($PlayerAdvancementKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerAdvancementKubeEvent$$Original = $PlayerAdvancementKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentHandler" {
import {$BlockCapability$$Type} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Set$$Type} from "java.util.Set"
import {$FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"

export interface $BlockEntityAttachmentHandler$$Interface {
}

export class $BlockEntityAttachmentHandler implements $BlockEntityAttachmentHandler$$Interface {
 "inventory"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, width: integer, height: integer): void
 "inventory"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, width: integer, height: integer, inputFilter: $ItemPredicate$$Type): void
 "attach"(id: StringJS, type: $ResourceLocation$$Type, directions: $Set$$Type<($Direction$$Type)>, args: any): void
 "fluidTank"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer, inputFilter: $FluidIngredient$$Type): void
 "fluidTank"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer): void
 "energyStorage"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capacity: integer, maxReceive: integer, maxExtract: integer, autoOutput: integer): void
 "attachCustomCapability"(id: StringJS, directions: $Set$$Type<($Direction$$Type)>, capability: $BlockCapability$$Type<(never), (never)>, dataFactory: $Supplier$$Type<(never)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentHandler$$Type = ($BlockEntityAttachmentHandler);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityAttachmentHandler$$Original = $BlockEntityAttachmentHandler;}
declare module "dev.latvian.mods.kubejs.core.ReloadableServerResourceHolderKJS" {
import {$ReloadableServerResourcesKJS, $ReloadableServerResourcesKJS$$Type} from "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ReloadableServerResourceHolderKJS$$Interface {
}

export class $ReloadableServerResourceHolderKJS implements $ReloadableServerResourceHolderKJS$$Interface {
 "kjs$setResources"(resources: $ReloadableServerResourcesKJS$$Type): void
 "kjs$getResources"(): $ReloadableServerResourcesKJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReloadableServerResourceHolderKJS$$Type = ($ReloadableServerResourceHolderKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReloadableServerResourceHolderKJS$$Original = $ReloadableServerResourceHolderKJS;}
declare module "dev.latvian.mods.kubejs.command.ArgumentTypeWrappers" {
import {$CommandContext$$Type} from "com.mojang.brigadier.context.CommandContext"
import {$ArgumentType} from "com.mojang.brigadier.arguments.ArgumentType"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Enum} from "java.lang.Enum"
import {$CommandRegistryKubeEvent$$Type} from "dev.latvian.mods.kubejs.command.CommandRegistryKubeEvent"
import {$ArgumentTypeWrapper, $ArgumentTypeWrapper$$Interface} from "dev.latvian.mods.kubejs.command.ArgumentTypeWrapper"
import {$CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"

export class $ArgumentTypeWrappers extends $Enum<($ArgumentTypeWrappers)> implements $ArgumentTypeWrapper$$Interface {
static readonly "ROTATION": $ArgumentTypeWrappers
static readonly "VEC2_CENTERED": $ArgumentTypeWrappers
static readonly "FLOAT": $ArgumentTypeWrappers
static readonly "PARTICLE": $ArgumentTypeWrappers
static readonly "INT_RANGE": $ArgumentTypeWrappers
static readonly "BLOCK_STATE": $ArgumentTypeWrappers
static readonly "NBT_TAG": $ArgumentTypeWrappers
static readonly "NBT_PATH": $ArgumentTypeWrappers
static readonly "ANGLE": $ArgumentTypeWrappers
static readonly "ITEM_PREDICATE": $ArgumentTypeWrappers
static readonly "BLOCK_POS_LOADED": $ArgumentTypeWrappers
static readonly "BLOCK_POS": $ArgumentTypeWrappers
static readonly "MESSAGE": $ArgumentTypeWrappers
static readonly "ITEM_SLOT": $ArgumentTypeWrappers
static readonly "ENTITY": $ArgumentTypeWrappers
static readonly "BLOCK_PREDICATE": $ArgumentTypeWrappers
static readonly "DIMENSION": $ArgumentTypeWrappers
static readonly "VEC2": $ArgumentTypeWrappers
static readonly "COLOR": $ArgumentTypeWrappers
static readonly "VEC3": $ArgumentTypeWrappers
static readonly "ITEM_STACK": $ArgumentTypeWrappers
static readonly "SWIZZLE": $ArgumentTypeWrappers
static readonly "OBJECTIVE": $ArgumentTypeWrappers
static readonly "DOUBLE": $ArgumentTypeWrappers
static readonly "ENTITIES": $ArgumentTypeWrappers
static readonly "UUID": $ArgumentTypeWrappers
static readonly "INTEGER": $ArgumentTypeWrappers
static readonly "LONG": $ArgumentTypeWrappers
static readonly "WORD": $ArgumentTypeWrappers
static readonly "VEC3_CENTERED": $ArgumentTypeWrappers
static readonly "TIME": $ArgumentTypeWrappers
static readonly "GREEDY_STRING": $ArgumentTypeWrappers
static readonly "NBT_COMPOUND": $ArgumentTypeWrappers
static readonly "BOOLEAN": $ArgumentTypeWrappers
static readonly "PLAYER": $ArgumentTypeWrappers
static readonly "RESOURCE_LOCATION": $ArgumentTypeWrappers
static readonly "FLOAT_RANGE": $ArgumentTypeWrappers
static readonly "PLAYERS": $ArgumentTypeWrappers
static readonly "GAME_PROFILE": $ArgumentTypeWrappers
static readonly "COLUMN_POS": $ArgumentTypeWrappers
static readonly "STRING": $ArgumentTypeWrappers
static readonly "COMPONENT": $ArgumentTypeWrappers
static readonly "ENTITY_ANCHOR": $ArgumentTypeWrappers

public static "values"(): ($ArgumentTypeWrappers)[]
public static "valueOf"(name: StringJS): $ArgumentTypeWrappers
public "time"(minRequired: integer): $ArgumentTypeWrapper
public "create"(event: $CommandRegistryKubeEvent$$Type): $ArgumentType<(never)>
public "getResult"(context: $CommandContext$$Type<($CommandSourceStack$$Type)>, input: StringJS): any
public static "byName"(name: $ResourceLocation$$Type): typeof never
public static "registry"<T>(event: $CommandRegistryKubeEvent$$Type, reg: $ResourceLocation$$Type): $ArgumentTypeWrapper
public static "printAll"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArgumentTypeWrappers$$Type = (("boolean") | ("float") | ("double") | ("integer") | ("long") | ("string") | ("greedy_string") | ("word") | ("entity") | ("entities") | ("player") | ("players") | ("game_profile") | ("block_pos") | ("block_pos_loaded") | ("column_pos") | ("vec3") | ("vec2") | ("vec3_centered") | ("vec2_centered") | ("block_state") | ("block_predicate") | ("item_stack") | ("item_predicate") | ("color") | ("component") | ("message") | ("nbt_compound") | ("nbt_tag") | ("nbt_path") | ("particle") | ("angle") | ("rotation") | ("swizzle") | ("item_slot") | ("resource_location") | ("entity_anchor") | ("int_range") | ("float_range") | ("dimension") | ("time") | ("uuid") | ("objective"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArgumentTypeWrappers$$Original = $ArgumentTypeWrappers;}
declare module "dev.latvian.mods.kubejs.entity.EntitySpawnedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an entity is about to be added to the world.
 * 
 * This event also fires for existing entities when they are loaded from a save.
 */
export class $EntitySpawnedKubeEvent implements $KubeEntityEvent$$Interface {
constructor(entity: $Entity$$Type, level: $Level$$Type)

/**
 * The level the entity is being added to.
 */
public "getLevel"(): $Level
/**
 * The entity being added to the world.
 */
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "entity"(): $Entity
get "player"(): $Player
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySpawnedKubeEvent$$Type = ($EntitySpawnedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntitySpawnedKubeEvent$$Original = $EntitySpawnedKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicate" {
import {$BlockPredicate$$Interface} from "dev.latvian.mods.kubejs.block.predicate.BlockPredicate"
import {$LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$BlockEntityPredicateDataCheck$$Type} from "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicateDataCheck"

export class $BlockEntityPredicate implements $BlockPredicate$$Interface {
constructor(i: $ResourceLocation$$Type)

public "toString"(): StringJS
public "data"(cd: $BlockEntityPredicateDataCheck$$Type): $BlockEntityPredicate
public "check"(block: $LevelBlock$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityPredicate$$Type = ($BlockEntityPredicate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityPredicate$$Original = $BlockEntityPredicate;}
declare module "dev.latvian.mods.kubejs.recipe.CompostableRecipesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$VirtualDataMapFile, $VirtualDataMapFile$$Type} from "dev.latvian.mods.kubejs.script.data.VirtualDataMapFile"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Compostable, $Compostable$$Type} from "net.neoforged.neoforge.registries.datamaps.builtin.Compostable"
import {$Record} from "java.lang.Record"

export class $CompostableRecipesKubeEvent extends $Record implements $KubeEvent$$Interface {
constructor(compostables: $VirtualDataMapFile$$Type<($Item$$Type), ($Compostable$$Type)>)

public "remove"(match: $ItemPredicate$$Type): void
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "replaceAll"(): void
public "add"(match: $ItemPredicate$$Type, f: float, villager: boolean): void
public "add"(match: $ItemPredicate$$Type, f: float): void
public "removeAll"(): void
public "compostables"(): $VirtualDataMapFile<($Item), ($Compostable)>
public "addReplace"(match: $ItemPredicate$$Type, f: float, villager: boolean): void
public "addReplace"(match: $ItemPredicate$$Type, f: float): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompostableRecipesKubeEvent$$Type = ({"compostables"?: $VirtualDataMapFile$$Type<($Item$$Type), ($Compostable$$Type)>}) | ([compostables?: $VirtualDataMapFile$$Type<($Item$$Type), ($Compostable$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CompostableRecipesKubeEvent$$Original = $CompostableRecipesKubeEvent;}
declare module "dev.latvian.mods.kubejs.player.PlayerStatsJS" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$Stat, $Stat$$Type} from "net.minecraft.stats.Stat"
import {$Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$StatsCounter$$Type} from "net.minecraft.stats.StatsCounter"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $PlayerStatsJS {
readonly "player": $Player

constructor(p: $Player$$Type, s: $StatsCounter$$Type)

public "get"(stat: $Stat$$Type<(never)>): integer
public "add"(stat: $Stat$$Type<(never)>, value: integer): void
public "set"(stat: $Stat$$Type<(never)>, value: integer): void
public static "wrapStat"(o: any): $Stat<(never)>
public "getSprintDistance"(): integer
public "getDamageResisted"(): integer
public "getItemsCrafted"(item: $Item$$Type): integer
public "getSwimDistance"(): integer
public "getItemsBroken"(item: $Item$$Type): integer
public "getItemsPickedUp"(item: $Item$$Type): integer
public "getTimeCrouchTime"(): integer
public "getMobKills"(): integer
public "getTimeSinceRest"(): integer
public "getTimeSinceDeath"(): integer
public "getDamageAbsorbed"(): integer
public "getFishCaught"(): integer
public "getBlocksMined"(block: $Block$$Type): integer
public "getCrouchDistance"(): integer
public "getItemsUsed"(item: $Item$$Type): integer
public "getKilledBy"(entity: $EntityType$$Type<(never)>): integer
public "getPlayTime"(): integer
public "getItemsDropped"(item: $Item$$Type): integer
public "getWalkDistance"(): integer
public "getDamageTaken"(): integer
public "getDamageDealt"(): integer
public "getAnimalsBred"(): integer
public "getPlayerKills"(): integer
public "getDamageDealt_resisted"(): integer
public "getDamageBlocked_by_shield"(): integer
public "getDamageDealt_absorbed"(): integer
public "getJumps"(): integer
public "getDeaths"(): integer
public "getKilled"(entity: $EntityType$$Type<(never)>): integer
get "sprintDistance"(): integer
get "damageResisted"(): integer
get "swimDistance"(): integer
get "timeCrouchTime"(): integer
get "mobKills"(): integer
get "timeSinceRest"(): integer
get "timeSinceDeath"(): integer
get "damageAbsorbed"(): integer
get "fishCaught"(): integer
get "crouchDistance"(): integer
get "playTime"(): integer
get "walkDistance"(): integer
get "damageTaken"(): integer
get "damageDealt"(): integer
get "animalsBred"(): integer
get "playerKills"(): integer
get "damageDealt_resisted"(): integer
get "damageBlocked_by_shield"(): integer
get "damageDealt_absorbed"(): integer
get "jumps"(): integer
get "deaths"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerStatsJS$$Type = ($PlayerStatsJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerStatsJS$$Original = $PlayerStatsJS;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $RecipeComponentBuilder$$Interface {
}

export class $RecipeComponentBuilder implements $RecipeComponentBuilder$$Interface {
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentBuilder$$Type = ($RecipeComponentBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponentBuilder$$Original = $RecipeComponentBuilder;}
declare module "dev.latvian.mods.kubejs.recipe.filter.RecipeFilter" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Predicate, $Predicate$$Type, $Predicate$$Interface} from "java.util.function.Predicate"
import {$RecipeMatchContext, $RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"

export interface $RecipeFilter$$Interface extends $Predicate$$Interface<($RecipeMatchContext)> {

(cx: $RecipeMatchContext): boolean
}

export class $RecipeFilter implements $RecipeFilter$$Interface {
 "test"(cx: $RecipeMatchContext$$Type): boolean
 "test"(cx: any): boolean
static "wrap"(o: any): $RecipeFilter
 "or"(arg0: $Predicate$$Type<($RecipeMatchContext)>): $Predicate<($RecipeMatchContext)>
 "negate"(): $Predicate<($RecipeMatchContext)>
 "and"(arg0: $Predicate$$Type<($RecipeMatchContext)>): $Predicate<($RecipeMatchContext)>
static "not"<T>(arg0: $Predicate$$Type<($RecipeMatchContext)>): $Predicate<($RecipeMatchContext)>
static "isEqual"<T>(arg0: any): $Predicate<($RecipeMatchContext)>
}
export type RecipeFilterObject = {"or"?: $RecipeFilter$$Type, "not"?: $RecipeFilter$$Type, "id"?: Special.RecipeId, "type"?: Special.RecipeSerializer, "group"?: StringJS, "mod"?: Special.Mod, "input"?: $Ingredient$$Type, "output"?: $ItemStack$$Type};
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeFilter$$Type = (RegExp) | ("*") | ("-") | (($RecipeFilter$$Type)[]) | (RecipeFilterObject) | ((cx: $RecipeMatchContext) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeFilter$$Original = $RecipeFilter;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.AddEntriesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"

export interface $AddEntriesKubeEvent$$Interface<E, F> extends $KubeEvent$$Interface {

(items: E): void
}

export class $AddEntriesKubeEvent<E, F> implements $AddEntriesKubeEvent$$Interface {
 "add"(items: E): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddEntriesKubeEvent$$Type<E, F> = ((items: (any)[]) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AddEntriesKubeEvent$$Original<E, F> = $AddEntriesKubeEvent<(E), (F)>;}
declare module "dev.latvian.mods.kubejs.util.TickDuration" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$TemporalUnit, $TemporalUnit$$Type} from "java.time.temporal.TemporalUnit"
import {$Codec} from "com.mojang.serialization.Codec"
import {$List} from "java.util.List"
import {$TemporalAmount$$Interface} from "java.time.temporal.TemporalAmount"
import {$Temporal, $Temporal$$Type} from "java.time.temporal.Temporal"
import {$Record} from "java.lang.Record"

export class $TickDuration extends $Record implements $TemporalAmount$$Interface {
static readonly "ZERO": $TickDuration
static readonly "CODEC": $Codec<($TickDuration)>
static readonly "SECONDS_CODEC": $Codec<($TickDuration)>
static readonly "MINUTES_CODEC": $Codec<($TickDuration)>
static readonly "TYPE_INFO": $TypeInfo
static readonly "HOURS_CODEC": $Codec<($TickDuration)>

constructor(ticks: long)

public "get"(unit: $TemporalUnit$$Type): long
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "wrap"(from: any): $TickDuration
public static "of"(ticks: long): $TickDuration
public "getUnits"(): $List<($TemporalUnit)>
public "addTo"(temporal: $Temporal$$Type): $Temporal
public "subtractFrom"(temporal: $Temporal$$Type): $Temporal
public "intTicks"(): integer
public "ticks"(): long
get "units"(): $List<($TemporalUnit)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickDuration$$Type = ({"ticks"?: long}) | ([ticks?: long]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TickDuration$$Original = $TickDuration;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$FinishUsingCallback" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export interface $ItemBuilder$FinishUsingCallback$$Interface {

(itemStack: $ItemStack, level: $Level, livingEntity: $LivingEntity): $ItemStack$$Type
}

export class $ItemBuilder$FinishUsingCallback implements $ItemBuilder$FinishUsingCallback$$Interface {
 "finishUsingItem"(itemStack: $ItemStack$$Type, level: $Level$$Type, livingEntity: $LivingEntity$$Type): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$FinishUsingCallback$$Type = ((itemStack: $ItemStack, level: $Level, livingEntity: $LivingEntity) => $ItemStack$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$FinishUsingCallback$$Original = $ItemBuilder$FinishUsingCallback;}
declare module "dev.latvian.mods.kubejs.recipe.CachedTagLookup" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$List, $List$$Type} from "java.util.List"
import {$Set} from "java.util.Set"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$Holder} from "net.minecraft.core.Holder"

export class $CachedTagLookup<T> {
readonly "registry": $Registry<(T)>
readonly "originalMap": $Map<($ResourceLocation), ($List<($TagLoader$EntryWithSource)>)>

constructor(registry: $Registry$$Type<(T)>, originalMap: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>)

public "values"(key: $TagKey$$Type<(T)>): $Set<(T)>
public "isEmpty"(key: $TagKey$$Type<(T)>): boolean
public "keys"(value: T): $Set<($TagKey<(T)>)>
public "build"(builders: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>): $Map<($ResourceLocation), ($Collection<(T)>)>
public "keyToValue"(): $Map<($TagKey<(T)>), ($Set<(T)>)>
public "tagMap"(): $Map<($ResourceLocation), ($Collection<($Holder<(T)>)>)>
public "bindingMap"(): $Map<($TagKey<(T)>), ($List<($Holder<(T)>)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedTagLookup$$Type<T> = ($CachedTagLookup<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CachedTagLookup$$Original<T> = $CachedTagLookup<(T)>;}
declare module "dev.latvian.mods.kubejs.web.SessionInfo" {
import {$Set, $Set$$Type} from "java.util.Set"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Record} from "java.lang.Record"

export class $SessionInfo extends $Record {
static readonly "NONE": $SessionInfo

constructor(source: StringJS, tags: $Set$$Type<(StringJS)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "source"(): StringJS
public "tags"(): $Set<(StringJS)>
public static "fromJson"(info: $SessionInfo$$Type, json: $JsonObject$$Type): $SessionInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SessionInfo$$Type = ({"tags"?: $Set$$Type<(StringJS)>, "source"?: StringJS}) | ([tags?: $Set$$Type<(StringJS)>, source?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SessionInfo$$Original = $SessionInfo;}
declare module "dev.latvian.mods.kubejs.component.ItemComponentFunctions" {
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ComponentFunctions, $ComponentFunctions$$Interface} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID$$Type} from "java.util.UUID"
import {$ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$EquipmentSlotGroup$$Type} from "net.minecraft.world.entity.EquipmentSlotGroup"
import {$List$$Type} from "java.util.List"
import {$ItemAttributeModifiers} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$FireworkExplosion$$Type} from "net.minecraft.world.item.component.FireworkExplosion"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$AttributeModifier, $AttributeModifier$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Instrument$$Type} from "net.minecraft.world.item.Instrument"
import {$Map$$Type} from "java.util.Map"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Tool$$Type} from "net.minecraft.world.item.component.Tool"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$AttributeModifierFunctions$$Interface} from "dev.latvian.mods.kubejs.component.AttributeModifierFunctions"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Unit$$Type} from "net.minecraft.util.Unit"

export interface $ItemComponentFunctions$$Interface extends $ComponentFunctions$$Interface, $AttributeModifierFunctions$$Interface {
get "unbreakableWithTooltip"(): void
set "maxStackSize"(value: integer)
set "mapItemColor"(value: $KubeColor$$Type)
set "bundleContents"(value: $List$$Type<($ItemStack$$Type)>)
set "bucketEntityData"(value: $CompoundTag$$Type)
set "fireworkExplosion"(value: $FireworkExplosion$$Type)
set "blockEntityData"(value: $CompoundTag$$Type)
get "fireResistant"(): void
set "noteBlockSound"(value: $ResourceLocation$$Type)
get "attributeModifiers"(): $ItemAttributeModifiers
set "chargedProjectiles"(value: $List$$Type<($ItemStack$$Type)>)
set "instrument"(value: $Holder$$Type<($Instrument)>)
get "unbreakable"(): void
set "itemName"(value: $Component$$Type)
set "repairCost"(value: integer)
set "tool"(value: $Tool$$Type)
set "food"(value: $FoodProperties$$Type)
set "fireworks"(value: $Fireworks$$Type)
set "damage"(value: integer)
set "maxDamage"(value: integer)
get "additionalTooltipHidden"(): void
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
get "componentMap"(): $DataComponentMap
get "componentString"(): StringJS
set "customModelData"(value: integer)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
get "tooltipHidden"(): void
set "potionContents"(value: $PotionContents$$Type)
set "glintOverride"(value: boolean)
set "dyedColor"(value: $KubeColor$$Type)
set "customData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
set "potionId"(value: $Holder$$Type<($Potion)>)
get "customData"(): $CompoundTag
set "lockCode"(value: StringJS)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "entityData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "customName"(value: $Component$$Type)
get "baseAttackDamage"(): double
set "attackDamage"(value: double)
get "baseAttackSpeed"(): double
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "baseAttackSpeed"(value: double)
set "baseAttackDamage"(value: double)
get "attackDamage"(): double
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "attackSpeed"(value: double)
get "attackSpeed"(): double
}

export class $ItemComponentFunctions implements $ItemComponentFunctions$$Interface {
 "setUnbreakableWithTooltip"(): void
 "setMaxStackSize"(size: integer): void
 "setMapItemColor"(color: $KubeColor$$Type): void
 "setBundleContents"(items: $List$$Type<($ItemStack$$Type)>): void
 "setBucketEntityData"(tag: $CompoundTag$$Type): void
 "setFireworkExplosion"(explosion: $FireworkExplosion$$Type): void
 "setBlockEntityData"(tag: $CompoundTag$$Type): void
 "setFireResistant"(): void
 "setNoteBlockSound"(id: $ResourceLocation$$Type): void
 "getAttributeModifiers"(): $ItemAttributeModifiers
 "setChargedProjectiles"(items: $List$$Type<($ItemStack$$Type)>): void
 "setInstrument"(instrument: $Holder$$Type<($Instrument)>): void
 "setUnbreakable"(): void
 "setItemName"(component: $Component$$Type): void
 "setRepairCost"(repairCost: integer): void
 "setTool"(tool: $Tool$$Type): void
 "setFood"(foodProperties: $FoodProperties$$Type): void
 "setFood"(nutrition: integer, saturation: float): void
 "setFireworks"(fireworks: $Fireworks$$Type): void
 "setDamage"(damage: integer): void
 "setMaxDamage"(maxDamage: integer): void
 "setAdditionalTooltipHidden"(): void
 "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
 "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
 "getComponentMap"(): $DataComponentMap
 "resetComponents"(): $ComponentFunctions
 "getComponentString"(): StringJS
 "setCustomModelData"(data: integer): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
 "setTooltipHidden"(): void
 "setPotionContents"(contents: $PotionContents$$Type): void
 "setGlintOverride"(override: boolean): void
 "get"<T>(type: $DataComponentType$$Type<(T)>): T
 "remove"(type: $DataComponentType$$Type<(never)>): $ComponentFunctions
 "patch"(components: $DataComponentPatch$$Type): $ComponentFunctions
 "set"(component: $DataComponentType$$Type<(never)>, value: any): $ComponentFunctions
 "set"(components: $DataComponentMap$$Type): $ComponentFunctions
 "setDyedColor"(color: $KubeColor$$Type): void
 "setCustomData"(tag: $CompoundTag$$Type): void
 "setProfile"(profile: $GameProfile$$Type): void
 "setProfile"(name: StringJS, uuid: $UUID$$Type): void
 "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "setPotionId"(potion: $Holder$$Type<($Potion)>): void
 "getCustomData"(): $CompoundTag
 "setLockCode"(lock: StringJS): void
 "getCustomName"(): $Component
 "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
 "setLore"(lines: $List$$Type<($Component$$Type)>): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "setRarity"(rarity: $Rarity$$Type): void
 "setBaseColor"(color: $DyeColor$$Type): void
 "setCustomName"(name: $Component$$Type): void
 "getBaseAttackDamage"(): double
/**
 * Sets the attack damage of this item to the given value, **removing** all other modifiers to attack damage.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 * (In practice, this simply means that most weapons have this value set to 1 less than what you might think.)
 */
 "setAttackDamage"(dmg: double): void
 "hasAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): boolean
 "getBaseAttackSpeed"(): double
 "setAttributeModifiers"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Overrides the *base* attack speed of this item to be the given value, keeping other modifiers intact.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 */
 "setBaseAttackSpeed"(speed: double): void
/**
 * Overrides the *base* attack damage of this item to be the given value, keeping other modifiers intact.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 */
 "setBaseAttackDamage"(dmg: double): void
 "addAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, mod: $AttributeModifier$$Type, slot: $EquipmentSlotGroup$$Type): void
 "getAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): $AttributeModifier
 "getAttackDamage"(): double
 "setAttributeModifiersWithTooltip"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Sets the attack speed of this item to the given value, **removing** all other modifiers to attack speed.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 * (Example: Swords have an attack speed of -2.4, leading to a total value of 1.6 without any other changes.)
 */
 "setAttackSpeed"(speed: double): void
 "getAttackSpeed"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemComponentFunctions$$Type = ($ItemComponentFunctions);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemComponentFunctions$$Original = $ItemComponentFunctions;}
declare module "dev.latvian.mods.kubejs.core.ItemStackKJS" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$EquipmentSlotGroup$$Type} from "net.minecraft.world.entity.EquipmentSlotGroup"
import {$RelativeURL} from "dev.latvian.mods.kubejs.web.RelativeURL"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ItemEnchantments, $ItemEnchantments$$Type} from "net.minecraft.world.item.enchantment.ItemEnchantments"
import {$SpecialEquality$$Interface} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$MutableDataComponentHolderFunctions, $MutableDataComponentHolderFunctions$$Interface} from "dev.latvian.mods.kubejs.component.MutableDataComponentHolderFunctions"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$AttributeModifier, $AttributeModifier$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$ItemMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ItemMatch"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$ItemComponentFunctions$$Interface} from "dev.latvian.mods.kubejs.component.ItemComponentFunctions"
import {$LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Unit$$Type} from "net.minecraft.util.Unit"
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ComponentFunctions} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$MutableDataComponentHolder} from "net.neoforged.neoforge.common.MutableDataComponentHolder"
import {$UUID$$Type} from "java.util.UUID"
import {$ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$List, $List$$Type} from "java.util.List"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$ItemAttributeModifiers} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$FireworkExplosion$$Type} from "net.minecraft.world.item.component.FireworkExplosion"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$ToStringJS$$Interface} from "dev.latvian.mods.rhino.util.ToStringJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$Item} from "net.minecraft.world.item.Item"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Instrument$$Type} from "net.minecraft.world.item.Instrument"
import {$Map, $Map$$Type} from "java.util.Map"
import {$WithCodec$$Interface} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Tool$$Type} from "net.minecraft.world.item.component.Tool"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Enchantment$$Type} from "net.minecraft.world.item.enchantment.Enchantment"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$IngredientSupplierKJS$$Interface} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ItemStackKJS$$Interface extends $SpecialEquality$$Interface, $WithCodec$$Interface, $IngredientSupplierKJS$$Interface, $ToStringJS$$Interface, $Replaceable$$Interface, $ItemComponentFunctions$$Interface, $MutableDataComponentHolderFunctions$$Interface, $ItemMatch$$Interface, $RegistryObjectKJS$$Interface<($Item)> {
get "id"(): StringJS
get "componentString"(): StringJS
get "block"(): $Block
get "mod"(): StringJS
get "harvestSpeed"(): float
get "enchantments"(): $ItemEnchantments
get "idLocation"(): $ResourceLocation
get "registryId"(): $ResourceKey<($Registry<($Item)>)>
get "registry"(): $Registry<($Item)>
get "typeData"(): $Map<(StringJS), (any)>
get "key"(): $ResourceKey<($Item)>
get "codec"(): $Codec<($ItemStack)>
get "unbreakableWithTooltip"(): void
set "maxStackSize"(value: integer)
set "mapItemColor"(value: $KubeColor$$Type)
set "bundleContents"(value: $List$$Type<($ItemStack$$Type)>)
set "bucketEntityData"(value: $CompoundTag$$Type)
set "fireworkExplosion"(value: $FireworkExplosion$$Type)
set "blockEntityData"(value: $CompoundTag$$Type)
get "fireResistant"(): void
set "noteBlockSound"(value: $ResourceLocation$$Type)
get "attributeModifiers"(): $ItemAttributeModifiers
set "chargedProjectiles"(value: $List$$Type<($ItemStack$$Type)>)
set "instrument"(value: $Holder$$Type<($Instrument)>)
get "unbreakable"(): void
set "itemName"(value: $Component$$Type)
set "repairCost"(value: integer)
set "tool"(value: $Tool$$Type)
set "food"(value: $FoodProperties$$Type)
set "fireworks"(value: $Fireworks$$Type)
set "damage"(value: integer)
set "maxDamage"(value: integer)
get "componentMap"(): $DataComponentMap
get "componentHolder"(): $MutableDataComponentHolder
get "tagKeys"(): $List<($TagKey<($Item)>)>
get "tags"(): $List<($ResourceLocation)>
get "additionalTooltipHidden"(): void
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
set "customModelData"(value: integer)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
get "tooltipHidden"(): void
set "potionContents"(value: $PotionContents$$Type)
set "glintOverride"(value: boolean)
set "dyedColor"(value: $KubeColor$$Type)
set "customData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
set "potionId"(value: $Holder$$Type<($Potion)>)
get "customData"(): $CompoundTag
set "lockCode"(value: StringJS)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "entityData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "customName"(value: $Component$$Type)
get "baseAttackDamage"(): double
set "attackDamage"(value: double)
get "baseAttackSpeed"(): double
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "baseAttackSpeed"(value: double)
set "baseAttackDamage"(value: double)
get "attackDamage"(): double
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "attackSpeed"(value: double)
get "attackSpeed"(): double
}

export class $ItemStackKJS implements $ItemStackKJS$$Interface {
 "toStringJS"(): StringJS
 "getId"(): StringJS
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $Ingredient$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, s: $ItemStack$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, itemLike: $ItemLike$$Type, exact: boolean): boolean
 "getComponentString"(): StringJS
 "getWebIconURL"(ops: $DynamicOps$$Type<($Tag$$Type)>, size: integer): $RelativeURL
 "getBlock"(): $Block
 "getMod"(): StringJS
 "getHarvestSpeed"(block: $LevelBlock$$Type): float
 "getHarvestSpeed"(): float
 "equalsIgnoringCount"(stack: $ItemStack$$Type): boolean
 "getEnchantments"(): $ItemEnchantments
 "areComponentsEqual"(other: $ItemStack$$Type): boolean
 "getIdLocation"(): $ResourceLocation
 "getRegistryId"(): $ResourceKey<($Registry<($Item)>)>
 "getRegistry"(): $Registry<($Item)>
 "asHolder"(): $Holder<($Item)>
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "getTypeData"(): $Map<(StringJS), (any)>
 "getKey"(): $ResourceKey<($Item)>
 "self"(): $ItemStack
 "getCodec"(): $Codec<($ItemStack)>
 "asIngredient"(): $Ingredient
 "specialEquals"(o: any, shallow: boolean): boolean
 "withCount"(c: integer): this
 "withLore"(lines: ($Component$$Type)[], styledLines: ($Component$$Type)[]): this
 "withLore"(lines: ($Component$$Type)[]): this
 "toItemString0"(dynamicOps: $DynamicOps$$Type<($Tag$$Type)>): StringJS
/**
 * 
 * @deprecated
 */
 "withChance"(chance: float): $ItemStack
 "withCustomName"(name: $Component$$Type): this
 "hasEnchantment"(enchantment: $Holder$$Type<($Enchantment)>, level: integer): boolean
 "enchant"(enchantment: $Holder$$Type<($Enchantment)>, level: integer): this
 "enchant"(enchantments: $ItemEnchantments$$Type): this
 "areItemsEqual"(other: $ItemStack$$Type): boolean
 "toItemString"(): StringJS
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
static "toStringJS"(arg1: any): StringJS
 "setUnbreakableWithTooltip"(): void
 "setMaxStackSize"(size: integer): void
 "setMapItemColor"(color: $KubeColor$$Type): void
 "setBundleContents"(items: $List$$Type<($ItemStack$$Type)>): void
 "setBucketEntityData"(tag: $CompoundTag$$Type): void
 "setFireworkExplosion"(explosion: $FireworkExplosion$$Type): void
 "setBlockEntityData"(tag: $CompoundTag$$Type): void
 "setFireResistant"(): void
 "setNoteBlockSound"(id: $ResourceLocation$$Type): void
 "getAttributeModifiers"(): $ItemAttributeModifiers
 "setChargedProjectiles"(items: $List$$Type<($ItemStack$$Type)>): void
 "setInstrument"(instrument: $Holder$$Type<($Instrument)>): void
 "setUnbreakable"(): void
 "setItemName"(component: $Component$$Type): void
 "setRepairCost"(repairCost: integer): void
 "setTool"(tool: $Tool$$Type): void
 "setFood"(foodProperties: $FoodProperties$$Type): void
 "setFood"(nutrition: integer, saturation: float): void
 "setFireworks"(fireworks: $Fireworks$$Type): void
 "setDamage"(damage: integer): void
 "setMaxDamage"(maxDamage: integer): void
 "getComponentMap"(): $DataComponentMap
 "patch"(components: $DataComponentPatch$$Type): $ComponentFunctions
 "set"(components: $DataComponentMap$$Type): $MutableDataComponentHolderFunctions
 "getComponentHolder"(): $MutableDataComponentHolder
 "matchesAny"(cx: $RecipeMatchContext$$Type, itemLikes: $Iterable$$Type<($ItemLike$$Type)>, exact: boolean): boolean
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getTagKeys"(): $List<($TagKey<($Item)>)>
 "getTags"(): $List<($ResourceLocation)>
 "setAdditionalTooltipHidden"(): void
 "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
 "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
 "resetComponents"(): $ComponentFunctions
 "setCustomModelData"(data: integer): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
 "setTooltipHidden"(): void
 "setPotionContents"(contents: $PotionContents$$Type): void
 "setGlintOverride"(override: boolean): void
 "get"<T>(type: $DataComponentType$$Type<(T)>): T
 "remove"(type: $DataComponentType$$Type<(never)>): $ComponentFunctions
 "set"(component: $DataComponentType$$Type<(never)>, value: any): $ComponentFunctions
 "setDyedColor"(color: $KubeColor$$Type): void
 "setCustomData"(tag: $CompoundTag$$Type): void
 "setProfile"(profile: $GameProfile$$Type): void
 "setProfile"(name: StringJS, uuid: $UUID$$Type): void
 "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "setPotionId"(potion: $Holder$$Type<($Potion)>): void
 "getCustomData"(): $CompoundTag
 "setLockCode"(lock: StringJS): void
 "getCustomName"(): $Component
 "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
 "setLore"(lines: $List$$Type<($Component$$Type)>): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "setRarity"(rarity: $Rarity$$Type): void
 "setBaseColor"(color: $DyeColor$$Type): void
 "setCustomName"(name: $Component$$Type): void
 "getBaseAttackDamage"(): double
/**
 * Sets the attack damage of this item to the given value, **removing** all other modifiers to attack damage.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 * (In practice, this simply means that most weapons have this value set to 1 less than what you might think.)
 */
 "setAttackDamage"(dmg: double): void
 "hasAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): boolean
 "getBaseAttackSpeed"(): double
 "setAttributeModifiers"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Overrides the *base* attack speed of this item to be the given value, keeping other modifiers intact.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 */
 "setBaseAttackSpeed"(speed: double): void
/**
 * Overrides the *base* attack damage of this item to be the given value, keeping other modifiers intact.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 */
 "setBaseAttackDamage"(dmg: double): void
 "addAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, mod: $AttributeModifier$$Type, slot: $EquipmentSlotGroup$$Type): void
 "getAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): $AttributeModifier
 "getAttackDamage"(): double
 "setAttributeModifiersWithTooltip"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Sets the attack speed of this item to the given value, **removing** all other modifiers to attack speed.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 * (Example: Swords have an attack speed of -2.4, leading to a total value of 1.6 without any other changes.)
 */
 "setAttackSpeed"(speed: double): void
 "getAttackSpeed"(): double
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackKJS$$Type = ($ItemStackKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemStackKJS$$Original = $ItemStackKJS;}
declare module "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundInstance" {
import {$JsonElement} from "com.google.gson.JsonElement"

export class $SoundsGenerator$SoundInstance {
constructor(fileLocation: StringJS)

public "pitch"(f: float): $SoundsGenerator$SoundInstance
public "volume"(f: float): $SoundsGenerator$SoundInstance
public "stream"(): $SoundsGenerator$SoundInstance
public "stream"(b: boolean): $SoundsGenerator$SoundInstance
public "toJson"(): $JsonElement
public "weight"(i: integer): $SoundsGenerator$SoundInstance
public "preload"(b: boolean): $SoundsGenerator$SoundInstance
public "preload"(): $SoundsGenerator$SoundInstance
public "attenuationDistance"(i: integer): $SoundsGenerator$SoundInstance
public "asReferenceToEvent"(): $SoundsGenerator$SoundInstance
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundsGenerator$SoundInstance$$Type = ($SoundsGenerator$SoundInstance);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoundsGenerator$SoundInstance$$Original = $SoundsGenerator$SoundInstance;}
declare module "dev.latvian.mods.kubejs.misc.CustomStatBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $CustomStatBuilder extends $BuilderBase<($ResourceLocation)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomStatBuilder$$Type = ($CustomStatBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomStatBuilder$$Original = $CustomStatBuilder;}
declare module "dev.latvian.mods.kubejs.block.callback.AfterEntityFallenOnBlockCallback" {
import {$BlockGetter$$Type} from "net.minecraft.world.level.BlockGetter"
import {$Vec3, $Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$EntitySteppedOnBlockCallback} from "dev.latvian.mods.kubejs.block.callback.EntitySteppedOnBlockCallback"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"

export class $AfterEntityFallenOnBlockCallback extends $EntitySteppedOnBlockCallback {
constructor(blockGetter: $BlockGetter$$Type, entity: $Entity$$Type)

/**
 * Bounce the entity upwards by bounciness * their fall velocity.
 * Do not make bounciness negative, as that is a recipe for a long and laggy trip to the void
 */
public "bounce"(bounciness: float): void
/**
 * Returns the Vec3 of the entity's velocity. Use .x, .y and .z to get the respective components of that
 */
public "getVelocity"(): $Vec3
/**
 * Sets the entity's velocity
 */
public "setVelocity"(x: float, y: float, z: float): void
/**
 * Sets the entity's velocity
 */
public "setVelocity"(vec: $Vec3$$Type): void
get "velocity"(): $Vec3
set "velocity"(value: $Vec3$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterEntityFallenOnBlockCallback$$Type = ($AfterEntityFallenOnBlockCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AfterEntityFallenOnBlockCallback$$Original = $AfterEntityFallenOnBlockCallback;}
declare module "dev.latvian.mods.kubejs.block.custom.BasicKubeBlock$Builder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $BasicKubeBlock$Builder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicKubeBlock$Builder$$Type = ($BasicKubeBlock$Builder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BasicKubeBlock$Builder$$Original = $BasicKubeBlock$Builder;}
declare module "dev.latvian.mods.kubejs.core.ServerLevelKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$WithPersistentData$$Interface} from "dev.latvian.mods.kubejs.core.WithPersistentData"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$LevelKJS$$Interface} from "dev.latvian.mods.kubejs.core.LevelKJS"
import {$ExplosionProperties$$Type} from "dev.latvian.mods.kubejs.level.ExplosionProperties"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ServerLevelKJS$$Interface extends $LevelKJS$$Interface, $WithPersistentData$$Interface {

(): $AttachedData$$Type<($Level$$Type)>
get "side"(): $ScriptType
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "dimension"(): $ResourceLocation
set "time"(value: long)
get "overworld"(): boolean
get "persistentData"(): $CompoundTag
get "data"(): $AttachedData<($Level)>
get "players"(): $EntityArrayList
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "displayName"(): $Component
get "entities"(): $EntityArrayList
}

export class $ServerLevelKJS implements $ServerLevelKJS$$Interface {
 "self"(): $EntityGetter
 "spawnParticles"(options: $ParticleOptions$$Type, overrideLimiter: boolean, x: double, y: double, z: double, vx: double, vy: double, vz: double, count: integer, speed: double): void
 "getSide"(): $ScriptType
 "getBlock"(pos: $BlockPos$$Type): $LevelBlock
 "getBlock"(entity: $BlockEntity$$Type): $LevelBlock
 "getBlock"(x: integer, y: integer, z: integer): $LevelBlock
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "tell"(message: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(command: StringJS): void
 "getDimension"(): $ResourceLocation
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean, cause: $ServerPlayer$$Type): void
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean): void
 "setTime"(time: long): void
 "spawnFireworks"(x: double, y: double, z: double, fireworks: $Fireworks$$Type, lifetime: integer): void
 "createEntity"(type: $EntityType$$Type<(never)>): $Entity
 "spawnEntity"(type: $EntityType$$Type<(never)>, callback: $Consumer$$Type<($Entity)>): void
 "isOverworld"(): boolean
 "explode"(x: double, y: double, z: double, properties: $ExplosionProperties$$Type): $Explosion
 "getPersistentData"(): $CompoundTag
 "getData"(): $AttachedData<($Level)>
 "getPlayers"(): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getMcPlayers"(): $List<($Player)>
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getDisplayName"(): $Component
 "getEntities"(): $EntityArrayList
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerLevelKJS$$Type = (() => $AttachedData$$Type<($Level$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerLevelKJS$$Original = $ServerLevelKJS;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchema, $RecipeSchema$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchema"
import {$RecipeNamespace, $RecipeNamespace$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RecipeSerializer} from "net.minecraft.world.item.crafting.RecipeSerializer"

export class $RecipeSchemaType {
readonly "schema": $RecipeSchema
 "parent": $RecipeSchemaType
readonly "serializerType": StringJS
readonly "namespace": $RecipeNamespace
readonly "serializerKey": $ResourceKey<($RecipeSerializer<(never)>)>
readonly "id": $ResourceLocation

constructor(namespace: $RecipeNamespace$$Type, id: $ResourceLocation$$Type, schema: $RecipeSchema$$Type)

public "getSerializer"(): $RecipeSerializer<(never)>
public "toString"(): StringJS
get "serializer"(): $RecipeSerializer<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchemaType$$Type = ($RecipeSchemaType);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeSchemaType$$Original = $RecipeSchemaType;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.ParticleOptionsWrapper" {
import {$DustParticleOptions} from "net.minecraft.core.particles.DustParticleOptions"
import {$RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ParticleOptionsWrapper$$Interface {
}

export class $ParticleOptionsWrapper implements $ParticleOptionsWrapper$$Interface {
static readonly "ERROR": $DustParticleOptions

static "wrap"(registries: $RegistryAccessContainer$$Type, o: any): $ParticleOptions
static "create"(options: $ParticleOptions$$Type): $ParticleOptions
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleOptionsWrapper$$Type = ($ParticleOptionsWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ParticleOptionsWrapper$$Original = $ParticleOptionsWrapper;}
declare module "dev.latvian.mods.kubejs.event.EventHandlerContainer" {
import {$EventHandler$$Type} from "dev.latvian.mods.kubejs.event.EventHandler"
import {$KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ConsoleJS$$Type} from "dev.latvian.mods.kubejs.script.ConsoleJS"
import {$IEventHandler, $IEventHandler$$Type} from "dev.latvian.mods.kubejs.event.IEventHandler"
import {$EventResult} from "dev.latvian.mods.kubejs.event.EventResult"

export class $EventHandlerContainer {
readonly "handler": $IEventHandler
readonly "line": integer
readonly "source": StringJS
readonly "target": any

constructor(target: any, handler: $IEventHandler$$Type, source: StringJS, line: integer)

public "toString"(): StringJS
public static "isEmpty"(array: ($EventHandlerContainer$$Type)[]): boolean
public "add"(extraId: any, handler: $IEventHandler$$Type, source: StringJS, line: integer): void
public "handle"(console: $ConsoleJS$$Type, handler: $EventHandler$$Type, event: $KubeEvent$$Type): $EventResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventHandlerContainer$$Type = ($EventHandlerContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventHandlerContainer$$Original = $EventHandlerContainer;}
declare module "dev.latvian.mods.kubejs.util.Tristate" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$BooleanSupplier$$Type} from "java.util.function.BooleanSupplier"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export class $Tristate extends $Enum<($Tristate)> implements $StringRepresentable$$Interface {
static readonly "CODEC": $Codec<($Tristate)>
static readonly "TRUE": $Tristate
static readonly "FALSE": $Tristate
static readonly "VALUES": ($Tristate)[]
static readonly "DEFAULT": $Tristate
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($Tristate)>

public static "values"(): ($Tristate)[]
public "test"(enabled: $BooleanSupplier$$Type): boolean
public "test"(enabled: boolean): boolean
public static "valueOf"(name: StringJS): $Tristate
public static "wrap"(from: any): $Tristate
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Tristate$$Type = (("false") | ("true") | ("default"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Tristate$$Original = $Tristate;}
declare module "dev.latvian.mods.kubejs.client.ParticleProviderRegistryKubeEvent" {
import {$ParticleProvider$$Type} from "net.minecraft.client.particle.ParticleProvider"
import {$RegisterParticleProvidersEvent$$Type} from "net.neoforged.neoforge.client.event.RegisterParticleProvidersEvent"
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$ParticleType$$Type} from "net.minecraft.core.particles.ParticleType"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$KubeAnimatedParticle$$Type} from "dev.latvian.mods.kubejs.client.KubeAnimatedParticle"
import {$ParticleOptions} from "net.minecraft.core.particles.ParticleOptions"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Type} from "dev.latvian.mods.kubejs.client.ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider"

export class $ParticleProviderRegistryKubeEvent implements $ClientKubeEvent$$Interface {
constructor(event: $RegisterParticleProvidersEvent$$Type)

public "register"<T extends $ParticleOptions>(type: $ParticleType$$Type<(T)>): void
public "register"<T extends $ParticleOptions>(type: $ParticleType$$Type<(T)>, particle: $Consumer$$Type<($KubeAnimatedParticle)>): void
public "register"<T extends $ParticleOptions>(type: $ParticleType$$Type<(T)>, spriteProvider: $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Type<(T)>): void
public "registerSpecial"<T extends $ParticleOptions>(type: $ParticleType$$Type<(T)>, provider: $ParticleProvider$$Type<(T)>): void
public "getClient"(): $Minecraft
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleProviderRegistryKubeEvent$$Type = ($ParticleProviderRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ParticleProviderRegistryKubeEvent$$Original = $ParticleProviderRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.SizedIngredientWrapper" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$SizedIngredient, $SizedIngredient$$Type} from "net.neoforged.neoforge.common.crafting.SizedIngredient"

/**
 * Various SizedIngredient related helper methods
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $SizedIngredientWrapper$$Interface {
}

export class $SizedIngredientWrapper implements $SizedIngredientWrapper$$Interface {
/**
 * An ingredient that matches everything
 */
static readonly "all": $SizedIngredient
static readonly "TYPE_INFO": $TypeInfo
/**
 * A completely empty ingredient that will only match air
 */
static readonly "empty": $SizedIngredient

/**
 * Returns a sized ingredient of the input
 */
static "of"(ingredient: $SizedIngredient$$Type): $SizedIngredient
/**
 * Returns a sized ingredient of the input
 */
static "of"(ingredient: $Ingredient$$Type, count: integer): $SizedIngredient
static "ofTag"(tag: $TagKey$$Type<($Item)>, count: integer): $SizedIngredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SizedIngredientWrapper$$Type = ($SizedIngredientWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SizedIngredientWrapper$$Original = $SizedIngredientWrapper;}
declare module "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer" {
import {$HighlightRenderer$Mode} from "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer$Mode"
import {$IntOpenHashSet} from "it.unimi.dsi.fastutil.ints.IntOpenHashSet"
import {$Long2IntMap} from "it.unimi.dsi.fastutil.longs.Long2IntMap"
import {$KeyMapping} from "net.minecraft.client.KeyMapping"
import {$HighlightRenderer$ShaderChain} from "dev.latvian.mods.kubejs.client.highlight.HighlightRenderer$ShaderChain"
import {$Slot} from "net.minecraft.world.inventory.Slot"
import {$AbstractContainerScreen$$Type} from "net.minecraft.client.gui.screens.inventory.AbstractContainerScreen"
import {$GuiGraphics$$Type} from "net.minecraft.client.gui.GuiGraphics"
import {$Reference2IntMap} from "it.unimi.dsi.fastutil.objects.Reference2IntMap"
import {$RenderLevelStageEvent$$Type} from "net.neoforged.neoforge.client.event.RenderLevelStageEvent"
import {$ShaderInstance} from "net.minecraft.client.renderer.ShaderInstance"
import {$KubeColor} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Set} from "java.util.Set"
import {$Minecraft$$Type} from "net.minecraft.client.Minecraft"
import {$Entity} from "net.minecraft.world.entity.Entity"

export class $HighlightRenderer {
readonly "highlightedEntities": $Reference2IntMap<($Entity)>
 "color": $KubeColor
static "INSTANCE": $HighlightRenderer
readonly "hoveredSlots": $Set<($Slot)>
static "keyMapping": $KeyMapping
readonly "uniqueColors": $IntOpenHashSet
 "highlightShader": $ShaderInstance
 "mode": $HighlightRenderer$Mode
 "worldChain": $HighlightRenderer$ShaderChain
 "actualKey": boolean
 "guiChain": $HighlightRenderer$ShaderChain
 "cancelBlockHighlight": boolean
readonly "highlightedBlocks": $Long2IntMap

constructor()

public "updateDepth"(mc: $Minecraft$$Type): void
public "screen"(mc: $Minecraft$$Type, graphics: $GuiGraphics$$Type, screen: $AbstractContainerScreen$$Type<(never)>, mx: integer, my: integer, delta: float): void
public "hudPostDraw"(mc: $Minecraft$$Type, graphics: $GuiGraphics$$Type, delta: float): void
public "clearBuffers"(mc: $Minecraft$$Type): void
public "renderAfterLevel"(mc: $Minecraft$$Type, event: $RenderLevelStageEvent$$Type): void
public "resizePostChains"(width: integer, height: integer): void
public "loadPostChains"(mc: $Minecraft$$Type): void
public "renderAfterEntities"(mc: $Minecraft$$Type, event: $RenderLevelStageEvent$$Type): void
public "tickPre"(mc: $Minecraft$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HighlightRenderer$$Type = ($HighlightRenderer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $HighlightRenderer$$Original = $HighlightRenderer;}
declare module "dev.latvian.mods.kubejs.block.custom.TrapdoorBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$BlockSetType$$Type} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $TrapdoorBlockBuilder extends $ShapedBlockBuilder {
static readonly "TRAPDOOR_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

public "behaviour"(wt: $BlockSetType$$Type): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrapdoorBlockBuilder$$Type = ($TrapdoorBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TrapdoorBlockBuilder$$Original = $TrapdoorBlockBuilder;}
declare module "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map} from "java.util.Map"
import {$BlockEntityTicker} from "net.minecraft.world.level.block.entity.BlockEntityTicker"
import {$UUID} from "java.util.UUID"
import {$BlockEntityInfo, $BlockEntityInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityInfo"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$HolderLookup$Provider$$Type} from "net.minecraft.core.HolderLookup$Provider"
import {$ClientGamePacketListener} from "net.minecraft.network.protocol.game.ClientGamePacketListener"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Packet} from "net.minecraft.network.protocol.Packet"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $KubeBlockEntity extends $BlockEntity {
readonly "attachments": $Map<(StringJS), (any)>
 "data": $CompoundTag
static readonly "ATTACHMENTS_NBT_KEY": StringJS
 "tick": integer
 "placerId": $UUID
 "cycle": integer
readonly "blockKey": $ResourceKey<($Block)>
static readonly "TICKER": $BlockEntityTicker<($KubeBlockEntity)>
readonly "x": integer
readonly "y": integer
readonly "z": integer
readonly "info": $BlockEntityInfo

constructor(blockPos: $BlockPos$$Type, blockState: $BlockState$$Type, entityInfo: $BlockEntityInfo$$Type)

public "save"(): void
public "sync"(): void
public "setLevel"(level: $Level$$Type): void
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
public "loadAdditional"(tag: $CompoundTag$$Type, registries: $HolderLookup$Provider$$Type): void
public "getBlock"(): $LevelBlock
public "getUpdateTag"(provider: $HolderLookup$Provider$$Type): $CompoundTag
public "sendEvent"(eventId: integer, data: integer): void
public "triggerEvent"(eventId: integer, data: integer): boolean
public "getPlacer"(): $Entity
set "level"(value: $Level$$Type)
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
get "block"(): $LevelBlock
get "placer"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeBlockEntity$$Type = ($KubeBlockEntity);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeBlockEntity$$Original = $KubeBlockEntity;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$ReleaseUsingCallback" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"

export interface $ItemBuilder$ReleaseUsingCallback$$Interface {

(itemStack: $ItemStack, level: $Level, user: $LivingEntity, tick: integer): void
}

export class $ItemBuilder$ReleaseUsingCallback implements $ItemBuilder$ReleaseUsingCallback$$Interface {
 "releaseUsing"(itemStack: $ItemStack$$Type, level: $Level$$Type, user: $LivingEntity$$Type, tick: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$ReleaseUsingCallback$$Type = ((itemStack: $ItemStack, level: $Level, user: $LivingEntity, tick: integer) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$ReleaseUsingCallback$$Original = $ItemBuilder$ReleaseUsingCallback;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory" {
import {$KubeBlockEntity, $KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$BlockCapability} from "net.neoforged.neoforge.capabilities.BlockCapability"
import {$BlockEntityAttachmentInfo, $BlockEntityAttachmentInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo"
import {$List} from "java.util.List"
import {$BlockEntityAttachment, $BlockEntityAttachment$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachment"

export interface $BlockEntityAttachmentFactory$$Interface {

(info: $BlockEntityAttachmentInfo, entity: $KubeBlockEntity): $BlockEntityAttachment$$Type
get "capabilities"(): $List<($BlockCapability<(never), (never)>)>
get "ticking"(): boolean
}

export class $BlockEntityAttachmentFactory implements $BlockEntityAttachmentFactory$$Interface {
 "create"(info: $BlockEntityAttachmentInfo$$Type, entity: $KubeBlockEntity$$Type): $BlockEntityAttachment
 "getCapabilities"(): $List<($BlockCapability<(never), (never)>)>
 "isTicking"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentFactory$$Type = ((info: $BlockEntityAttachmentInfo, entity: $KubeBlockEntity) => $BlockEntityAttachment$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityAttachmentFactory$$Original = $BlockEntityAttachmentFactory;}
declare module "dev.latvian.mods.kubejs.script.ScriptTypePredicate" {
import {$List} from "java.util.List"
import {$Predicate, $Predicate$$Type, $Predicate$$Interface} from "java.util.function.Predicate"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ScriptTypePredicate$$Interface extends $Predicate$$Interface<($ScriptType)> {

(type: $ScriptType): boolean
get "validTypes"(): $List<($ScriptType)>
}

export class $ScriptTypePredicate implements $ScriptTypePredicate$$Interface {
static readonly "ALL": $ScriptTypePredicate
static readonly "STARTUP_OR_CLIENT": $ScriptTypePredicate
static readonly "COMMON": $ScriptTypePredicate
static readonly "STARTUP_OR_SERVER": $ScriptTypePredicate

 "test"(type: $ScriptType$$Type): boolean
 "test"(type: any): boolean
 "getValidTypes"(): $List<($ScriptType)>
 "or"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
 "negate"(): $Predicate<($ScriptType)>
 "and"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
static "not"<T>(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
static "isEqual"<T>(arg0: any): $Predicate<($ScriptType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptTypePredicate$$Type = ((type: $ScriptType) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptTypePredicate$$Original = $ScriptTypePredicate;}
declare module "dev.latvian.mods.kubejs.util.TinyMap" {
import {$Collection$$Type} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$TinyMap$Entry, $TinyMap$Entry$$Type} from "dev.latvian.mods.kubejs.util.TinyMap$Entry"
import {$Record} from "java.lang.Record"

export class $TinyMap<K, V> extends $Record {
constructor(entries: ($TinyMap$Entry$$Type<(K), (V)>)[])
constructor(map: $TinyMap$$Type<(K), (V)>)
constructor(collection: $Collection$$Type<($TinyMap$Entry$$Type<(K), (V)>)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public "toMap"(): $Map<(K), (V)>
public "entries"(): ($TinyMap$Entry<(K), (V)>)[]
public static "ofMap"<K, V>(map: $Map$$Type<(K), (V)>): $TinyMap<(K), (V)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TinyMap$$Type<K, V> = ({"entries"?: ($TinyMap$Entry$$Type<(K), (V)>)[]}) | ([entries?: ($TinyMap$Entry$$Type<(K), (V)>)[]]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TinyMap$$Original<K, V> = $TinyMap<(K), (V)>;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.UtilsWrapper" {
import {$Pattern} from "java.util.regex.Pattern"
import {$Map} from "java.util.Map"
import {$Collection$$Type} from "java.util.Collection"
import {$List} from "java.util.List"
import {$Duration$$Type} from "java.time.Duration"
import {$Runnable$$Type} from "java.lang.Runnable"
import {$SoundEvent} from "net.minecraft.sounds.SoundEvent"
import {$Random$$Type} from "java.util.Random"
import {$RandomSource} from "net.minecraft.util.RandomSource"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$CountingMap} from "dev.latvian.mods.kubejs.util.CountingMap"
import {$Stat} from "net.minecraft.stats.Stat"
import {$CreativeModeTab} from "net.minecraft.world.item.CreativeModeTab"
import {$CompletableFuture} from "java.util.concurrent.CompletableFuture"
import {$Supplier$$Type} from "java.util.function.Supplier"

/**
 * A collection of utilities
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $UtilsWrapper$$Interface {
get "random"(): $RandomSource
get "systemTime"(): long
}

export class $UtilsWrapper implements $UtilsWrapper$$Interface {
/**
 * Get a Random, for generating random numbers. Note this will always return the same Random instance
 */
static "getRandom"(): $RandomSource
/**
 * Gets a SoundEvent from the id
 */
static "getSound"(id: $ResourceLocation$$Type): $SoundEvent
/**
 * Returns a regex pattern of the input with the specified flags
 */
static "regex"(pattern: StringJS, flags: integer): $Pattern
/**
 * Returns a regex pattern of the input
 */
static "regex"(s: any): $Pattern
/**
 * Get an immutable empty list
 */
static "emptyList"<T>(): $List<(T)>
/**
 * Checks if the passed in object is an instance of WrappedJS
 */
static "isWrapped"(o: any): boolean
/**
 * Returns a new mutable map
 */
static "newMap"(): $Map<(never), (never)>
/**
 * Get an immutable empty map
 */
static "emptyMap"<K, V>(): $Map<(K), (V)>
/**
 * Returns a new mutable list
 */
static "newList"(): $List<(never)>
/**
 * Returns a lazy value with the supplier function as its value factory
 */
static "lazy"<T>(supplier: $Supplier$$Type<(T)>): $Lazy<(T)>
/**
 * Runs the provided runnable function in KubeJS' background thread and returns its CompletableFuture
 */
static "runAsync"(task: $Runnable$$Type): $CompletableFuture<(void)>
/**
 * Runs the provided supplier function in KubeJS' background thread and returns its CompletableFuture
 */
static "supplyAsync"(task: $Supplier$$Type<(any)>): $CompletableFuture<(any)>
/**
 * Returns a Stat of the passed in ResourceLocation.
 * Note that this requires the same ResourceLocation to get the same stat, so should not be used unless you want to make your own stat, and are storing an actual ResourceLocation somewhere to access it.
 */
static "getStat"(id: $ResourceLocation$$Type): $Stat<($ResourceLocation)>
/**
 * Returns the creative tab associated with the id
 */
static "findCreativeTab"(id: $ResourceLocation$$Type): $CreativeModeTab
/**
 * Gets the current system time, in milliseconds
 */
static "getSystemTime"(): long
/**
 * Returns a lazy value with the supplier function as its value factory, that will expire after the specified time
 */
static "expiringLazy"<T>(supplier: $Supplier$$Type<(T)>, expires: $Duration$$Type): $Lazy<(T)>
/**
 * Returns a new counting map
 */
static "newCountingMap"(): $CountingMap
/**
 * Get a new random with the specified seed
 */
static "newRandom"(seed: long): $RandomSource
/**
 * Gets a random object from the list using the passed in random
 */
static "randomOf"(random: $Random$$Type, objects: $Collection$$Type<(any)>): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UtilsWrapper$$Type = ($UtilsWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UtilsWrapper$$Original = $UtilsWrapper;}
declare module "dev.latvian.mods.kubejs.text.tooltip.TooltipRequirements" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Map, $Map$$Type} from "java.util.Map"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Tristate, $Tristate$$Type} from "dev.latvian.mods.kubejs.util.Tristate"
import {$Record} from "java.lang.Record"

export class $TooltipRequirements extends $Record {
static readonly "DEFAULT": $TooltipRequirements
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($TooltipRequirements)>

constructor(shift: $Tristate$$Type, ctrl: $Tristate$$Type, alt: $Tristate$$Type, advanced: $Tristate$$Type, creative: $Tristate$$Type, stages: $Map$$Type<(StringJS), ($Tristate$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "shift"(): $Tristate
public "ctrl"(): $Tristate
public "creative"(): $Tristate
public "advanced"(): $Tristate
public "alt"(): $Tristate
public "stages"(): $Map<(StringJS), ($Tristate)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipRequirements$$Type = ({"ctrl"?: $Tristate$$Type, "stages"?: $Map$$Type<(StringJS), ($Tristate$$Type)>, "advanced"?: $Tristate$$Type, "shift"?: $Tristate$$Type, "creative"?: $Tristate$$Type, "alt"?: $Tristate$$Type}) | ([ctrl?: $Tristate$$Type, stages?: $Map$$Type<(StringJS), ($Tristate$$Type)>, advanced?: $Tristate$$Type, shift?: $Tristate$$Type, creative?: $Tristate$$Type, alt?: $Tristate$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TooltipRequirements$$Original = $TooltipRequirements;}
declare module "dev.latvian.mods.kubejs.item.ItemPredicate" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ItemStackSet} from "dev.latvian.mods.kubejs.item.ItemStackSet"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Predicate, $Predicate$$Type, $Predicate$$Interface} from "java.util.function.Predicate"
import {$IngredientSupplierKJS$$Interface} from "dev.latvian.mods.kubejs.core.IngredientSupplierKJS"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Set} from "java.util.Set"
import {$Stream} from "java.util.stream.Stream"

export interface $ItemPredicate$$Interface extends $Predicate$$Interface<($ItemStack)>, $IngredientSupplierKJS$$Interface {

(itemStack: $ItemStack): boolean
get "displayStacks"(): $ItemStackSet
get "wildcard"(): boolean
get "stacks"(): $ItemStackSet
get "itemTypes"(): $Set<($Item)>
get "first"(): $ItemStack
get "stackArray"(): ($ItemStack)[]
get "itemIds"(): $Set<(StringJS)>
get "itemStream"(): $Stream<($Item)>
}

export class $ItemPredicate implements $ItemPredicate$$Interface {
static readonly "ALL": $ItemPredicate
static readonly "TYPE_INFO": $TypeInfo
static readonly "NONE": $ItemPredicate

 "test"(itemStack: any): boolean
 "test"(itemStack: $ItemStack$$Type): boolean
static "wrap"(from: any): $ItemPredicate
 "canBeUsedForMatching"(): boolean
 "getDisplayStacks"(): $ItemStackSet
 "isWildcard"(): boolean
 "getStacks"(): $ItemStackSet
 "testItem"(item: $Item$$Type): boolean
 "getItemTypes"(): $Set<($Item)>
 "getFirst"(): $ItemStack
 "getStackArray"(): ($ItemStack)[]
 "getItemIds"(): $Set<(StringJS)>
 "getItemStream"(): $Stream<($Item)>
 "asIngredient"(): $Ingredient
 "or"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
 "negate"(): $Predicate<($ItemStack)>
 "and"(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "not"<T>(arg0: $Predicate$$Type<($ItemStack)>): $Predicate<($ItemStack)>
static "isEqual"<T>(arg0: any): $Predicate<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPredicate$$Type = ($Ingredient$$Type) | ("*") | ("-") | ((item: $ItemStack) => boolean) | ((itemStack: $ItemStack) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemPredicate$$Original = $ItemPredicate;}
declare module "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS" {
import {$TagManager} from "net.minecraft.tags.TagManager"
import {$ServerScriptManager} from "dev.latvian.mods.kubejs.server.ServerScriptManager"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ReloadableServerResourcesKJS$$Interface {
}

export class $ReloadableServerResourcesKJS implements $ReloadableServerResourcesKJS$$Interface {
 "kjs$getServerScriptManager"(): $ServerScriptManager
 "kjs$getTagManager"(): $TagManager
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReloadableServerResourcesKJS$$Type = ($ReloadableServerResourcesKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReloadableServerResourcesKJS$$Original = $ReloadableServerResourcesKJS;}
declare module "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder" {
import {$ToDoubleFunction$$Type} from "java.util.function.ToDoubleFunction"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$NumberProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.number.NumberProvider"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$ToIntFunction$$Type} from "java.util.function.ToIntFunction"
import {$CropBlockBuilder$ShapeBuilder$$Type} from "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$ShapeBuilder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$KubeDataGenerator$$Type} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$Registry} from "net.minecraft.core.Registry"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$CropBlockBuilder$SurviveCallback$$Type} from "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$SurviveCallback"
import {$RandomTickCallback, $RandomTickCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"

export class $CropBlockBuilder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "CROP_ITEM_TAGS": ($ResourceLocation)[]
static readonly "CROP_BLOCK_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

/**
 * Add a crop output with exactly one output.
 */
public "crop"(output: $Holder$$Type<($Item)>): this
/**
 * Add a crop output with a specific amount.
 */
public "crop"(output: $Holder$$Type<($Item)>, chance: $NumberProvider$$Type): this
public "randomTick"(randomTickCallback: $Consumer$$Type<($RandomTickCallback)>): $BlockBuilder
/**
 * Set the age of the crop. Note that the box will be the same for all ages (A full block size).
 */
public "age"(age: integer): this
/**
 * Set the age of the crop and the shape of the crop at that age.
 */
public "age"(age: integer, builder: $Consumer$$Type<($CropBlockBuilder$ShapeBuilder)>): this
public "generateLootTable"(generator: $KubeDataGenerator$$Type): $LootTable
public "farmersCanPlant"(): this
public "bonemeal"(bonemealCallback: $ToIntFunction$$Type<($RandomTickCallback)>): this
/**
 * Remove seed drops from the loot table, does not prevent seed item from creating.
 */
public "noSeeds"(): this
public "survive"(surviveCallback: $CropBlockBuilder$SurviveCallback$$Type): this
public "growTick"(growSpeedCallback: $ToDoubleFunction$$Type<($RandomTickCallback)>): this
public "noItem"(): $BlockBuilder
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlockBuilder$$Type = ($CropBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CropBlockBuilder$$Original = $CropBlockBuilder;}
declare module "dev.latvian.mods.kubejs.util.Object2LongEntry" {
import {$Comparable$$Interface} from "java.lang.Comparable"
import {$Object2LongMap$Entry$$Type} from "it.unimi.dsi.fastutil.objects.Object2LongMap$Entry"

export class $Object2LongEntry implements $Comparable$$Interface<($Object2LongEntry)> {
readonly "value": long
readonly "key": any

constructor(k: any, v: long)
constructor(entry: $Object2LongMap$Entry$$Type<(any)>)

public "compareTo"(o: any): integer
public "compareTo"(o: $Object2LongEntry$$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2LongEntry$$Type = ($Object2LongEntry);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Object2LongEntry$$Original = $Object2LongEntry;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.ColorWrapper" {
import {$ColorRGBA} from "net.minecraft.util.ColorRGBA"
import {$Map} from "java.util.Map"
import {$DyeColor} from "net.minecraft.world.item.DyeColor"
import {$KubeColor} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$TextColor} from "net.minecraft.network.chat.TextColor"
import {$ChatFormatting} from "net.minecraft.ChatFormatting"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ColorWrapper$$Interface {
}

export class $ColorWrapper implements $ColorWrapper$$Interface {
static readonly "BLUE_DYE": $KubeColor
static readonly "GOLD": $KubeColor
static readonly "GRAY": $KubeColor
static readonly "MAGENTA_DYE": $KubeColor
static readonly "BLUE": $KubeColor
static readonly "DARK_AQUA": $KubeColor
static readonly "TEXT": $Map<(StringJS), ($ChatFormatting)>
static readonly "DYE": $Map<(StringJS), ($DyeColor)>
static readonly "WHITE_DYE": $KubeColor
static readonly "DARK_RED": $KubeColor
static readonly "LIGHT_PURPLE": $KubeColor
static readonly "BROWN_DYE": $KubeColor
static readonly "BLACK": $KubeColor
static readonly "GRAY_DYE": $KubeColor
static readonly "NONE": $KubeColor
static readonly "LIGHT_BLUE_DYE": $KubeColor
static readonly "AQUA": $KubeColor
static readonly "WHITE": $KubeColor
static readonly "LIGHT_GRAY_DYE": $KubeColor
static readonly "BLACK_DYE": $KubeColor
static readonly "RED_DYE": $KubeColor
static readonly "PURPLE_DYE": $KubeColor
static readonly "GREEN_DYE": $KubeColor
static readonly "PINK_DYE": $KubeColor
static readonly "DARK_BLUE": $KubeColor
static readonly "GREEN": $KubeColor
static readonly "CYAN_DYE": $KubeColor
static readonly "RED": $KubeColor
static readonly "DARK_PURPLE": $KubeColor
static readonly "ORANGE_DYE": $KubeColor
static readonly "YELLOW_DYE": $KubeColor
static readonly "DARK_GREEN": $KubeColor
static readonly "YELLOW": $KubeColor
static readonly "LIME_DYE": $KubeColor
static readonly "DARK_GRAY": $KubeColor
static readonly "MAP": $Map<(StringJS), ($KubeColor)>

static "wrap"(o: any): $KubeColor
static "wrapColorRGBA"(o: any): $ColorRGBA
static "createMapped"(o: any, ...names: (StringJS)[]): $KubeColor
static "wrapTextColor"(o: any): $TextColor
static "rgba"(r: integer, g: integer, b: integer, a: integer): $KubeColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColorWrapper$$Type = ($ColorWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ColorWrapper$$Original = $ColorWrapper;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentInfo" {
import {$BlockEntityAttachmentFactory, $BlockEntityAttachmentFactory$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentFactory"
import {$BlockEntityAttachmentType, $BlockEntityAttachmentType$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityAttachmentType"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$EnumSet, $EnumSet$$Type} from "java.util.EnumSet"
import {$Record} from "java.lang.Record"

export class $BlockEntityAttachmentInfo extends $Record {
constructor(id: StringJS, type: $BlockEntityAttachmentType$$Type, index: integer, directions: $EnumSet$$Type<($Direction$$Type)>, factory: $BlockEntityAttachmentFactory$$Type)

public "index"(): integer
public "type"(): $BlockEntityAttachmentType
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "factory"(): $BlockEntityAttachmentFactory
public "id"(): StringJS
public "directions"(): $EnumSet<($Direction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentInfo$$Type = ({"directions"?: $EnumSet$$Type<($Direction$$Type)>, "type"?: $BlockEntityAttachmentType$$Type, "id"?: StringJS, "index"?: integer, "factory"?: $BlockEntityAttachmentFactory$$Type}) | ([directions?: $EnumSet$$Type<($Direction$$Type)>, type?: $BlockEntityAttachmentType$$Type, id?: StringJS, index?: integer, factory?: $BlockEntityAttachmentFactory$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityAttachmentInfo$$Original = $BlockEntityAttachmentInfo;}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabContentSupplier" {
import {$ItemPredicate, $ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"

export interface $CreativeTabContentSupplier$$Interface {

(showRestrictedItems: boolean): $ItemPredicate$$Type
}

export class $CreativeTabContentSupplier implements $CreativeTabContentSupplier$$Interface {
static readonly "DEFAULT": $CreativeTabContentSupplier

 "getContent"(showRestrictedItems: boolean): $ItemPredicate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabContentSupplier$$Type = ((showRestrictedItems: boolean) => $ItemPredicate$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeTabContentSupplier$$Original = $CreativeTabContentSupplier;}
declare module "dev.latvian.mods.kubejs.command.ArgumentTypeWrapper" {
import {$CommandContext$$Type} from "com.mojang.brigadier.context.CommandContext"
import {$ArgumentType} from "com.mojang.brigadier.arguments.ArgumentType"
import {$CommandRegistryKubeEvent$$Type} from "dev.latvian.mods.kubejs.command.CommandRegistryKubeEvent"
import {$CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"

export interface $ArgumentTypeWrapper$$Interface {
}

export class $ArgumentTypeWrapper implements $ArgumentTypeWrapper$$Interface {
 "create"(event: $CommandRegistryKubeEvent$$Type): $ArgumentType<(never)>
 "getResult"(context: $CommandContext$$Type<($CommandSourceStack$$Type)>, input: StringJS): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArgumentTypeWrapper$$Type = ($ArgumentTypeWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArgumentTypeWrapper$$Original = $ArgumentTypeWrapper;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.NBTWrapper" {
import {$CollectionTag} from "net.minecraft.nbt.CollectionTag"
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$Map$$Type} from "java.util.Map"
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$List$$Type} from "java.util.List"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$ListTag} from "net.minecraft.nbt.ListTag"
import {$OrderedCompoundTag} from "dev.latvian.mods.kubejs.util.OrderedCompoundTag"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $NBTWrapper$$Interface {
}

export class $NBTWrapper implements $NBTWrapper$$Interface {
static "toTag"(tag: $Tag$$Type): $Tag
static "wrap"(v: any): $Tag
static "i"(v: integer): $Tag
static "b"(v: byte): $Tag
static "ba"(v: (byte)[]): $Tag
static "s"(v: short): $Tag
static "f"(v: float): $Tag
static "l"(v: long): $Tag
static "d"(v: double): $Tag
static "read"(buf: $FriendlyByteBuf$$Type): $OrderedCompoundTag
static "ia"(v: (integer)[]): $Tag
static "longTag"(v: long): $Tag
static "floatTag"(v: float): $Tag
static "shortTag"(v: short): $Tag
static "doubleTag"(v: double): $Tag
static "byteTag"(v: byte): $Tag
static "la"(v: (long)[]): $Tag
static "intTag"(v: integer): $Tag
static "toJson"(t: $Tag$$Type): $JsonElement
static "stringTag"(v: StringJS): $Tag
static "wrapCollection"(v: any): $CollectionTag<(never)>
static "longArrayTag"(v: (long)[]): $Tag
static "intArrayTag"(v: (integer)[]): $Tag
static "byteArrayTag"(v: (byte)[]): $Tag
static "wrapListTag"(list: any): $ListTag
static "wrapCompound"(v: any): $CompoundTag
static "isTagCollection"(o: any): boolean
static "isTagCompound"(o: any): boolean
static "compoundTag"(map: $Map$$Type<(never), (never)>): $Tag
static "compoundTag"(): $Tag
static "listTag"(): $Tag
static "listTag"(list: $List$$Type<(never)>): $Tag
static "fromTag"(t: $Tag$$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTWrapper$$Type = ($NBTWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NBTWrapper$$Original = $NBTWrapper;}
declare module "dev.latvian.mods.kubejs.core.ServerPlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubeJSInventoryListener} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$PlayerKJS$$Interface} from "dev.latvian.mods.kubejs.core.PlayerKJS"
import {$Stages} from "dev.latvian.mods.kubejs.stages.Stages"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ChestMenuData$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuData"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS, $InventoryKJS$$Type} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$KubeJSGUI$$Type} from "dev.latvian.mods.kubejs.gui.KubeJSGUI"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Container} from "net.minecraft.world.Container"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$EntityPotionEffectsJS} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ServerPlayerKJS$$Interface extends $PlayerKJS$$Interface {

(): $AttachedData$$Type<($Player$$Type)>
get "spawnLocation"(): $LevelBlock
set "creativeMode"(value: boolean)
set "spawnLocation"(value: $LevelBlock$$Type)
set "selectedSlot"(value: integer)
get "stats"(): $PlayerStatsJS
get "miningBlock"(): boolean
set "mouseItem"(value: $ItemStack$$Type)
get "op"(): boolean
set "activePostShader"(value: $ResourceLocation$$Type)
get "openInventory"(): $AbstractContainerMenu
get "selectedSlot"(): integer
get "craftingGrid"(): $InventoryKJS
get "profile"(): $GameProfile
get "player"(): boolean
get "foodLevel"(): integer
set "foodLevel"(value: integer)
get "saturation"(): float
set "saturation"(value: float)
set "xpLevel"(value: integer)
get "xpLevel"(): integer
get "stages"(): $Stages
get "inventory"(): $InventoryKJS
get "mouseItem"(): $ItemStack
set "statusMessage"(value: $Component$$Type)
get "inventoryChangeListener"(): $KubeJSInventoryListener
get "fake"(): boolean
set "xp"(value: integer)
get "xp"(): integer
set "headArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
get "legsArmorItem"(): $ItemStack
set "mainHandItem"(value: $ItemStack$$Type)
set "chestArmorItem"(value: $ItemStack$$Type)
set "legsArmorItem"(value: $ItemStack$$Type)
get "mainHandItem"(): $ItemStack
get "headArmorItem"(): $ItemStack
get "feetArmorItem"(): $ItemStack
get "potionEffects"(): $EntityPotionEffectsJS
set "feetArmorItem"(value: $ItemStack$$Type)
get "totalMovementSpeed"(): double
get "reachDistance"(): double
get "living"(): boolean
get "undead"(): boolean
set "maxHealth"(value: float)
get "offHandItem"(): $ItemStack
set "offHandItem"(value: $ItemStack$$Type)
set "defaultMovementSpeed"(value: double)
set "movementSpeedAddition"(value: double)
get "defaultMovementSpeed"(): double
set "totalMovementSpeedMultiplier"(value: double)
set "defaultMovementSpeedMultiplier"(value: double)
get "data"(): $AttachedData<($Player)>
get "nbt"(): $CompoundTag
set "z"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "x"(value: double)
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
get "level"(): $Level
get "type"(): StringJS
set "motionX"(value: double)
get "teamId"(): StringJS
set "motionY"(value: double)
get "server"(): $MinecraftServer
get "motionZ"(): double
get "motionX"(): double
get "passengers"(): $EntityArrayList
get "facing"(): $Direction
get "animal"(): boolean
get "item"(): $ItemStack
set "position"(value: $LevelBlock$$Type)
set "motionZ"(value: double)
get "scriptType"(): $ScriptType
get "frame"(): boolean
get "motionY"(): double
get "block"(): $LevelBlock
get "monster"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "persistentData"(): $CompoundTag
}

export class $ServerPlayerKJS implements $ServerPlayerKJS$$Interface {
 "isAdvancementDone"(id: $ResourceLocation$$Type): boolean
 "getSpawnLocation"(): $LevelBlock
 "captureInventory"(autoRestore: boolean): $Container
 "unlockAdvancement"(id: $ResourceLocation$$Type): void
 "openInventoryGUI"(inventory: $InventoryKJS$$Type, title: $Component$$Type, columns: integer, rows: integer): void
 "openInventoryGUI"(inventory: $InventoryKJS$$Type, title: $Component$$Type): void
 "openInventoryGUI"(inventory: $InventoryKJS$$Type, title: $Component$$Type, columns: integer): void
 "setCreativeMode"(mode: boolean): void
 "revokeAdvancement"(id: $ResourceLocation$$Type): void
 "setSpawnLocation"(c: $LevelBlock$$Type): void
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "setSelectedSlot"(index: integer): void
 "openChestGUI"(title: $Component$$Type, rows: integer, gui: $Consumer$$Type<($ChestMenuData)>): void
 "openChestGUI"(gui: $Consumer$$Type<($KubeJSGUI)>): void
 "getStats"(): $PlayerStatsJS
 "isMiningBlock"(): boolean
 "setMouseItem"(item: $ItemStack$$Type): void
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "ban"(banner: StringJS, reason: StringJS, expiresInMillis: long): void
 "heal"(): void
 "isOp"(): boolean
 "kick"(): void
 "kick"(reason: $Component$$Type): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "self"(): $Entity
 "notify"(builder: $NotificationToastData$$Type): void
 "spawn"(): void
 "boostElytraFlight"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "getSelectedSlot"(): integer
 "sendInventoryUpdate"(): void
 "getCraftingGrid"(): $InventoryKJS
 "addItemCooldown"(item: $Item$$Type, ticks: integer): void
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "getFoodLevel"(): integer
 "setFoodLevel"(foodLevel: integer): void
 "getSaturation"(): float
 "setSaturation"(saturation: float): void
 "addExhaustion"(exhaustion: float): void
 "addXPLevels"(l: integer): void
 "setXpLevel"(l: integer): void
 "getXpLevel"(): integer
 "getStages"(): $Stages
 "addFood"(f: integer, m: float): void
 "getInventory"(): $InventoryKJS
 "giveInHand"(item: $ItemStack$$Type): void
 "getMouseItem"(): $ItemStack
 "setStatusMessage"(message: $Component$$Type): void
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "isFake"(): boolean
 "setXp"(xp: integer): void
 "addXP"(xp: integer): void
 "give"(item: $ItemStack$$Type): void
 "getXp"(): integer
 "notify"(title: $Component$$Type, text: $Component$$Type): void
 "swing"(hand: $InteractionHand$$Type): void
 "swing"(): void
 "setHeadArmorItem"(item: $ItemStack$$Type): void
 "getChestArmorItem"(): $ItemStack
 "getLegsArmorItem"(): $ItemStack
 "isHoldingInAnyHand"(i: $ItemPredicate$$Type): boolean
 "setMainHandItem"(item: $ItemStack$$Type): void
 "setChestArmorItem"(item: $ItemStack$$Type): void
 "setLegsArmorItem"(item: $ItemStack$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$$Type): void
 "getMainHandItem"(): $ItemStack
 "getHeadArmorItem"(): $ItemStack
 "getFeetArmorItem"(): $ItemStack
 "getPotionEffects"(): $EntityPotionEffectsJS
 "setFeetArmorItem"(item: $ItemStack$$Type): void
 "getTotalMovementSpeed"(): double
 "canEntityBeSeen"(entity: $LivingEntity$$Type): boolean
 "getAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>): double
 "getAttributeTotalValue"(attribute: $Holder$$Type<($Attribute)>): double
 "setAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>, value: double): void
 "getReachDistance"(): double
 "modifyAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): void
 "removeAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): void
 "foodEaten"(is: $ItemStack$$Type, food: $FoodProperties$$Type): void
 "setEquipment"(slot: $EquipmentSlot$$Type, item: $ItemStack$$Type): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer): void
 "rayTrace"(): $KubeRayTraceResult
 "isLiving"(): boolean
 "isUndead"(): boolean
 "setMaxHealth"(hp: float): void
 "getHeldItem"(hand: $InteractionHand$$Type): $ItemStack
 "getOffHandItem"(): $ItemStack
 "setHeldItem"(hand: $InteractionHand$$Type, item: $ItemStack$$Type): void
 "setOffHandItem"(item: $ItemStack$$Type): void
 "rayTraceEntity"(filter: $Predicate$$Type<($Entity)>): $Entity
 "getEquipment"(slot: $EquipmentSlot$$Type): $ItemStack
 "setDefaultMovementSpeed"(speed: double): void
 "setMovementSpeedAddition"(speed: double): void
 "getDefaultMovementSpeed"(): double
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "sendData"(channel: StringJS): void
 "getData"(): $AttachedData<($Player)>
 "getNbt"(): $CompoundTag
 "attack"(hp: float): void
 "setZ"(z: double): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setX"(x: double): void
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "getLevel"(): $Level
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "getType"(): StringJS
 "setMotionX"(x: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getTeamId"(): StringJS
 "setMotionY"(y: double): void
 "getServer"(): $MinecraftServer
 "getMotionZ"(): double
 "getMotionX"(): double
 "getPassengers"(): $EntityArrayList
 "getFacing"(): $Direction
 "setRotation"(yaw: float, pitch: float): void
 "isAnimal"(): boolean
 "getItem"(): $ItemStack
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "setPosition"(x: double, y: double, z: double): void
 "setPosition"(block: $LevelBlock$$Type): void
 "setMotionZ"(z: double): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getBlock"(): $LevelBlock
 "isMonster"(): boolean
 "runCommandSilent"(command: StringJS): void
 "tell"(message: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(command: StringJS): void
 "getDisplayName"(): $Component
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerPlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerPlayerKJS$$Original = $ServerPlayerKJS;}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$CreativeModeTab} from "net.minecraft.world.item.CreativeModeTab"
import {$Registry} from "net.minecraft.core.Registry"
import {$CreativeTabContentSupplier$$Type} from "dev.latvian.mods.kubejs.item.creativetab.CreativeTabContentSupplier"
import {$CreativeTabIconSupplier$$Type} from "dev.latvian.mods.kubejs.item.creativetab.CreativeTabIconSupplier"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $CreativeTabBuilder extends $BuilderBase<($CreativeModeTab)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "content"(content: $CreativeTabContentSupplier$$Type): this
public "icon"(icon: $CreativeTabIconSupplier$$Type): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabBuilder$$Type = ($CreativeTabBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeTabBuilder$$Original = $CreativeTabBuilder;}
declare module "dev.latvian.mods.kubejs.block.state.BlockStatePredicate" {
import {$ReplacementMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Collection} from "java.util.Collection"
import {$OreConfiguration$TargetBlockState$$Type} from "net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration$TargetBlockState"
import {$List$$Type} from "java.util.List"
import {$Predicate, $Predicate$$Type, $Predicate$$Interface} from "java.util.function.Predicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Set} from "java.util.Set"
import {$RuleTest} from "net.minecraft.world.level.levelgen.structure.templatesystem.RuleTest"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $BlockStatePredicate$$Interface extends $Predicate$$Interface<($BlockState)>, $ReplacementMatch$$Interface {

(state: $BlockState): boolean
get "blocks"(): $Collection<($Block)>
get "blockIds"(): $Set<($ResourceLocation)>
get "blockStates"(): $Collection<($BlockState)>
}

export class $BlockStatePredicate implements $BlockStatePredicate$$Interface {
 "getBlocks"(): $Collection<($Block)>
 "test"(state: $BlockState$$Type): boolean
 "test"(state: any): boolean
static "wrap"(o: any): $BlockStatePredicate
 "check"(targetStates: $List$$Type<($OreConfiguration$TargetBlockState$$Type)>): boolean
static "fromString"(s: StringJS): $BlockStatePredicate
 "getBlockIds"(): $Set<($ResourceLocation)>
 "testBlock"(block: $Block$$Type): boolean
 "getBlockStates"(): $Collection<($BlockState)>
static "wrapRuleTest"(o: any): $RuleTest
 "asRuleTest"(): $RuleTest
 "or"(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockState)>
 "negate"(): $Predicate<($BlockState)>
 "and"(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockState)>
static "not"<T>(arg0: $Predicate$$Type<($BlockState)>): $Predicate<($BlockState)>
static "isEqual"<T>(arg0: any): $Predicate<($BlockState)>
}
export type BlockStatePredicateObject = {"or"?: $BlockStatePredicate$$Type, "not"?: $BlockStatePredicate$$Type};
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStatePredicate$$Type = (($BlockStatePredicate$$Type)[]) | (BlockStatePredicateObject) | ($Block$$Type) | (Special.BlockTag) | (RegExp) | ("*") | ("-") | ((state: $BlockState) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStatePredicate$$Original = $BlockStatePredicate;}
declare module "dev.latvian.mods.kubejs.block.callback.CanBeReplacedCallback" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$InteractionHand} from "net.minecraft.world.InteractionHand"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Fluid$$Type} from "net.minecraft.world.level.material.Fluid"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$FluidState} from "net.minecraft.world.level.material.FluidState"
import {$BlockPlaceContext$$Type} from "net.minecraft.world.item.context.BlockPlaceContext"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $CanBeReplacedCallback {
constructor(blockPlaceContext: $BlockPlaceContext$$Type, state: $BlockState$$Type)

public "getNearestLookingDirection"(): $Direction
public "getHorizontalDirection"(): $Direction
public "getNearestLookingDirections"(): ($Direction)[]
public "getNearestLookingVerticalDirection"(): $Direction
public "getLevel"(): $Level
public "getItem"(): $ItemStack
public "isSecondaryUseActive"(): boolean
public "getClickLocation"(): $Vec3
public "getHand"(): $InteractionHand
public "getPlayer"(): $Player
public "canBeReplaced"(): boolean
public "getClickedPos"(): $BlockPos
public "getClickedFace"(): $Direction
public "isInside"(): boolean
public "getRotation"(): float
public "getFluidStateAtClickedPos"(): $FluidState
public "getClickedBlock"(): $LevelBlock
public "isClickedPosIn"(fluid: $Fluid$$Type): boolean
get "nearestLookingDirection"(): $Direction
get "horizontalDirection"(): $Direction
get "nearestLookingDirections"(): ($Direction)[]
get "nearestLookingVerticalDirection"(): $Direction
get "level"(): $Level
get "item"(): $ItemStack
get "secondaryUseActive"(): boolean
get "clickLocation"(): $Vec3
get "hand"(): $InteractionHand
get "player"(): $Player
get "clickedPos"(): $BlockPos
get "clickedFace"(): $Direction
get "inside"(): boolean
get "rotation"(): float
get "fluidStateAtClickedPos"(): $FluidState
get "clickedBlock"(): $LevelBlock
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CanBeReplacedCallback$$Type = ($CanBeReplacedCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CanBeReplacedCallback$$Original = $CanBeReplacedCallback;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.NativeEventWrapper$Listeners$Key" {
import {$EventPriority, $EventPriority$$Type} from "net.neoforged.bus.api.EventPriority"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $NativeEventWrapper$Listeners$Key extends $Record {
constructor(eventClass: $Class$$Type<(never)>, priority: $EventPriority$$Type)

public "priority"(): $EventPriority
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "eventClass"(): $Class<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeEventWrapper$Listeners$Key$$Type = ({"priority"?: $EventPriority$$Type, "eventClass"?: $Class$$Type<(never)>}) | ([priority?: $EventPriority$$Type, eventClass?: $Class$$Type<(never)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NativeEventWrapper$Listeners$Key$$Original = $NativeEventWrapper$Listeners$Key;}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Shovel" {
import {$BiFunction} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DiggerItemBuilder} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$Item$Properties} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Shovel extends $DiggerItemBuilder {
static readonly "SHOVEL_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "SHOVEL_MODEL": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Shovel$$Type = ($DiggerItemBuilder$Shovel);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemBuilder$Shovel$$Original = $DiggerItemBuilder$Shovel;}
declare module "dev.latvian.mods.kubejs.entity.AfterLivingEntityHurtKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$DamageSource} from "net.minecraft.world.damagesource.DamageSource"
import {$Level} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$LivingDamageEvent$Post$$Type} from "net.neoforged.neoforge.event.entity.living.LivingDamageEvent$Post"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked after an entity is hurt by a damage source.
 */
export class $AfterLivingEntityHurtKubeEvent implements $KubeLivingEntityEvent$$Interface {
constructor(event: $LivingDamageEvent$Post$$Type)

/**
 * The amount of damage.
 */
public "getDamage"(): float
/**
 * The damage source.
 */
public "getSource"(): $DamageSource
/**
 * The entity that was hurt.
 */
public "getEntity"(): $LivingEntity
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "damage"(): float
get "source"(): $DamageSource
get "entity"(): $LivingEntity
get "level"(): $Level
get "player"(): $Player
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterLivingEntityHurtKubeEvent$$Type = ($AfterLivingEntityHurtKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AfterLivingEntityHurtKubeEvent$$Original = $AfterLivingEntityHurtKubeEvent;}
declare module "dev.latvian.mods.kubejs.plugin.KubeJSPluginEvent" {
import {$Event} from "net.neoforged.bus.api.Event"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $KubeJSPluginEvent extends $Event {
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSPluginEvent$$Type = ($KubeJSPluginEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSPluginEvent$$Original = $KubeJSPluginEvent;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeConstructor" {
import {$OpsContainer$$Type} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$Map} from "java.util.Map"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ComponentValueMap$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentValueMap"
import {$KubeRecipe} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$RecipeOptional, $RecipeOptional$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $RecipeConstructor {
readonly "keys": $List<($RecipeKey<(never)>)>
 "defaultValues": $Map<($RecipeKey<(never)>), ($RecipeOptional<(never)>)>
 "overrides": $Map<($RecipeKey<(never)>), ($RecipeOptional<(never)>)>

constructor(keys: $List$$Type<($RecipeKey$$Type<(never)>)>)
constructor(...keys: ($RecipeKey$$Type<(never)>)[])

public "toString"(): StringJS
public "toString"(ops: $OpsContainer$$Type): StringJS
public "defaultValue"<T>(key: $RecipeKey$$Type<(T)>, value: $RecipeOptional$$Type<(T)>): $RecipeConstructor
public "override"<T>(key: $RecipeKey$$Type<(T)>, value: $RecipeOptional$$Type<(T)>): $RecipeConstructor
public "create"(sourceLine: $SourceLine$$Type, type: $RecipeTypeFunction$$Type, schemaType: $RecipeSchemaType$$Type, from: $ComponentValueMap$$Type): $KubeRecipe
public "toJson"(type: $RecipeSchemaType$$Type, ops: $DynamicOps$$Type<($JsonElement$$Type)>): $JsonObject
public "setValues"(cx: $RecipeScriptContext$$Type, schemaType: $RecipeSchemaType$$Type, from: $ComponentValueMap$$Type): void
public "overrideValue"<T>(key: $RecipeKey$$Type<(T)>, value: T): $RecipeConstructor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeConstructor$$Type = ($RecipeConstructor);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeConstructor$$Original = $RecipeConstructor;}
declare module "dev.latvian.mods.kubejs.item.ItemDestroyedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$PlayerDestroyItemEvent$$Type} from "net.neoforged.neoforge.event.entity.player.PlayerDestroyItemEvent"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$InteractionHand} from "net.minecraft.world.InteractionHand"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $ItemDestroyedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(e: $PlayerDestroyItemEvent$$Type)

public "getItem"(): $ItemStack
public "getHand"(): $InteractionHand
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "item"(): $ItemStack
get "hand"(): $InteractionHand
get "entity"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDestroyedKubeEvent$$Type = ($ItemDestroyedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemDestroyedKubeEvent$$Original = $ItemDestroyedKubeEvent;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Chestplate" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ArmorItemBuilder} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ArmorItemBuilder$Chestplate extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "CHESTPLATE_TAGS": ($ResourceLocation)[]

constructor(id: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Chestplate$$Type = ($ArmorItemBuilder$Chestplate);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$Chestplate$$Original = $ArmorItemBuilder$Chestplate;}
declare module "dev.latvian.mods.kubejs.script.ScriptManager" {
import {$ScriptPack, $ScriptPack$$Type} from "dev.latvian.mods.kubejs.script.ScriptPack"
import {$Map} from "java.util.Map"
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Path$$Type} from "java.nio.file.Path"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$KubeJSContextFactory} from "dev.latvian.mods.kubejs.script.KubeJSContextFactory"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptManager {
readonly "scriptType": $ScriptType
 "canListenEvents": boolean
readonly "packs": $Map<(StringJS), ($ScriptPack)>
 "contextFactory": $KubeJSContextFactory

constructor(t: $ScriptType$$Type)

public "loadPackFromDirectory"(path: $Path$$Type, name: StringJS, exampleFile: boolean): void
public "unload"(): void
public "reload"(): void
public "loadFromDirectory"(): void
public "getRegistries"(): $RegistryAccessContainer
public "loadAdditional"(): void
public "isClassAllowed"(name: StringJS): boolean
public "collectScripts"(pack: $ScriptPack$$Type, dir: $Path$$Type, path: StringJS): void
get "registries"(): $RegistryAccessContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptManager$$Type = ($ScriptManager);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptManager$$Original = $ScriptManager;}
declare module "dev.latvian.mods.kubejs.server.BasicCommandKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Level} from "net.minecraft.world.level.Level"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$CommandSourceStack$$Type} from "net.minecraft.commands.CommandSourceStack"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $BasicCommandKubeEvent implements $KubeEntityEvent$$Interface {
readonly "input": StringJS
readonly "id": StringJS

constructor(source: $CommandSourceStack$$Type, id: StringJS, input: StringJS)

public "getId"(): StringJS
public "getLevel"(): $Level
public "getBlock"(): $LevelBlock
public "getPlayer"(): $Player
public "getEntity"(): $Entity
public "respond"(text: $Component$$Type): void
public "respondLazily"(text: $Supplier$$Type<($Component$$Type)>, informAdmins: boolean): void
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "block"(): $LevelBlock
get "player"(): $Player
get "entity"(): $Entity
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicCommandKubeEvent$$Type = ($BasicCommandKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BasicCommandKubeEvent$$Original = $BasicCommandKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.MessageSenderKJS" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $MessageSenderKJS$$Interface {
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "displayName"(): $Component
}

export class $MessageSenderKJS implements $MessageSenderKJS$$Interface {
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "tell"(message: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(command: StringJS): void
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageSenderKJS$$Type = ($MessageSenderKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MessageSenderKJS$$Original = $MessageSenderKJS;}
declare module "dev.latvian.mods.kubejs.client.KeybindRegistryKubeEvent" {
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$KeybindRegistryKubeEvent$Builder} from "dev.latvian.mods.kubejs.client.KeybindRegistryKubeEvent$Builder"
import {$Minecraft} from "net.minecraft.client.Minecraft"

export class $KeybindRegistryKubeEvent implements $ClientKubeEvent$$Interface {
constructor()

public "register"(id: StringJS, defaultKey: StringJS): $KeybindRegistryKubeEvent$Builder
public "register"(id: StringJS): $KeybindRegistryKubeEvent$Builder
public "getClient"(): $Minecraft
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeybindRegistryKubeEvent$$Type = ($KeybindRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KeybindRegistryKubeEvent$$Original = $KeybindRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.text.tooltip.ItemTooltipData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$TextAction, $TextAction$$Type} from "dev.latvian.mods.kubejs.text.action.TextAction"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$TooltipRequirements, $TooltipRequirements$$Type} from "dev.latvian.mods.kubejs.text.tooltip.TooltipRequirements"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$Record} from "java.lang.Record"

export class $ItemTooltipData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemTooltipData)>

constructor(filter: ($Ingredient$$Type)?, requirements: ($TooltipRequirements$$Type)?, actions: $List$$Type<($TextAction$$Type)>)

public "requirements"(): $Optional<($TooltipRequirements)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $Optional<($Ingredient)>
public "actions"(): $List<($TextAction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTooltipData$$Type = ({"filter"?: ($Ingredient$$Type)?, "requirements"?: ($TooltipRequirements$$Type)?, "actions"?: $List$$Type<($TextAction$$Type)>}) | ([filter?: ($Ingredient$$Type)?, requirements?: ($TooltipRequirements$$Type)?, actions?: $List$$Type<($TextAction$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemTooltipData$$Original = $ItemTooltipData;}
declare module "dev.latvian.mods.kubejs.client.ParticleGenerator" {
import {$List$$Type} from "java.util.List"
import {$JsonObject} from "com.google.gson.JsonObject"

export class $ParticleGenerator {
constructor()

public "toJson"(): $JsonObject
public "texture"(texture: StringJS): $ParticleGenerator
public "textures"(textures: $List$$Type<(StringJS)>): $ParticleGenerator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleGenerator$$Type = ($ParticleGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ParticleGenerator$$Original = $ParticleGenerator;}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Pickaxe" {
import {$BiFunction} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DiggerItemBuilder} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$Item$Properties} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Pickaxe extends $DiggerItemBuilder {
 "sourceLine": $SourceLine
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
static readonly "PICKAXE_TAGS": ($ResourceLocation)[]
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "PICKAXE_MODEL": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Pickaxe$$Type = ($DiggerItemBuilder$Pickaxe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemBuilder$Pickaxe$$Original = $DiggerItemBuilder$Pickaxe;}
declare module "dev.latvian.mods.kubejs.recipe.schema.function.RecipeFunctionInstance" {
import {$ResolvedRecipeSchemaFunction, $ResolvedRecipeSchemaFunction$$Type} from "dev.latvian.mods.kubejs.recipe.schema.function.ResolvedRecipeSchemaFunction"
import {$List, $List$$Type} from "java.util.List"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$Record} from "java.lang.Record"

export class $RecipeFunctionInstance extends $Record {
constructor(name: StringJS, arg1: $ResolvedRecipeSchemaFunction$$Type)
constructor(name: StringJS, arg1: $List$$Type<($RecipeComponent$$Type<(never)>)>, arg2: $ResolvedRecipeSchemaFunction$$Type)

public "name"(): StringJS
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "function"(): $ResolvedRecipeSchemaFunction
public "arguments"(): $List<($RecipeComponent<(never)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeFunctionInstance$$Type = ({"function"?: $ResolvedRecipeSchemaFunction$$Type, "arguments"?: $List$$Type<($RecipeComponent$$Type<(never)>)>, "name"?: StringJS}) | ([arg?: $ResolvedRecipeSchemaFunction$$Type, arg?: $List$$Type<($RecipeComponent$$Type<(never)>)>, name?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeFunctionInstance$$Original = $RecipeFunctionInstance;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Group" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Record} from "java.lang.Record"

export class $ItemData$Group extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData$Group)>

constructor(filter: $Ingredient$$Type, groupId: $ResourceLocation$$Type, description: $Component$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $Ingredient
public "description"(): $Component
public "groupId"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$Group$$Type = ({"filter"?: $Ingredient$$Type, "groupId"?: $ResourceLocation$$Type, "description"?: $Component$$Type}) | ([filter?: $Ingredient$$Type, groupId?: $ResourceLocation$$Type, description?: $Component$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemData$Group$$Original = $ItemData$Group;}
declare module "dev.latvian.mods.kubejs.text.action.TooltipActionType" {
import {$StreamCodec, $StreamCodec$$Type} from "net.minecraft.network.codec.StreamCodec"
import {$TextAction} from "dev.latvian.mods.kubejs.text.action.TextAction"
import {$RegistryFriendlyByteBuf, $RegistryFriendlyByteBuf$$Type} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Record} from "java.lang.Record"

export class $TooltipActionType<T extends $TextAction> extends $Record {
constructor(type: integer, streamCodec: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>)

public "type"(): integer
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "streamCodec"(): $StreamCodec<($RegistryFriendlyByteBuf), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TooltipActionType$$Type<T> = ({"streamCodec"?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>, "type"?: integer}) | ([streamCodec?: $StreamCodec$$Type<($RegistryFriendlyByteBuf$$Type), (T)>, type?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TooltipActionType$$Original<T> = $TooltipActionType<(T)>;}
declare module "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder$Helmet" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ArmorItemBuilder} from "dev.latvian.mods.kubejs.item.custom.ArmorItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$ArmorItem$Type} from "net.minecraft.world.item.ArmorItem$Type"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $ArmorItemBuilder$Helmet extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "sourceLine": $SourceLine
static readonly "HELMET_TAGS": ($ResourceLocation)[]
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Helmet$$Type = ($ArmorItemBuilder$Helmet);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ArmorItemBuilder$Helmet$$Original = $ArmorItemBuilder$Helmet;}
declare module "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessorType" {
import {$RecipeTypeRegistryContext, $RecipeTypeRegistryContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$RecipePostProcessor} from "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessor"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"
import {$Record} from "java.lang.Record"

export class $RecipePostProcessorType<T extends $RecipePostProcessor> extends $Record {
static readonly "CODEC": $Codec<($RecipePostProcessorType<(never)>)>
static readonly "MAP": $Lazy<($Map<($ResourceLocation), ($RecipePostProcessorType<(never)>)>)>

constructor(id: $ResourceLocation$$Type, mapCodec: $Function$$Type<($RecipeTypeRegistryContext), ($MapCodec$$Type<(T)>)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "id"(): $ResourceLocation
public "mapCodec"(): $Function<($RecipeTypeRegistryContext), ($MapCodec<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipePostProcessorType$$Type<T> = ({"mapCodec"?: $Function$$Type<($RecipeTypeRegistryContext$$Type), ($MapCodec$$Type<(T)>)>, "id"?: $ResourceLocation$$Type}) | ([mapCodec?: $Function$$Type<($RecipeTypeRegistryContext$$Type), ($MapCodec$$Type<(T)>)>, id?: $ResourceLocation$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipePostProcessorType$$Original<T> = $RecipePostProcessorType<(T)>;}
declare module "dev.latvian.mods.kubejs.recipe.match.ItemMatch" {
import {$Iterable$$Type} from "java.lang.Iterable"
import {$ReplacementMatch, $ReplacementMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$ItemLike$$Type} from "net.minecraft.world.level.ItemLike"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"

export interface $ItemMatch$$Interface extends $ReplacementMatch$$Interface {
}

export class $ItemMatch implements $ItemMatch$$Interface {
 "matchesAny"(cx: $RecipeMatchContext$$Type, itemLikes: $Iterable$$Type<($ItemLike$$Type)>, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, item: $ItemStack$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, itemLike: $ItemLike$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $Ingredient$$Type, exact: boolean): boolean
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemMatch$$Type = ($ItemMatch);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemMatch$$Original = $ItemMatch;}
declare module "dev.latvian.mods.kubejs.block.drop.BlockDrops" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$NumberProvider, $NumberProvider$$Type} from "net.minecraft.world.level.storage.loot.providers.number.NumberProvider"
import {$Record} from "java.lang.Record"

export class $BlockDrops extends $Record {
static readonly "EMPTY": $BlockDrops

constructor(items: ($ItemStack$$Type)[], rolls: $NumberProvider$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "items"(): ($ItemStack)[]
public static "createDefault"(item: $ItemStack$$Type): $BlockDrops
public "rolls"(): $NumberProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockDrops$$Type = ({"items"?: ($ItemStack$$Type)[], "rolls"?: $NumberProvider$$Type}) | ([items?: ($ItemStack$$Type)[], rolls?: $NumberProvider$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockDrops$$Original = $BlockDrops;}
declare module "dev.latvian.mods.kubejs.level.LevelBlock" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$Direction$$Type} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$Holder} from "net.minecraft.core.Holder"
import {$BlockProviderKJS$$Interface} from "dev.latvian.mods.kubejs.core.BlockProviderKJS"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ExplosionProperties$$Type} from "dev.latvian.mods.kubejs.level.ExplosionProperties"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

export interface $LevelBlock$$Interface extends $BlockProviderKJS$$Interface {
get "x"(): integer
get "z"(): integer
get "skyLight"(): integer
get "playersInRadius"(): $EntityArrayList
get "canSeeSky"(): boolean
set "entityData"(value: $CompoundTag$$Type)
get "blockLight"(): integer
get "entityId"(): StringJS
get "properties"(): $Map<(StringJS), (StringJS)>
get "level"(): $Level
get "item"(): $ItemStack
get "dimension"(): $ResourceLocation
get "pos"(): $BlockPos
get "centerZ"(): double
get "centerX"(): double
get "block"(): $Block
get "entityData"(): $CompoundTag
get "y"(): integer
get "blockState"(): $BlockState
get "drops"(): $List<($ItemStack)>
get "entity"(): $BlockEntity
get "inventory"(): $InventoryKJS
get "east"(): $LevelBlock
get "north"(): $LevelBlock
get "down"(): $LevelBlock
get "west"(): $LevelBlock
get "centerY"(): double
get "light"(): integer
get "biomeId"(): $ResourceLocation
get "south"(): $LevelBlock
get "up"(): $LevelBlock
set "blockState"(value: $BlockState$$Type)
get "dimensionKey"(): $ResourceKey<($Level)>
get "id"(): StringJS
get "registryId"(): $ResourceKey<($Registry<($Block)>)>
get "registry"(): $Registry<($Block)>
get "typeData"(): $Map<(StringJS), (any)>
get "key"(): $ResourceKey<($Block)>
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Block)>)>
get "tags"(): $List<($ResourceLocation)>
}

export class $LevelBlock implements $LevelBlock$$Interface {
 "getX"(): integer
 "getZ"(): integer
 "spawnLightning"(): void
 "spawnLightning"(effectOnly: boolean): void
 "spawnLightning"(effectOnly: boolean, player: $ServerPlayer$$Type): void
 "getSkyLight"(): integer
 "toBlockStateString"(): StringJS
 "getPlayersInRadius"(): $EntityArrayList
 "getPlayersInRadius"(radius: double): $EntityArrayList
 "getCanSeeSky"(): boolean
 "setEntityData"(tag: $CompoundTag$$Type): void
 "mergeEntityData"(tag: $CompoundTag$$Type): void
 "popItemFromFace"(item: $ItemStack$$Type, dir: $Direction$$Type): void
 "getBlockLight"(): integer
 "getEntityId"(): StringJS
 "spawnFireworks"(fireworks: $Fireworks$$Type, lifetime: integer): void
 "offset"(x: integer, y: integer, z: integer): $LevelBlock
 "offset"(f: $Direction$$Type, d: integer): $LevelBlock
 "offset"(f: $Direction$$Type): $LevelBlock
 "set"(block: $Block$$Type, properties: $Map$$Type<(never), (never)>): void
 "set"(block: $Block$$Type): void
 "set"(block: $Block$$Type, properties: $Map$$Type<(never), (never)>, flags: integer): void
 "getProperties"(): $Map<(StringJS), (StringJS)>
 "getLevel"(): $Level
 "getItem"(): $ItemStack
 "createEntity"(type: $EntityType$$Type<(never)>): $Entity
 "getDimension"(): $ResourceLocation
 "explode"(properties: $ExplosionProperties$$Type): $Explosion
 "getPos"(): $BlockPos
 "getCenterZ"(): double
 "getCenterX"(): double
 "getBlock"(): $Block
 "getEntityData"(): $CompoundTag
 "getY"(): integer
 "getBlockState"(): $BlockState
 "getDrops"(entity: $Entity$$Type, heldItem: $ItemStack$$Type): $List<($ItemStack)>
 "getDrops"(): $List<($ItemStack)>
 "getEntity"(): $BlockEntity
 "getInventory"(facing: $Direction$$Type): $InventoryKJS
 "getInventory"(): $InventoryKJS
 "canSeeSkyFromBelowWater"(): boolean
 "getEast"(): $LevelBlock
 "popItem"(item: $ItemStack$$Type): void
 "getNorth"(): $LevelBlock
 "getDown"(): $LevelBlock
 "getWest"(): $LevelBlock
 "getCenterY"(): double
 "getLight"(): integer
 "getBiomeId"(): $ResourceLocation
 "getSouth"(): $LevelBlock
 "getUp"(): $LevelBlock
 "setBlockState"(state: $BlockState$$Type): void
 "setBlockState"(state: $BlockState$$Type, flags: integer): void
 "getDimensionKey"(): $ResourceKey<($Level)>
 "getId"(): StringJS
 "getRegistryId"(): $ResourceKey<($Registry<($Block)>)>
 "getRegistry"(): $Registry<($Block)>
 "asHolder"(): $Holder<($Block)>
 "getTypeData"(): $Map<(StringJS), (any)>
 "getKey"(): $ResourceKey<($Block)>
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getMod"(): StringJS
 "getIdLocation"(): $ResourceLocation
 "getTagKeys"(): $List<($TagKey<($Block)>)>
 "getTags"(): $List<($ResourceLocation)>
 "specialEquals"(o: any, shallow: boolean): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelBlock$$Type = ($LevelBlock);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelBlock$$Original = $LevelBlock;}
declare module "dev.latvian.mods.kubejs.core.LevelKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$WithAttachedData$$Interface} from "dev.latvian.mods.kubejs.core.WithAttachedData"
import {$UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Explosion} from "net.minecraft.world.level.Explosion"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$ScriptTypeHolder$$Interface} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$ExplosionProperties$$Type} from "dev.latvian.mods.kubejs.level.ExplosionProperties"
import {$ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityGetterKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityGetterKJS"
import {$ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $LevelKJS$$Interface extends $WithAttachedData$$Interface<($Level)>, $ScriptTypeHolder$$Interface, $EntityGetterKJS$$Interface {

(): $AttachedData$$Type<($Level$$Type)>
get "side"(): $ScriptType
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "dimension"(): $ResourceLocation
set "time"(value: long)
get "overworld"(): boolean
get "data"(): $AttachedData<($Level)>
get "players"(): $EntityArrayList
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "displayName"(): $Component
get "entities"(): $EntityArrayList
}

export class $LevelKJS implements $LevelKJS$$Interface {
 "getSide"(): $ScriptType
 "getBlock"(pos: $BlockPos$$Type): $LevelBlock
 "getBlock"(entity: $BlockEntity$$Type): $LevelBlock
 "getBlock"(x: integer, y: integer, z: integer): $LevelBlock
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "tell"(message: $Component$$Type): void
 "self"(): $EntityGetter
 "getName"(): $Component
 "runCommand"(command: StringJS): void
 "getDimension"(): $ResourceLocation
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean, cause: $ServerPlayer$$Type): void
 "spawnLightning"(x: double, y: double, z: double, visualOnly: boolean): void
 "setTime"(time: long): void
 "spawnFireworks"(x: double, y: double, z: double, fireworks: $Fireworks$$Type, lifetime: integer): void
 "createEntity"(type: $EntityType$$Type<(never)>): $Entity
 "spawnParticles"(options: $ParticleOptions$$Type, overrideLimiter: boolean, x: double, y: double, z: double, vx: double, vy: double, vz: double, count: integer, speed: double): void
 "spawnEntity"(type: $EntityType$$Type<(never)>, callback: $Consumer$$Type<($Entity)>): void
 "isOverworld"(): boolean
 "explode"(x: double, y: double, z: double, properties: $ExplosionProperties$$Type): $Explosion
 "getData"(): $AttachedData<($Level)>
 "getPlayers"(): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getMcPlayers"(): $List<($Player)>
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getDisplayName"(): $Component
 "getEntities"(): $EntityArrayList
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelKJS$$Type = (() => $AttachedData$$Type<($Level$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LevelKJS$$Original = $LevelKJS;}
declare module "dev.latvian.mods.kubejs.util.IntBounds" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Codec} from "com.mojang.serialization.Codec"
import {$MapCodec} from "com.mojang.serialization.MapCodec"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"
import {$Record} from "java.lang.Record"

export class $IntBounds extends $Record {
static readonly "OPTIONAL": $IntBounds
static readonly "CODEC": $Codec<($IntBounds)>
static readonly "MAP_CODEC": $MapCodec<($IntBounds)>
static readonly "DEFAULT": $IntBounds
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($IntBounds)>

constructor(min: integer, max: integer)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "min"(): integer
public "max"(): integer
public static "of"(min: integer, max: integer): $IntBounds
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntBounds$$Type = ({"max"?: integer, "min"?: integer}) | ([max?: integer, min?: integer]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $IntBounds$$Original = $IntBounds;}
declare module "dev.latvian.mods.kubejs.entity.KubeEntityEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export interface $KubeEntityEvent$$Interface extends $KubeLevelEvent$$Interface {

(): $Entity$$Type
get "level"(): $Level
get "player"(): $Player
get "entity"(): $Entity
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}

export class $KubeEntityEvent implements $KubeEntityEvent$$Interface {
 "getLevel"(): $Level
 "getPlayer"(): $Player
 "getEntity"(): $Entity
 "getServer"(): $MinecraftServer
 "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeEntityEvent$$Type = (() => $Entity$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeEntityEvent$$Original = $KubeEntityEvent;}
declare module "dev.latvian.mods.kubejs.item.ItemEntityInteractedKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$InteractionHand, $InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player right clicks on an entity.
 */
export class $ItemEntityInteractedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $Player$$Type, entity: $Entity$$Type, hand: $InteractionHand$$Type, item: $ItemStack$$Type)

/**
 * The entity that was interacted with.
 */
public "getTarget"(): $Entity
/**
 * The item that was used to interact with the entity.
 */
public "getItem"(): $ItemStack
/**
 * The hand that was used to interact with the entity.
 */
public "getHand"(): $InteractionHand
/**
 * The player that interacted with the entity.
 */
public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "target"(): $Entity
get "item"(): $ItemStack
get "hand"(): $InteractionHand
get "entity"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEntityInteractedKubeEvent$$Type = ($ItemEntityInteractedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemEntityInteractedKubeEvent$$Original = $ItemEntityInteractedKubeEvent;}
declare module "dev.latvian.mods.kubejs.client.ClientKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Minecraft} from "net.minecraft.client.Minecraft"

export interface $ClientKubeEvent$$Interface extends $KubeEvent$$Interface {
get "client"(): $Minecraft
}

export class $ClientKubeEvent implements $ClientKubeEvent$$Interface {
 "getClient"(): $Minecraft
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientKubeEvent$$Type = ($ClientKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientKubeEvent$$Original = $ClientKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.FluidKJS" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$FluidLike, $FluidLike$$Interface} from "dev.latvian.mods.kubejs.fluid.FluidLike"
import {$Holder} from "net.minecraft.core.Holder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $FluidKJS$$Interface extends $RegistryObjectKJS$$Interface<($Fluid)>, $FluidLike$$Interface {
get "amount"(): integer
get "fluid"(): $Fluid
get "registryId"(): $ResourceKey<($Registry<($Fluid)>)>
get "registry"(): $Registry<($Fluid)>
get "empty"(): boolean
get "id"(): StringJS
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($Fluid)>)>
get "tags"(): $List<($ResourceLocation)>
get "key"(): $ResourceKey<($Fluid)>
}

export class $FluidKJS implements $FluidKJS$$Interface {
 "getAmount"(): integer
 "getFluid"(): $Fluid
 "getRegistryId"(): $ResourceKey<($Registry<($Fluid)>)>
 "getRegistry"(): $Registry<($Fluid)>
 "isEmpty"(): boolean
 "getId"(): StringJS
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getMod"(): StringJS
 "getIdLocation"(): $ResourceLocation
 "getTagKeys"(): $List<($TagKey<($Fluid)>)>
 "asHolder"(): $Holder<($Fluid)>
 "getTags"(): $List<($ResourceLocation)>
 "getKey"(): $ResourceKey<($Fluid)>
 "specialEquals"(o: any, shallow: boolean): boolean
 "copy"(amount: integer): $FluidLike
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidKJS$$Type = ($FluidKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidKJS$$Original = $FluidKJS;}
declare module "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent" {
import {$TinyMap} from "dev.latvian.mods.kubejs.util.TinyMap"
import {$List, $List$$Type} from "java.util.List"
import {$ComponentRole$$Type} from "dev.latvian.mods.kubejs.recipe.component.ComponentRole"
import {$RecipeComponent, $RecipeComponent$$Type, $RecipeComponent$$Interface} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecipeKey} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$RecipeComponentValue$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue"
import {$RecipeComponentType} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Set$$Type} from "java.util.Set"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"
import {$OpsContainer$$Type} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$EitherRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.EitherRecipeComponent"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$CustomObjectRecipeComponent$Key, $CustomObjectRecipeComponent$Key$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Key"
import {$UniqueIdBuilder$$Type} from "dev.latvian.mods.kubejs.recipe.component.UniqueIdBuilder"
import {$CustomObjectRecipeComponent$Value, $CustomObjectRecipeComponent$Value$$Type} from "dev.latvian.mods.kubejs.recipe.component.CustomObjectRecipeComponent$Value"
import {$RecipeComponentBuilder} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentBuilder"
import {$KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$ListRecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.ListRecipeComponent"
import {$MapCodec} from "com.mojang.serialization.MapCodec"

export class $CustomObjectRecipeComponent implements $RecipeComponent$$Interface<($List<($CustomObjectRecipeComponent$Value)>)> {
static readonly "TYPE": $RecipeComponentType<(never)>

constructor(keys: $List$$Type<($CustomObjectRecipeComponent$Key$$Type)>)

public "type"(): $RecipeComponentType<(never)>
public "toString"(): StringJS
public "wrap"(rcx: $RecipeScriptContext$$Type, from: any): $List<($CustomObjectRecipeComponent$Value)>
public "isEmpty"(value: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>): boolean
public "isEmpty"(value: any): boolean
public "replace"(cx: $RecipeScriptContext$$Type, original: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>, match: $ReplacementMatchInfo$$Type, arg3: any): $List<($CustomObjectRecipeComponent$Value)>
public "replace"(cx: $RecipeScriptContext$$Type, original: any, match: $ReplacementMatchInfo$$Type, arg3: any): any
public "matches"(cx: $RecipeMatchContext$$Type, value: any, match: $ReplacementMatchInfo$$Type): boolean
public "matches"(cx: $RecipeMatchContext$$Type, value: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>, match: $ReplacementMatchInfo$$Type): boolean
public "validate"(ctx: $RecipeValidationContext$$Type, value: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>): void
public "validate"(ctx: $RecipeValidationContext$$Type, value: any): void
public "typeInfo"(): $TypeInfo
public "keys"(): $List<($CustomObjectRecipeComponent$Key)>
public "codec"(): $Codec<($List<($CustomObjectRecipeComponent$Value)>)>
public "mapCodec"(): $MapCodec<($List<($CustomObjectRecipeComponent$Value)>)>
public "createCopy"(): $CustomObjectRecipeComponent
public "hasPriority"(hasPriority: $Predicate$$Type<($Set<(StringJS)>)>): $CustomObjectRecipeComponent
public "hasPriority"(cx: $RecipeMatchContext$$Type, from: any): boolean
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, list: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>): void
public "buildUniqueId"(builder: $UniqueIdBuilder$$Type, list: any): void
public "toString"(ops: $OpsContainer$$Type, value: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>): StringJS
public static "builder"(keys: $List$$Type<($CustomObjectRecipeComponent$Key$$Type)>): $CustomObjectRecipeComponent
public static "builder"(...keys: ($CustomObjectRecipeComponent$Key$$Type)[]): $CustomObjectRecipeComponent
public "key"(name: StringJS, role: $ComponentRole$$Type): $RecipeKey<($List<($CustomObjectRecipeComponent$Value)>)>
public "asList"(): $ListRecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "spread"(value: $List$$Type<($CustomObjectRecipeComponent$Value$$Type)>): $List<(never)>
public "or"<O>(other: $RecipeComponent$$Type<(O)>): $EitherRecipeComponent<($List<($CustomObjectRecipeComponent$Value)>), (O)>
public "allowEmpty"(): boolean
public "orSelf"(): $RecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "createBuilder"(): $RecipeComponentBuilder
public "asConditionalListOrSelf"(): $ListRecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "asMap"<K>(key: $RecipeComponent$$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($List<($CustomObjectRecipeComponent$Value)>)>)>
public "otherKey"(name: StringJS): $RecipeKey<($List<($CustomObjectRecipeComponent$Value)>)>
public "inputKey"(name: StringJS): $RecipeKey<($List<($CustomObjectRecipeComponent$Value)>)>
public "outputKey"(name: StringJS): $RecipeKey<($List<($CustomObjectRecipeComponent$Value)>)>
public "readFromJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($List$$Type<($CustomObjectRecipeComponent$Value$$Type)>)>, json: $JsonObject$$Type): void
public "writeToJson"(recipe: $KubeRecipe$$Type, cv: $RecipeComponentValue$$Type<($List$$Type<($CustomObjectRecipeComponent$Value$$Type)>)>, json: $JsonObject$$Type): void
public "asListOrSelf"(): $ListRecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "asConditionalList"(): $ListRecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($List<($CustomObjectRecipeComponent$Value)>)>)>
public "isIgnored"(): boolean
public "withCodec"(codec: $Codec$$Type<($List$$Type<($CustomObjectRecipeComponent$Value$$Type)>)>): $RecipeComponent<($List<($CustomObjectRecipeComponent$Value)>)>
get "ignored"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomObjectRecipeComponent$$Type = ($CustomObjectRecipeComponent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CustomObjectRecipeComponent$$Original = $CustomObjectRecipeComponent;}
declare module "dev.latvian.mods.kubejs.core.LivingEntityKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$EntityPotionEffectsJS} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$EntityKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityKJS"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $LivingEntityKJS$$Interface extends $EntityKJS$$Interface {
set "headArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
get "legsArmorItem"(): $ItemStack
set "mainHandItem"(value: $ItemStack$$Type)
set "chestArmorItem"(value: $ItemStack$$Type)
set "legsArmorItem"(value: $ItemStack$$Type)
get "mainHandItem"(): $ItemStack
get "headArmorItem"(): $ItemStack
get "feetArmorItem"(): $ItemStack
get "potionEffects"(): $EntityPotionEffectsJS
set "feetArmorItem"(value: $ItemStack$$Type)
get "totalMovementSpeed"(): double
get "reachDistance"(): double
get "living"(): boolean
get "undead"(): boolean
set "maxHealth"(value: float)
get "offHandItem"(): $ItemStack
set "offHandItem"(value: $ItemStack$$Type)
set "defaultMovementSpeed"(value: double)
set "movementSpeedAddition"(value: double)
get "defaultMovementSpeed"(): double
set "totalMovementSpeedMultiplier"(value: double)
set "defaultMovementSpeedMultiplier"(value: double)
get "nbt"(): $CompoundTag
set "z"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "x"(value: double)
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
get "level"(): $Level
get "type"(): StringJS
set "motionX"(value: double)
get "teamId"(): StringJS
set "motionY"(value: double)
get "profile"(): $GameProfile
get "server"(): $MinecraftServer
get "motionZ"(): double
get "motionX"(): double
get "passengers"(): $EntityArrayList
get "facing"(): $Direction
get "player"(): boolean
get "animal"(): boolean
get "item"(): $ItemStack
set "position"(value: $LevelBlock$$Type)
set "motionZ"(value: double)
get "scriptType"(): $ScriptType
get "frame"(): boolean
get "motionY"(): double
get "block"(): $LevelBlock
get "monster"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $LivingEntityKJS implements $LivingEntityKJS$$Interface {
static readonly "KJS_PLAYER_CUSTOM_SPEED": $ResourceLocation

 "swing"(hand: $InteractionHand$$Type): void
 "swing"(): void
 "setHeadArmorItem"(item: $ItemStack$$Type): void
 "getChestArmorItem"(): $ItemStack
 "getLegsArmorItem"(): $ItemStack
 "isHoldingInAnyHand"(i: $ItemPredicate$$Type): boolean
 "setMainHandItem"(item: $ItemStack$$Type): void
 "setChestArmorItem"(item: $ItemStack$$Type): void
 "setLegsArmorItem"(item: $ItemStack$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$$Type): void
 "getMainHandItem"(): $ItemStack
 "getHeadArmorItem"(): $ItemStack
 "getFeetArmorItem"(): $ItemStack
 "getPotionEffects"(): $EntityPotionEffectsJS
 "setFeetArmorItem"(item: $ItemStack$$Type): void
 "getTotalMovementSpeed"(): double
 "canEntityBeSeen"(entity: $LivingEntity$$Type): boolean
 "getAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>): double
 "getAttributeTotalValue"(attribute: $Holder$$Type<($Attribute)>): double
 "setAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>, value: double): void
 "getReachDistance"(): double
 "modifyAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): void
 "removeAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): void
 "foodEaten"(is: $ItemStack$$Type, food: $FoodProperties$$Type): void
 "setEquipment"(slot: $EquipmentSlot$$Type, item: $ItemStack$$Type): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer): void
 "rayTrace"(): $KubeRayTraceResult
 "isLiving"(): boolean
 "isUndead"(): boolean
 "setMaxHealth"(hp: float): void
 "getHeldItem"(hand: $InteractionHand$$Type): $ItemStack
 "getOffHandItem"(): $ItemStack
 "setHeldItem"(hand: $InteractionHand$$Type, item: $ItemStack$$Type): void
 "setOffHandItem"(item: $ItemStack$$Type): void
 "rayTraceEntity"(filter: $Predicate$$Type<($Entity)>): $Entity
 "getEquipment"(slot: $EquipmentSlot$$Type): $ItemStack
 "setDefaultMovementSpeed"(speed: double): void
 "setMovementSpeedAddition"(speed: double): void
 "getDefaultMovementSpeed"(): double
 "self"(): $LivingEntity
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "spawn"(): void
 "getNbt"(): $CompoundTag
 "attack"(hp: float): void
 "setZ"(z: double): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setX"(x: double): void
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "isAmbientCreature"(): boolean
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "getLevel"(): $Level
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "getType"(): StringJS
 "setMotionX"(x: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getTeamId"(): StringJS
 "setMotionY"(y: double): void
 "getProfile"(): $GameProfile
 "getServer"(): $MinecraftServer
 "getMotionZ"(): double
 "getMotionX"(): double
 "getPassengers"(): $EntityArrayList
 "getFacing"(): $Direction
 "isPlayer"(): boolean
 "setRotation"(yaw: float, pitch: float): void
 "isAnimal"(): boolean
 "getItem"(): $ItemStack
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "setPosition"(x: double, y: double, z: double): void
 "setPosition"(block: $LevelBlock$$Type): void
 "setMotionZ"(z: double): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getBlock"(): $LevelBlock
 "isMonster"(): boolean
 "runCommandSilent"(command: StringJS): void
 "tell"(message: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(command: StringJS): void
 "getDisplayName"(): $Component
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$$Type): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityKJS$$Type = ($LivingEntityKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LivingEntityKJS$$Original = $LivingEntityKJS;}
declare module "dev.latvian.mods.kubejs.item.ItemStackSet" {
import {$Iterable$$Interface} from "java.lang.Iterable"
import {$Iterator} from "java.util.Iterator"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Spliterator} from "java.util.Spliterator"
import {$List} from "java.util.List"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$Stream} from "java.util.stream.Stream"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ItemStackSet implements $Iterable$$Interface<($ItemStack)> {
constructor(...items: ($ItemStack$$Type)[])
constructor()
constructor(initialSize: integer)

public "remove"(stack: $ItemStack$$Type): void
public "size"(): integer
public "isEmpty"(): boolean
public "add"(stack: $ItemStack$$Type): void
public "toArray"(): ($ItemStack)[]
public "iterator"(): $Iterator<($ItemStack)>
public "toList"(): $List<($ItemStack)>
public "stream"(): $Stream<($ItemStack)>
public "contains"(stack: $ItemStack$$Type): boolean
public "addAll"(other: $ItemStackSet$$Type): void
public static "merge"(first: $ItemStackSet$$Type, second: $ItemStackSet$$Type): $ItemStackSet
public "forEach"(action: $Consumer$$Type<($ItemStack)>): void
public "getFirst"(): $ItemStack
public "addItem"(item: $Item$$Type): void
public "spliterator"(): $Spliterator<($ItemStack)>
[Symbol.iterator](): IterableIterator<$ItemStack>;
get "empty"(): boolean
get "first"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackSet$$Type = ($ItemStackSet);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemStackSet$$Original = $ItemStackSet;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent$Callback" {
import {$ChestMenuInventoryClickEvent, $ChestMenuInventoryClickEvent$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuInventoryClickEvent"

export interface $ChestMenuInventoryClickEvent$Callback$$Interface {

(event: $ChestMenuInventoryClickEvent): void
}

export class $ChestMenuInventoryClickEvent$Callback implements $ChestMenuInventoryClickEvent$Callback$$Interface {
 "onClick"(event: $ChestMenuInventoryClickEvent$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuInventoryClickEvent$Callback$$Type = ((event: $ChestMenuInventoryClickEvent) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuInventoryClickEvent$Callback$$Original = $ChestMenuInventoryClickEvent$Callback;}
declare module "dev.latvian.mods.kubejs.level.SimpleLevelKubeEvent" {
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $SimpleLevelKubeEvent implements $KubeLevelEvent$$Interface {
constructor(l: $Level$$Type)

public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleLevelKubeEvent$$Type = ($SimpleLevelKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimpleLevelKubeEvent$$Original = $SimpleLevelKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeOptional" {
import {$RecipeSchemaType, $RecipeSchemaType$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"

export interface $RecipeOptional$$Interface<T> {

(type: $RecipeSchemaType): T
get "default"(): boolean
get "informativeValue"(): T
}

export class $RecipeOptional<T> implements $RecipeOptional$$Interface {
static readonly "DEFAULT": $RecipeOptional<(never)>

 "isDefault"(): boolean
 "getDefaultValue"(type: $RecipeSchemaType$$Type): T
static "unit"<T>(value: T): $RecipeOptional<(T)>
 "getInformativeValue"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeOptional$$Type<T> = ((type: $RecipeSchemaType) => T);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeOptional$$Original<T> = $RecipeOptional<(T)>;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeMappingRegistry" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeSchemaStorage$$Type} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"

export class $RecipeMappingRegistry implements $KubeEvent$$Interface {
constructor(storage: $RecipeSchemaStorage$$Type)

public "register"(name: StringJS, type: $ResourceLocation$$Type): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeMappingRegistry$$Type = ($RecipeMappingRegistry);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeMappingRegistry$$Original = $RecipeMappingRegistry;}
declare module "dev.latvian.mods.kubejs.core.ClientPlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubeJSInventoryListener} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$PlayerKJS$$Interface} from "dev.latvian.mods.kubejs.core.PlayerKJS"
import {$Stages} from "dev.latvian.mods.kubejs.stages.Stages"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$EntityPotionEffectsJS} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity, $LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ClientPlayerKJS$$Interface extends $PlayerKJS$$Interface {

(): $AttachedData$$Type<($Player$$Type)>
get "stats"(): $PlayerStatsJS
get "miningBlock"(): boolean
get "openInventory"(): $AbstractContainerMenu
get "selectedSlot"(): integer
get "craftingGrid"(): $InventoryKJS
set "selectedSlot"(value: integer)
get "profile"(): $GameProfile
get "player"(): boolean
get "foodLevel"(): integer
set "foodLevel"(value: integer)
get "saturation"(): float
set "saturation"(value: float)
set "xpLevel"(value: integer)
get "xpLevel"(): integer
get "stages"(): $Stages
get "inventory"(): $InventoryKJS
get "mouseItem"(): $ItemStack
set "mouseItem"(value: $ItemStack$$Type)
set "statusMessage"(value: $Component$$Type)
get "inventoryChangeListener"(): $KubeJSInventoryListener
get "fake"(): boolean
set "xp"(value: integer)
get "xp"(): integer
set "headArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
get "legsArmorItem"(): $ItemStack
set "mainHandItem"(value: $ItemStack$$Type)
set "chestArmorItem"(value: $ItemStack$$Type)
set "legsArmorItem"(value: $ItemStack$$Type)
get "mainHandItem"(): $ItemStack
get "headArmorItem"(): $ItemStack
get "feetArmorItem"(): $ItemStack
get "potionEffects"(): $EntityPotionEffectsJS
set "feetArmorItem"(value: $ItemStack$$Type)
get "totalMovementSpeed"(): double
get "reachDistance"(): double
get "living"(): boolean
get "undead"(): boolean
set "maxHealth"(value: float)
get "offHandItem"(): $ItemStack
set "offHandItem"(value: $ItemStack$$Type)
set "defaultMovementSpeed"(value: double)
set "movementSpeedAddition"(value: double)
get "defaultMovementSpeed"(): double
set "totalMovementSpeedMultiplier"(value: double)
set "defaultMovementSpeedMultiplier"(value: double)
get "data"(): $AttachedData<($Player)>
get "nbt"(): $CompoundTag
set "z"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "x"(value: double)
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
get "level"(): $Level
get "type"(): StringJS
set "motionX"(value: double)
get "teamId"(): StringJS
set "motionY"(value: double)
get "server"(): $MinecraftServer
get "motionZ"(): double
get "motionX"(): double
get "passengers"(): $EntityArrayList
get "facing"(): $Direction
get "animal"(): boolean
get "item"(): $ItemStack
set "position"(value: $LevelBlock$$Type)
set "motionZ"(value: double)
get "scriptType"(): $ScriptType
get "frame"(): boolean
get "motionY"(): double
get "block"(): $LevelBlock
get "monster"(): boolean
get "name"(): $Component
get "displayName"(): $Component
set "activePostShader"(value: $ResourceLocation$$Type)
get "persistentData"(): $CompoundTag
}

export class $ClientPlayerKJS implements $ClientPlayerKJS$$Interface {
 "getStats"(): $PlayerStatsJS
 "isMiningBlock"(): boolean
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "isSelf"(): boolean
 "self"(): $LivingEntity
 "notify"(notification: $NotificationToastData$$Type): void
 "spawn"(): void
 "boostElytraFlight"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "getSelectedSlot"(): integer
 "sendInventoryUpdate"(): void
 "getCraftingGrid"(): $InventoryKJS
 "setSelectedSlot"(index: integer): void
 "addItemCooldown"(item: $Item$$Type, ticks: integer): void
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "getFoodLevel"(): integer
 "setFoodLevel"(foodLevel: integer): void
 "getSaturation"(): float
 "setSaturation"(saturation: float): void
 "addExhaustion"(exhaustion: float): void
 "addXPLevels"(l: integer): void
 "setXpLevel"(l: integer): void
 "getXpLevel"(): integer
 "getStages"(): $Stages
 "addFood"(f: integer, m: float): void
 "getInventory"(): $InventoryKJS
 "giveInHand"(item: $ItemStack$$Type): void
 "getMouseItem"(): $ItemStack
 "setMouseItem"(item: $ItemStack$$Type): void
 "setStatusMessage"(message: $Component$$Type): void
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "isFake"(): boolean
 "setXp"(xp: integer): void
 "addXP"(xp: integer): void
 "give"(item: $ItemStack$$Type): void
 "getXp"(): integer
 "notify"(title: $Component$$Type, text: $Component$$Type): void
 "swing"(hand: $InteractionHand$$Type): void
 "swing"(): void
 "setHeadArmorItem"(item: $ItemStack$$Type): void
 "getChestArmorItem"(): $ItemStack
 "getLegsArmorItem"(): $ItemStack
 "isHoldingInAnyHand"(i: $ItemPredicate$$Type): boolean
 "setMainHandItem"(item: $ItemStack$$Type): void
 "setChestArmorItem"(item: $ItemStack$$Type): void
 "setLegsArmorItem"(item: $ItemStack$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$$Type): void
 "getMainHandItem"(): $ItemStack
 "getHeadArmorItem"(): $ItemStack
 "getFeetArmorItem"(): $ItemStack
 "getPotionEffects"(): $EntityPotionEffectsJS
 "setFeetArmorItem"(item: $ItemStack$$Type): void
 "getTotalMovementSpeed"(): double
 "canEntityBeSeen"(entity: $LivingEntity$$Type): boolean
 "getAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>): double
 "getAttributeTotalValue"(attribute: $Holder$$Type<($Attribute)>): double
 "setAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>, value: double): void
 "getReachDistance"(): double
 "modifyAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): void
 "removeAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): void
 "foodEaten"(is: $ItemStack$$Type, food: $FoodProperties$$Type): void
 "setEquipment"(slot: $EquipmentSlot$$Type, item: $ItemStack$$Type): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer): void
 "rayTrace"(): $KubeRayTraceResult
 "isLiving"(): boolean
 "isUndead"(): boolean
 "setMaxHealth"(hp: float): void
 "getHeldItem"(hand: $InteractionHand$$Type): $ItemStack
 "getOffHandItem"(): $ItemStack
 "setHeldItem"(hand: $InteractionHand$$Type, item: $ItemStack$$Type): void
 "setOffHandItem"(item: $ItemStack$$Type): void
 "rayTraceEntity"(filter: $Predicate$$Type<($Entity)>): $Entity
 "getEquipment"(slot: $EquipmentSlot$$Type): $ItemStack
 "setDefaultMovementSpeed"(speed: double): void
 "setMovementSpeedAddition"(speed: double): void
 "getDefaultMovementSpeed"(): double
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "sendData"(channel: StringJS): void
 "getData"(): $AttachedData<($Player)>
 "getNbt"(): $CompoundTag
 "attack"(hp: float): void
 "setZ"(z: double): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setX"(x: double): void
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "isAmbientCreature"(): boolean
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "getLevel"(): $Level
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "getType"(): StringJS
 "setMotionX"(x: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getTeamId"(): StringJS
 "setMotionY"(y: double): void
 "getServer"(): $MinecraftServer
 "getMotionZ"(): double
 "getMotionX"(): double
 "getPassengers"(): $EntityArrayList
 "getFacing"(): $Direction
 "setRotation"(yaw: float, pitch: float): void
 "isAnimal"(): boolean
 "getItem"(): $ItemStack
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "setPosition"(x: double, y: double, z: double): void
 "setPosition"(block: $LevelBlock$$Type): void
 "setMotionZ"(z: double): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getBlock"(): $LevelBlock
 "isMonster"(): boolean
 "runCommandSilent"(command: StringJS): void
 "tell"(message: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(command: StringJS): void
 "getDisplayName"(): $Component
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClientPlayerKJS$$Original = $ClientPlayerKJS;}
declare module "dev.latvian.mods.kubejs.script.data.GeneratedDataStage" {
import {$Keyable} from "com.mojang.serialization.Keyable"
import {$Map} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Enum, $Enum$$Type} from "java.lang.Enum"
import {$StringRepresentable$EnumCodec} from "net.minecraft.util.StringRepresentable$EnumCodec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$Function, $Function$$Type} from "java.util.function.Function"
import {$StringRepresentable, $StringRepresentable$$Type, $StringRepresentable$$Interface} from "net.minecraft.util.StringRepresentable"
import {$EventTargetType} from "dev.latvian.mods.kubejs.event.EventTargetType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $GeneratedDataStage extends $Enum<($GeneratedDataStage)> implements $StringRepresentable$$Interface {
static readonly "BEFORE_MODS": $GeneratedDataStage
static readonly "TARGET": $EventTargetType<($GeneratedDataStage)>
static readonly "REGISTRIES": $GeneratedDataStage
static readonly "LAST": $GeneratedDataStage
readonly "displayName": StringJS
static readonly "INTERNAL": $GeneratedDataStage
static readonly "AFTER_MODS": $GeneratedDataStage
static readonly "FOR_SCRIPTS": ($GeneratedDataStage)[]

public static "values"(): ($GeneratedDataStage)[]
public static "valueOf"(name: StringJS): $GeneratedDataStage
public static "forScripts"<T>(factory: $Function$$Type<($GeneratedDataStage), (T)>): $Map<($GeneratedDataStage), (T)>
public "getSerializedName"(): StringJS
public static "keys"(arg0: ($StringRepresentable$$Type)[]): $Keyable
public static "fromEnumWithMapping"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>, arg1: $Function$$Type<(StringJS), (StringJS)>): $StringRepresentable$EnumCodec<(E)>
public static "fromValues"<T extends $StringRepresentable>(arg0: $Supplier$$Type<((T)[])>): $Codec<(T)>
public static "fromEnum"<E extends $Enum<(object)>>(arg0: $Supplier$$Type<((E)[])>): $StringRepresentable$EnumCodec<(E)>
public "getRemappedEnumConstantName"(): StringJS
public static "createNameLookup"<T extends $StringRepresentable>(arg0: (T)[], arg1: $Function$$Type<(StringJS), (StringJS)>): $Function<(StringJS), (T)>
get "serializedName"(): StringJS
get "remappedEnumConstantName"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedDataStage$$Type = (("internal") | ("registries") | ("before_mods") | ("after_mods") | ("last"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GeneratedDataStage$$Original = $GeneratedDataStage;}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder$Axe" {
import {$BiFunction} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DiggerItemBuilder} from "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder"
import {$Registry} from "net.minecraft.core.Registry"
import {$Item$Properties} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder$Axe extends $DiggerItemBuilder {
 "sourceLine": $SourceLine
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
readonly "id": $ResourceLocation
static readonly "AXE_MODEL": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "AXE_TAGS": ($ResourceLocation)[]

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$Axe$$Type = ($DiggerItemBuilder$Axe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemBuilder$Axe$$Original = $DiggerItemBuilder$Axe;}
declare module "dev.latvian.mods.kubejs.script.ScriptFile" {
import {$ScriptFileInfo, $ScriptFileInfo$$Type} from "dev.latvian.mods.kubejs.script.ScriptFileInfo"
import {$ScriptPack, $ScriptPack$$Type} from "dev.latvian.mods.kubejs.script.ScriptPack"
import {$Comparable$$Interface} from "java.lang.Comparable"
import {$List} from "java.util.List"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptFile implements $Comparable$$Interface<($ScriptFile)> {
 "lastModified": long
 "lines": (StringJS)[]
readonly "pack": $ScriptPack
readonly "info": $ScriptFileInfo

constructor(pack: $ScriptPack$$Type, info: $ScriptFileInfo$$Type)

public "getProperty"(s: StringJS, def: StringJS): StringJS
public "compareTo"(o: any): integer
public "compareTo"(o: $ScriptFile$$Type): integer
public "load"(): void
public "getProperties"(s: StringJS): $List<(StringJS)>
public "getPriority"(): integer
public "skipLoading"(): StringJS
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptFile$$Type = ($ScriptFile);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptFile$$Original = $ScriptFile;}
declare module "dev.latvian.mods.kubejs.event.EventTargetType" {
import {$TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Enum} from "java.lang.Enum"
import {$EventTargetType$Transformer$$Type} from "dev.latvian.mods.kubejs.event.EventTargetType$Transformer"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"

export class $EventTargetType<T> {
static readonly "STRING": $EventTargetType<(StringJS)>
static readonly "ID": $EventTargetType<($ResourceLocation)>
readonly "type": $Class<(T)>
static readonly "REGISTRY": $EventTargetType<($ResourceKey<($Registry<(never)>)>)>

public "toString"(factory: $EventTargetType$Transformer$$Type): $EventTargetType<(T)>
public "identity"(): $EventTargetType<(T)>
public static "create"<T>(type: $Class$$Type<(T)>): $EventTargetType<(T)>
public "transformer"(factory: $EventTargetType$Transformer$$Type): $EventTargetType<(T)>
public "validator"(validator: $Predicate$$Type<(any)>): $EventTargetType<(T)>
public static "registryKey"<T>(registry: $ResourceKey$$Type<($Registry<(T)>)>, type: $Class$$Type<(never)>): $EventTargetType<($ResourceKey<(T)>)>
public "describeType"(describeType: $TypeInfo$$Type): $EventTargetType<(T)>
public static "fromEnum"<T extends $Enum<(object)>>(type: $Class$$Type<(T)>): $EventTargetType<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventTargetType$$Type<T> = ($EventTargetType<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventTargetType$$Original<T> = $EventTargetType<(T)>;}
declare module "dev.latvian.mods.kubejs.net.NetworkKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a network packet is received.
 * 
 * Note that the behaviour of this event is depending on the **script type**.
 * 
 * In `server_scripts`, this event is invoked on the server side when a packet is received from a client.
 * 
 * In `client_scripts`, this event is invoked on the client side when a packet is received from the server.
 */
export class $NetworkKubeEvent implements $KubePlayerEvent$$Interface {
constructor(p: $Player$$Type, c: StringJS, d: $CompoundTag$$Type)

/**
 * The channel of the packet.
 */
public "getChannel"(): StringJS
/**
 * The data of the packet.
 */
public "getData"(): $CompoundTag
/**
 * The player that sent the packet. Always `Minecraft.player` in `client_scripts`.
 */
public "getEntity"(): $Player
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "channel"(): StringJS
get "data"(): $CompoundTag
get "entity"(): $Player
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkKubeEvent$$Type = ($NetworkKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $NetworkKubeEvent$$Original = $NetworkKubeEvent;}
declare module "dev.latvian.mods.kubejs.component.ComponentFunctions" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$Map$$Type} from "java.util.Map"
import {$UUID$$Type} from "java.util.UUID"
import {$List$$Type} from "java.util.List"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$Unit$$Type} from "net.minecraft.util.Unit"

export interface $ComponentFunctions$$Interface {
get "additionalTooltipHidden"(): void
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
get "componentMap"(): $DataComponentMap
get "componentString"(): StringJS
set "customModelData"(value: integer)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
get "tooltipHidden"(): void
set "potionContents"(value: $PotionContents$$Type)
set "glintOverride"(value: boolean)
set "dyedColor"(value: $KubeColor$$Type)
set "customData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
set "potionId"(value: $Holder$$Type<($Potion)>)
get "customData"(): $CompoundTag
set "lockCode"(value: StringJS)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "entityData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "customName"(value: $Component$$Type)
}

export class $ComponentFunctions implements $ComponentFunctions$$Interface {
 "setAdditionalTooltipHidden"(): void
 "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
 "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
 "getComponentMap"(): $DataComponentMap
 "resetComponents"(): this
 "getComponentString"(): StringJS
 "setCustomModelData"(data: integer): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
 "setTooltipHidden"(): void
 "setPotionContents"(contents: $PotionContents$$Type): void
 "setGlintOverride"(override: boolean): void
 "get"<T>(type: $DataComponentType$$Type<(T)>): T
 "remove"(type: $DataComponentType$$Type<(never)>): this
 "patch"(components: $DataComponentPatch$$Type): this
 "set"(component: $DataComponentType$$Type<(never)>, value: any): this
 "set"(components: $DataComponentMap$$Type): this
 "setDyedColor"(color: $KubeColor$$Type): void
 "setCustomData"(tag: $CompoundTag$$Type): void
 "setProfile"(profile: $GameProfile$$Type): void
 "setProfile"(name: StringJS, uuid: $UUID$$Type): void
 "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): this
 "setPotionId"(potion: $Holder$$Type<($Potion)>): void
 "getCustomData"(): $CompoundTag
 "setLockCode"(lock: StringJS): void
 "getCustomName"(): $Component
 "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
 "setLore"(lines: $List$$Type<($Component$$Type)>): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "setRarity"(rarity: $Rarity$$Type): void
 "setBaseColor"(color: $DyeColor$$Type): void
 "setCustomName"(name: $Component$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentFunctions$$Type = ($ComponentFunctions);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComponentFunctions$$Original = $ComponentFunctions;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.RemoteRecipeViewerDataUpdatedEvent" {
import {$Event} from "net.neoforged.bus.api.Event"
import {$RecipeViewerData, $RecipeViewerData$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.RecipeViewerData"

export class $RemoteRecipeViewerDataUpdatedEvent extends $Event {
readonly "data": $RecipeViewerData

constructor(data: $RecipeViewerData$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoteRecipeViewerDataUpdatedEvent$$Type = ($RemoteRecipeViewerDataUpdatedEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RemoteRecipeViewerDataUpdatedEvent$$Original = $RemoteRecipeViewerDataUpdatedEvent;}
declare module "dev.latvian.mods.kubejs.core.MenuTypeKJS" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$MenuType} from "net.minecraft.world.inventory.MenuType"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$Holder} from "net.minecraft.core.Holder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $MenuTypeKJS$$Interface extends $RegistryObjectKJS$$Interface<($MenuType<(never)>)> {
get "registryId"(): $ResourceKey<($Registry<($MenuType<(never)>)>)>
get "registry"(): $Registry<($MenuType<(never)>)>
get "id"(): StringJS
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "tagKeys"(): $List<($TagKey<($MenuType<(never)>)>)>
get "tags"(): $List<($ResourceLocation)>
get "key"(): $ResourceKey<($MenuType<(never)>)>
}

export class $MenuTypeKJS implements $MenuTypeKJS$$Interface {
 "getRegistryId"(): $ResourceKey<($Registry<($MenuType<(never)>)>)>
 "getRegistry"(): $Registry<($MenuType<(never)>)>
 "getId"(): StringJS
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getMod"(): StringJS
 "getIdLocation"(): $ResourceLocation
 "getTagKeys"(): $List<($TagKey<($MenuType<(never)>)>)>
 "asHolder"(): $Holder<($MenuType<(never)>)>
 "getTags"(): $List<($ResourceLocation)>
 "getKey"(): $ResourceKey<($MenuType<(never)>)>
 "specialEquals"(o: any, shallow: boolean): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MenuTypeKJS$$Type = ($MenuTypeKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MenuTypeKJS$$Original = $MenuTypeKJS;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentValue" {
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$WrappedJS$$Interface} from "dev.latvian.mods.kubejs.util.WrappedJS"
import {$Comparable} from "java.lang.Comparable"
import {$Comparator, $Comparator$$Type} from "java.util.Comparator"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$RecipeValidationContext$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$RecipeKey, $RecipeKey$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeKey"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$Map$Entry, $Map$Entry$$Type, $Map$Entry$$Interface} from "java.util.Map$Entry"

export class $RecipeComponentValue<T> implements $WrappedJS$$Interface, $Map$Entry$$Interface<($RecipeKey<(T)>), (T)> {
static readonly "EMPTY_ARRAY": ($RecipeComponentValue<(never)>)[]
readonly "index": integer
 "value": T
readonly "key": $RecipeKey<(T)>

constructor(key: $RecipeKey$$Type<(T)>, index: integer)

public "equals"(obj: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "getValue"(): T
public "replace"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "matches"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
public "validate"(ctx: $RecipeValidationContext$$Type, sourceLine: $SourceLine$$Type): void
public "getKey"(): any
public "write"(): void
public "setValue"(newValue: T): T
public "copy"(): $RecipeComponentValue<(T)>
public "getIndex"(): integer
public "shouldWrite"(): boolean
public static "copyOf"<K, V>(arg0: $Map$Entry$$Type<($RecipeKey$$Type<(T)>), (T)>): $Map$Entry<($RecipeKey<(T)>), (T)>
public static "comparingByKey"<K, V>(arg0: $Comparator$$Type<($RecipeKey<(T)>)>): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
public static "comparingByKey"<K extends $Comparable<(object)>, V>(): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
public static "comparingByValue"<K, V extends $Comparable<(object)>>(): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
public static "comparingByValue"<K, V>(arg0: $Comparator$$Type<(T)>): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentValue$$Type<T> = ($RecipeComponentValue<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponentValue$$Original<T> = $RecipeComponentValue<(T)>;}
declare module "dev.latvian.mods.kubejs.recipe.RecipesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Pattern} from "java.util.regex.Pattern"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$DocumentedRecipes} from "moe.wolfgirl.probejs.generated.DocumentedRecipes"
import {$Shaped} from "moe.wolfgirl.probejs.generated.schema.kubejs.Shaped"
import {$List$$Type} from "java.util.List"
import {$ServerScriptManager$$Type} from "dev.latvian.mods.kubejs.server.ServerScriptManager"
import {$Stonecutting} from "moe.wolfgirl.probejs.generated.schema.minecraft.Stonecutting"
import {$RecipeSchemaStorage} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$RecipeTypeFunction} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$RecipeFilter$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeFilter"
import {$JsonObject$$Type} from "com.google.gson.JsonObject"
import {$TickDuration$$Type} from "dev.latvian.mods.kubejs.util.TickDuration"
import {$Stream} from "java.util.stream.Stream"
import {$SmithingTransform} from "moe.wolfgirl.probejs.generated.schema.minecraft.SmithingTransform"
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$Smelting} from "moe.wolfgirl.probejs.generated.schema.minecraft.Smelting"
import {$Blasting} from "moe.wolfgirl.probejs.generated.schema.minecraft.Blasting"
import {$CampfireCooking} from "moe.wolfgirl.probejs.generated.schema.minecraft.CampfireCooking"
import {$Shapeless} from "moe.wolfgirl.probejs.generated.schema.kubejs.Shapeless"
import {$Smoking} from "moe.wolfgirl.probejs.generated.schema.minecraft.Smoking"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$SmithingTrim} from "moe.wolfgirl.probejs.generated.schema.minecraft.SmithingTrim"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$ResourceManager, $ResourceManager$$Type} from "net.minecraft.server.packs.resources.ResourceManager"

export class $RecipesKubeEvent implements $KubeEvent$$Interface {
readonly "smithingTrim": (template: $Ingredient$$Type, base: $Ingredient$$Type, addition: $Ingredient$$Type) => $SmithingTrim
readonly "addedRecipes": $Collection<($KubeRecipe)>
readonly "stonecutting": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type) => $Stonecutting
readonly "shaped": (result: $ItemStack$$Type, pattern: $List$$Type<(StringJS)>, key: $Map$$Type<(character), ($Ingredient$$Type)>) => $Shaped
readonly "registries": $RegistryAccessContainer
readonly "removedRecipes": $Collection<($KubeRecipe)>
readonly "recipeSchemaStorage": $RecipeSchemaStorage
readonly "campfireCooking": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, time?: $TickDuration$$Type) => $CampfireCooking
readonly "shapeless": (result: $ItemStack$$Type, ingredients: $List$$Type<($Ingredient$$Type)>) => $Shapeless
readonly "blasting": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, time?: $TickDuration$$Type) => $Blasting
readonly "smithing": (result: $ItemStack$$Type, template: $Ingredient$$Type, base: $Ingredient$$Type, addition: $Ingredient$$Type) => $SmithingTransform
readonly "ops": $RegistryOpsContainer
static readonly "CREATE_RECIPE_SKIP_ERROR": $Pattern
readonly "originalRecipes": $Map<($ResourceLocation), ($KubeRecipe)>
readonly "smoking": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, time?: $TickDuration$$Type) => $Smoking
static readonly "POST_SKIP_ERROR": $Pattern
readonly "resourceManager": $ResourceManager
readonly "smelting": (result: $ItemStack$$Type, ingredient: $Ingredient$$Type, xp?: float, time?: $TickDuration$$Type) => $Smelting

constructor(manager: $ServerScriptManager$$Type, resourceManager: $ResourceManager$$Type)

public "remove"(filter: $RecipeFilter$$Type): void
public "stage"(filter: $RecipeFilter$$Type, stage: StringJS): void
public "getRecipes"(): $DocumentedRecipes
public "addRecipe"(r: $KubeRecipe$$Type, json: boolean): $KubeRecipe
public "printTypes"(): void
public "custom"(json: $JsonObject$$Type): $KubeRecipe
public "replaceInput"(filter: $RecipeFilter$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): void
public "replaceOutput"(filter: $RecipeFilter$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): void
public "countRecipes"(filter: $RecipeFilter$$Type): integer
public "takeId"(recipe: $KubeRecipe$$Type, prefix: StringJS, ids: StringJS): $ResourceLocation
public "getRecipeFunction"(id: StringJS): $RecipeTypeFunction
public "printExamples"(type: StringJS): void
public "recipeStream"(filter: $RecipeFilter$$Type): $Stream<($KubeRecipe)>
public "printAllTypes"(): void
public "containsRecipe"(filter: $RecipeFilter$$Type): boolean
public "forEachRecipe"(filter: $RecipeFilter$$Type, consumer: $Consumer$$Type<($KubeRecipe)>): void
public "findRecipeIds"(filter: $RecipeFilter$$Type): $Collection<($ResourceLocation)>
public "findRecipes"(filter: $RecipeFilter$$Type): $Collection<($KubeRecipe)>
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "recipes"(): $DocumentedRecipes
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipesKubeEvent$$Type = ($RecipesKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipesKubeEvent$$Original = $RecipesKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $ShapedBlockBuilder extends $BlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type, ...suffixes: (StringJS)[])

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedBlockBuilder$$Type = ($ShapedBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ShapedBlockBuilder$$Original = $ShapedBlockBuilder;}
declare module "dev.latvian.mods.kubejs.util.JsonUtils" {
import {$JsonPrimitive} from "com.google.gson.JsonPrimitive"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$MapLike} from "com.mojang.serialization.MapLike"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$JsonArray} from "com.google.gson.JsonArray"

export interface $JsonUtils$$Interface {
}

export class $JsonUtils implements $JsonUtils$$Interface {
static readonly "MAP_LIKE": $MapLike<($JsonElement)>

static "toString"(json: $JsonElement$$Type): StringJS
static "of"(o: any): $JsonElement
static "copy"(element: $JsonElement$$Type): $JsonElement
static "fromString"(string: StringJS): $JsonElement
static "arrayOf"(array: any): $JsonArray
static "objectOf"(map: any): $JsonObject
static "toPrettyString"(json: $JsonElement$$Type): StringJS
static "toObject"(json: $JsonElement$$Type): any
static "toPrimitive"(element: $JsonElement$$Type): any
static "primitiveOf"(o: any): $JsonPrimitive
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonUtils$$Type = ($JsonUtils);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $JsonUtils$$Original = $JsonUtils;}
declare module "dev.latvian.mods.kubejs.misc.MobEffectBuilder" {
import {$MobEffectBuilder$EffectEntityCallback$$Type} from "dev.latvian.mods.kubejs.misc.MobEffectBuilder$EffectEntityCallback"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$MobEffectCategory$$Type} from "net.minecraft.world.effect.MobEffectCategory"
import {$MobEffect} from "net.minecraft.world.effect.MobEffect"

export class $MobEffectBuilder extends $BuilderBase<($MobEffect)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$$Type)

public "getTranslationKeyGroup"(): StringJS
public "color"(col: $KubeColor$$Type): this
public "instant"(): this
public "instant"(instant: boolean): this
public "category"(c: $MobEffectCategory$$Type): this
public "modifyAttribute"(attribute: $ResourceLocation$$Type, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): this
public "beneficial"(): this
public "effectTick"(effectTick: $MobEffectBuilder$EffectEntityCallback$$Type): this
public "harmful"(): this
get "translationKeyGroup"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectBuilder$$Type = ($MobEffectBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MobEffectBuilder$$Original = $MobEffectBuilder;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityEventCallback" {
import {$KubeBlockEntity, $KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"

export interface $BlockEntityEventCallback$$Interface {

(entity: $KubeBlockEntity, data: integer): void
}

export class $BlockEntityEventCallback implements $BlockEntityEventCallback$$Interface {
 "accept"(entity: $KubeBlockEntity$$Type, data: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityEventCallback$$Type = ((entity: $KubeBlockEntity, data: integer) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityEventCallback$$Original = $BlockEntityEventCallback;}
declare module "dev.latvian.mods.kubejs.event.EventResult" {
import {$Context} from "dev.latvian.mods.rhino.Context"
import {$ICancellableEvent$$Type} from "net.neoforged.bus.api.ICancellableEvent"
import {$EventResult$Type} from "dev.latvian.mods.kubejs.event.EventResult$Type"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$TriState$$Type} from "net.neoforged.neoforge.common.util.TriState"

export class $EventResult {
static readonly "PASS": $EventResult

public "interruptDefault"(): boolean
public "type"(): $EventResult$Type
public "value"(): any
public "override"(): boolean
public "pass"(): boolean
public "cx"(): $Context
public "interruptTrue"(): boolean
public "interruptFalse"(): boolean
public "applyTristate"(consumer: $Consumer$$Type<($TriState)>): void
public "applyCancel"(event: $ICancellableEvent$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventResult$$Type = ($EventResult);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventResult$$Original = $EventResult;}
declare module "dev.latvian.mods.kubejs.event.EventExceptionHandler" {
import {$KubeEvent, $KubeEvent$$Type} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$Throwable, $Throwable$$Type} from "java.lang.Throwable"
import {$EventHandlerContainer, $EventHandlerContainer$$Type} from "dev.latvian.mods.kubejs.event.EventHandlerContainer"

export interface $EventExceptionHandler$$Interface {

(event: $KubeEvent, container: $EventHandlerContainer, ex: $Throwable): $Throwable$$Type
}

export class $EventExceptionHandler implements $EventExceptionHandler$$Interface {
 "handle"(event: $KubeEvent$$Type, container: $EventHandlerContainer$$Type, ex: $Throwable$$Type): $Throwable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventExceptionHandler$$Type = ((event: $KubeEvent, container: $EventHandlerContainer, ex: $Throwable) => $Throwable$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventExceptionHandler$$Original = $EventExceptionHandler;}
declare module "dev.latvian.mods.kubejs.recipe.ModifyCraftingItemKubeEvent" {
import {$CraftingInput$$Type} from "net.minecraft.world.item.crafting.CraftingInput"
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RecipeInput, $RecipeInput$$Type} from "net.minecraft.world.item.crafting.RecipeInput"

export class $ModifyCraftingItemKubeEvent implements $KubeEvent$$Interface {
 "item": $ItemStack
readonly "grid": $RecipeInput
readonly "width": integer
readonly "index": integer
readonly "height": integer

constructor(grid: $RecipeInput$$Type, width: integer, height: integer, item: $ItemStack$$Type, index: integer)
constructor(grid: $CraftingInput$$Type, item: $ItemStack$$Type, index: integer)

/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifyCraftingItemKubeEvent$$Type = ($ModifyCraftingItemKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModifyCraftingItemKubeEvent$$Original = $ModifyCraftingItemKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.TagManagerKJS" {
import {$ReloadableServerResourceHolderKJS$$Interface} from "dev.latvian.mods.kubejs.core.ReloadableServerResourceHolderKJS"
import {$ReloadableServerResourcesKJS, $ReloadableServerResourcesKJS$$Type} from "dev.latvian.mods.kubejs.core.ReloadableServerResourcesKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $TagManagerKJS$$Interface extends $ReloadableServerResourceHolderKJS$$Interface {
}

export class $TagManagerKJS implements $TagManagerKJS$$Interface {
 "kjs$setResources"(resources: $ReloadableServerResourcesKJS$$Type): void
 "kjs$getResources"(): $ReloadableServerResourcesKJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagManagerKJS$$Type = ($TagManagerKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TagManagerKJS$$Original = $TagManagerKJS;}
declare module "dev.latvian.mods.kubejs.recipe.KubeRecipeContext" {
import {$RecipeLikeContext$$Interface} from "dev.latvian.mods.kubejs.recipe.RecipeLikeContext"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$RecipeLikeKJS} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $KubeRecipeContext$$Interface extends $RecipeLikeContext$$Interface {
}

export class $KubeRecipeContext implements $KubeRecipeContext$$Interface {
 "registries"(): $RegistryAccessContainer
 "ops"(): $RegistryOpsContainer
 "recipe"(): $RecipeLikeKJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeRecipeContext$$Type = ($KubeRecipeContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeRecipeContext$$Original = $KubeRecipeContext;}
declare module "dev.latvian.mods.kubejs.core.BlockBuilderProvider" {
import {$BlockBuilder} from "dev.latvian.mods.kubejs.block.BlockBuilder"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $BlockBuilderProvider$$Interface {
get "blockBuilder"(): $BlockBuilder
}

export class $BlockBuilderProvider implements $BlockBuilderProvider$$Interface {
 "getBlockBuilder"(): $BlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBuilderProvider$$Type = ($BlockBuilderProvider);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBuilderProvider$$Original = $BlockBuilderProvider;}
declare module "dev.latvian.mods.kubejs.util.ScheduledEvents$ScheduledEvent" {
import {$ScheduledEvents} from "dev.latvian.mods.kubejs.util.ScheduledEvents"

export class $ScheduledEvents$ScheduledEvent {
 "timer": long
 "repeating": boolean
 "scheduledEvents": $ScheduledEvents
 "id": integer
 "endTime": long
 "ofTicks": boolean

constructor()

public "clear"(): void
public "reschedule"(): $ScheduledEvents$ScheduledEvent
public "reschedule"(timer: long): $ScheduledEvents$ScheduledEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledEvents$ScheduledEvent$$Type = ($ScheduledEvents$ScheduledEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScheduledEvents$ScheduledEvent$$Original = $ScheduledEvents$ScheduledEvent;}
declare module "dev.latvian.mods.kubejs.registry.BuilderBase" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$Supplier$$Interface} from "java.util.function.Supplier"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $BuilderBase<T> implements $Supplier$$Interface<(T)> {
 "registryKey": $ResourceKey<($Registry<(T)>)>
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation

constructor(id: $ResourceLocation$$Type)

public "getTranslationKeyGroup"(): StringJS
public "getBuilderTranslationKey"(): StringJS
public "get"(): T
public "toString"(): StringJS
/**
 * Sets the display name for this object, e.g. `Stone`.
 * 
 * This will be overridden by a lang file if it exists.
 */
public "displayName"(name: $Component$$Type): this
/**
 * Adds a tag to this object, e.g. `minecraft:stone`.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): this
/**
 * Makes displayName() override language files.
 */
public "formattedDisplayName"(): this
/**
 * Combined method of formattedDisplayName().displayName(name).
 */
public "formattedDisplayName"(name: $Component$$Type): this
/**
 * Sets the translation key for this object, e.g. `block.minecraft.stone`.
 */
public "translationKey"(key: StringJS): this
get "translationKeyGroup"(): StringJS
get "builderTranslationKey"(): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuilderBase$$Type<T> = ($BuilderBase<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BuilderBase$$Original<T> = $BuilderBase<(T)>;}
declare module "dev.latvian.mods.kubejs.server.tag.TagWrapper" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$List, $List$$Type} from "java.util.List"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$TagKubeEvent, $TagKubeEvent$$Type} from "dev.latvian.mods.kubejs.server.tag.TagKubeEvent"

export class $TagWrapper {
readonly "entries": $List<($TagLoader$EntryWithSource)>
readonly "id": $ResourceLocation
readonly "event": $TagKubeEvent

constructor(e: $TagKubeEvent$$Type, i: $ResourceLocation$$Type, t: $List$$Type<($TagLoader$EntryWithSource$$Type)>)

public "remove"(...filters: (any)[]): $TagWrapper
public "toString"(): StringJS
public "add"(...filters: (any)[]): $TagWrapper
public "removeAll"(): $TagWrapper
public "getObjectIds"(): $List<($ResourceLocation)>
get "objectIds"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagWrapper$$Type = ($TagWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $TagWrapper$$Original = $TagWrapper;}
declare module "dev.latvian.mods.kubejs.event.EventExit" {
import {$Exception} from "java.lang.Exception"
import {$EventResult, $EventResult$$Type} from "dev.latvian.mods.kubejs.event.EventResult"

export class $EventExit extends $Exception {
readonly "result": $EventResult

constructor(result: $EventResult$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventExit$$Type = ($EventExit);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EventExit$$Original = $EventExit;}
declare module "dev.latvian.mods.kubejs.recipe.match.FluidMatch" {
import {$ReplacementMatch, $ReplacementMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"

export interface $FluidMatch$$Interface extends $ReplacementMatch$$Interface {
}

export class $FluidMatch implements $FluidMatch$$Interface {
 "matches"(cx: $RecipeMatchContext$$Type, stack: $FluidStack$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, ingredient: $FluidIngredient$$Type, exact: boolean): boolean
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidMatch$$Type = ($FluidMatch);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidMatch$$Original = $FluidMatch;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.BlockWrapper" {
import {$RegistryKubeEvent$$Type} from "dev.latvian.mods.kubejs.registry.RegistryKubeEvent"
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$List} from "java.util.List"
import {$Direction} from "net.minecraft.core.Direction"
import {$BlockEntityPredicate} from "dev.latvian.mods.kubejs.block.predicate.BlockEntityPredicate"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockIDPredicate} from "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate"
import {$BlockSetType} from "net.minecraft.world.level.block.state.properties.BlockSetType"
import {$RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$BlockPredicate, $BlockPredicate$$Type} from "dev.latvian.mods.kubejs.block.predicate.BlockPredicate"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$BuildingMaterialProperties$$Type} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.BuildingMaterialProperties"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

/**
 * Various block related helper functions
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $BlockWrapper {
static readonly "TYPE_INFO": $TypeInfo
static readonly "STATE_TYPE_INFO": $TypeInfo

constructor()

public static "id"(id: $ResourceLocation$$Type, properties: $Map$$Type<(StringJS), (any)>): $BlockIDPredicate
public static "id"(id: $ResourceLocation$$Type): $BlockIDPredicate
/**
 * Gets a blocks id from the Block
 */
public static "getId"(block: $Block$$Type): $ResourceLocation
public static "entity"(id: $ResourceLocation$$Type): $BlockEntityPredicate
public static "withProperties"(state: $BlockState$$Type, properties: $Map$$Type<(never), (never)>): $BlockState
public static "getAllBlockStates"(): $Collection<($BlockState)>
/**
 * Gets a list of all blocks with tags
 */
public static "getTaggedIds"(tag: $ResourceLocation$$Type): $List<($ResourceLocation)>
public static "parseBlockState"(registries: $RegistryAccessContainer$$Type, string: StringJS): $BlockState
/**
 * Gets a Block from a block id
 */
public static "getBlock"(id: $ResourceLocation$$Type): $Block
public static "custom"(predicate: $BlockPredicate$$Type): $BlockPredicate
/**
 * Gets a list of the classname of all registered blocks
 */
public static "getTypeList"(): $List<(StringJS)>
public static "wrapSetType"(from: any, target: $TypeInfo$$Type): $BlockSetType
/**
 * Parses a block state from the input string. May throw for invalid inputs!
 */
public static "wrapBlockState"(registries: $RegistryAccessContainer$$Type, o: any): $BlockState
/**
 * Get a map of direction name to Direction. Functionally identical to Direction.ALL
 */
public static "getFacing"(): $Map<(StringJS), ($Direction)>
public static "registerBuildingMaterial"(event: $RegistryKubeEvent$$Type<($Block$$Type)>, id: $ResourceLocation$$Type): void
public static "registerBuildingMaterial"(event: $RegistryKubeEvent$$Type<($Block$$Type)>, id: $ResourceLocation$$Type, properties: $BuildingMaterialProperties$$Type): void
get "allBlockStates"(): $Collection<($BlockState)>
get "typeList"(): $List<(StringJS)>
get "facing"(): $Map<(StringJS), ($Direction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockWrapper$$Type = ($BlockWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockWrapper$$Original = $BlockWrapper;}
declare module "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaStorage" {
import {$RecipePostProcessor} from "dev.latvian.mods.kubejs.recipe.schema.postprocessing.RecipePostProcessor"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Map} from "java.util.Map"
import {$Codec} from "com.mojang.serialization.Codec"
import {$RecipeSchemaType} from "dev.latvian.mods.kubejs.recipe.schema.RecipeSchemaType"
import {$ServerScriptManager$$Type} from "dev.latvian.mods.kubejs.server.ServerScriptManager"
import {$RecipeNamespace} from "dev.latvian.mods.kubejs.recipe.schema.RecipeNamespace"
import {$RecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$KubeRecipeFactory} from "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory"
import {$RegistryAccessContainer$$Type} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$ResourceManager$$Type} from "net.minecraft.server.packs.resources.ResourceManager"

export class $RecipeSchemaStorage {
readonly "mappings": $Map<(StringJS), ($ResourceLocation)>
readonly "recipeTypes": $Map<($ResourceLocation), ($KubeRecipeFactory)>
readonly "schemaTypes": $Map<(StringJS), ($RecipeSchemaType)>
 "recipeComponentCodec": $Codec<($RecipeComponent<(never)>)>
 "recipePostProcessorCodec": $Codec<($RecipePostProcessor)>
readonly "namespaces": $Map<(StringJS), ($RecipeNamespace)>

constructor(manager: $ServerScriptManager$$Type)

public "namespace"(namespace: StringJS): $RecipeNamespace
public "fireEvents"(registries: $RegistryAccessContainer$$Type, resourceManager: $ResourceManager$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchemaStorage$$Type = ($RecipeSchemaStorage);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeSchemaStorage$$Original = $RecipeSchemaStorage;}
declare module "dev.latvian.mods.kubejs.item.ItemStackKey" {
import {$DataComponentPatch, $DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"

export class $ItemStackKey {
readonly "patch": $DataComponentPatch
readonly "item": $Item
static "EMPTY": $ItemStackKey

constructor(item: $Item$$Type, patch: $DataComponentPatch$$Type)

public "equals"(obj: any): boolean
public "hashCode"(): integer
public static "of"(stack: $ItemStack$$Type): $ItemStackKey
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackKey$$Type = ($ItemStackKey);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemStackKey$$Original = $ItemStackKey;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.RemoveCategoriesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"

export interface $RemoveCategoriesKubeEvent$$Interface extends $KubeEvent$$Interface {

(categories: ($ResourceLocation)[]): void
}

export class $RemoveCategoriesKubeEvent implements $RemoveCategoriesKubeEvent$$Interface {
 "remove"(categories: ($ResourceLocation$$Type)[]): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveCategoriesKubeEvent$$Type = ((categories: ($ResourceLocation)[]) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RemoveCategoriesKubeEvent$$Original = $RemoveCategoriesKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.LocalClientPlayerKJS" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$KubeJSInventoryListener} from "dev.latvian.mods.kubejs.player.KubeJSInventoryListener"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Stages} from "dev.latvian.mods.kubejs.stages.Stages"
import {$Holder$$Type} from "net.minecraft.core.Holder"
import {$FoodProperties$$Type} from "net.minecraft.world.food.FoodProperties"
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EquipmentSlot$$Type} from "net.minecraft.world.entity.EquipmentSlot"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$Item$$Type} from "net.minecraft.world.item.Item"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$ClientPlayerKJS$$Interface} from "dev.latvian.mods.kubejs.core.ClientPlayerKJS"
import {$NotificationToastData$$Type} from "dev.latvian.mods.kubejs.util.NotificationToastData"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$InteractionHand$$Type} from "net.minecraft.world.InteractionHand"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$PlayerStatsJS} from "dev.latvian.mods.kubejs.player.PlayerStatsJS"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$AbstractContainerMenu} from "net.minecraft.world.inventory.AbstractContainerMenu"
import {$AttributeModifier$Operation$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier$Operation"
import {$EntityPotionEffectsJS} from "dev.latvian.mods.kubejs.entity.EntityPotionEffectsJS"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $LocalClientPlayerKJS$$Interface extends $ClientPlayerKJS$$Interface {

(): $AttachedData$$Type<($Player$$Type)>
get "stats"(): $PlayerStatsJS
get "miningBlock"(): boolean
set "activePostShader"(value: $ResourceLocation$$Type)
get "minecraft"(): $Minecraft
get "openInventory"(): $AbstractContainerMenu
get "selectedSlot"(): integer
get "craftingGrid"(): $InventoryKJS
set "selectedSlot"(value: integer)
get "profile"(): $GameProfile
get "player"(): boolean
get "foodLevel"(): integer
set "foodLevel"(value: integer)
get "saturation"(): float
set "saturation"(value: float)
set "xpLevel"(value: integer)
get "xpLevel"(): integer
get "stages"(): $Stages
get "inventory"(): $InventoryKJS
get "mouseItem"(): $ItemStack
set "mouseItem"(value: $ItemStack$$Type)
set "statusMessage"(value: $Component$$Type)
get "inventoryChangeListener"(): $KubeJSInventoryListener
get "fake"(): boolean
set "xp"(value: integer)
get "xp"(): integer
set "headArmorItem"(value: $ItemStack$$Type)
get "chestArmorItem"(): $ItemStack
get "legsArmorItem"(): $ItemStack
set "mainHandItem"(value: $ItemStack$$Type)
set "chestArmorItem"(value: $ItemStack$$Type)
set "legsArmorItem"(value: $ItemStack$$Type)
get "mainHandItem"(): $ItemStack
get "headArmorItem"(): $ItemStack
get "feetArmorItem"(): $ItemStack
get "potionEffects"(): $EntityPotionEffectsJS
set "feetArmorItem"(value: $ItemStack$$Type)
get "totalMovementSpeed"(): double
get "reachDistance"(): double
get "living"(): boolean
get "undead"(): boolean
set "maxHealth"(value: float)
get "offHandItem"(): $ItemStack
set "offHandItem"(value: $ItemStack$$Type)
set "defaultMovementSpeed"(value: double)
set "movementSpeedAddition"(value: double)
get "defaultMovementSpeed"(): double
set "totalMovementSpeedMultiplier"(value: double)
set "defaultMovementSpeedMultiplier"(value: double)
get "data"(): $AttachedData<($Player)>
get "nbt"(): $CompoundTag
set "z"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "x"(value: double)
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
get "level"(): $Level
get "type"(): StringJS
set "motionX"(value: double)
get "teamId"(): StringJS
set "motionY"(value: double)
get "server"(): $MinecraftServer
get "motionZ"(): double
get "motionX"(): double
get "passengers"(): $EntityArrayList
get "facing"(): $Direction
get "animal"(): boolean
get "item"(): $ItemStack
set "position"(value: $LevelBlock$$Type)
set "motionZ"(value: double)
get "scriptType"(): $ScriptType
get "frame"(): boolean
get "motionY"(): double
get "block"(): $LevelBlock
get "monster"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "persistentData"(): $CompoundTag
}

export class $LocalClientPlayerKJS implements $LocalClientPlayerKJS$$Interface {
 "getStats"(): $PlayerStatsJS
 "isMiningBlock"(): boolean
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "isSelf"(): boolean
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "self"(): $Entity
 "getMinecraft"(): $Minecraft
 "runCommand"(command: StringJS): void
 "notify"(notification: $NotificationToastData$$Type): void
 "spawn"(): void
 "boostElytraFlight"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "getSelectedSlot"(): integer
 "sendInventoryUpdate"(): void
 "getCraftingGrid"(): $InventoryKJS
 "setSelectedSlot"(index: integer): void
 "addItemCooldown"(item: $Item$$Type, ticks: integer): void
 "getProfile"(): $GameProfile
 "isPlayer"(): boolean
 "getFoodLevel"(): integer
 "setFoodLevel"(foodLevel: integer): void
 "getSaturation"(): float
 "setSaturation"(saturation: float): void
 "addExhaustion"(exhaustion: float): void
 "addXPLevels"(l: integer): void
 "setXpLevel"(l: integer): void
 "getXpLevel"(): integer
 "getStages"(): $Stages
 "addFood"(f: integer, m: float): void
 "getInventory"(): $InventoryKJS
 "giveInHand"(item: $ItemStack$$Type): void
 "getMouseItem"(): $ItemStack
 "setMouseItem"(item: $ItemStack$$Type): void
 "setStatusMessage"(message: $Component$$Type): void
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "isFake"(): boolean
 "setXp"(xp: integer): void
 "addXP"(xp: integer): void
 "give"(item: $ItemStack$$Type): void
 "getXp"(): integer
 "notify"(title: $Component$$Type, text: $Component$$Type): void
 "swing"(hand: $InteractionHand$$Type): void
 "swing"(): void
 "setHeadArmorItem"(item: $ItemStack$$Type): void
 "getChestArmorItem"(): $ItemStack
 "getLegsArmorItem"(): $ItemStack
 "isHoldingInAnyHand"(i: $ItemPredicate$$Type): boolean
 "setMainHandItem"(item: $ItemStack$$Type): void
 "setChestArmorItem"(item: $ItemStack$$Type): void
 "setLegsArmorItem"(item: $ItemStack$$Type): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageEquipment"(slot: $EquipmentSlot$$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$$Type): void
 "getMainHandItem"(): $ItemStack
 "getHeadArmorItem"(): $ItemStack
 "getFeetArmorItem"(): $ItemStack
 "getPotionEffects"(): $EntityPotionEffectsJS
 "setFeetArmorItem"(item: $ItemStack$$Type): void
 "getTotalMovementSpeed"(): double
 "canEntityBeSeen"(entity: $LivingEntity$$Type): boolean
 "getAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>): double
 "getAttributeTotalValue"(attribute: $Holder$$Type<($Attribute)>): double
 "setAttributeBaseValue"(attribute: $Holder$$Type<($Attribute)>, value: double): void
 "getReachDistance"(): double
 "modifyAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type, amount: double, operation: $AttributeModifier$Operation$$Type): void
 "removeAttribute"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): void
 "foodEaten"(is: $ItemStack$$Type, food: $FoodProperties$$Type): void
 "setEquipment"(slot: $EquipmentSlot$$Type, item: $ItemStack$$Type): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer, onBroken: $Consumer$$Type<($ItemStack)>): void
 "damageHeldItem"(): void
 "damageHeldItem"(hand: $InteractionHand$$Type, amount: integer): void
 "rayTrace"(): $KubeRayTraceResult
 "isLiving"(): boolean
 "isUndead"(): boolean
 "setMaxHealth"(hp: float): void
 "getHeldItem"(hand: $InteractionHand$$Type): $ItemStack
 "getOffHandItem"(): $ItemStack
 "setHeldItem"(hand: $InteractionHand$$Type, item: $ItemStack$$Type): void
 "setOffHandItem"(item: $ItemStack$$Type): void
 "rayTraceEntity"(filter: $Predicate$$Type<($Entity)>): $Entity
 "getEquipment"(slot: $EquipmentSlot$$Type): $ItemStack
 "setDefaultMovementSpeed"(speed: double): void
 "setMovementSpeedAddition"(speed: double): void
 "getDefaultMovementSpeed"(): double
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "sendData"(channel: StringJS): void
 "getData"(): $AttachedData<($Player)>
 "getNbt"(): $CompoundTag
 "attack"(hp: float): void
 "setZ"(z: double): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setX"(x: double): void
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "isAmbientCreature"(): boolean
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "getLevel"(): $Level
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "getType"(): StringJS
 "setMotionX"(x: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getTeamId"(): StringJS
 "setMotionY"(y: double): void
 "getServer"(): $MinecraftServer
 "getMotionZ"(): double
 "getMotionX"(): double
 "getPassengers"(): $EntityArrayList
 "getFacing"(): $Direction
 "setRotation"(yaw: float, pitch: float): void
 "isAnimal"(): boolean
 "getItem"(): $ItemStack
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "setPosition"(x: double, y: double, z: double): void
 "setPosition"(block: $LevelBlock$$Type): void
 "setMotionZ"(z: double): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "isFrame"(): boolean
 "getMotionY"(): double
 "getBlock"(): $LevelBlock
 "isMonster"(): boolean
 "tell"(message: $Component$$Type): void
 "getName"(): $Component
 "getDisplayName"(): $Component
 "getPersistentData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LocalClientPlayerKJS$$Type = (() => $AttachedData$$Type<($Player$$Type)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $LocalClientPlayerKJS$$Original = $LocalClientPlayerKJS;}
declare module "dev.latvian.mods.kubejs.client.SoundsGenerator" {
import {$JsonObject} from "com.google.gson.JsonObject"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$SoundsGenerator$SoundGen$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundGen"

export class $SoundsGenerator {
constructor()

public "toJson"(): $JsonObject
public "addSound"(path: StringJS, consumer: $Consumer$$Type<($SoundsGenerator$SoundGen)>, overlayExisting: boolean): void
public "addSound"(path: StringJS, consumer: $Consumer$$Type<($SoundsGenerator$SoundGen)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundsGenerator$$Type = ($SoundsGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoundsGenerator$$Original = $SoundsGenerator;}
declare module "dev.latvian.mods.kubejs.core.WithPersistentData" {
import {$CompoundTag} from "net.minecraft.nbt.CompoundTag"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MessageSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $WithPersistentData$$Interface extends $MessageSenderKJS$$Interface {
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "displayName"(): $Component
}

export class $WithPersistentData implements $WithPersistentData$$Interface {
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "tell"(message: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(command: StringJS): void
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithPersistentData$$Type = ($WithPersistentData);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WithPersistentData$$Original = $WithPersistentData;}
declare module "dev.latvian.mods.kubejs.entity.KubeRayTraceResult" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$HitResult$Type} from "net.minecraft.world.phys.HitResult$Type"
import {$Direction} from "net.minecraft.core.Direction"
import {$HitResult$$Type} from "net.minecraft.world.phys.HitResult"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"

export class $KubeRayTraceResult {
readonly "hit": $Vec3
readonly "fromEntity": $Entity
readonly "distance": double
readonly "facing": $Direction
readonly "block": $LevelBlock
readonly "type": $HitResult$Type
readonly "entity": $Entity

constructor(from: $Entity$$Type, result: $HitResult$$Type, d: double)
constructor(from: $Entity$$Type, result: $HitResult$$Type)

public "getHitX"(): double
public "getHitZ"(): double
public "getHitY"(): double
get "hitX"(): double
get "hitZ"(): double
get "hitY"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeRayTraceResult$$Type = ($KubeRayTraceResult);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeRayTraceResult$$Original = $KubeRayTraceResult;}
declare module "dev.latvian.mods.kubejs.script.ScriptTypeHolder" {
import {$ScriptType, $ScriptType$$Type} from "dev.latvian.mods.kubejs.script.ScriptType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ScriptTypeHolder$$Interface {

(): $ScriptType$$Type
}

export class $ScriptTypeHolder implements $ScriptTypeHolder$$Interface {
 "kjs$getScriptType"(): $ScriptType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptTypeHolder$$Type = (() => $ScriptType$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptTypeHolder$$Original = $ScriptTypeHolder;}
declare module "dev.latvian.mods.kubejs.generator.KubeAssetGenerator" {
import {$ParticleGenerator$$Type} from "dev.latvian.mods.kubejs.client.ParticleGenerator"
import {$GeneratedData, $GeneratedData$$Type} from "dev.latvian.mods.kubejs.script.data.GeneratedData"
import {$SoundsGenerator$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator"
import {$Map$$Type} from "java.util.Map"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$KubeResourceGenerator$$Interface} from "dev.latvian.mods.kubejs.generator.KubeResourceGenerator"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$VariantBlockStateGenerator$$Type} from "dev.latvian.mods.kubejs.client.VariantBlockStateGenerator"
import {$ModelGenerator$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$MultipartBlockStateGenerator$$Type} from "dev.latvian.mods.kubejs.client.MultipartBlockStateGenerator"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$LoadedTexture, $LoadedTexture$$Type} from "dev.latvian.mods.kubejs.client.LoadedTexture"

export interface $KubeAssetGenerator$$Interface extends $KubeResourceGenerator$$Interface {
get "registries"(): $RegistryAccessContainer
}

export class $KubeAssetGenerator implements $KubeAssetGenerator$$Interface {
static readonly "HANDHELD_ITEM_MODEL": $ResourceLocation
static readonly "CUBE_BLOCK_MODEL": $ResourceLocation
static readonly "CUBE_ALL_BLOCK_MODEL": $ResourceLocation
static readonly "GENERATED_ITEM_MODEL": $ResourceLocation

 "mask"(target: $ResourceLocation$$Type, mask: $ResourceLocation$$Type, input: $ResourceLocation$$Type): boolean
 "defaultHandheldItemModel"(id: $ResourceLocation$$Type): void
 "texture"(target: $ResourceLocation$$Type, texture: $LoadedTexture$$Type): void
 "stencil"(target: $ResourceLocation$$Type, stencil: $ResourceLocation$$Type, colors: $Map$$Type<($KubeColor$$Type), ($KubeColor$$Type)>): void
 "sounds"(namespace: StringJS, consumer: $Consumer$$Type<($SoundsGenerator)>): void
 "loadTexture"(id: $ResourceLocation$$Type): $LoadedTexture
 "defaultItemModel"(id: $ResourceLocation$$Type): void
 "multipartState"(id: $ResourceLocation$$Type, consumer: $Consumer$$Type<($MultipartBlockStateGenerator)>): void
 "blockModel"(id: $ResourceLocation$$Type, consumer: $Consumer$$Type<($ModelGenerator)>): void
 "itemModel"(id: $ResourceLocation$$Type, consumer: $Consumer$$Type<($ModelGenerator)>): void
 "particle"(id: $ResourceLocation$$Type, consumer: $Consumer$$Type<($ParticleGenerator)>): void
 "blockState"(id: $ResourceLocation$$Type, consumer: $Consumer$$Type<($VariantBlockStateGenerator)>): void
 "flush"(): void
 "add"(data: $GeneratedData$$Type): void
 "text"(id: $ResourceLocation$$Type, content: StringJS): void
 "json"(id: $ResourceLocation$$Type, json: $JsonElement$$Type): void
 "getRegistries"(): $RegistryAccessContainer
 "getGenerated"(id: $ResourceLocation$$Type): $GeneratedData
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeAssetGenerator$$Type = ($KubeAssetGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeAssetGenerator$$Original = $KubeAssetGenerator;}
declare module "dev.latvian.mods.kubejs.block.BlockModificationKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$BlockModificationKubeEvent$BlockModifications$$Type} from "dev.latvian.mods.kubejs.block.BlockModificationKubeEvent$BlockModifications"
import {$BlockStatePredicate$$Type} from "dev.latvian.mods.kubejs.block.state.BlockStatePredicate"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $BlockModificationKubeEvent implements $KubeEvent$$Interface {
constructor()

/**
 * Modifies blocks that match the given predicate.
 * 
 * **NOTE**: tag predicates are not supported at this time.
 */
public "modify"(predicate: $BlockStatePredicate$$Type, c: $Consumer$$Type<($BlockModificationKubeEvent$BlockModifications)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockModificationKubeEvent$$Type = ($BlockModificationKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockModificationKubeEvent$$Original = $BlockModificationKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$SurviveCallback" {
import {$LevelReader, $LevelReader$$Type} from "net.minecraft.world.level.LevelReader"
import {$BlockPos, $BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$BlockState, $BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export interface $CropBlockBuilder$SurviveCallback$$Interface {

(state: $BlockState, reader: $LevelReader, pos: $BlockPos): boolean
}

export class $CropBlockBuilder$SurviveCallback implements $CropBlockBuilder$SurviveCallback$$Interface {
 "survive"(state: $BlockState$$Type, reader: $LevelReader$$Type, pos: $BlockPos$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlockBuilder$SurviveCallback$$Type = ((state: $BlockState, reader: $LevelReader, pos: $BlockPos) => boolean);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CropBlockBuilder$SurviveCallback$$Original = $CropBlockBuilder$SurviveCallback;}
declare module "dev.latvian.mods.kubejs.client.KubeJSKeybinds$KeyEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LocalPlayer$$Type} from "net.minecraft.client.player.LocalPlayer"
import {$KubeJSKeybinds$KubeKey$$Type} from "dev.latvian.mods.kubejs.client.KubeJSKeybinds$KubeKey"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$ClientPlayerKubeEvent} from "dev.latvian.mods.kubejs.client.ClientPlayerKubeEvent"

export class $KubeJSKeybinds$KeyEvent extends $ClientPlayerKubeEvent {
constructor(player: $LocalPlayer$$Type, key: $KubeJSKeybinds$KubeKey$$Type)

public "getPlayer"(): $Player
public "getEntity"(): $Entity
get "player"(): $Player
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSKeybinds$KeyEvent$$Type = ($KubeJSKeybinds$KeyEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSKeybinds$KeyEvent$$Original = $KubeJSKeybinds$KeyEvent;}
declare module "dev.latvian.mods.kubejs.client.ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider" {
import {$ClientLevel, $ClientLevel$$Type} from "net.minecraft.client.multiplayer.ClientLevel"
import {$ParticleProvider} from "net.minecraft.client.particle.ParticleProvider"
import {$Particle, $Particle$$Type} from "net.minecraft.client.particle.Particle"
import {$ParticleEngine$SpriteParticleRegistration$$Interface} from "net.minecraft.client.particle.ParticleEngine$SpriteParticleRegistration"
import {$SpriteSet, $SpriteSet$$Type} from "net.minecraft.client.particle.SpriteSet"
import {$ParticleOptions, $ParticleOptions$$Type} from "net.minecraft.core.particles.ParticleOptions"

export interface $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Interface<T extends $ParticleOptions> extends $ParticleEngine$SpriteParticleRegistration$$Interface<(T)> {

(type: T, clientLevel: $ClientLevel, x: double, y: double, z: double, sprites: $SpriteSet, xSpeed: double, ySpeed: double, zSpeed: double): $Particle$$Type
}

export class $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider<T extends $ParticleOptions> implements $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Interface {
 "create"(type: T, clientLevel: $ClientLevel$$Type, x: double, y: double, z: double, sprites: $SpriteSet$$Type, xSpeed: double, ySpeed: double, zSpeed: double): $Particle
 "create"(sprites: $SpriteSet$$Type): $ParticleProvider<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Type<T> = ((type: T, clientLevel: $ClientLevel, x: double, y: double, z: double, sprites: $SpriteSet, xSpeed: double, ySpeed: double, zSpeed: double) => $Particle$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider$$Original<T> = $ParticleProviderRegistryKubeEvent$SpriteSetParticleProvider<(T)>;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.StringUtilsWrapper" {
import {$Pattern} from "java.util.regex.Pattern"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Function$$Type} from "java.util.function.Function"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$Set} from "java.util.Set"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $StringUtilsWrapper$$Interface {
}

export class $StringUtilsWrapper implements $StringUtilsWrapper$$Interface {
static readonly "ALWAYS_LOWER_CASE": $Set<(StringJS)>
static readonly "SNAKE_CASE_SPLIT": $Pattern
static readonly "EMPTY_STRING_ARRAY": (StringJS)[]

/**
 * Returns the provided snake_case_string in Title Case
 */
static "snakeCaseToTitleCase"(string: StringJS): StringJS
/**
 * Tries to parse the first parameter as an integer, and returns that. The second parameter is returned if parsing fails
 */
static "parseInt"(object: any, def: integer): integer
/**
 * Capitalises the first letter of the string unless it is "a", "an", "the", "of", "on", "in", "and", "or", "but" or "for"
 */
static "toTitleCase"(s: StringJS): StringJS
/**
 * Capitalises the first letter of the string. If ignoreSpecial is true, it will also capitalise articles and prepositions
 */
static "toTitleCase"(s: StringJS, ignoreSpecial: boolean): StringJS
/**
 * Tries to parse the first parameter as a double and returns that. The second parameter is returned if parsing fails
 */
static "parseDouble"(object: any, def: double): double
static "parseLong"(object: any, def: long): long
static "stripIdForEvent"(id: $ResourceLocation$$Type): StringJS
static "stripEventName"(s: StringJS): StringJS
static "getUniqueId"(json: $JsonElement$$Type): StringJS
static "getUniqueId"<T>(input: T, toJson: $Function$$Type<(T), ($JsonElement$$Type)>): StringJS
/**
 * Returns the provided snake_case_string in camelCase
 */
static "snakeCaseToCamelCase"(string: StringJS): StringJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringUtilsWrapper$$Type = ($StringUtilsWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $StringUtilsWrapper$$Original = $StringUtilsWrapper;}
declare module "dev.latvian.mods.kubejs.util.FluidAmounts" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $FluidAmounts$$Interface {
}

export class $FluidAmounts implements $FluidAmounts$$Interface {
static readonly "B": long
static readonly "METAL_BLOCK": long
static readonly "MB": long
static readonly "BOTTLE": long
static readonly "BUCKET": long
static readonly "MILLIBUCKET": long
static readonly "INGOT": long
static readonly "NUGGET": long

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidAmounts$$Type = ($FluidAmounts);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidAmounts$$Original = $FluidAmounts;}
declare module "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext" {
import {$RecipeLikeContext$$Interface} from "dev.latvian.mods.kubejs.recipe.RecipeLikeContext"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$RecipeLikeKJS} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RecipeMatchContext$$Interface extends $RecipeLikeContext$$Interface {
}

export class $RecipeMatchContext implements $RecipeMatchContext$$Interface {
 "registries"(): $RegistryAccessContainer
 "ops"(): $RegistryOpsContainer
 "recipe"(): $RecipeLikeKJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeMatchContext$$Type = ($RecipeMatchContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeMatchContext$$Original = $RecipeMatchContext;}
declare module "dev.latvian.mods.kubejs.util.KubeResourceLocation" {
import {$UnaryOperator$$Type} from "java.util.function.UnaryOperator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$Record} from "java.lang.Record"

export class $KubeResourceLocation extends $Record {
static readonly "CODEC": $Codec<($ResourceLocation)>

constructor(wrapped: $ResourceLocation$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "wrap"(from: any): $ResourceLocation
public "wrapped"(): $ResourceLocation
public "withPath"(path: StringJS): $ResourceLocation
public "withPath"(path: $UnaryOperator$$Type<(StringJS)>): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeResourceLocation$$Type = ({"wrapped"?: $ResourceLocation$$Type}) | ([wrapped?: $ResourceLocation$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeResourceLocation$$Original = $KubeResourceLocation;}
declare module "dev.latvian.mods.kubejs.web.KJSHTTPRequest" {
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Runnable$$Type} from "java.lang.Runnable"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"
import {$DataComponentPatch} from "net.minecraft.core.component.DataComponentPatch"
import {$HTTPResponse, $HTTPResponse$$Type} from "dev.latvian.apps.tinyserver.http.response.HTTPResponse"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$BlockableEventLoop, $BlockableEventLoop$$Type} from "net.minecraft.util.thread.BlockableEventLoop"
import {$Tag$$Type} from "net.minecraft.nbt.Tag"
import {$Throwable$$Type} from "java.lang.Throwable"
import {$HTTPRequest} from "dev.latvian.apps.tinyserver.http.HTTPRequest"
import {$HTTPPayload$$Type} from "dev.latvian.apps.tinyserver.http.response.HTTPPayload"

export class $KJSHTTPRequest extends $HTTPRequest {
readonly "eventLoop": $BlockableEventLoop<(never)>

constructor(eventLoop: $BlockableEventLoop$$Type<(never)>)

public "handleResponse"(payload: $HTTPPayload$$Type, response: $HTTPResponse$$Type, error: $Throwable$$Type): $HTTPResponse
public "registries"(): $RegistryAccessContainer
public "id"(ns: StringJS, path: StringJS): $ResourceLocation
public "id"(): $ResourceLocation
public "components"(ops: $DynamicOps$$Type<($Tag$$Type)>): $DataComponentPatch
public "runInMainThread"(task: $Runnable$$Type): void
public "supplyInMainThread"<T>(task: $Supplier$$Type<(T)>): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KJSHTTPRequest$$Type = ($KJSHTTPRequest);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KJSHTTPRequest$$Original = $KJSHTTPRequest;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.UUIDWrapper" {
import {$StringBuilder$$Type} from "java.lang.StringBuilder"
import {$UUID, $UUID$$Type} from "java.util.UUID"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $UUIDWrapper$$Interface {
}

export class $UUIDWrapper implements $UUIDWrapper$$Interface {
static "toString"(id: $UUID$$Type): StringJS
static "digits"(sb: $StringBuilder$$Type, val: long, digits: integer): void
static "fromString"(o: any): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UUIDWrapper$$Type = ($UUIDWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UUIDWrapper$$Original = $UUIDWrapper;}
declare module "dev.latvian.mods.kubejs.block.BlockModificationKubeEvent$BlockModifications" {
import {$SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$RandomTickCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Record} from "java.lang.Record"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $BlockModificationKubeEvent$BlockModifications extends $Record {
constructor(block: $Block$$Type)

public "setIsRandomlyTicking"(v: boolean): void
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "block"(): $Block
public "setNameKey"(key: StringJS): void
public "setHasCollision"(v: boolean): void
public "setRandomTickCallback"(callback: $Consumer$$Type<($RandomTickCallback)>): void
public "setExplosionResistance"(v: float): void
public "setRequiresTool"(v: boolean): void
public "setSoundType"(v: $SoundType$$Type): void
public "setJumpFactor"(v: float): void
public "setFriction"(v: float): void
public "setLightEmission"(v: integer): void
public "setSpeedFactor"(v: float): void
public "setDestroySpeed"(v: float): void
set "isRandomlyTicking"(value: boolean)
set "nameKey"(value: StringJS)
set "hasCollision"(value: boolean)
set "randomTickCallback"(value: $Consumer$$Type<($RandomTickCallback)>)
set "explosionResistance"(value: float)
set "requiresTool"(value: boolean)
set "soundType"(value: $SoundType$$Type)
set "jumpFactor"(value: float)
set "friction"(value: float)
set "lightEmission"(value: integer)
set "speedFactor"(value: float)
set "destroySpeed"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockModificationKubeEvent$BlockModifications$$Type = ({"block"?: $Block$$Type}) | ([block?: $Block$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockModificationKubeEvent$BlockModifications$$Original = $BlockModificationKubeEvent$BlockModifications;}
declare module "dev.latvian.mods.kubejs.registry.RegistryKubeEvent" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$KubeStartupEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeStartupEvent"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$List} from "java.util.List"
import {$CustomBuilderObject} from "dev.latvian.mods.kubejs.registry.CustomBuilderObject"
import {$ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$AdditionalObjectRegistry$$Interface} from "dev.latvian.mods.kubejs.registry.AdditionalObjectRegistry"

export class $RegistryKubeEvent<T> implements $KubeStartupEvent$$Interface, $AdditionalObjectRegistry$$Interface {
readonly "created": $List<($BuilderBase<(T)>)>

constructor(registryKey: $ResourceKey$$Type<($Registry<(T)>)>)

public "add"<R>(registry: $ResourceKey$$Type<($Registry<(R)>)>, builder: $BuilderBase$$Type<(R)>): void
public "create"(id: $ResourceLocation$$Type): $BuilderBase<(T)>
public "create"(id: $ResourceLocation$$Type, type: $ResourceLocation$$Type): $BuilderBase<(T)>
public "createCustom"(id: $ResourceLocation$$Type, object: () => T): $CustomBuilderObject
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryKubeEvent$$Type<T> = ($RegistryKubeEvent<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryKubeEvent$$Original<T> = $RegistryKubeEvent<(T)>;}
declare module "dev.latvian.mods.kubejs.level.ExplosionKubeEvent$After" {
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$List, $List$$Type} from "java.util.List"
import {$Level$$Type} from "net.minecraft.world.level.Level"
import {$Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$ExplosionKubeEvent} from "dev.latvian.mods.kubejs.level.ExplosionKubeEvent"

/**
 * Invoked right after an explosion happens.
 */
export class $ExplosionKubeEvent$After extends $ExplosionKubeEvent {
constructor(level: $Level$$Type, explosion: $Explosion$$Type, affectedEntities: $List$$Type<($Entity$$Type)>)

/**
 * Gets a list of all blocks affected by the explosion.
 */
public "getAffectedBlocks"(): $List<($LevelBlock)>
/**
 * Gets a list of all entities affected by the explosion.
 */
public "getAffectedEntities"(): $EntityArrayList
/**
 * Remove an entity from the list of affected entities.
 */
public "removeAffectedEntity"(entity: $Entity$$Type): void
/**
 * Remove all entities from the list of affected entities.
 */
public "removeAllAffectedEntities"(): void
/**
 * Remove a block from the list of affected blocks.
 */
public "removeAffectedBlock"(block: $LevelBlock$$Type): void
/**
 * Remove all blocks from the list of affected blocks.
 */
public "removeAllAffectedBlocks"(): void
/**
 * Remove all knockback from all affected *players*.
 */
public "removeKnockback"(): void
get "affectedBlocks"(): $List<($LevelBlock)>
get "affectedEntities"(): $EntityArrayList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionKubeEvent$After$$Type = ($ExplosionKubeEvent$After);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExplosionKubeEvent$After$$Original = $ExplosionKubeEvent$After;}
declare module "dev.latvian.mods.kubejs.recipe.schema.UnknownKubeRecipe" {
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$KubeRecipe} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$RecipeTypeFunction} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$KubeRecipeFactory} from "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$ReplacementMatchInfo$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo"

export class $UnknownKubeRecipe extends $KubeRecipe {
 "newRecipe": boolean
static readonly "RECIPE_FACTORY": $KubeRecipeFactory
 "type": $RecipeTypeFunction
 "sourceLine": $SourceLine
 "originalJson": $JsonObject
 "removed": boolean
 "creationError": boolean
static readonly "TYPE_INFO": $TypeInfo
 "json": $JsonObject
static readonly "CHANGED_MARKER": StringJS
 "changed": boolean

constructor()

public "serialize"(): void
public "replaceInput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "replaceOutput"(cx: $RecipeScriptContext$$Type, match: $ReplacementMatchInfo$$Type, arg2: any): boolean
public "deserialize"(merge: boolean): void
public "hasInput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
public "hasOutput"(cx: $RecipeMatchContext$$Type, match: $ReplacementMatchInfo$$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnknownKubeRecipe$$Type = ($UnknownKubeRecipe);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $UnknownKubeRecipe$$Original = $UnknownKubeRecipe;}
declare module "dev.latvian.mods.kubejs.player.PlayerClonedKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$ServerPlayer, $ServerPlayer$$Type} from "net.minecraft.server.level.ServerPlayer"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when a player respawns.
 * 
 * The reason of respawn can be either death or returning from the end.
 */
export class $PlayerClonedKubeEvent implements $KubePlayerEvent$$Interface {
constructor(player: $ServerPlayer$$Type, oldPlayer: $ServerPlayer$$Type, keepData: boolean)

/**
 * Gets the player that was before respawn. Note that this entity is already removed from the world.
 */
public "getOldPlayer"(): $ServerPlayer
/**
 * Gets the player that respawned.
 */
public "getEntity"(): $LivingEntity
/**
 * Gets whether the player's data was kept, e.g. when returning from the end.
 */
public "getKeepData"(): boolean
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "oldPlayer"(): $ServerPlayer
get "entity"(): $LivingEntity
get "keepData"(): boolean
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerClonedKubeEvent$$Type = ($PlayerClonedKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PlayerClonedKubeEvent$$Original = $PlayerClonedKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.DataSenderKJS" {
import {$CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $DataSenderKJS$$Interface {
}

export class $DataSenderKJS implements $DataSenderKJS$$Interface {
 "sendData"(channel: StringJS, data: $CompoundTag$$Type): void
 "sendData"(channel: StringJS): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataSenderKJS$$Type = ($DataSenderKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DataSenderKJS$$Original = $DataSenderKJS;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Info" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$Record} from "java.lang.Record"

export class $ItemData$Info extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData$Info)>

constructor(filter: $Ingredient$$Type, info: $List$$Type<($Component$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "filter"(): $Ingredient
public "info"(): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$Info$$Type = ({"filter"?: $Ingredient$$Type, "info"?: $List$$Type<($Component$$Type)>}) | ([filter?: $Ingredient$$Type, info?: $List$$Type<($Component$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemData$Info$$Original = $ItemData$Info;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData" {
import {$ItemData$DataComponentSubtypes, $ItemData$DataComponentSubtypes$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$DataComponentSubtypes"
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$List, $List$$Type} from "java.util.List"
import {$ItemData$Group, $ItemData$Group$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Group"
import {$ItemData$Info, $ItemData$Info$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.ItemData$Info"
import {$Record} from "java.lang.Record"

export class $ItemData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($ItemData)>

constructor(addedEntries: $List$$Type<($ItemStack$$Type)>, removedEntries: $List$$Type<($Ingredient$$Type)>, completelyRemovedEntries: $List$$Type<($Ingredient$$Type)>, groupedEntries: $List$$Type<($ItemData$Group$$Type)>, info: $List$$Type<($ItemData$Info$$Type)>, dataComponentSubtypes: $List$$Type<($ItemData$DataComponentSubtypes$$Type)>)

public "dataComponentSubtypes"(): $List<($ItemData$DataComponentSubtypes)>
public "completelyRemovedEntries"(): $List<($Ingredient)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public static "collect"(): $ItemData
public "info"(): $List<($ItemData$Info)>
public "addedEntries"(): $List<($ItemStack)>
public "removedEntries"(): $List<($Ingredient)>
public "groupedEntries"(): $List<($ItemData$Group)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemData$$Type = ({"removedEntries"?: $List$$Type<($Ingredient$$Type)>, "groupedEntries"?: $List$$Type<($ItemData$Group$$Type)>, "completelyRemovedEntries"?: $List$$Type<($Ingredient$$Type)>, "info"?: $List$$Type<($ItemData$Info$$Type)>, "addedEntries"?: $List$$Type<($ItemStack$$Type)>, "dataComponentSubtypes"?: $List$$Type<($ItemData$DataComponentSubtypes$$Type)>}) | ([removedEntries?: $List$$Type<($Ingredient$$Type)>, groupedEntries?: $List$$Type<($ItemData$Group$$Type)>, completelyRemovedEntries?: $List$$Type<($Ingredient$$Type)>, info?: $List$$Type<($ItemData$Info$$Type)>, addedEntries?: $List$$Type<($ItemStack$$Type)>, dataComponentSubtypes?: $List$$Type<($ItemData$DataComponentSubtypes$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemData$$Original = $ItemData;}
declare module "dev.latvian.mods.kubejs.item.FoodEatenKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Level} from "net.minecraft.world.level.Level"
import {$LivingEntity$$Type} from "net.minecraft.world.entity.LivingEntity"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an entity eats food.
 */
export class $FoodEatenKubeEvent implements $KubeEntityEvent$$Interface {
constructor(e: $LivingEntity$$Type, is: $ItemStack$$Type)

/**
 * The food that was eaten.
 */
public "getItem"(): $ItemStack
/**
 * The entity that ate the food.
 */
public "getEntity"(): $Entity
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "item"(): $ItemStack
get "entity"(): $Entity
get "level"(): $Level
get "player"(): $Player
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoodEatenKubeEvent$$Type = ($FoodEatenKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FoodEatenKubeEvent$$Original = $FoodEatenKubeEvent;}
declare module "dev.latvian.mods.kubejs.core.FluidIngredientKJS" {
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Codec} from "com.mojang.serialization.Codec"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$FluidMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.FluidMatch"
import {$WithCodec$$Interface} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$SizedFluidIngredient} from "net.neoforged.neoforge.fluids.crafting.SizedFluidIngredient"
import {$FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $FluidIngredientKJS$$Interface extends $WithCodec$$Interface, $FluidMatch$$Interface {
get "codec"(): $Codec<(never)>
}

export class $FluidIngredientKJS implements $FluidIngredientKJS$$Interface {
 "matches"(cx: $RecipeMatchContext$$Type, arg1: $FluidIngredient$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, s: $FluidStack$$Type, exact: boolean): boolean
 "withAmount"(amount: integer): $SizedFluidIngredient
 "self"(): $FluidIngredient
 "getCodec"(): $Codec<(never)>
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
static "wrap"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidIngredientKJS$$Type = ($FluidIngredientKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidIngredientKJS$$Original = $FluidIngredientKJS;}
declare module "dev.latvian.mods.kubejs.client.KubeJSKeybinds$KubeKey" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $KubeJSKeybinds$KubeKey {
readonly "id": StringJS

constructor(id: StringJS)

public "equals"(obj: any): boolean
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSKeybinds$KubeKey$$Type = ($KubeJSKeybinds$KubeKey);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeJSKeybinds$KubeKey$$Original = $KubeJSKeybinds$KubeKey;}
declare module "dev.latvian.mods.kubejs.core.ItemFrameEntityKJS" {
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$Direction} from "net.minecraft.core.Direction"
import {$Level} from "net.minecraft.world.level.Level"
import {$SoundEvent$$Type} from "net.minecraft.sounds.SoundEvent"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$KubeRayTraceResult} from "dev.latvian.mods.kubejs.entity.KubeRayTraceResult"
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ScriptType} from "dev.latvian.mods.kubejs.script.ScriptType"
import {$EntityKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityKJS"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$GameProfile} from "com.mojang.authlib.GameProfile"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ItemFrameEntityKJS$$Interface extends $EntityKJS$$Interface {
get "item"(): $ItemStack
get "frame"(): boolean
get "nbt"(): $CompoundTag
set "z"(value: double)
set "nbt"(value: $CompoundTag$$Type)
set "y"(value: double)
set "x"(value: double)
get "waterCreature"(): boolean
get "peacefulCreature"(): boolean
get "ambientCreature"(): boolean
get "living"(): boolean
get "level"(): $Level
get "type"(): StringJS
set "motionX"(value: double)
get "teamId"(): StringJS
set "motionY"(value: double)
get "profile"(): $GameProfile
get "server"(): $MinecraftServer
get "motionZ"(): double
get "motionX"(): double
get "passengers"(): $EntityArrayList
get "facing"(): $Direction
get "player"(): boolean
get "animal"(): boolean
set "position"(value: $LevelBlock$$Type)
set "motionZ"(value: double)
get "scriptType"(): $ScriptType
get "motionY"(): double
get "block"(): $LevelBlock
get "monster"(): boolean
get "name"(): $Component
get "displayName"(): $Component
get "persistentData"(): $CompoundTag
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
}

export class $ItemFrameEntityKJS implements $ItemFrameEntityKJS$$Interface {
 "getItem"(): $ItemStack
 "isFrame"(): boolean
 "self"(): $Entity
 "spawn"(): void
 "getNbt"(): $CompoundTag
 "attack"(hp: float): void
 "setZ"(z: double): void
 "setNbt"(nbt: $CompoundTag$$Type): void
 "setY"(y: double): void
 "setX"(x: double): void
 "isOnScoreboardTeam"(teamId: StringJS): boolean
 "isWaterCreature"(): boolean
 "isPeacefulCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "isAmbientCreature"(): boolean
 "rayTrace"(distance: double): $KubeRayTraceResult
 "rayTrace"(distance: double, fluids: boolean): $KubeRayTraceResult
 "isLiving"(): boolean
 "getLevel"(): $Level
 "rayTraceEntity"(distance: double, filter: $Predicate$$Type<($Entity)>): $Entity
 "getType"(): StringJS
 "setMotionX"(x: double): void
 "teleportTo"(dimension: $ResourceLocation$$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$$Type): void
 "getTeamId"(): StringJS
 "setMotionY"(y: double): void
 "getProfile"(): $GameProfile
 "getServer"(): $MinecraftServer
 "getMotionZ"(): double
 "getMotionX"(): double
 "getPassengers"(): $EntityArrayList
 "getFacing"(): $Direction
 "isPlayer"(): boolean
 "setRotation"(yaw: float, pitch: float): void
 "isAnimal"(): boolean
 "mergeNbt"(tag: $CompoundTag$$Type): $Entity
 "setPosition"(x: double, y: double, z: double): void
 "setPosition"(block: $LevelBlock$$Type): void
 "setMotionZ"(z: double): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$$Type): double
 "getDistanceSq"(pos: $BlockPos$$Type): double
 "getScriptType"(): $ScriptType
 "getMotionY"(): double
 "getBlock"(): $LevelBlock
 "isMonster"(): boolean
 "runCommandSilent"(command: StringJS): void
 "tell"(message: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(command: StringJS): void
 "getDisplayName"(): $Component
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$$Type): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFrameEntityKJS$$Type = ($ItemFrameEntityKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemFrameEntityKJS$$Original = $ItemFrameEntityKJS;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$FluidData$Group, $FluidData$Group$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Group"
import {$FluidData$Info, $FluidData$Info$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$Info"
import {$RegistryFriendlyByteBuf} from "net.minecraft.network.RegistryFriendlyByteBuf"
import {$List, $List$$Type} from "java.util.List"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$FluidIngredient, $FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$FluidData$DataComponentSubtypes, $FluidData$DataComponentSubtypes$$Type} from "dev.latvian.mods.kubejs.recipe.viewer.server.FluidData$DataComponentSubtypes"
import {$Record} from "java.lang.Record"

export class $FluidData extends $Record {
static readonly "STREAM_CODEC": $StreamCodec<($RegistryFriendlyByteBuf), ($FluidData)>

constructor(addedEntries: $List$$Type<($FluidStack$$Type)>, removedEntries: $List$$Type<($FluidIngredient$$Type)>, completelyRemovedEntries: $List$$Type<($FluidIngredient$$Type)>, groupedEntries: $List$$Type<($FluidData$Group$$Type)>, info: $List$$Type<($FluidData$Info$$Type)>, dataComponentSubtypes: $List$$Type<($FluidData$DataComponentSubtypes$$Type)>)

public "dataComponentSubtypes"(): $List<($FluidData$DataComponentSubtypes)>
public "completelyRemovedEntries"(): $List<($FluidIngredient)>
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "isEmpty"(): boolean
public static "collect"(): $FluidData
public "info"(): $List<($FluidData$Info)>
public "addedEntries"(): $List<($FluidStack)>
public "removedEntries"(): $List<($FluidIngredient)>
public "groupedEntries"(): $List<($FluidData$Group)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidData$$Type = ({"removedEntries"?: $List$$Type<($FluidIngredient$$Type)>, "groupedEntries"?: $List$$Type<($FluidData$Group$$Type)>, "completelyRemovedEntries"?: $List$$Type<($FluidIngredient$$Type)>, "info"?: $List$$Type<($FluidData$Info$$Type)>, "addedEntries"?: $List$$Type<($FluidStack$$Type)>, "dataComponentSubtypes"?: $List$$Type<($FluidData$DataComponentSubtypes$$Type)>}) | ([removedEntries?: $List$$Type<($FluidIngredient$$Type)>, groupedEntries?: $List$$Type<($FluidData$Group$$Type)>, completelyRemovedEntries?: $List$$Type<($FluidIngredient$$Type)>, info?: $List$$Type<($FluidData$Info$$Type)>, addedEntries?: $List$$Type<($FluidStack$$Type)>, dataComponentSubtypes?: $List$$Type<($FluidData$DataComponentSubtypes$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidData$$Original = $FluidData;}
declare module "dev.latvian.mods.kubejs.recipe.component.RecipeComponentCodecFactory" {
import {$RecipeTypeRegistryContext, $RecipeTypeRegistryContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeRegistryContext"
import {$RecipeComponentType, $RecipeComponentType$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponentType"
import {$RecipeComponent} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$MapCodec, $MapCodec$$Type} from "com.mojang.serialization.MapCodec"

export interface $RecipeComponentCodecFactory$$Interface<CT extends $RecipeComponent<(object)>> {

(type: $RecipeComponentType<(never)>, ctx: $RecipeTypeRegistryContext): $MapCodec$$Type<(CT)>
}

export class $RecipeComponentCodecFactory<CT extends $RecipeComponent<(object)>> implements $RecipeComponentCodecFactory$$Interface {
 "create"(type: $RecipeComponentType$$Type<(never)>, ctx: $RecipeTypeRegistryContext$$Type): $MapCodec<(CT)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentCodecFactory$$Type<CT> = ((type: $RecipeComponentType<(never)>, ctx: $RecipeTypeRegistryContext) => $MapCodec$$Type<(CT)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeComponentCodecFactory$$Original<CT> = $RecipeComponentCodecFactory<(CT)>;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.GroupEntriesKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $GroupEntriesKubeEvent$$Interface<E, F> extends $KubeEvent$$Interface {

(filter: F, groupId: $ResourceLocation, description: $Component): void
}

export class $GroupEntriesKubeEvent<E, F> implements $GroupEntriesKubeEvent$$Interface {
 "group"(filter: F, groupId: $ResourceLocation$$Type, description: $Component$$Type): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GroupEntriesKubeEvent$$Type<E, F> = ((filter: any, groupId: $ResourceLocation, description: $Component) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $GroupEntriesKubeEvent$$Original<E, F> = $GroupEntriesKubeEvent<(E), (F)>;}
declare module "dev.latvian.mods.kubejs.util.RotationAxis" {
import {$Enum} from "java.lang.Enum"
import {$Vector3f} from "org.joml.Vector3f"
import {$Quaternionf} from "org.joml.Quaternionf"

export class $RotationAxis extends $Enum<($RotationAxis)> {
static readonly "ZN": $RotationAxis
static readonly "YN": $RotationAxis
readonly "vec": $Vector3f
static readonly "XN": $RotationAxis
static readonly "ZP": $RotationAxis
static readonly "YP": $RotationAxis
static readonly "XP": $RotationAxis

public static "values"(): ($RotationAxis)[]
public static "valueOf"(name: StringJS): $RotationAxis
public "deg"(f: float): $Quaternionf
public "rad"(f: float): $Quaternionf
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotationAxis$$Type = (("xn") | ("xp") | ("yn") | ("yp") | ("zn") | ("zp"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RotationAxis$$Original = $RotationAxis;}
declare module "dev.latvian.mods.kubejs.core.WindowKJS" {
import {$List, $List$$Type} from "java.util.List"
import {$IoSupplier, $IoSupplier$$Type} from "net.minecraft.server.packs.resources.IoSupplier"
import {$InputStream, $InputStream$$Type} from "java.io.InputStream"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $WindowKJS$$Interface {
}

export class $WindowKJS implements $WindowKJS$$Interface {
 "kjs$loadIcons"(original: $List$$Type<($IoSupplier$$Type<($InputStream$$Type)>)>): $List<($IoSupplier<($InputStream)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WindowKJS$$Type = ($WindowKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WindowKJS$$Original = $WindowKJS;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.DirectionWrapper" {
import {$Map} from "java.util.Map"
import {$Direction} from "net.minecraft.core.Direction"
import {$EnumSet} from "java.util.EnumSet"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $DirectionWrapper$$Interface {
}

export class $DirectionWrapper implements $DirectionWrapper$$Interface {
static readonly "ALL": $Map<(StringJS), ($Direction)>
static readonly "DOWN": $Direction
static readonly "ALL_SET": $EnumSet<($Direction)>
static readonly "south": $Direction
static readonly "north": $Direction
static readonly "WEST": $Direction
static readonly "down": $Direction
static readonly "east": $Direction
static readonly "NORTH": $Direction
static readonly "west": $Direction
static readonly "EMPTY_SET": $EnumSet<($Direction)>
static readonly "VALUES": ($Direction)[]
static readonly "up": $Direction
static readonly "UP": $Direction
static readonly "SOUTH": $Direction
static readonly "NONE": ($Direction)[]
static readonly "EAST": $Direction

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectionWrapper$$Type = ($DirectionWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DirectionWrapper$$Original = $DirectionWrapper;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.EntitySelectorWrapper" {
import {$EntitySelector, $EntitySelector$$Type} from "net.minecraft.commands.arguments.selector.EntitySelector"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $EntitySelectorWrapper {
constructor()

public static "of"(selector: $EntitySelector$$Type): $EntitySelector
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySelectorWrapper$$Type = ($EntitySelectorWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntitySelectorWrapper$$Original = $EntitySelectorWrapper;}
declare module "dev.latvian.mods.kubejs.block.custom.SlabBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $SlabBlockBuilder extends $ShapedBlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>
static readonly "SLAB_TAGS": ($ResourceLocation)[]

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlabBlockBuilder$$Type = ($SlabBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SlabBlockBuilder$$Original = $SlabBlockBuilder;}
declare module "dev.latvian.mods.kubejs.item.ItemBuilder$NameCallback" {
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $ItemBuilder$NameCallback$$Interface {

(itemStack: $ItemStack): $Component$$Type
}

export class $ItemBuilder$NameCallback implements $ItemBuilder$NameCallback$$Interface {
 "apply"(itemStack: $ItemStack$$Type): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$NameCallback$$Type = ((itemStack: $ItemStack) => $Component$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemBuilder$NameCallback$$Original = $ItemBuilder$NameCallback;}
declare module "dev.latvian.mods.kubejs.item.creativetab.CreativeTabCallback" {
import {$ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$ItemPredicate$$Type} from "dev.latvian.mods.kubejs.item.ItemPredicate"
import {$CreativeModeTab$TabVisibility$$Type} from "net.minecraft.world.item.CreativeModeTab$TabVisibility"

export interface $CreativeTabCallback$$Interface {
}

export class $CreativeTabCallback implements $CreativeTabCallback$$Interface {
 "remove"(filter: $ItemPredicate$$Type, removeParent: boolean, removeSearch: boolean): void
 "addAfter"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[], visibility: $CreativeModeTab$TabVisibility$$Type): void
 "addBefore"(order: $ItemStack$$Type, items: ($ItemStack$$Type)[], visibility: $CreativeModeTab$TabVisibility$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabCallback$$Type = ($CreativeTabCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CreativeTabCallback$$Original = $CreativeTabCallback;}
declare module "dev.latvian.mods.kubejs.block.callback.BlockStateMirrorCallback" {
import {$Mirror, $Mirror$$Type} from "net.minecraft.world.level.block.Mirror"
import {$Rotation} from "net.minecraft.world.level.block.Rotation"
import {$Direction, $Direction$$Type} from "net.minecraft.core.Direction"
import {$BlockStateModifyCallback} from "dev.latvian.mods.kubejs.block.callback.BlockStateModifyCallback"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"

export class $BlockStateMirrorCallback extends $BlockStateModifyCallback {
constructor(state: $BlockState$$Type, mirror: $Mirror$$Type)

/**
 * Gets the Mirror
 */
public "getMirror"(): $Mirror
/**
 * Mirrors the direction passed in
 */
public "mirror"(dir: $Direction$$Type): $Direction
/**
 * Gets the rotation of the direction passed in relative to this mirror
 */
public "getRotation"(dir: $Direction$$Type): $Rotation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateMirrorCallback$$Type = ($BlockStateMirrorCallback);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockStateMirrorCallback$$Original = $BlockStateMirrorCallback;}
declare module "dev.latvian.mods.kubejs.core.EntityGetterKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$EntityCollectionKJS$$Interface} from "dev.latvian.mods.kubejs.core.EntityCollectionKJS"
import {$UUID$$Type} from "java.util.UUID"
import {$List} from "java.util.List"
import {$EntityGetter} from "net.minecraft.world.level.EntityGetter"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$EntityArrayList} from "dev.latvian.mods.kubejs.player.EntityArrayList"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $EntityGetterKJS$$Interface extends $EntityCollectionKJS$$Interface {
get "players"(): $EntityArrayList
get "mcEntities"(): $Iterable<($Entity)>
get "mcPlayers"(): $List<($Player)>
get "entities"(): $EntityArrayList
}

export class $EntityGetterKJS implements $EntityGetterKJS$$Interface {
 "self"(): $EntityGetter
 "getPlayers"(): $EntityArrayList
 "getMcEntities"(): $Iterable<($Entity)>
 "getMcPlayers"(): $List<($Player)>
 "getEntitiesWithin"(aabb: $AABB$$Type): $EntityArrayList
 "getEntities"(): $EntityArrayList
 "getEntityByUUID"(id: $UUID$$Type): $Entity
 "getEntityByNetworkID"(id: integer): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityGetterKJS$$Type = ($EntityGetterKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityGetterKJS$$Original = $EntityGetterKJS;}
declare module "dev.latvian.mods.kubejs.core.WithAttachedData" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$AttachedData, $AttachedData$$Type} from "dev.latvian.mods.kubejs.util.AttachedData"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$MessageSenderKJS$$Interface} from "dev.latvian.mods.kubejs.core.MessageSenderKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $WithAttachedData$$Interface<T> extends $MessageSenderKJS$$Interface {

(): $AttachedData$$Type<(T)>
get "data"(): $AttachedData<(T)>
set "statusMessage"(value: $Component$$Type)
set "activePostShader"(value: $ResourceLocation$$Type)
get "name"(): $Component
get "displayName"(): $Component
}

export class $WithAttachedData<T> implements $WithAttachedData$$Interface {
 "getData"(): $AttachedData<(T)>
 "setStatusMessage"(message: $Component$$Type): void
 "runCommandSilent"(command: StringJS): void
 "setActivePostShader"(id: $ResourceLocation$$Type): void
 "tell"(message: $Component$$Type): void
 "getName"(): $Component
 "runCommand"(command: StringJS): void
 "getDisplayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithAttachedData$$Type<T> = (() => $AttachedData$$Type<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WithAttachedData$$Original<T> = $WithAttachedData<(T)>;}
declare module "dev.latvian.mods.kubejs.item.custom.ItemToolTierRegistryKubeEvent" {
import {$MutableToolTier$$Type} from "dev.latvian.mods.kubejs.item.MutableToolTier"
import {$Map, $Map$$Type} from "java.util.Map"
import {$KubeStartupEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeStartupEvent"
import {$Tier, $Tier$$Type} from "net.minecraft.world.item.Tier"
import {$Record} from "java.lang.Record"
import {$Consumer$$Type} from "java.util.function.Consumer"

/**
 * Invoked when the game is starting up and the item tool tiers are being registered.
 */
export class $ItemToolTierRegistryKubeEvent extends $Record implements $KubeStartupEvent$$Interface {
constructor(tiers: $Map$$Type<(StringJS), ($Tier$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
/**
 * Adds a new tool tier.
 */
public "add"(id: StringJS, tier: $Consumer$$Type<($MutableToolTier)>): void
public "tiers"(): $Map<(StringJS), ($Tier)>
public "addExisting"(id: StringJS, tier: $Tier$$Type): void
public "addBasedOnExisting"(id: StringJS, existing: StringJS, tier: $Consumer$$Type<($MutableToolTier)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemToolTierRegistryKubeEvent$$Type = ({"tiers"?: $Map$$Type<(StringJS), ($Tier$$Type)>}) | ([tiers?: $Map$$Type<(StringJS), ($Tier$$Type)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemToolTierRegistryKubeEvent$$Original = $ItemToolTierRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.script.ScriptsLoadedEvent" {
import {$Event} from "net.neoforged.bus.api.Event"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptsLoadedEvent extends $Event {
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptsLoadedEvent$$Type = ($ScriptsLoadedEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptsLoadedEvent$$Original = $ScriptsLoadedEvent;}
declare module "dev.latvian.mods.kubejs.core.FluidStackKJS" {
import {$Potion$$Type} from "net.minecraft.world.item.alchemy.Potion"
import {$DataComponentMap, $DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$ReplacementMatch} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$ComponentFunctions} from "dev.latvian.mods.kubejs.component.ComponentFunctions"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$MutableDataComponentHolder} from "net.neoforged.neoforge.common.MutableDataComponentHolder"
import {$UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$FluidMatch$$Interface} from "dev.latvian.mods.kubejs.recipe.match.FluidMatch"
import {$RelativeURL} from "dev.latvian.mods.kubejs.web.RelativeURL"
import {$FluidStack, $FluidStack$$Type} from "net.neoforged.neoforge.fluids.FluidStack"
import {$DataComponentType$$Type} from "net.minecraft.core.component.DataComponentType"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"
import {$FluidIngredient$$Type} from "net.neoforged.neoforge.fluids.crafting.FluidIngredient"
import {$Replaceable$$Interface} from "dev.latvian.mods.kubejs.recipe.match.Replaceable"
import {$Holder, $Holder$$Type} from "net.minecraft.core.Holder"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Codec} from "com.mojang.serialization.Codec"
import {$DyeColor$$Type} from "net.minecraft.world.item.DyeColor"
import {$SpecialEquality$$Interface} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$MutableDataComponentHolderFunctions, $MutableDataComponentHolderFunctions$$Interface} from "dev.latvian.mods.kubejs.component.MutableDataComponentHolderFunctions"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$RegistryObjectKJS$$Interface} from "dev.latvian.mods.kubejs.core.RegistryObjectKJS"
import {$PotionContents$$Type} from "net.minecraft.world.item.alchemy.PotionContents"
import {$FluidLike, $FluidLike$$Interface} from "dev.latvian.mods.kubejs.fluid.FluidLike"
import {$CompoundTag, $CompoundTag$$Type} from "net.minecraft.nbt.CompoundTag"
import {$Map$$Type} from "java.util.Map"
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"
import {$WithCodec$$Interface} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$RecipeMatchContext$$Type} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$Rarity$$Type} from "net.minecraft.world.item.Rarity"
import {$LootTable$$Type} from "net.minecraft.world.level.storage.loot.LootTable"
import {$DataComponentPatch$$Type} from "net.minecraft.core.component.DataComponentPatch"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$Registry} from "net.minecraft.core.Registry"
import {$TagKey} from "net.minecraft.tags.TagKey"
import {$Tag, $Tag$$Type} from "net.minecraft.nbt.Tag"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$GameProfile$$Type} from "com.mojang.authlib.GameProfile"
import {$Unit$$Type} from "net.minecraft.util.Unit"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $FluidStackKJS$$Interface extends $Replaceable$$Interface, $SpecialEquality$$Interface, $WithCodec$$Interface, $FluidLike$$Interface, $FluidMatch$$Interface, $MutableDataComponentHolderFunctions$$Interface, $RegistryObjectKJS$$Interface<($Fluid)> {
get "id"(): StringJS
get "amount"(): integer
get "fluid"(): $Fluid
get "mod"(): StringJS
get "idLocation"(): $ResourceLocation
get "registryId"(): $ResourceKey<($Registry<($Fluid)>)>
get "registry"(): $Registry<($Fluid)>
get "key"(): $ResourceKey<($Fluid)>
get "codec"(): $Codec<(never)>
get "empty"(): boolean
get "componentMap"(): $DataComponentMap
get "componentHolder"(): $MutableDataComponentHolder
get "tagKeys"(): $List<($TagKey<($Fluid)>)>
get "tags"(): $List<($ResourceLocation)>
get "additionalTooltipHidden"(): void
set "dyedColorWithTooltip"(value: $KubeColor$$Type)
set "blockStateProperties"(value: $Map$$Type<(StringJS), (StringJS)>)
get "componentString"(): StringJS
set "customModelData"(value: integer)
set "containerLootTable"(value: $ResourceKey$$Type<($LootTable)>)
get "tooltipHidden"(): void
set "potionContents"(value: $PotionContents$$Type)
set "glintOverride"(value: boolean)
set "dyedColor"(value: $KubeColor$$Type)
set "customData"(value: $CompoundTag$$Type)
set "profile"(value: $GameProfile$$Type)
set "unit"(value: $DataComponentType$$Type<($Unit$$Type)>)
set "potionId"(value: $Holder$$Type<($Potion)>)
get "customData"(): $CompoundTag
set "lockCode"(value: StringJS)
get "customName"(): $Component
set "lore"(value: $List$$Type<($Component$$Type)>)
set "entityData"(value: $CompoundTag$$Type)
set "rarity"(value: $Rarity$$Type)
set "baseColor"(value: $DyeColor$$Type)
set "customName"(value: $Component$$Type)
}

export class $FluidStackKJS implements $FluidStackKJS$$Interface {
 "getId"(): StringJS
 "matches"(cx: $RecipeMatchContext$$Type, s: $FluidStack$$Type, exact: boolean): boolean
 "matches"(cx: $RecipeMatchContext$$Type, ingredient: $FluidIngredient$$Type, exact: boolean): boolean
 "copy"(amount: integer): $FluidLike
 "getAmount"(): integer
 "getFluid"(): $Fluid
 "kjs$getWebIconURL"(ops: $DynamicOps$$Type<($Tag$$Type)>, size: integer): $RelativeURL
 "getMod"(): StringJS
 "kjs$equalsIgnoringCount"(stack: $FluidStack$$Type): boolean
 "getIdLocation"(): $ResourceLocation
 "getRegistryId"(): $ResourceKey<($Registry<($Fluid)>)>
 "getRegistry"(): $Registry<($Fluid)>
 "asHolder"(): $Holder<($Fluid)>
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
 "getKey"(): $ResourceKey<($Fluid)>
 "kjs$self"(): $FluidStack
 "getCodec"(): $Codec<(never)>
 "specialEquals"(o: any, shallow: boolean): boolean
 "isEmpty"(): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
 "getComponentMap"(): $DataComponentMap
 "patch"(components: $DataComponentPatch$$Type): $ComponentFunctions
 "set"(components: $DataComponentMap$$Type): $MutableDataComponentHolderFunctions
 "getComponentHolder"(): $MutableDataComponentHolder
 "hasTag"(tag: $ResourceLocation$$Type): boolean
 "getTagKeys"(): $List<($TagKey<($Fluid)>)>
 "getTags"(): $List<($ResourceLocation)>
static "wrap"(o: any): $ReplacementMatch
 "setAdditionalTooltipHidden"(): void
 "setDyedColorWithTooltip"(color: $KubeColor$$Type): void
 "setBlockStateProperties"(properties: $Map$$Type<(StringJS), (StringJS)>): void
 "resetComponents"(): $ComponentFunctions
 "getComponentString"(): StringJS
 "setCustomModelData"(data: integer): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>, seed: long): void
 "setContainerLootTable"(lootTable: $ResourceKey$$Type<($LootTable)>): void
 "setTooltipHidden"(): void
 "setPotionContents"(contents: $PotionContents$$Type): void
 "setGlintOverride"(override: boolean): void
 "get"<T>(type: $DataComponentType$$Type<(T)>): T
 "remove"(type: $DataComponentType$$Type<(never)>): $ComponentFunctions
 "set"(component: $DataComponentType$$Type<(never)>, value: any): $ComponentFunctions
 "setDyedColor"(color: $KubeColor$$Type): void
 "setCustomData"(tag: $CompoundTag$$Type): void
 "setProfile"(profile: $GameProfile$$Type): void
 "setProfile"(name: StringJS, uuid: $UUID$$Type): void
 "setUnit"(component: $DataComponentType$$Type<($Unit$$Type)>): $ComponentFunctions
 "setPotionId"(potion: $Holder$$Type<($Potion)>): void
 "getCustomData"(): $CompoundTag
 "setLockCode"(lock: StringJS): void
 "getCustomName"(): $Component
 "setLore"(lines: $List$$Type<($Component$$Type)>, styledLines: $List$$Type<($Component$$Type)>): void
 "setLore"(lines: $List$$Type<($Component$$Type)>): void
 "setEntityData"(tag: $CompoundTag$$Type): void
 "setRarity"(rarity: $Rarity$$Type): void
 "setBaseColor"(color: $DyeColor$$Type): void
 "setCustomName"(name: $Component$$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidStackKJS$$Type = ($FluidStackKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FluidStackKJS$$Original = $FluidStackKJS;}
declare module "dev.latvian.mods.kubejs.core.mixin.RecipeInputMixin" {
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$RecipeInput} from "net.minecraft.world.item.crafting.RecipeInput"
import {$List} from "java.util.List"
import {$SlotFilter$$Type} from "dev.latvian.mods.kubejs.util.SlotFilter"
import {$RecipeInputKJS$$Interface} from "dev.latvian.mods.kubejs.core.RecipeInputKJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $RecipeInputMixin$$Interface extends $RecipeInputKJS$$Interface {
}

export class $RecipeInputMixin implements $RecipeInputMixin$$Interface {
 "find"(filter: $SlotFilter$$Type): $ItemStack
 "find"(filter: $SlotFilter$$Type, skip: integer): $ItemStack
 "self"(): $RecipeInput
 "findAll"(filter: $SlotFilter$$Type): $List<($ItemStack)>
 "findAll"(): $List<($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeInputMixin$$Type = ($RecipeInputMixin);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeInputMixin$$Original = $RecipeInputMixin;}
declare module "dev.latvian.mods.kubejs.registry.AdditionalObjectRegistry" {
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"

export interface $AdditionalObjectRegistry$$Interface {

(registry: $ResourceKey<($Registry<(T)>)>, builder: $BuilderBase<(T)>): void
}

export class $AdditionalObjectRegistry implements $AdditionalObjectRegistry$$Interface {
 "add"<T>(registry: $ResourceKey$$Type<($Registry<(T)>)>, builder: $BuilderBase$$Type<(T)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdditionalObjectRegistry$$Type = ((registry: $ResourceKey<($Registry<(T)>)>, builder: $BuilderBase<(T)>) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AdditionalObjectRegistry$$Original = $AdditionalObjectRegistry;}
declare module "dev.latvian.mods.kubejs.recipe.special.SpecialRecipeSerializerManager$AfterPost" {
import {$Event} from "net.neoforged.bus.api.Event"

export class $SpecialRecipeSerializerManager$AfterPost extends $Event {
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpecialRecipeSerializerManager$AfterPost$$Type = ($SpecialRecipeSerializerManager$AfterPost);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SpecialRecipeSerializerManager$AfterPost$$Original = $SpecialRecipeSerializerManager$AfterPost;}
declare module "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundGen" {
import {$SoundsGenerator$SoundInstance$$Type} from "dev.latvian.mods.kubejs.client.SoundsGenerator$SoundInstance"
import {$JsonObject} from "com.google.gson.JsonObject"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $SoundsGenerator$SoundGen {
constructor()

public "sound"(file: StringJS): $SoundsGenerator$SoundGen
public "sound"(file: StringJS, consumer: $Consumer$$Type<($SoundsGenerator$SoundInstance)>): $SoundsGenerator$SoundGen
public "replace"(b: boolean): $SoundsGenerator$SoundGen
public "replace"(): $SoundsGenerator$SoundGen
public "toJson"(): $JsonObject
public "subtitle"(subtitle: StringJS): $SoundsGenerator$SoundGen
public "sounds"(...sounds: (StringJS)[]): $SoundsGenerator$SoundGen
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundsGenerator$SoundGen$$Type = ($SoundsGenerator$SoundGen);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SoundsGenerator$SoundGen$$Original = $SoundsGenerator$SoundGen;}
declare module "dev.latvian.mods.kubejs.recipe.match.ReplacementMatchInfo" {
import {$TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ReplacementMatch, $ReplacementMatch$$Type} from "dev.latvian.mods.kubejs.recipe.match.ReplacementMatch"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$RecipeComponent, $RecipeComponent$$Type} from "dev.latvian.mods.kubejs.recipe.component.RecipeComponent"
import {$RecordTypeInfo} from "dev.latvian.mods.rhino.type.RecordTypeInfo"
import {$Record} from "java.lang.Record"

export class $ReplacementMatchInfo extends $Record {
static readonly "TYPE_INFO": $RecordTypeInfo
static readonly "NONE": $ReplacementMatchInfo

constructor(match: $ReplacementMatch$$Type, exact: boolean, componentType: ($RecipeComponent$$Type<(never)>)?)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "componentType"(): $Optional<($RecipeComponent<(never)>)>
public static "wrap"(o: any, target: $TypeInfo$$Type): $ReplacementMatchInfo
public "match"(): $ReplacementMatch
public "exact"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplacementMatchInfo$$Type = ({"componentType"?: ($RecipeComponent$$Type<(never)>)?, "exact"?: boolean, "match"?: $ReplacementMatch$$Type}) | ([componentType?: ($RecipeComponent$$Type<(never)>)?, exact?: boolean, match?: $ReplacementMatch$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ReplacementMatchInfo$$Original = $ReplacementMatchInfo;}
declare module "dev.latvian.mods.kubejs.recipe.RecipeLikeContext" {
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$RecipeLikeKJS} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RecipeLikeContext$$Interface {
}

export class $RecipeLikeContext implements $RecipeLikeContext$$Interface {
 "registries"(): $RegistryAccessContainer
 "ops"(): $RegistryOpsContainer
 "recipe"(): $RecipeLikeKJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeLikeContext$$Type = ($RecipeLikeContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeLikeContext$$Original = $RecipeLikeContext;}
declare module "dev.latvian.mods.kubejs.level.WrappedSpawner" {
import {$LevelBlock, $LevelBlock$$Type} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Either$$Type} from "com.mojang.datafixers.util.Either"
import {$Entity, $Entity$$Type} from "net.minecraft.world.entity.Entity"
import {$BlockEntity$$Type} from "net.minecraft.world.level.block.entity.BlockEntity"
import {$Record} from "java.lang.Record"

export class $WrappedSpawner extends $Record {
constructor(entity: $Entity$$Type, block: $LevelBlock$$Type)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "of"(spawner: $Either$$Type<($BlockEntity$$Type), ($Entity$$Type)>): $WrappedSpawner
public "block"(): $LevelBlock
public "entity"(): $Entity
public "isWorldgen"(): boolean
get "worldgen"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedSpawner$$Type = ({"block"?: $LevelBlock$$Type, "entity"?: $Entity$$Type}) | ([block?: $LevelBlock$$Type, entity?: $Entity$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WrappedSpawner$$Original = $WrappedSpawner;}
declare module "dev.latvian.mods.kubejs.util.ClassWrapper" {
import {$CustomJavaToJsWrapper$$Interface} from "dev.latvian.mods.rhino.util.CustomJavaToJsWrapper"
import {$TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$Class, $Class$$Type} from "java.lang.Class"
import {$Scriptable, $Scriptable$$Type} from "dev.latvian.mods.rhino.Scriptable"
import {$Record} from "java.lang.Record"

export class $ClassWrapper<T> extends $Record implements $CustomJavaToJsWrapper$$Interface {
constructor(wrappedClass: $Class$$Type<(T)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "wrappedClass"(): $Class<(T)>
public "convertJavaToJs"(scope: $Scriptable$$Type, staticType: $TypeInfo$$Type): $Scriptable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassWrapper$$Type<T> = ({"wrappedClass"?: $Class$$Type<(T)>}) | ([wrappedClass?: $Class$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ClassWrapper$$Original<T> = $ClassWrapper<(T)>;}
declare module "dev.latvian.mods.kubejs.entity.BeforeLivingEntityHurtKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$DamageSource} from "net.minecraft.world.damagesource.DamageSource"
import {$LivingDamageEvent$Pre$$Type} from "net.neoforged.neoforge.event.entity.living.LivingDamageEvent$Pre"
import {$Level} from "net.minecraft.world.level.Level"
import {$KubeLivingEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeLivingEntityEvent"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked before an entity is hurt by a damage source.
 */
export class $BeforeLivingEntityHurtKubeEvent implements $KubeLivingEntityEvent$$Interface {
constructor(event: $LivingDamageEvent$Pre$$Type)

/**
 * The amount of damage.
 */
public "getDamage"(): float
/**
 * The damage source.
 */
public "getSource"(): $DamageSource
public "setDamage"(damage: float): void
/**
 * The entity that was hurt.
 */
public "getEntity"(): $LivingEntity
public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "damage"(): float
get "source"(): $DamageSource
set "damage"(value: float)
get "entity"(): $LivingEntity
get "level"(): $Level
get "player"(): $Player
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeforeLivingEntityHurtKubeEvent$$Type = ($BeforeLivingEntityHurtKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BeforeLivingEntityHurtKubeEvent$$Original = $BeforeLivingEntityHurtKubeEvent;}
declare module "dev.latvian.mods.kubejs.server.tag.PreTagKubeEvent" {
import {$EventExceptionHandler} from "dev.latvian.mods.kubejs.event.EventExceptionHandler"
import {$ResourceLocation} from "net.minecraft.resources.ResourceLocation"
import {$Map, $Map$$Type} from "java.util.Map"
import {$PreTagWrapper} from "dev.latvian.mods.kubejs.server.tag.PreTagWrapper"
import {$Registry} from "net.minecraft.core.Registry"
import {$List} from "java.util.List"
import {$Set} from "java.util.Set"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$TagKubeEvent} from "dev.latvian.mods.kubejs.server.tag.TagKubeEvent"
import {$Consumer} from "java.util.function.Consumer"

export class $PreTagKubeEvent extends $TagKubeEvent {
readonly "registryKey": $ResourceKey<(never)>
 "totalRemoved": integer
 "invalid": boolean
static readonly "SOURCE": StringJS
readonly "vanillaRegistry": $Registry<(never)>
 "totalAdded": integer
static readonly "TAG_EVENT_HANDLER": $EventExceptionHandler
readonly "actions": $List<($Consumer<($TagKubeEvent)>)>
readonly "tags": $Map<($ResourceLocation), ($PreTagWrapper)>

constructor(registryKey: $ResourceKey$$Type<(never)>)

public static "handle"(tagEventHolders: $Map$$Type<($ResourceKey$$Type<(never)>), ($PreTagKubeEvent$$Type)>): void
public "getElementIds"(): $Set<($ResourceLocation)>
public "removeAllTagsFrom"(...ignored: (any)[]): void
get "elementIds"(): $Set<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PreTagKubeEvent$$Type = ($PreTagKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $PreTagKubeEvent$$Original = $PreTagKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.match.Replaceable" {
import {$RecipeScriptContext$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeScriptContext"

export interface $Replaceable$$Interface {
}

export class $Replaceable implements $Replaceable$$Interface {
 "replaceThisWith"(cx: $RecipeScriptContext$$Type, arg1: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Replaceable$$Type = ($Replaceable);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $Replaceable$$Original = $Replaceable;}
declare module "dev.latvian.mods.kubejs.block.custom.WallBlockBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$ShapedBlockBuilder} from "dev.latvian.mods.kubejs.block.custom.ShapedBlockBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$Consumer} from "java.util.function.Consumer"

export class $WallBlockBuilder extends $ShapedBlockBuilder {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "WALL_TAGS": ($ResourceLocation)[]
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WallBlockBuilder$$Type = ($WallBlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $WallBlockBuilder$$Original = $WallBlockBuilder;}
declare module "dev.latvian.mods.kubejs.player.SimplePlayerKubeEvent" {
import {$Player, $Player$$Type} from "net.minecraft.world.entity.player.Player"
import {$KubePlayerEvent$$Interface} from "dev.latvian.mods.kubejs.player.KubePlayerEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $SimplePlayerKubeEvent implements $KubePlayerEvent$$Interface {
constructor(p: $Player$$Type)

public "getEntity"(): $Entity
public "getPlayer"(): $Player
public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "entity"(): $Entity
get "player"(): $Player
get "level"(): $Level
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimplePlayerKubeEvent$$Type = ($SimplePlayerKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SimplePlayerKubeEvent$$Original = $SimplePlayerKubeEvent;}
declare module "dev.latvian.mods.kubejs.registry.ServerRegistryKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$DynamicOps, $DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$Codec, $Codec$$Type} from "com.mojang.serialization.Codec"
import {$Supplier$$Type} from "java.util.function.Supplier"
import {$JsonElement, $JsonElement$$Type} from "com.google.gson.JsonElement"
import {$List$$Type} from "java.util.List"
import {$CustomBuilderObject} from "dev.latvian.mods.kubejs.registry.CustomBuilderObject"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$BuilderBase, $BuilderBase$$Type} from "dev.latvian.mods.kubejs.registry.BuilderBase"

export class $ServerRegistryKubeEvent<T> implements $KubeEvent$$Interface {
readonly "registryKey": $ResourceKey<($Registry<(T)>)>
readonly "codec": $Codec<(T)>
readonly "jsonOps": $DynamicOps<($JsonElement)>

constructor(registryKey: $ResourceKey$$Type<($Registry<(T)>)>, jsonOps: $DynamicOps$$Type<($JsonElement$$Type)>, codec: $Codec$$Type<(T)>, builders: $List$$Type<($BuilderBase$$Type<(never)>)>)

public "create"(id: $ResourceLocation$$Type): $BuilderBase<(T)>
public "create"(id: $ResourceLocation$$Type, type: $ResourceLocation$$Type): $BuilderBase<(T)>
public "createFromJson"(id: $ResourceLocation$$Type, json: $JsonElement$$Type): $CustomBuilderObject
public "createCustom"(id: $ResourceLocation$$Type, object: $Supplier$$Type<(any)>): $CustomBuilderObject
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerRegistryKubeEvent$$Type<T> = ($ServerRegistryKubeEvent<(T)>);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ServerRegistryKubeEvent$$Original<T> = $ServerRegistryKubeEvent<(T)>;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.ItemWrapper" {
import {$DataComponentMap$$Type} from "net.minecraft.core.component.DataComponentMap"
import {$Collection} from "java.util.Collection"
import {$Map} from "java.util.Map"
import {$DynamicOps$$Type} from "com.mojang.serialization.DynamicOps"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$UUID$$Type} from "java.util.UUID"
import {$StringReader$$Type} from "com.mojang.brigadier.StringReader"
import {$JsonElement$$Type} from "com.google.gson.JsonElement"
import {$DataResult} from "com.mojang.serialization.DataResult"
import {$List} from "java.util.List"
import {$ItemAbility} from "net.neoforged.neoforge.common.ItemAbility"
import {$Fireworks, $Fireworks$$Type} from "net.minecraft.world.item.component.Fireworks"
import {$TypeInfo} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Item, $Item$$Type} from "net.minecraft.world.item.Item"
import {$Tag$$Type} from "net.minecraft.nbt.Tag"

/**
 * Various item related helper methods
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ItemWrapper$$Interface {
get "typeToStackMap"(): $Map<($ResourceLocation), ($Collection<($ItemStack)>)>
get "typeList"(): $List<(StringJS)>
get "empty"(): $ItemStack
get "list"(): $List<($ItemStack)>
}

export class $ItemWrapper implements $ItemWrapper$$Interface {
static readonly "ITEM_TYPE_INFO": $TypeInfo
static readonly "EMPTY_ARRAY": ($ItemStack)[]
static readonly "TYPE_INFO": $TypeInfo

/**
 * Returns an ItemStack of the input
 */
static "of"(arg0: $ItemStack$$Type): $ItemStack
/**
 * Returns an ItemStack of the input, with the specified count
 */
static "of"(arg0: $ItemStack$$Type, count: integer): $ItemStack
/**
 * Returns an ItemStack of the input, with the specified count and data components
 */
static "of"(arg0: $ItemStack$$Type, count: integer, components: $DataComponentMap$$Type): $ItemStack
/**
 * Returns an ItemStack of the input, with the specified data components
 */
static "of"(arg0: $ItemStack$$Type, components: $DataComponentMap$$Type): $ItemStack
static "read"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, reader: $StringReader$$Type): $DataResult<($ItemStack)>
/**
 * Gets an items id from the Item
 */
static "getId"(item: $Item$$Type): $ResourceLocation
/**
 * Checks if the provided item id exists in the registry
 */
static "exists"(id: $ResourceLocation$$Type): boolean
static "getVariants"(item: $ItemStack$$Type): $Collection<($ItemStack)>
/**
 * Gets an Item from an item id
 */
static "getItem"(id: $ResourceLocation$$Type): $Item
static "parseString"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, s: StringJS): $DataResult<($ItemStack)>
static "findItem"(s: StringJS): $DataResult<($Item)>
static "playerHead"(name: StringJS): $ItemStack
/**
 * Returns a Firework with the input properties
 */
static "fireworks"(fireworks: $Fireworks$$Type): $Fireworks
static "parseJson"(registryOps: $DynamicOps$$Type<($Tag$$Type)>, json: $JsonElement$$Type): $DataResult<($ItemStack)>
static "getTypeToStackMap"(): $Map<($ResourceLocation), ($Collection<($ItemStack)>)>
static "playerHeadFromUrl"(url: StringJS): $ItemStack
static "isItemStackLike"(from: any): boolean
/**
 * Get a list of all the item ids in the game
 */
static "getTypeList"(): $List<(StringJS)>
/**
 * Get the item that represents air/an empty slot
 */
static "getEmpty"(): $ItemStack
static "wrapItemAbility"(object: any): $ItemAbility
/**
 * Checks if the passed in object is an ItemStack.
 * Note that this does not mean it will not function as an ItemStack if passed to something that requests one.
 */
static "isItem"(o: any): boolean
/**
 * Get a list of most items in the game. Items not in a creative tab are ignored
 */
static "getList"(): $List<($ItemStack)>
static "playerHeadFromBase64"(uuid: $UUID$$Type, textureBase64: StringJS): $ItemStack
static "playerHeadFromSkinHash"(hash: StringJS): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemWrapper$$Type = ($ItemWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemWrapper$$Original = $ItemWrapper;}
declare module "dev.latvian.mods.kubejs.recipe.viewer.AddInformationKubeEvent" {
import {$KubeEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeEvent"
import {$List, $List$$Type} from "java.util.List"
import {$Component, $Component$$Type} from "net.minecraft.network.chat.Component"

export interface $AddInformationKubeEvent$$Interface<E, F> extends $KubeEvent$$Interface {

(filter: F, info: $List<($Component)>): void
}

export class $AddInformationKubeEvent<E, F> implements $AddInformationKubeEvent$$Interface {
 "add"(filter: F, info: $List$$Type<($Component$$Type)>): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
 "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
 "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
 "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddInformationKubeEvent$$Type<E, F> = ((filter: any, info: $List<($Component)>) => void);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AddInformationKubeEvent$$Original<E, F> = $AddInformationKubeEvent<(E), (F)>;}
declare module "dev.latvian.mods.kubejs.block.BlockBuilder" {
import {$BlockRenderType$$Type} from "dev.latvian.mods.kubejs.block.BlockRenderType"
import {$BlockRightClickedKubeEvent$$Type} from "dev.latvian.mods.kubejs.block.BlockRightClickedKubeEvent"
import {$MapColor$$Type} from "net.minecraft.world.level.material.MapColor"
import {$AfterEntityFallenOnBlockCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.AfterEntityFallenOnBlockCallback"
import {$List$$Type} from "java.util.List"
import {$Component$$Type} from "net.minecraft.network.chat.Component"
import {$BlockBehaviour$Properties} from "net.minecraft.world.level.block.state.BlockBehaviour$Properties"
import {$NoteBlockInstrument$$Type} from "net.minecraft.world.level.block.state.properties.NoteBlockInstrument"
import {$BlockDropSupplier$$Type} from "dev.latvian.mods.kubejs.block.drop.BlockDropSupplier"
import {$KubeDataGenerator$$Type} from "dev.latvian.mods.kubejs.generator.KubeDataGenerator"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$EntitySteppedOnBlockCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.EntitySteppedOnBlockCallback"
import {$Function$$Type} from "java.util.function.Function"
import {$ItemBuilder$$Type} from "dev.latvian.mods.kubejs.item.ItemBuilder"
import {$CanBeReplacedCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.CanBeReplacedCallback"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$BlockTintFunction$$Type} from "dev.latvian.mods.kubejs.block.BlockTintFunction"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$RandomTickCallback, $RandomTickCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.RandomTickCallback"
import {$BlockState$$Type} from "net.minecraft.world.level.block.state.BlockState"
import {$BlockEntityInfo$$Type} from "dev.latvian.mods.kubejs.block.entity.BlockEntityInfo"
import {$Predicate$$Type} from "java.util.function.Predicate"
import {$SoundType$$Type} from "net.minecraft.world.level.block.SoundType"
import {$BlockStateRotateCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.BlockStateRotateCallback"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$BlockStateModifyPlacementCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.BlockStateModifyPlacementCallback"
import {$BlockExplodedCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.BlockExplodedCallback"
import {$ModelledBuilderBase} from "dev.latvian.mods.kubejs.registry.ModelledBuilderBase"
import {$BuilderBase} from "dev.latvian.mods.kubejs.registry.BuilderBase"
import {$BlockStateMirrorCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.BlockStateMirrorCallback"
import {$LootTable} from "net.minecraft.world.level.storage.loot.LootTable"
import {$Consumer, $Consumer$$Type} from "java.util.function.Consumer"
import {$EntityFallenOnBlockCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.EntityFallenOnBlockCallback"
import {$Registry} from "net.minecraft.core.Registry"
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$AABB$$Type} from "net.minecraft.world.phys.AABB"
import {$BlockStateModifyCallback$$Type} from "dev.latvian.mods.kubejs.block.callback.BlockStateModifyCallback"
import {$Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $BlockBuilder extends $ModelledBuilderBase<($Block)> {
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
 "randomTickCallback": $Consumer<($RandomTickCallback)>
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(id: $ResourceLocation$$Type)

/**
 * Sets the opacity of the block. Opaque blocks do not let light through.
 */
public "opaque"(o: boolean): this
/**
 * Change drops of this block
 */
public "drops"(drops: $BlockDropSupplier$$Type): this
public "createProperties"(): $BlockBehaviour$Properties
/**
 * Add a blockstate property to the block.
 * 
 * For example, facing, lit, etc.
 */
public "property"(property: $Property$$Type<(never)>): this
/**
 * Set the shape of the block.
 */
public "box"(x0: double, y0: double, z0: double, x1: double, y1: double, z1: double, scale16: boolean): this
/**
 * Set the shape of the block.
 */
public "box"(x0: double, y0: double, z0: double, x1: double, y1: double, z1: double): this
/**
 * Set the color of a specific layer of the block.
 */
public "color"(color: $BlockTintFunction$$Type): this
/**
 * Set the color of a specific layer of the block.
 */
public "color"(index: integer, color: $BlockTintFunction$$Type): this
/**
 * Sets the display name for this object, e.g. `Stone`.
 * 
 * This will be overridden by a lang file if it exists.
 */
public "displayName"(name: $Component$$Type): $BuilderBase<($Block)>
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: ($ResourceLocation$$Type)[]): $BuilderBase
/**
 * Modifies the block's item representation.
 */
public "item"(i: $Consumer$$Type<($ItemBuilder)>): this
/**
 * Sets the block's map color. Defaults to NONE.
 */
public "mapColor"(m: $MapColor$$Type): this
/**
 * Sets random tick callback for this black.
 */
public "randomTick"(randomTickCallback: $Consumer$$Type<($RandomTickCallback)>): this
public static "createShape"(boxes: $List$$Type<($AABB$$Type)>): $VoxelShape
/**
 * Set the callback for determining the blocks state when placed.
 */
public "placementState"(callbackJS: $Consumer$$Type<($BlockStateModifyPlacementCallback)>): this
/**
 * Makes the block unbreakable.
 */
public "unbreakable"(): this
public "transformObject"(obj: $Block$$Type): $Block
/**
 * Makes the block transparent.
 */
public "transparent"(b: boolean): this
/**
 * Sets the blast resistance of the block. Defaults to 3.
 */
public "resistance"(r: float): this
/**
 * Makes the block not collide with entities.
 */
public "noCollision"(): this
/**
 * Sets the light level of the block. Defaults to 0 (no light).
 */
public "lightLevel"(light: float): this
/**
 * Sets the block's sound type. Defaults to wood.
 */
public "soundType"(m: $SoundType$$Type): this
/**
 * Set if the block can be replaced by something else.
 */
public "canBeReplaced"(callbackJS: $Predicate$$Type<($CanBeReplacedCallback)>): this
/**
 * Set how fast you can walk on the block.
 * 
 * Any value above 1 will make you walk insanely fast as your speed is multiplied by this value each tick.
 * 
 * Recommended values are between 0.1 and 1, useful for mimicking soul sand or ice.
 */
public "speedFactor"(f: float): this
/**
 * Creates a Block Entity for this block
 */
public "blockEntity"(callback: $Consumer$$Type<($BlockEntityInfo)>): this
/**
 * Set the callback used for right-clicking on the block
 */
public "rightClick"(callbackJS: $Consumer$$Type<($BlockRightClickedKubeEvent)>): this
/**
 * Sets the hardness of the block. Defaults to 1.5.
 * 
 * Setting this to -1 will make the block unbreakable like bedrock.
 */
public "hardness"(h: float): this
/**
 * 
 * @deprecated
 */
public "generateLootTable"(): $LootTable
public "generateLootTable"(generator: $KubeDataGenerator$$Type): $LootTable
/**
 * Sets the block should be a full block or not, like cactus or doors.
 */
public "fullBlock"(f: boolean): this
/**
 * Sets the render type of the block. Can be `cutout`, `cutout_mipped`, `translucent`, or `basic`.
 */
public "renderType"(l: $BlockRenderType$$Type): this
/**
 * Makes the block can be waterlogged.
 */
public "waterlogged"(): this
/**
 * Set the default state of the block.
 */
public "defaultState"(callbackJS: $Consumer$$Type<($BlockStateModifyCallback)>): this
/**
 * Makes the block suffocating.
 */
public "suffocating"(b: boolean): this
/**
 * Set how high you can jump on the block.
 */
public "jumpFactor"(f: float): this
/**
 * Note block instrument.
 */
public "instrument"(i: $NoteBlockInstrument$$Type): this
/**
 * Makes mobs not spawn on the block.
 */
public "noValidSpawns"(b: boolean): this
public "copyPropertiesFrom"(block: $Block$$Type): this
/**
 * Checks if the block can be waterlogged.
 */
public "canBeWaterlogged"(): boolean
/**
 * Set how this block bounces/moves entities that land on top of this. Do not use this to modify the block, use fallOn instead!
 * Use ctx.bounce(height) or ctx.setVelocity(x, y, z) to change the entities velocity.
 */
public "afterFallenOn"(callbackJS: $Consumer$$Type<($AfterEntityFallenOnBlockCallback)>): this
/**
 * Sets the block's map color dynamically per block state. If unset, defaults to NONE.
 */
public "dynamicMapColor"(m: $Function$$Type<($BlockState), (any)>): this
/**
 * Set the callback used for determining how the block is mirrored
 */
public "mirrorState"(callbackJS: $Consumer$$Type<($BlockStateMirrorCallback)>): this
public "cropSoundType"(): this
public "stoneSoundType"(): this
public "glassSoundType"(): this
/**
 * 
 * @deprecated
 */
public "getWaterlogged"(): boolean
/**
 * Makes the block require a tool to have drops when broken.
 */
public "requiresTool"(f: boolean): this
/**
 * Makes the block require a tool to have drops when broken.
 */
public "requiresTool"(): this
public "noSoundType"(): this
public "woodSoundType"(): this
public "sandSoundType"(): this
/**
 * Set the callback used for determining how the block rotates
 */
public "rotateState"(callbackJS: $Consumer$$Type<($BlockStateRotateCallback)>): this
/**
 * 
 * @deprecated
 */
public "setWaterlogged"(waterlogged: boolean): this
/**
 * Makes the block view blocking.
 */
public "viewBlocking"(b: boolean): this
/**
 * Makes the block a redstone conductor.
 */
public "redstoneConductor"(b: boolean): this
/**
 * Helper method for setting the render type of the block to `cutout` correctly.
 */
public "defaultCutout"(): this
public "grassSoundType"(): this
public "gravelSoundType"(): this
/**
 * Set how slippery the block is.
 */
public "slipperiness"(f: float): this
/**
 * Helper method for setting the render type of the block to `translucent` correctly.
 */
public "defaultTranslucent"(): this
/**
 * Makes the block not be solid.
 */
public "notSolid"(): this
/**
 * Set how this block reacts after an explosion. Note the block has already been destroyed at this point
 */
public "exploded"(callbackJS: $Consumer$$Type<($BlockExplodedCallback)>): this
/**
 * Set what happens when an entity steps on the block
 * This is called every tick for every entity standing on the block, so be careful what you do here.
 */
public "steppedOn"(callbackJS: $Consumer$$Type<($EntitySteppedOnBlockCallback)>): this
/**
 * Set what happens when an entity falls on the block. Do not use this for moving them, use bounce instead!
 */
public "fallenOn"(callbackJS: $Consumer$$Type<($EntityFallenOnBlockCallback)>): this
/**
 * Tags both the block and the item with the given tag.
 */
public "tagBoth"(tag: ($ResourceLocation$$Type)[]): this
/**
 * Set the block to have no corresponding item.
 */
public "noItem"(): this
/**
 * Clears all drops for the block.
 */
public "noDrops"(): this
/**
 * Tags the block with the given tag.
 */
public "tagBlock"(tag: ($ResourceLocation$$Type)[]): this
/**
 * Tags the item with the given tag.
 */
public "tagItem"(tag: ($ResourceLocation$$Type)[]): this
/**
 * Bounces entities that land on this block by bounciness * their fall velocity.
 * Do not make bounciness negative, as that is a recipe for a long and laggy trip to the void
 */
public "bounciness"(bounciness: float): this
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBuilder$$Type = ($BlockBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockBuilder$$Original = $BlockBuilder;}
declare module "dev.latvian.mods.kubejs.component.AttributeModifierFunctions" {
import {$AttributeModifier, $AttributeModifier$$Type} from "net.minecraft.world.entity.ai.attributes.AttributeModifier"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$ItemAttributeModifiers$Entry$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers$Entry"
import {$EquipmentSlotGroup$$Type} from "net.minecraft.world.entity.EquipmentSlotGroup"
import {$List$$Type} from "java.util.List"
import {$ItemAttributeModifiers, $ItemAttributeModifiers$$Type} from "net.minecraft.world.item.component.ItemAttributeModifiers"
import {$Attribute$$Type} from "net.minecraft.world.entity.ai.attributes.Attribute"
import {$Holder$$Type} from "net.minecraft.core.Holder"

export interface $AttributeModifierFunctions$$Interface {

(): $ItemAttributeModifiers$$Type
get "baseAttackDamage"(): double
set "attackDamage"(value: double)
get "baseAttackSpeed"(): double
set "attributeModifiers"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "baseAttackSpeed"(value: double)
set "baseAttackDamage"(value: double)
get "attackDamage"(): double
get "attributeModifiers"(): $ItemAttributeModifiers
set "attributeModifiersWithTooltip"(value: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>)
set "attackSpeed"(value: double)
get "attackSpeed"(): double
}

export class $AttributeModifierFunctions implements $AttributeModifierFunctions$$Interface {
 "getBaseAttackDamage"(): double
/**
 * Sets the attack damage of this item to the given value, **removing** all other modifiers to attack damage.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 * (In practice, this simply means that most weapons have this value set to 1 less than what you might think.)
 */
 "setAttackDamage"(dmg: double): void
 "hasAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): boolean
 "getBaseAttackSpeed"(): double
 "setAttributeModifiers"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Overrides the *base* attack speed of this item to be the given value, keeping other modifiers intact.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 */
 "setBaseAttackSpeed"(speed: double): void
/**
 * Overrides the *base* attack damage of this item to be the given value, keeping other modifiers intact.
 * Note that since players have a default attack damage of 1.0, total damage will be (dmg + 1.0) before other modifiers.
 */
 "setBaseAttackDamage"(dmg: double): void
 "addAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, mod: $AttributeModifier$$Type, slot: $EquipmentSlotGroup$$Type): void
 "getAttributeModifier"(attribute: $Holder$$Type<($Attribute)>, id: $ResourceLocation$$Type): $AttributeModifier
 "getAttackDamage"(): double
 "getAttributeModifiers"(): $ItemAttributeModifiers
 "setAttributeModifiersWithTooltip"(modifiers: $List$$Type<($ItemAttributeModifiers$Entry$$Type)>): void
/**
 * Sets the attack speed of this item to the given value, **removing** all other modifiers to attack speed.
 * Note that players have a default attack speed of 4.0, so this modifier is added on top of that.
 * (Example: Swords have an attack speed of -2.4, leading to a total value of 1.6 without any other changes.)
 */
 "setAttackSpeed"(speed: double): void
 "getAttackSpeed"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttributeModifierFunctions$$Type = (() => $ItemAttributeModifiers$$Type);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AttributeModifierFunctions$$Original = $AttributeModifierFunctions;}
declare module "dev.latvian.mods.kubejs.client.EntityRendererRegistryKubeEvent" {
import {$ClientKubeEvent$$Interface} from "dev.latvian.mods.kubejs.client.ClientKubeEvent"
import {$EntityRenderersEvent$RegisterRenderers$$Type} from "net.neoforged.neoforge.client.event.EntityRenderersEvent$RegisterRenderers"
import {$Minecraft} from "net.minecraft.client.Minecraft"
import {$EntityRendererProvider$$Type} from "net.minecraft.client.renderer.entity.EntityRendererProvider"
import {$EntityType$$Type} from "net.minecraft.world.entity.EntityType"

export class $EntityRendererRegistryKubeEvent implements $ClientKubeEvent$$Interface {
constructor(event: $EntityRenderersEvent$RegisterRenderers$$Type)

public "register"(type: $EntityType$$Type<(never)>, renderer: $EntityRendererProvider$$Type): void
public "getClient"(): $Minecraft
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "client"(): $Minecraft
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityRendererRegistryKubeEvent$$Type = ($EntityRendererRegistryKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $EntityRendererRegistryKubeEvent$$Original = $EntityRendererRegistryKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.RecipeScriptContext" {
import {$Context} from "dev.latvian.mods.rhino.Context"
import {$ErrorStack} from "dev.latvian.mods.kubejs.util.ErrorStack"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$RecipeValidationContext$$Interface} from "dev.latvian.mods.kubejs.recipe.component.RecipeValidationContext"
import {$RecipeMatchContext$$Interface} from "dev.latvian.mods.kubejs.recipe.filter.RecipeMatchContext"
import {$WithScriptContext$$Interface} from "dev.latvian.mods.kubejs.script.WithScriptContext"
import {$KubeRecipeContext$$Interface} from "dev.latvian.mods.kubejs.recipe.KubeRecipeContext"
import {$RecipeLikeKJS} from "dev.latvian.mods.kubejs.core.RecipeLikeKJS"
import {$RegistryAccessContainer} from "dev.latvian.mods.kubejs.util.RegistryAccessContainer"

export interface $RecipeScriptContext$$Interface extends $WithScriptContext$$Interface, $RecipeValidationContext$$Interface, $KubeRecipeContext$$Interface, $RecipeMatchContext$$Interface {
}

export class $RecipeScriptContext implements $RecipeScriptContext$$Interface {
 "cx"(): $Context
 "errors"(): $ErrorStack
 "registries"(): $RegistryAccessContainer
 "ops"(): $RegistryOpsContainer
 "recipe"(): $RecipeLikeKJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeScriptContext$$Type = ($RecipeScriptContext);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RecipeScriptContext$$Original = $RecipeScriptContext;}
declare module "dev.latvian.mods.kubejs.item.ItemModelPropertiesKubeEvent" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$KubeStartupEvent$$Interface} from "dev.latvian.mods.kubejs.event.KubeStartupEvent"
import {$Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$ClampedItemPropertyFunction$$Type} from "net.minecraft.client.renderer.item.ClampedItemPropertyFunction"

export class $ItemModelPropertiesKubeEvent implements $KubeStartupEvent$$Interface {
constructor()

/**
 * Register a model property for an item. Model properties are used to change the appearance of an item in the world.
 * 
 * More about model properties: https://minecraft.wiki/w/Tutorials/Models#Item_predicates
 */
public "register"(ingredient: $Ingredient$$Type, overwriteId: $ResourceLocation$$Type, callback: $ClampedItemPropertyFunction$$Type): void
/**
 * Register a model property for all items.
 */
public "registerAll"(overwriteId: $ResourceLocation$$Type, callback: $ClampedItemPropertyFunction$$Type): void
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModelPropertiesKubeEvent$$Type = ($ItemModelPropertiesKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ItemModelPropertiesKubeEvent$$Original = $ItemModelPropertiesKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.CachedTagLookup$Entry" {
import {$Registry, $Registry$$Type} from "net.minecraft.core.Registry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$CachedTagLookup, $CachedTagLookup$$Type} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup"
import {$Record} from "java.lang.Record"

export class $CachedTagLookup$Entry<T> extends $Record {
constructor(key: $ResourceKey$$Type<(T)>, registry: $Registry$$Type<(T)>, lookup: $CachedTagLookup$$Type<(T)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "lookup"(): $CachedTagLookup<(T)>
public "key"(): $ResourceKey<(T)>
public "registry"(): $Registry<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedTagLookup$Entry$$Type<T> = ({"registry"?: $Registry$$Type<(T)>, "key"?: $ResourceKey$$Type<(T)>, "lookup"?: $CachedTagLookup$$Type<(T)>}) | ([registry?: $Registry$$Type<(T)>, key?: $ResourceKey$$Type<(T)>, lookup?: $CachedTagLookup$$Type<(T)>]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CachedTagLookup$Entry$$Original<T> = $CachedTagLookup$Entry<(T)>;}
declare module "dev.latvian.mods.kubejs.color.KubeColor" {
import {$StreamCodec} from "net.minecraft.network.codec.StreamCodec"
import {$Optional} from "java.util.Optional"
import {$Codec} from "com.mojang.serialization.Codec"
import {$SpecialEquality$$Interface} from "dev.latvian.mods.rhino.util.SpecialEquality"
import {$TextColor} from "net.minecraft.network.chat.TextColor"
import {$ByteBuf} from "io.netty.buffer.ByteBuf"

export interface $KubeColor$$Interface extends $SpecialEquality$$Interface {

(): integer
get "argb"(): integer
get "fireworkRGB"(): integer
get "rgb"(): integer
}

export class $KubeColor implements $KubeColor$$Interface {
static readonly "CODEC": $Codec<($KubeColor)>
static readonly "OPTIONAL_STREAM_CODEC": $StreamCodec<($ByteBuf), ($Optional<($KubeColor)>)>
static readonly "STREAM_CODEC": $StreamCodec<($ByteBuf), ($KubeColor)>

 "getArgb"(): integer
 "toHexString"(): StringJS
 "getFireworkRGB"(): integer
 "serialize"(): StringJS
 "getRgb"(): integer
 "createTextColor"(): $TextColor
 "specialEquals"(o: any, shallow: boolean): boolean
static "checkSpecialEquality"(arg1: any, arg2: any, arg3: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeColor$$Type = (("") | ("light_blue_dye") | ("blue_dye") | ("purple_dye") | ("dark_red") | ("lightgraydye") | ("dark_aqua") | ("none") | ("green_dye") | ("blackdye") | ("dark_blue") | ("red") | ("pink_dye") | ("aqua") | ("white") | ("white_dye") | ("dark_gray") | ("light_purple") | ("brown_dye") | ("black") | ("darkpurple") | ("lightbluedye") | ("limedye") | ("magenta_dye") | ("-") | ("lime_dye") | ("yellowdye") | ("graydye") | ("purpledye") | ("dark_purple") | ("orange_dye") | ("darkgray") | ("browndye") | ("yellow") | ("bluedye") | ("pinkdye") | ("cyandye") | ("gold") | ("gray") | ("blue") | ("darkblue") | ("transparent") | ("red_dye") | ("darkred") | ("greendye") | ("reddye") | ("gray_dye") | ("orangedye") | ("yellow_dye") | ("black_dye") | ("magentadye") | ("green") | ("light_gray_dye") | ("darkgreen") | ("dark_green") | ("lightpurple") | ("darkaqua") | ("cyan_dye") | ("whitedye")) | (`#${string}`) | (integer) | (() => integer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeColor$$Original = $KubeColor;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.AABBWrapper" {
import {$Vec3$$Type} from "net.minecraft.world.phys.Vec3"
import {$BlockPos$$Type} from "net.minecraft.core.BlockPos"
import {$AABB} from "net.minecraft.world.phys.AABB"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $AABBWrapper$$Interface {
}

export class $AABBWrapper implements $AABBWrapper$$Interface {
static readonly "CUBE": $AABB
static readonly "EMPTY": $AABB

static "ofSize"(x: double, y: double, z: double): $AABB
static "ofSize"(vec3: $Vec3$$Type, x: double, y: double, z: double): $AABB
static "wrap"(o: any): $AABB
static "of"(x0: double, y0: double, z0: double, x1: double, y1: double, z1: double): $AABB
static "ofBlock"(pos: $BlockPos$$Type): $AABB
static "ofBlocks"(pos1: $BlockPos$$Type, pos2: $BlockPos$$Type): $AABB
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AABBWrapper$$Type = ($AABBWrapper);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $AABBWrapper$$Original = $AABBWrapper;}
declare module "dev.latvian.mods.kubejs.block.predicate.BlockIDPredicate$PropertyObject" {
import {$Record} from "java.lang.Record"
import {$Property, $Property$$Type} from "net.minecraft.world.level.block.state.properties.Property"

export class $BlockIDPredicate$PropertyObject extends $Record {
constructor(property: $Property$$Type<(never)>, value: any)

public "value"(): any
public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "property"(): $Property<(never)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockIDPredicate$PropertyObject$$Type = ({"property"?: $Property$$Type<(never)>, "value"?: any}) | ([property?: $Property$$Type<(never)>, value?: any]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockIDPredicate$PropertyObject$$Original = $BlockIDPredicate$PropertyObject;}
declare module "dev.latvian.mods.kubejs.script.ScriptType" {
import {$KubeJSFileWatcherThread} from "dev.latvian.mods.kubejs.script.KubeJSFileWatcherThread"
import {$Map} from "java.util.Map"
import {$Enum} from "java.lang.Enum"
import {$Predicate, $Predicate$$Type} from "java.util.function.Predicate"
import {$List} from "java.util.List"
import {$NativeEventWrapper$Listeners} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.NativeEventWrapper$Listeners"
import {$Lazy} from "dev.latvian.mods.kubejs.util.Lazy"
import {$ScriptTypePredicate, $ScriptTypePredicate$$Interface} from "dev.latvian.mods.kubejs.script.ScriptTypePredicate"
import {$ScriptTypeHolder$$Interface} from "dev.latvian.mods.kubejs.script.ScriptTypeHolder"
import {$NativeEventWrapper$Listeners$Key} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.NativeEventWrapper$Listeners$Key"
import {$Path} from "java.nio.file.Path"
import {$ConsoleJS} from "dev.latvian.mods.kubejs.script.ConsoleJS"
import {$ClassFilter} from "dev.latvian.mods.kubejs.plugin.ClassFilter"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptType extends $Enum<($ScriptType)> implements $ScriptTypePredicate$$Interface, $ScriptTypeHolder$$Interface {
readonly "console": $ConsoleJS
readonly "path": $Path
readonly "nativeEventListeners": $Map<($NativeEventWrapper$Listeners$Key), ($NativeEventWrapper$Listeners)>
static readonly "SERVER": $ScriptType
 "fileWatcherThread": $KubeJSFileWatcherThread
static readonly "VALUES": ($ScriptType)[]
static readonly "STARTUP": $ScriptType
readonly "classFilter": $Lazy<($ClassFilter)>
static readonly "CLIENT": $ScriptType
readonly "nameStrip": StringJS

public static "values"(): ($ScriptType)[]
public "test"(type: any): boolean
public "test"(type: $ScriptType$$Type): boolean
public static "valueOf"(name: StringJS): $ScriptType
public "negate"(): $ScriptTypePredicate
public "isClient"(): boolean
public "getLogFile"(): $Path
public "isStartup"(): boolean
public "kjs$getScriptType"(): $ScriptType
public "getValidTypes"(): $List<($ScriptType)>
public "isServer"(): boolean
public "or"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
public "and"(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
public static "not"<T>(arg0: $Predicate$$Type<($ScriptType)>): $Predicate<($ScriptType)>
public static "isEqual"<T>(arg0: any): $Predicate<($ScriptType)>
get "client"(): boolean
get "logFile"(): $Path
get "startup"(): boolean
get "validTypes"(): $List<($ScriptType)>
get "server"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptType$$Type = (("startup") | ("server") | ("client"));
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ScriptType$$Original = $ScriptType;}
declare module "dev.latvian.mods.kubejs.script.SourceLine" {
import {$FriendlyByteBuf$$Type} from "net.minecraft.network.FriendlyByteBuf"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$Record} from "java.lang.Record"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $SourceLine extends $Record {
static readonly "UNKNOWN": $SourceLine

constructor(source: StringJS, line: integer)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public static "of"(): $SourceLine
public static "of"(source: StringJS, line: integer): $SourceLine
public "line"(): integer
public "source"(): StringJS
public static "write"(buf: $FriendlyByteBuf$$Type, sourceLine: $SourceLine$$Type): void
public static "read"(buf: $FriendlyByteBuf$$Type): $SourceLine
public "isUnknown"(): boolean
public static "fromJson"(json: $JsonObject$$Type): $SourceLine
public "toJson"(): $JsonObject
get "unknown"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SourceLine$$Type = ({"line"?: integer, "source"?: StringJS}) | ([line?: integer, source?: StringJS]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SourceLine$$Original = $SourceLine;}
declare module "dev.latvian.mods.kubejs.core.ComponentKJS" {
import {$Iterable} from "java.lang.Iterable"
import {$FormattedText, $FormattedText$$Type} from "net.minecraft.network.chat.FormattedText"
import {$Optional, $Optional$$Type} from "java.util.Optional"
import {$UUID$$Type} from "java.util.UUID"
import {$List, $List$$Type} from "java.util.List"
import {$JsonElement} from "com.google.gson.JsonElement"
import {$Component, $Component$$Type, $Component$$Interface} from "net.minecraft.network.chat.Component"
import {$FormattedText$StyledContentConsumer$$Type} from "net.minecraft.network.chat.FormattedText$StyledContentConsumer"
import {$Message$$Type} from "com.mojang.brigadier.Message"
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$WrappedJS$$Interface} from "dev.latvian.mods.kubejs.util.WrappedJS"
import {$Codec} from "com.mojang.serialization.Codec"
import {$ComponentContents} from "net.minecraft.network.chat.ComponentContents"
import {$FormattedText$ContentConsumer$$Type} from "net.minecraft.network.chat.FormattedText$ContentConsumer"
import {$WithCodec$$Interface} from "dev.latvian.mods.kubejs.util.WithCodec"
import {$Style, $Style$$Type} from "net.minecraft.network.chat.Style"
import {$ClickEvent$$Type} from "net.minecraft.network.chat.ClickEvent"
import {$ChunkPos$$Type} from "net.minecraft.world.level.ChunkPos"
import {$Consumer$$Type} from "java.util.function.Consumer"
import {$FormattedCharSequence} from "net.minecraft.util.FormattedCharSequence"
import {$URI$$Type} from "java.net.URI"
import {$MutableComponent} from "net.minecraft.network.chat.MutableComponent"
import {$Tag} from "net.minecraft.nbt.Tag"
import {$KubeColor$$Type} from "dev.latvian.mods.kubejs.color.KubeColor"
import {$Date$$Type} from "java.util.Date"
import {$DataSource$$Type} from "net.minecraft.network.chat.contents.DataSource"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ComponentKJS$$Interface extends $Component$$Interface, $WithCodec$$Interface, $WrappedJS$$Interface {
get "codec"(): $Codec<(never)>
get "string"(): StringJS
get "contents"(): $ComponentContents
get "style"(): $Style
get "visualOrderText"(): $FormattedCharSequence
get "siblings"(): $List<($Component)>
}

export class $ComponentKJS implements $ComponentKJS$$Interface {
 "forEach"(action: $Consumer$$Type<($Component)>): void
 "color"(c: $KubeColor$$Type): $MutableComponent
 "italic"(value: boolean): $MutableComponent
 "italic"(): $MutableComponent
 "gray"(): $MutableComponent
 "blue"(): $MutableComponent
 "aqua"(): $MutableComponent
 "white"(): $MutableComponent
 "font"(s: $ResourceLocation$$Type): $MutableComponent
 "hover"(s: $Component$$Type): $MutableComponent
 "bold"(value: boolean): $MutableComponent
 "bold"(): $MutableComponent
 "click"(s: $ClickEvent$$Type): $MutableComponent
 "black"(): $MutableComponent
 "green"(): $MutableComponent
 "red"(): $MutableComponent
 "yellow"(): $MutableComponent
 "gold"(): $MutableComponent
 "clickRunCommand"(command: StringJS): $MutableComponent
 "clickChangePage"(page: StringJS): $MutableComponent
 "clickSuggestCommand"(command: StringJS): $MutableComponent
 "self"(): $MutableComponent
 "getCodec"(): $Codec<(never)>
 "asIterable"(): $Iterable<($Component)>
 "noColor"(): $MutableComponent
 "darkGray"(): $MutableComponent
 "hasStyle"(): boolean
/**
 * 
 * @deprecated
 */
 "rawCopy"(): $MutableComponent
 "darkAqua"(): $MutableComponent
 "lightPurple"(): $MutableComponent
/**
 * 
 * @deprecated
 */
 "rawComponent"(): $MutableComponent
 "strikethrough"(): $MutableComponent
 "strikethrough"(value: boolean): $MutableComponent
 "obfuscated"(): $MutableComponent
 "obfuscated"(value: boolean): $MutableComponent
 "insertion"(s: StringJS): $MutableComponent
 "darkGreen"(): $MutableComponent
 "darkBlue"(): $MutableComponent
 "clickOpenUrl"(url: StringJS): $MutableComponent
 "clickOpenFile"(path: StringJS): $MutableComponent
/**
 * 
 * @deprecated
 */
 "component"(): $Component
 "isEmpty"(): boolean
 "darkPurple"(): $MutableComponent
 "hasSiblings"(): boolean
 "underlined"(): $MutableComponent
 "underlined"(value: boolean): $MutableComponent
 "clickCopy"(text: StringJS): $MutableComponent
 "darkRed"(): $MutableComponent
 "contains"(arg0: $Component$$Type): boolean
static "empty"(): $MutableComponent
 "copy"(): $MutableComponent
static "literal"(arg0: StringJS): $MutableComponent
 "visit"<T>(arg0: $FormattedText$ContentConsumer$$Type<(T)>): $Optional<(T)>
 "visit"<T>(arg0: $FormattedText$StyledContentConsumer$$Type<(T)>, arg1: $Style$$Type): $Optional<(T)>
 "getString"(): StringJS
 "getString"(arg0: integer): StringJS
 "getContents"(): $ComponentContents
static "selector"(arg0: StringJS, arg1: ($Component$$Type)?): $MutableComponent
static "score"(arg0: StringJS, arg1: StringJS): $MutableComponent
 "getStyle"(): $Style
static "keybind"(arg0: StringJS): $MutableComponent
 "plainCopy"(): $MutableComponent
 "toFlatList"(): $List<($Component)>
 "toFlatList"(arg0: $Style$$Type): $List<($Component)>
static "nbt"(arg0: StringJS, arg1: boolean, arg2: ($Component$$Type)?, arg3: $DataSource$$Type): $MutableComponent
static "translatable"(arg0: StringJS, ...arg1: (any)[]): $MutableComponent
static "translatable"(arg0: StringJS): $MutableComponent
 "getVisualOrderText"(): $FormattedCharSequence
 "tryCollapseToString"(): StringJS
static "translatableWithFallback"(arg0: StringJS, arg1: StringJS, ...arg2: (any)[]): $MutableComponent
static "translatableWithFallback"(arg0: StringJS, arg1: StringJS): $MutableComponent
static "nullToEmpty"(arg0: StringJS): $Component
static "translatableEscape"(arg0: StringJS, ...arg1: (any)[]): $MutableComponent
 "getSiblings"(): $List<($Component)>
static "translationArg"(arg0: $ChunkPos$$Type): $Component
static "translationArg"(arg0: $ResourceLocation$$Type): $Component
static "translationArg"(arg0: $URI$$Type): $Component
static "translationArg"(arg0: $Date$$Type): $Component
static "translationArg"(arg0: $Message$$Type): $Component
static "translationArg"(arg0: $UUID$$Type): $Component
 "toJson"(): $JsonElement
 "toNBT"(): $Tag
static "of"(arg0: StringJS, arg1: $Style$$Type): $FormattedText
static "of"(arg0: StringJS): $FormattedText
static "composite"(arg0: $List$$Type<($FormattedText$$Type)>): $FormattedText
static "composite"(...arg0: ($FormattedText$$Type)[]): $FormattedText
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentKJS$$Type = ($ComponentKJS);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ComponentKJS$$Original = $ComponentKJS;}
declare module "dev.latvian.mods.kubejs.item.custom.SwordItemBuilder" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$HandheldItemBuilder} from "dev.latvian.mods.kubejs.item.custom.HandheldItemBuilder"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"

export class $SwordItemBuilder extends $HandheldItemBuilder {
static readonly "SWORD_TAGS": ($ResourceLocation)[]
 "sourceLine": $SourceLine
readonly "id": $ResourceLocation
static readonly "SWORD_MODEL": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SwordItemBuilder$$Type = ($SwordItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $SwordItemBuilder$$Original = $SwordItemBuilder;}
declare module "dev.latvian.mods.kubejs.util.RegistryAccessContainer" {
import {$OpsContainer} from "dev.latvian.mods.kubejs.util.OpsContainer"
import {$ItemStack} from "net.minecraft.world.item.ItemStack"
import {$Collection} from "java.util.Collection"
import {$Map, $Map$$Type} from "java.util.Map"
import {$DynamicOps} from "com.mojang.serialization.DynamicOps"
import {$List$$Type} from "java.util.List"
import {$Block} from "net.minecraft.world.level.block.Block"
import {$TagLoader$EntryWithSource$$Type} from "net.minecraft.tags.TagLoader$EntryWithSource"
import {$DamageSources} from "net.minecraft.world.damagesource.DamageSources"
import {$Holder} from "net.minecraft.core.Holder"
import {$RegistryWrapper} from "dev.latvian.mods.kubejs.plugin.builtin.wrapper.RegistryWrapper"
import {$CachedItemTagLookup} from "dev.latvian.mods.kubejs.recipe.CachedItemTagLookup"
import {$Fluid} from "net.minecraft.world.level.material.Fluid"
import {$RegistryAccess$Frozen, $RegistryAccess$Frozen$$Type} from "net.minecraft.core.RegistryAccess$Frozen"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry$$Type} from "net.minecraft.core.Registry"
import {$RegistryOpsContainer} from "dev.latvian.mods.kubejs.util.RegistryOpsContainer"
import {$TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$ICondition$IContext$$Interface} from "net.neoforged.neoforge.common.conditions.ICondition$IContext"
import {$CachedTagLookup$Entry} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup$Entry"
import {$ResourceKey, $ResourceKey$$Type} from "net.minecraft.resources.ResourceKey"
import {$CachedTagLookup} from "dev.latvian.mods.kubejs.recipe.CachedTagLookup"

export class $RegistryAccessContainer extends $RegistryOpsContainer implements $ICondition$IContext$$Interface {
static "current": $RegistryAccessContainer
 "cachedBlockTags": $CachedTagLookup<($Block)>
 "cachedFluidTags": $CachedTagLookup<($Fluid)>
 "cachedItemTags": $CachedItemTagLookup
static readonly "BUILTIN": $RegistryAccessContainer
readonly "cachedRegistryTags": $Map<($ResourceKey<(never)>), ($CachedTagLookup$Entry<(never)>)>
static readonly "DEFAULT": $OpsContainer

constructor(access: $RegistryAccess$Frozen$$Type)

public "getAllTags"<T>(key: $ResourceKey$$Type<($Registry<(T)>)>): $Map<($ResourceLocation), ($Collection<($Holder<(T)>)>)>
public static "of"(): $RegistryAccessContainer
public "access"(): $RegistryAccess$Frozen
public "itemStackParseCache"(): $Map<(StringJS), ($ItemStack)>
public "cacheTags"<T>(registry: $Registry$$Type<(T)>, map: $Map$$Type<($ResourceLocation$$Type), ($List$$Type<($TagLoader$EntryWithSource$$Type)>)>): void
public "wrapRegistry"(id: $ResourceLocation$$Type): $RegistryWrapper<(never)>
public "damageSources"(): $DamageSources
public "getTag"<T>(arg0: $TagKey$$Type<(T)>): $Collection<($Holder<(T)>)>
public "java"(): $DynamicOps
public "json"(): $DynamicOps
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryAccessContainer$$Type = ($RegistryAccessContainer);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $RegistryAccessContainer$$Original = $RegistryAccessContainer;}
declare module "dev.latvian.mods.kubejs.item.MutableToolTier" {
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Ingredient, $Ingredient$$Type} from "net.minecraft.world.item.crafting.Ingredient"
import {$TagKey, $TagKey$$Type} from "net.minecraft.tags.TagKey"
import {$Block, $Block$$Type} from "net.minecraft.world.level.block.Block"
import {$Tool} from "net.minecraft.world.item.component.Tool"
import {$Tier, $Tier$$Type, $Tier$$Interface} from "net.minecraft.world.item.Tier"

export class $MutableToolTier implements $Tier$$Interface {
readonly "parent": $Tier

constructor(p: $Tier$$Type)

public "setSpeed"(f: float): void
public "getSpeed"(): float
public "getAttackDamageBonus"(): float
public "getEnchantmentValue"(): integer
public "getUses"(): integer
public "getVanillaRepairIngredient"(): $Ingredient
public "getIncorrectBlocksForDrops"(): $TagKey<($Block)>
public "setAttackDamageBonus"(f: float): void
public "setUses"(i: integer): void
public "getIncorrectBlocksForDropsTag"(): $ResourceLocation
public "setIncorrectBlocksForDropsTag"(tag: $ResourceLocation$$Type): void
public "setEnchantmentValue"(i: integer): void
public "setRepairIngredient"(arg0: $Ingredient$$Type): void
public "createToolProperties"(arg0: $TagKey$$Type<($Block)>): $Tool
set "speed"(value: float)
get "speed"(): float
get "attackDamageBonus"(): float
get "enchantmentValue"(): integer
get "uses"(): integer
get "vanillaRepairIngredient"(): $Ingredient
get "incorrectBlocksForDrops"(): $TagKey<($Block)>
set "attackDamageBonus"(value: float)
set "uses"(value: integer)
get "incorrectBlocksForDropsTag"(): $ResourceLocation
set "incorrectBlocksForDropsTag"(value: $ResourceLocation$$Type)
set "enchantmentValue"(value: integer)
set "repairIngredient"(value: $Ingredient$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableToolTier$$Type = ($MutableToolTier);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $MutableToolTier$$Original = $MutableToolTier;}
declare module "dev.latvian.mods.kubejs.item.custom.DiggerItemBuilder" {
import {$BiFunction, $BiFunction$$Type} from "java.util.function.BiFunction"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Registry} from "net.minecraft.core.Registry"
import {$HandheldItemBuilder} from "dev.latvian.mods.kubejs.item.custom.HandheldItemBuilder"
import {$Item$Properties, $Item$Properties$$Type} from "net.minecraft.world.item.Item$Properties"
import {$ResourceKey} from "net.minecraft.resources.ResourceKey"
import {$DiggerItem, $DiggerItem$$Type} from "net.minecraft.world.item.DiggerItem"
import {$SourceLine} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Tier, $Tier$$Type} from "net.minecraft.world.item.Tier"

export class $DiggerItemBuilder extends $HandheldItemBuilder {
 "sourceLine": $SourceLine
readonly "function": $BiFunction<($Tier), ($Item$Properties), ($DiggerItem)>
readonly "id": $ResourceLocation
 "registryKey": $ResourceKey<($Registry<(T)>)>

constructor(i: $ResourceLocation$$Type, d: float, s: float, f: $BiFunction$$Type<($Tier), ($Item$Properties), ($DiggerItem$$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiggerItemBuilder$$Type = ($DiggerItemBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $DiggerItemBuilder$$Original = $DiggerItemBuilder;}
declare module "dev.latvian.mods.kubejs.client.ModelGenerator" {
import {$ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$Map$$Type} from "java.util.Map"
import {$ModelGenerator$Override$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator$Override"
import {$JsonObject, $JsonObject$$Type} from "com.google.gson.JsonObject"
import {$ModelGenerator$Element$$Type} from "dev.latvian.mods.kubejs.client.ModelGenerator$Element"
import {$Consumer$$Type} from "java.util.function.Consumer"

export class $ModelGenerator {
constructor()

public "parent"(s: $ResourceLocation$$Type): void
public "override"(model: $ResourceLocation$$Type, override: $Consumer$$Type<($ModelGenerator$Override)>): void
public "element"(consumer: $Consumer$$Type<($ModelGenerator$Element)>): void
public "toJson"(): $JsonObject
public "texture"(name: (StringJS)[], texture: StringJS): void
public "textures"(map: $Map$$Type<(StringJS), (StringJS)>): void
public "custom"(json: $Consumer$$Type<($JsonObject)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$$Type = ($ModelGenerator);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ModelGenerator$$Original = $ModelGenerator;}
declare module "dev.latvian.mods.kubejs.gui.chest.ChestMenuSlot" {
import {$ChestMenuData, $ChestMenuData$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuData"
import {$Map} from "java.util.Map"
import {$ChestMenuClickHandler} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickHandler"
import {$ItemStack, $ItemStack$$Type} from "net.minecraft.world.item.ItemStack"
import {$List} from "java.util.List"
import {$ChestMenuClickEvent$Callback$$Type} from "dev.latvian.mods.kubejs.gui.chest.ChestMenuClickEvent$Callback"
import {$InventoryKJS} from "dev.latvian.mods.kubejs.core.InventoryKJS"
import {$ClickType$$Type} from "net.minecraft.world.inventory.ClickType"

export class $ChestMenuSlot {
 "data": $Map<(StringJS), (any)>
readonly "clickHandlers": $List<($ChestMenuClickHandler)>
readonly "x": integer
readonly "index": integer
readonly "y": integer
 "inventorySlot": integer
readonly "gui": $ChestMenuData
 "inventory": $InventoryKJS

constructor(gui: $ChestMenuData$$Type, index: integer)

public "toString"(): StringJS
public "setThrown"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "getItem"(): $ItemStack
public "setItem"(stack: $ItemStack$$Type): void
public "clicked"(type: $ClickType$$Type, button: integer, callback: $ChestMenuClickEvent$Callback$$Type, autoHandle: boolean): void
public "setSwapped"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setMiddleClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setRightClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setDoubleClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "resetClickHandlers"(): void
public "setLeftClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setShiftRightClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
public "setShiftLeftClicked"(callback: $ChestMenuClickEvent$Callback$$Type): void
set "thrown"(value: $ChestMenuClickEvent$Callback$$Type)
get "item"(): $ItemStack
set "item"(value: $ItemStack$$Type)
set "swapped"(value: $ChestMenuClickEvent$Callback$$Type)
set "middleClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "rightClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "doubleClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "leftClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "shiftRightClicked"(value: $ChestMenuClickEvent$Callback$$Type)
set "shiftLeftClicked"(value: $ChestMenuClickEvent$Callback$$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuSlot$$Type = ($ChestMenuSlot);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ChestMenuSlot$$Original = $ChestMenuSlot;}
declare module "dev.latvian.mods.kubejs.block.custom.CropBlockBuilder$ShapeBuilder" {
import {$VoxelShape} from "net.minecraft.world.phys.shapes.VoxelShape"
import {$List} from "java.util.List"

export class $CropBlockBuilder$ShapeBuilder {
constructor(age: integer)

/**
 * Makes the block to have a box like beetroot for each stage.
 */
public "beetroot"(): $CropBlockBuilder$ShapeBuilder
/**
 * Makes the block to have a box like carrot for each stage.
 */
public "carrot"(): $CropBlockBuilder$ShapeBuilder
/**
 * Makes the block to have a box like potato for each stage.
 */
public "potato"(): $CropBlockBuilder$ShapeBuilder
/**
 * Describe the shape of the crop at a specific age.
 * min/max coordinates are double values between 0 and 16.
 */
public "shape"(age: integer, minX: double, minY: double, minZ: double, maxX: double, maxY: double, maxZ: double): $CropBlockBuilder$ShapeBuilder
/**
 * Makes the block to have a box like wheat for each stage.
 */
public "wheat"(): $CropBlockBuilder$ShapeBuilder
public "getShapes"(): $List<($VoxelShape)>
get "shapes"(): $List<($VoxelShape)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlockBuilder$ShapeBuilder$$Type = ($CropBlockBuilder$ShapeBuilder);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $CropBlockBuilder$ShapeBuilder$$Original = $CropBlockBuilder$ShapeBuilder;}
declare module "dev.latvian.mods.kubejs.plugin.builtin.wrapper.KMath" {
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Vector4f} from "org.joml.Vector4f"
import {$Vector3f} from "org.joml.Vector3f"
import {$Quaternionf} from "org.joml.Quaternionf"
import {$BlockPos} from "net.minecraft.core.BlockPos"
import {$Matrix4f} from "org.joml.Matrix4f"
import {$Matrix3f} from "org.joml.Matrix3f"
import {$Vector3d} from "org.joml.Vector3d"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $KMath$$Interface {
}

export class $KMath implements $KMath$$Interface {
static readonly "DEGREES_TO_RADIANS": double
static readonly "E": double
static readonly "PI": double
static readonly "RADIANS_TO_DEGREES": double

static "floor"(value: double): long
static "ceil"(value: double): long
static "clamp"(value: double, min: double, max: double): double
static "map"(value: double, min0: double, max0: double, min1: double, max1: double): double
static "v3"(x: double, y: double, z: double): $Vec3
static "block"(x: double, y: double, z: double): $BlockPos
static "deg"(value: double): double
static "isPowerOfTwo"(value: integer): boolean
static "wrapDegrees"(d: double): double
static "clampedLerp"(value: double, min: double, max: double): double
static "rotateIfNecessary"(current: double, target: double, max: double): double
static "approachDegrees"(current: double, target: double, speed: double): double
static "degreesDifference"(current: double, target: double): double
static "rad"(value: double): double
static "lerp"(value: double, min: double, max: double): double
static "quaternion"(x: float, y: float, z: float, w: float): $Quaternionf
static "approach"(current: double, target: double, speed: double): double
static "v4f"(x: float, y: float, z: float, w: float): $Vector4f
static "m4f"(): $Matrix4f
static "m3f"(): $Matrix3f
static "v3f"(x: float, y: float, z: float): $Vector3f
static "v3d"(x: double, y: double, z: double): $Vector3d
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMath$$Type = ($KMath);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KMath$$Original = $KMath;}
declare module "dev.latvian.mods.kubejs.level.ExplosionKubeEvent" {
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Vec3} from "net.minecraft.world.phys.Vec3"
import {$Explosion$$Type} from "net.minecraft.world.level.Explosion"
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level, $Level$$Type} from "net.minecraft.world.level.Level"
import {$LivingEntity} from "net.minecraft.world.entity.LivingEntity"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $ExplosionKubeEvent implements $KubeLevelEvent$$Interface {
constructor(level: $Level$$Type, explosion: $Explosion$$Type)

public "getX"(): double
public "getZ"(): double
public "getPosition"(): $Vec3
public "getLevel"(): $Level
public "getBlock"(): $LevelBlock
public "getY"(): double
public "getExploder"(): $LivingEntity
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "x"(): double
get "z"(): double
get "position"(): $Vec3
get "level"(): $Level
get "block"(): $LevelBlock
get "y"(): double
get "exploder"(): $LivingEntity
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionKubeEvent$$Type = ($ExplosionKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $ExplosionKubeEvent$$Original = $ExplosionKubeEvent;}
declare module "dev.latvian.mods.kubejs.block.FarmlandTrampledKubeEvent" {
import {$Player} from "net.minecraft.world.entity.player.Player"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$Level} from "net.minecraft.world.level.Level"
import {$Entity} from "net.minecraft.world.entity.Entity"
import {$BlockEvent$FarmlandTrampleEvent$$Type} from "net.neoforged.neoforge.event.level.BlockEvent$FarmlandTrampleEvent"
import {$KubeEntityEvent$$Interface} from "dev.latvian.mods.kubejs.entity.KubeEntityEvent"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

/**
 * Invoked when an entity attempts to trample farmland.
 */
export class $FarmlandTrampledKubeEvent implements $KubeEntityEvent$$Interface {
constructor(event: $BlockEvent$FarmlandTrampleEvent$$Type)

/**
 * The level that the farmland and the entity are in.
 */
public "getLevel"(): $Level
/**
 * The farmland block.
 */
public "getBlock"(): $LevelBlock
/**
 * The entity that is attempting to trample the farmland.
 */
public "getEntity"(): $Entity
/**
 * The distance of the entity from the block.
 */
public "getDistance"(): float
public "getPlayer"(): $Player
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "block"(): $LevelBlock
get "entity"(): $Entity
get "distance"(): float
get "player"(): $Player
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FarmlandTrampledKubeEvent$$Type = ($FarmlandTrampledKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $FarmlandTrampledKubeEvent$$Original = $FarmlandTrampledKubeEvent;}
declare module "dev.latvian.mods.kubejs.recipe.schema.KubeRecipeFactory" {
import {$TypeInfo, $TypeInfo$$Type} from "dev.latvian.mods.rhino.type.TypeInfo"
import {$ResourceLocation, $ResourceLocation$$Type} from "net.minecraft.resources.ResourceLocation"
import {$RecipeTypeFunction$$Type} from "dev.latvian.mods.kubejs.recipe.RecipeTypeFunction"
import {$KubeRecipe, $KubeRecipe$$Type} from "dev.latvian.mods.kubejs.recipe.KubeRecipe"
import {$Supplier, $Supplier$$Type} from "java.util.function.Supplier"
import {$Class$$Type} from "java.lang.Class"
import {$SourceLine$$Type} from "dev.latvian.mods.kubejs.script.SourceLine"
import {$Record} from "java.lang.Record"

export class $KubeRecipeFactory extends $Record {
static readonly "DEFAULT": $KubeRecipeFactory

constructor(id: $ResourceLocation$$Type, recipeType: $Class$$Type<(never)>, factory: $Supplier$$Type<($KubeRecipe$$Type)>)
constructor(id: $ResourceLocation$$Type, recipeType: $TypeInfo$$Type, factory: $Supplier$$Type<($KubeRecipe$$Type)>)

public "equals"(o: any): boolean
public "toString"(): StringJS
public "hashCode"(): integer
public "factory"(): $Supplier<($KubeRecipe)>
public "id"(): $ResourceLocation
public "create"(type: $RecipeTypeFunction$$Type, sourceLine: $SourceLine$$Type, save: boolean): $KubeRecipe
public "recipeType"(): $TypeInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeRecipeFactory$$Type = ({"factory"?: $Supplier$$Type<($KubeRecipe$$Type)>, "id"?: $ResourceLocation$$Type, "recipeType"?: $TypeInfo$$Type}) | ([factory?: $Supplier$$Type<($KubeRecipe$$Type)>, id?: $ResourceLocation$$Type, recipeType?: $TypeInfo$$Type]);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $KubeRecipeFactory$$Original = $KubeRecipeFactory;}
declare module "dev.latvian.mods.kubejs.block.entity.BlockEntityTickKubeEvent" {
import {$KubeBlockEntity$$Type} from "dev.latvian.mods.kubejs.block.entity.KubeBlockEntity"
import {$LevelBlock} from "dev.latvian.mods.kubejs.level.LevelBlock"
import {$KubeLevelEvent$$Interface} from "dev.latvian.mods.kubejs.level.KubeLevelEvent"
import {$Level} from "net.minecraft.world.level.Level"
import {$MinecraftServer} from "net.minecraft.server.MinecraftServer"
import {$RegistryAccess} from "net.minecraft.core.RegistryAccess"

export class $BlockEntityTickKubeEvent implements $KubeLevelEvent$$Interface {
constructor(entity: $KubeBlockEntity$$Type)

public "getLevel"(): $Level
public "getTick"(): integer
public "getBlock"(): $LevelBlock
public "getCycle"(): integer
public "getServer"(): $MinecraftServer
public "getRegistries"(): $RegistryAccess
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
get "level"(): $Level
get "tick"(): integer
get "block"(): $LevelBlock
get "cycle"(): integer
get "server"(): $MinecraftServer
get "registries"(): $RegistryAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityTickKubeEvent$$Type = ($BlockEntityTickKubeEvent);
/**
 * Original type to represent the class type itself. Use in JSDoc only.
 */
export type $BlockEntityTickKubeEvent$$Original = $BlockEntityTickKubeEvent;}
